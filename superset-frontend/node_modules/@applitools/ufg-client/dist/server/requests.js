"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeUFGRequests = void 0;
const logger_1 = require("@applitools/logger");
const req_ufg_1 = require("./req-ufg");
const utils = __importStar(require("@applitools/utils"));
function makeUFGRequests({ config, logger: defaultLogger }) {
    defaultLogger !== null && defaultLogger !== void 0 ? defaultLogger : (defaultLogger = (0, logger_1.makeLogger)());
    const req = (0, req_ufg_1.makeReqUFG)({ config, logger: defaultLogger });
    const getChromeEmulationDevicesWithCache = utils.general.cachify(getChromeEmulationDevices);
    const getIOSDevicesWithCache = utils.general.cachify(getIOSDevices);
    const getAndroidDevicesWithCache = utils.general.cachify(() => null);
    return {
        bookRenderers,
        startRenders,
        checkRenderResults,
        uploadResource,
        checkResources,
        getChromeEmulationDevices: getChromeEmulationDevicesWithCache,
        getIOSDevices: getIOSDevicesWithCache,
        getAndroidDevices: getAndroidDevicesWithCache,
    };
    async function bookRenderers({ settings, logger = defaultLogger, }) {
        logger.log('Request "bookRenderers" called for with settings', settings);
        const response = await req('./job-info', {
            name: 'bookRenderers',
            method: 'POST',
            body: settings.map(settings => {
                const renderOptions = {
                    agentId: config.agentId,
                    webhook: config.uploadUrl,
                    stitchingService: config.stitchingServiceUrl,
                    ...extractRenderEnvironment({ settings }),
                };
                renderOptions.renderInfo.target = 'viewport';
                return renderOptions;
            }),
            expected: 200,
            logger,
        });
        const results = await response.json().then(results => {
            return results.map((result, index) => {
                var _a, _b;
                return {
                    rendererId: result.renderer,
                    rendererInfo: { type: (_a = settings[index]) === null || _a === void 0 ? void 0 : _a.type, renderer: (_b = settings[index]) === null || _b === void 0 ? void 0 : _b.renderer },
                    rawEnvironment: result.eyesEnvironment,
                };
            });
        });
        logger.log('Request "bookRenderers" finished successfully with body', results);
        return results;
    }
    async function startRenders({ requests, logger = defaultLogger, }) {
        logger.log('Request "startRenders" called for requests', requests);
        const response = await req('./render', {
            name: 'startRenders',
            method: 'POST',
            body: requests.map(({ target, settings }) => {
                var _a;
                const renderOptions = {
                    url: target.source,
                    snapshot: target.snapshot,
                    resources: target.resources,
                    selectorsToFindRegionsFor: (_a = settings.selectorsToCalculate) === null || _a === void 0 ? void 0 : _a.map(selector => transformSelector({ selector })),
                    options: settings.ufgOptions,
                    scriptHooks: settings.hooks,
                    renderer: settings.rendererId,
                    agentId: config.agentId,
                    webhook: config.uploadUrl,
                    stitchingService: config.stitchingServiceUrl,
                    sendDom: settings.sendDom,
                    includeFullPageSize: settings.includeFullPageSize,
                    enableMultipleResultsPerSelector: true,
                    ...extractRenderEnvironment({ settings }),
                };
                if (settings.type === 'native') {
                    renderOptions.renderInfo.vhsType = target.vhsType;
                    renderOptions.renderInfo.vhsCompatibilityParams = target.vhsCompatibilityParams;
                }
                if (settings.region) {
                    if (utils.types.has(settings.region, ['x', 'y', 'width', 'height'])) {
                        renderOptions.renderInfo.target = 'region';
                        renderOptions.renderInfo.region = settings.region;
                    }
                    else {
                        renderOptions.renderInfo.target = settings.fully ? 'full-selector' : 'selector';
                        renderOptions.renderInfo.selector = transformSelector({ selector: settings.region });
                    }
                }
                else {
                    renderOptions.renderInfo.target = settings.fully ? 'full-page' : 'viewport';
                }
                return renderOptions;
            }),
            expected: 200,
            logger,
        });
        const results = await response.json().then(results => {
            return results.map(result => ({ jobIb: result.jobId, renderId: result.renderId, status: result.renderStatus }));
        });
        logger.log('Request "startRenders" finished successfully with body', results);
        return results;
    }
    async function checkRenderResults({ renders, logger = defaultLogger, }) {
        logger.log('Request "checkRenderResults" called for renders', renders);
        const response = await req('./render-status', {
            name: 'checkRenderResults',
            method: 'POST',
            body: renders.map(render => render.renderId),
            expected: 200,
            timeout: 15000,
            hooks: {
                afterOptionsMerged({ options }) {
                    options.retry = [
                        {
                            limit: 3,
                            timeout: 500,
                            statuses: [404, 500, 502, 504],
                            codes: ['ECONNRESET', 'ECONNABORTED', 'ETIMEDOUT', 'ENOTFOUND', 'EAI_AGAIN'],
                        },
                    ];
                },
            },
            logger,
        });
        const results = await response.json().then(results => {
            return results.map((result, index) => {
                var _a;
                return ({
                    renderId: renders[index].renderId,
                    status: result.status,
                    error: result.error,
                    image: result.imageLocation,
                    dom: result.domLocation,
                    locationInViewport: result.imagePositionInActiveFrame,
                    locationInView: result.imagePositionInActiveFrame,
                    fullViewSize: result.fullPageSize,
                    selectorRegions: (_a = result.selectorRegions) === null || _a === void 0 ? void 0 : _a.map(regions => {
                        return regions === null || regions === void 0 ? void 0 : regions.map(region => ({
                            ...region,
                            x: Math.max(0, region.x - result.imagePositionInActiveFrame.x),
                            y: Math.max(0, region.y - result.imagePositionInActiveFrame.y),
                        }));
                    }),
                });
            });
        });
        logger.log('Request "checkRenderResults" finished successfully with body', results);
        return results;
    }
    async function checkResources({ resources, logger = defaultLogger, }) {
        logger.log('Request "checkResources" called for resources', resources);
        const response = await req('./resources/query/resources-exist', {
            name: 'checkResources',
            method: 'POST',
            query: {
                'render-id': utils.general.guid(),
            },
            body: resources.map(resource => resource.hash),
            expected: 200,
            logger,
        });
        const results = await response.json();
        logger.log('Request "checkResources" finished successfully with body', results);
        return results;
    }
    async function uploadResource({ resource, logger = defaultLogger, }) {
        logger.log('Request "uploadResource" called for resource', resource);
        await req(`./resources/sha256/${resource.hash.hash}`, {
            name: 'uploadResource',
            method: 'PUT',
            headers: {
                'Content-Type': resource.contentType,
            },
            query: {
                'render-id': utils.general.guid(),
            },
            body: resource.value,
            expected: 200,
            logger,
        });
        logger.log('Request "uploadResource" finished successfully');
    }
    async function getChromeEmulationDevices({ logger = defaultLogger } = {}) {
        logger.log('Request "getChromeEmulationDevices" called');
        const response = await req('./emulated-devices-sizes', {
            name: 'getChromeEmulationDevices',
            method: 'GET',
            logger,
        });
        const result = await response.json();
        logger.log('Request "getChromeEmulationDevices" finished successfully with body', result);
        return result;
    }
    async function getIOSDevices({ logger = defaultLogger } = {}) {
        logger.log('Request "getIOSDevices" called');
        const response = await req('./ios-devices-sizes', {
            name: 'getIOSDevices',
            method: 'GET',
            logger,
        });
        const result = await response.json();
        logger.log('Request "getIOSDevices" finished successfully with body', result);
        return result;
    }
}
exports.makeUFGRequests = makeUFGRequests;
function extractRenderEnvironment({ settings }) {
    var _a, _b;
    if (utils.types.has(settings.renderer, ['width', 'height'])) {
        return {
            platform: { name: 'linux', type: 'web' },
            browser: { name: settings.renderer.name.replace(/(one|two)-versions?-back$/, (_, num) => ({ one: 1, two: 2 }[num])) },
            renderInfo: { width: settings.renderer.width, height: settings.renderer.height },
        };
    }
    else if (utils.types.has(settings.renderer, 'chromeEmulationInfo')) {
        return {
            platform: { name: 'linux', type: 'web' },
            browser: { name: 'chrome' },
            renderInfo: {
                emulationInfo: {
                    deviceName: settings.renderer.chromeEmulationInfo.deviceName,
                    screenOrientation: settings.renderer.chromeEmulationInfo.screenOrientation,
                },
            },
        };
    }
    else if (utils.types.has(settings.renderer, 'androidDeviceInfo')) {
        return {
            platform: { name: 'android', type: (_a = settings.type) !== null && _a !== void 0 ? _a : 'native' },
            browser: settings.type === 'web' ? { name: 'chrome' } : undefined,
            renderInfo: {
                androidDeviceInfo: {
                    name: settings.renderer.androidDeviceInfo.deviceName,
                    version: settings.renderer.androidDeviceInfo.version,
                    screenOrientation: settings.renderer.androidDeviceInfo.screenOrientation,
                },
            },
        };
    }
    else if (utils.types.has(settings.renderer, 'iosDeviceInfo')) {
        return {
            platform: { name: 'ios', type: (_b = settings.type) !== null && _b !== void 0 ? _b : 'native' },
            browser: settings.type === 'web' ? { name: 'safari' } : undefined,
            renderInfo: {
                iosDeviceInfo: {
                    name: settings.renderer.iosDeviceInfo.deviceName,
                    version: settings.renderer.iosDeviceInfo.version,
                    screenOrientation: settings.renderer.iosDeviceInfo.screenOrientation,
                },
            },
        };
    }
}
function transformSelector({ selector }) {
    var _a;
    if (utils.types.isString(selector))
        return { type: 'css', selector };
    if (!selector.frame && !selector.shadow)
        return selector;
    const pathSelector = [];
    let currentSelector = selector;
    while (currentSelector) {
        let stepSelector;
        if (utils.types.isString(currentSelector)) {
            stepSelector = { nodeType: 'element', type: 'css', selector: currentSelector };
            currentSelector = undefined;
        }
        else {
            stepSelector = { type: (_a = currentSelector.type) !== null && _a !== void 0 ? _a : 'css', selector: currentSelector.selector };
            if (currentSelector.frame) {
                stepSelector.nodeType = 'frame';
                currentSelector = currentSelector.frame;
            }
            else if (currentSelector.shadow) {
                stepSelector.nodeType = 'shadow-root';
                currentSelector = currentSelector.shadow;
            }
            else {
                stepSelector.nodeType = 'element';
                currentSelector = undefined;
            }
        }
        pathSelector.push(stepSelector);
    }
    return pathSelector;
}
