import type { Location, Size, Region } from '@applitools/utils';
import { type SpecDriver } from './spec-driver';
import { type Context } from './context';
import { type Selector } from './selector';
import { type Logger } from '@applitools/logger';
export declare type ElementState<TElement> = {
    contentSize?: Size;
    scrollOffset?: Location;
    transforms?: any;
    attributes?: Record<string, string | Error>;
    touchPadding?: number;
    containedElements?: Map<TElement, boolean>;
};
export declare class Element<TDriver, TContext, TElement, TSelector> {
    private _target;
    private _context;
    private _selector;
    private _commonSelector?;
    private _index;
    private _state;
    private _originalOverflow;
    private _logger;
    protected readonly _spec: SpecDriver<TDriver, TContext, TElement, TSelector>;
    constructor(options: {
        spec: SpecDriver<TDriver, TContext, TElement, TSelector>;
        element?: TElement | Element<TDriver, TContext, TElement, TSelector>;
        context?: Context<TDriver, TContext, TElement, TSelector>;
        selector?: Selector<TSelector>;
        index?: number;
        logger?: Logger;
    });
    get target(): TElement;
    get selector(): Selector<TSelector>;
    get commonSelector(): Selector<never>;
    get index(): number;
    get context(): Context<TDriver, TContext, TElement, TSelector>;
    get driver(): import("./driver").Driver<TDriver, TContext, TElement, TSelector>;
    get isRef(): boolean;
    equals(element: Element<TDriver, TContext, TElement, TSelector> | TElement): Promise<boolean>;
    contains(innerElement: Element<TDriver, TContext, TElement, TSelector> | TElement): Promise<boolean>;
    init(context: Context<TDriver, TContext, TElement, TSelector>): Promise<this>;
    getRegion(): Promise<Region>;
    getClientRegion(): Promise<Region>;
    getContentRegion(options?: {
        lazyLoad?: {
            scrollLength?: number;
            waitingTime?: number;
            maxAmountToScroll?: number;
        };
    }): Promise<Region>;
    getContentSizeIOS(): Promise<Region>;
    getContentSize(options?: {
        lazyLoad?: {
            scrollLength?: number;
            waitingTime?: number;
            maxAmountToScroll?: number;
        };
    }): Promise<Size>;
    isPager(): Promise<boolean>;
    isScrollable(): Promise<boolean>;
    isRoot(): Promise<boolean>;
    getShadowRoot(): Promise<TElement>;
    getTouchPadding(): Promise<number>;
    getText(): Promise<string>;
    getAttribute(name: string): Promise<string>;
    setAttribute(name: string, value: string): Promise<void>;
    scrollTo(offset: Location, options?: {
        force: boolean;
    }): Promise<Location>;
    translateTo(offset: Location): Promise<Location>;
    getScrollOffset(): Promise<Location>;
    getTranslateOffset(): Promise<Location>;
    getInnerOffset(): Promise<Location>;
    click(): Promise<void>;
    type(value: string): Promise<void>;
    preserveState(): Promise<ElementState<TElement>>;
    restoreState(state?: ElementState<TElement>): Promise<void>;
    hideScrollbars(): Promise<void>;
    restoreScrollbars(): Promise<void>;
    refresh(freshElement?: TElement): Promise<boolean>;
    withRefresh<TResult>(operation: (...args: any[]) => TResult): Promise<TResult>;
    toJSON(): TElement;
}
