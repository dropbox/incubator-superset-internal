import type { Location, Size, Region } from '@applitools/utils';
import type { Cookie } from './types';
import { type SpecDriver, type WaitOptions } from './spec-driver';
import { type Driver } from './driver';
import { type Selector } from './selector';
import { type Logger } from '@applitools/logger';
import { Element } from './element';
export declare type ContextReference<TDriver, TContext, TElement, TSelector> = Context<TDriver, TContext, TElement, TSelector> | Element<TDriver, TContext, TElement, TSelector> | TElement | Selector<TSelector> | string | number;
export declare type ContextPlain<TDriver, TContext, TElement, TSelector> = ContextReference<TDriver, TContext, TElement, TSelector> | {
    reference: ContextReference<TDriver, TContext, TElement, TSelector>;
    scrollingElement?: Element<TDriver, TContext, TElement, TSelector>;
    parent?: ContextPlain<TDriver, TContext, TElement, TSelector>;
};
export declare type ContextState = {
    region?: Region;
    clientRegion?: Region;
    scrollingRegion?: Region;
    innerOffset?: Location;
};
export declare class Context<TDriver, TContext, TElement, TSelector> {
    private _target;
    private _driver;
    private _parent;
    private _element;
    private _reference;
    private _scrollingElement;
    private _state;
    private _logger;
    private _isReference;
    protected readonly _spec: SpecDriver<TDriver, TContext, TElement, TSelector>;
    constructor(options: {
        spec: SpecDriver<TDriver, TContext, TElement, TSelector>;
        context?: TContext | Context<TDriver, TContext, TElement, TSelector>;
        driver?: Driver<TDriver, TContext, TElement, TSelector>;
        parent?: Context<TDriver, TContext, TElement, TSelector>;
        reference?: ContextReference<TDriver, TContext, TElement, TSelector>;
        element?: Element<TDriver, TContext, TElement, TSelector>;
        scrollingElement?: Element<TDriver, TContext, TElement, TSelector>;
        logger?: Logger;
    });
    get target(): TContext;
    get driver(): Driver<TDriver, TContext, TElement, TSelector>;
    get parent(): Context<TDriver, TContext, TElement, TSelector> | null;
    get main(): Context<TDriver, TContext, TElement, TSelector>;
    get path(): Context<TDriver, TContext, TElement, TSelector>[];
    get isMain(): boolean;
    get isCurrent(): boolean;
    get isInitialized(): boolean;
    get isRef(): boolean;
    private _findElements;
    init(): Promise<this>;
    focus(): Promise<this>;
    equals(context: Context<TDriver, TContext, TElement, TSelector> | Element<TDriver, TContext, TElement, TSelector>): Promise<boolean>;
    context(reference: ContextPlain<TDriver, TContext, TElement, TSelector>): Promise<Context<TDriver, TContext, TElement, TSelector>>;
    element(elementOrSelector: TElement | Selector<TSelector>): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    elements(selectorOrElement: Selector<TSelector> | TElement): Promise<Element<TDriver, TContext, TElement, TSelector>[]>;
    waitFor(selector: Selector<TSelector>, options?: WaitOptions): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    execute(script: ((args: any) => any) | string, arg?: any): Promise<any>;
    executePoll(script: ((arg: any) => any) | string | {
        main: ((arg: any) => any) | string;
        poll: ((arg: any) => any) | string;
    }, arg?: any | {
        main: any;
        poll: any;
        executionTimeout?: number;
        pollTimeout?: number;
    }): Promise<any>;
    getContextElement(): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    getScrollingElement(): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    setScrollingElement(scrollingElement: Element<TDriver, TContext, TElement, TSelector> | TElement | Selector<TSelector>): Promise<void>;
    blurElement(element?: Element<TDriver, TContext, TElement, TSelector>): Promise<TElement>;
    focusElement(element: Element<TDriver, TContext, TElement, TSelector>): Promise<any>;
    getRegion(): Promise<Region>;
    getClientRegion(): Promise<Region>;
    getScrollingRegion(): Promise<Region>;
    getContentSize(): Promise<Size>;
    getInnerOffset(): Promise<Location>;
    getLocationInMainContext(): Promise<Location>;
    getLocationInViewport(): Promise<Location>;
    getRegionInViewport(region: Region): Promise<Region>;
    getCookies(): Promise<Cookie[]>;
    private preserveInnerOffset;
    private preserveContextRegions;
    private preserveScrollingRegion;
}
