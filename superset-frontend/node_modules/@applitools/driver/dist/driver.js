"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDriver = exports.isDriver = exports.Driver = void 0;
const context_1 = require("./context");
const logger_1 = require("@applitools/logger");
const helper_ios_1 = require("./helper-ios");
const helper_android_1 = require("./helper-android");
const user_agent_1 = require("./user-agent");
const user_agent_data_1 = require("./user-agent-data");
const capabilities_1 = require("./capabilities");
const snippets = __importStar(require("@applitools/snippets"));
const utils = __importStar(require("@applitools/utils"));
const specUtils = __importStar(require("./spec-utils"));
// eslint-disable-next-line
class Driver {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (options.driver instanceof Driver)
            return options.driver;
        this._customConfig = (_a = options.customConfig) !== null && _a !== void 0 ? _a : {};
        this._spec = options.spec;
        this._logger = (_c = (_b = options.logger) === null || _b === void 0 ? void 0 : _b.extend({ label: 'driver' })) !== null && _c !== void 0 ? _c : (0, logger_1.makeLogger)({ label: 'driver' });
        this._target = (_f = (_e = (_d = this._spec).transformDriver) === null || _e === void 0 ? void 0 : _e.call(_d, options.driver)) !== null && _f !== void 0 ? _f : options.driver;
        if (!this._spec.isDriver(this._target)) {
            throw new TypeError('Driver constructor called with argument of unknown type!');
        }
        this._mainContext = new context_1.Context({
            spec: this._spec,
            context: (_j = (_h = (_g = this._spec).extractContext) === null || _h === void 0 ? void 0 : _h.call(_g, this._target)) !== null && _j !== void 0 ? _j : this._target,
            driver: this,
            logger: this._logger,
        });
        this._currentContext = this._mainContext;
    }
    get target() {
        return this._target;
    }
    get currentContext() {
        return this._currentContext;
    }
    get mainContext() {
        return this._mainContext;
    }
    get helper() {
        return this._helper;
    }
    get features() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.features;
    }
    get deviceName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.deviceName;
    }
    get platformName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.platformName;
    }
    get platformVersion() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.platformVersion;
    }
    get browserName() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.browserName;
    }
    get browserVersion() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.browserVersion;
    }
    get userAgent() {
        var _a;
        return (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.userAgent;
    }
    get orientation() {
        return this._driverInfo.orientation;
    }
    get pixelRatio() {
        var _a;
        return (_a = this._driverInfo.pixelRatio) !== null && _a !== void 0 ? _a : 1;
    }
    get viewportScale() {
        var _a;
        return (_a = this._driverInfo.viewportScale) !== null && _a !== void 0 ? _a : 1;
    }
    get statusBarSize() {
        var _a;
        return (_a = this._driverInfo.statusBarSize) !== null && _a !== void 0 ? _a : (this.isNative ? 0 : undefined);
    }
    get navigationBarSize() {
        var _a;
        return (_a = this._driverInfo.navigationBarSize) !== null && _a !== void 0 ? _a : (this.isNative ? 0 : undefined);
    }
    get isNative() {
        var _a, _b;
        return (_b = (!this.isWebView && ((_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isNative))) !== null && _b !== void 0 ? _b : false;
    }
    get isWebView() {
        var _a, _b, _c;
        return (_c = (((_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isNative) && ((_b = this._driverInfo) === null || _b === void 0 ? void 0 : _b.isWebView))) !== null && _c !== void 0 ? _c : false;
    }
    get isWeb() {
        return this.isWebView || !this.isNative;
    }
    get isEmulation() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isEmulation) !== null && _b !== void 0 ? _b : false;
    }
    get isMobile() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isMobile) !== null && _b !== void 0 ? _b : false;
    }
    get isIOS() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isIOS) !== null && _b !== void 0 ? _b : /iOS/i.test(this.platformName);
    }
    get isAndroid() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isAndroid) !== null && _b !== void 0 ? _b : /Android/i.test(this.platformName);
    }
    get isMac() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isMac) !== null && _b !== void 0 ? _b : /mac\s?OS/i.test(this.platformName);
    }
    get isWindows() {
        var _a, _b;
        return (_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isWindows) !== null && _b !== void 0 ? _b : /Windows/i.test(this.platformName);
    }
    get isChromium() {
        var _a, _b;
        return ((_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.isChromium) !== null && _b !== void 0 ? _b : (/(chrome)/i.test(this.browserName) || (/edge/i.test(this.browserName) && Number(this.browserVersion) > 44)));
    }
    get isIE() {
        return /(internet explorer|ie)/i.test(this.browserName);
    }
    get isEdgeLegacy() {
        return /edge/i.test(this.browserName) && Number(this.browserVersion) <= 44;
    }
    updateCurrentContext(context) {
        this._currentContext = context;
    }
    async init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18;
        var _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34;
        // NOTE: this is here because saucelabs does not provide right capabilities for the first call
        await ((_b = (_a = this._spec).getCapabilities) === null || _b === void 0 ? void 0 : _b.call(_a, this.target));
        const capabilities = await ((_d = (_c = this._spec).getCapabilities) === null || _d === void 0 ? void 0 : _d.call(_c, this.target));
        this._logger.log('Driver capabilities', capabilities);
        const capabilitiesInfo = capabilities ? (0, capabilities_1.parseCapabilities)(capabilities) : undefined;
        const driverInfo = await ((_f = (_e = this._spec).getDriverInfo) === null || _f === void 0 ? void 0 : _f.call(_e, this.target));
        this._driverInfo = { ...capabilitiesInfo, ...driverInfo };
        if (this.isMobile) {
            this._driverInfo.orientation =
                (_g = (await this.getOrientation().catch(() => undefined))) !== null && _g !== void 0 ? _g : this._driverInfo.orientation;
            const world = await this.getCurrentWorld();
            this._driverInfo.isWebView = !!(world === null || world === void 0 ? void 0 : world.isWebView);
        }
        if (this.isWeb) {
            const browserInfo = await this.currentContext.executePoll(snippets.getBrowserInfo);
            (_h = (_19 = this._driverInfo).userAgent) !== null && _h !== void 0 ? _h : (_19.userAgent = browserInfo.userAgent);
            (_j = (_20 = this._driverInfo).pixelRatio) !== null && _j !== void 0 ? _j : (_20.pixelRatio = browserInfo.pixelRatio);
            (_k = (_21 = this._driverInfo).viewportScale) !== null && _k !== void 0 ? _k : (_21.viewportScale = browserInfo.viewportScale);
            if (browserInfo.userAgentData) {
                (_l = (_22 = this._driverInfo).isMobile) !== null && _l !== void 0 ? _l : (_22.isMobile = this._driverInfo.isMobile);
                (_m = (_23 = this._driverInfo).isChromium) !== null && _m !== void 0 ? _m : (_23.isChromium = this._driverInfo.isChromium);
                if (this.isChromium) {
                    if (this.isWindows && Number.parseInt(this.browserVersion) >= 107) {
                        this._driverInfo.platformVersion = (_o = browserInfo.platformVersion) !== null && _o !== void 0 ? _o : this._driverInfo.platformVersion;
                    }
                    else if (this.isMac && Number.parseInt(this.browserVersion) >= 90) {
                        this._driverInfo.platformVersion = (_p = browserInfo.platformVersion) !== null && _p !== void 0 ? _p : this._driverInfo.platformVersion;
                    }
                }
            }
            if (this._driverInfo.userAgent) {
                const userAgentInfo = (0, user_agent_1.parseUserAgent)(this._driverInfo.userAgent);
                const userAgentDataInfo = browserInfo.userAgentData && (0, user_agent_data_1.parseUserAgentData)(browserInfo.userAgentData);
                this._driverInfo.browserName =
                    (_r = (_q = userAgentInfo.browserName) !== null && _q !== void 0 ? _q : userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.browserName) !== null && _r !== void 0 ? _r : this._driverInfo.browserName;
                this._driverInfo.browserVersion =
                    (_t = (_s = userAgentInfo.browserVersion) !== null && _s !== void 0 ? _s : userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.browserVersion) !== null && _t !== void 0 ? _t : this._driverInfo.browserVersion;
                (_u = (_24 = this._driverInfo).isMobile) !== null && _u !== void 0 ? _u : (_24.isMobile = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.isMobile);
                (_v = (_25 = this._driverInfo).isChromium) !== null && _v !== void 0 ? _v : (_25.isChromium = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.isChromium);
                if (this._driverInfo.isMobile) {
                    (_w = (_26 = this._driverInfo).platformName) !== null && _w !== void 0 ? _w : (_26.platformName = (_x = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.platformName) !== null && _x !== void 0 ? _x : userAgentInfo.platformName);
                    (_y = (_27 = this._driverInfo).platformVersion) !== null && _y !== void 0 ? _y : (_27.platformVersion = (_z = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.platformVersion) !== null && _z !== void 0 ? _z : userAgentInfo.platformVersion);
                }
                else {
                    this._driverInfo.platformName =
                        (_1 = (_0 = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.platformName) !== null && _0 !== void 0 ? _0 : userAgentInfo.platformName) !== null && _1 !== void 0 ? _1 : this._driverInfo.platformName;
                    this._driverInfo.platformVersion =
                        (_3 = (_2 = userAgentDataInfo === null || userAgentDataInfo === void 0 ? void 0 : userAgentDataInfo.platformVersion) !== null && _2 !== void 0 ? _2 : userAgentInfo.platformVersion) !== null && _3 !== void 0 ? _3 : this._driverInfo.platformVersion;
                }
            }
            if (!this.isMobile && (this.isAndroid || this.isIOS)) {
                this._driverInfo.isMobile = true;
                this._driverInfo.isEmulation = this._driverInfo.isChrome;
            }
            (_4 = (_28 = this._driverInfo).features) !== null && _4 !== void 0 ? _4 : (_28.features = {});
            (_5 = (_29 = this._driverInfo.features).allCookies) !== null && _5 !== void 0 ? _5 : (_29.allCookies = this._driverInfo.isChrome || (/chrome/i.test(this._driverInfo.browserName) && !this._driverInfo.isMobile));
        }
        else {
            // this value always excludes the height of the navigation bar, and sometimes it also excludes the height of the status bar
            let windowSize = await this._spec.getWindowSize(this.target);
            (_6 = (_30 = this._driverInfo).displaySize) !== null && _6 !== void 0 ? _6 : (_30.displaySize = windowSize);
            if (((_7 = this.orientation) === null || _7 === void 0 ? void 0 : _7.startsWith('landscape')) &&
                this._driverInfo.displaySize.height > this._driverInfo.displaySize.width) {
                this._driverInfo.displaySize = {
                    width: this._driverInfo.displaySize.height,
                    height: this._driverInfo.displaySize.width,
                };
            }
            if (this.isAndroid) {
                // bar sizes could be extracted only on android
                const systemBars = await ((_9 = (_8 = this._spec).getSystemBars) === null || _9 === void 0 ? void 0 : _9.call(_8, this.target).catch(() => null));
                const { statusBar, navigationBar } = systemBars !== null && systemBars !== void 0 ? systemBars : {};
                if (statusBar === null || statusBar === void 0 ? void 0 : statusBar.visible) {
                    this._logger.log('Driver status bar', statusBar);
                    const statusBarSize = statusBar.height;
                    // when status bar is overlapping content on android it returns status bar height equal to display height
                    if (statusBarSize < this._driverInfo.displaySize.height) {
                        this._driverInfo.statusBarSize = Math.max((_10 = this._driverInfo.statusBarSize) !== null && _10 !== void 0 ? _10 : 0, statusBarSize);
                    }
                }
                if (navigationBar === null || navigationBar === void 0 ? void 0 : navigationBar.visible) {
                    this._logger.log('Driver navigation size', navigationBar);
                    // if navigation bar is placed on the right side is screen the the orientation is landscape-secondary
                    if (navigationBar.x > 0)
                        this._driverInfo.orientation = 'landscape-secondary';
                    // navigation bar size could be its height or width depending on screen orientation
                    const navigationBarSize = navigationBar[((_11 = this.orientation) === null || _11 === void 0 ? void 0 : _11.startsWith('landscape')) ? 'width' : 'height'];
                    // when navigation bar is invisible on android it returns navigation bar size equal to display size
                    if (navigationBarSize <
                        this._driverInfo.displaySize[((_12 = this.orientation) === null || _12 === void 0 ? void 0 : _12.startsWith('landscape')) ? 'width' : 'height']) {
                        this._driverInfo.navigationBarSize = Math.max((_13 = this._driverInfo.navigationBarSize) !== null && _13 !== void 0 ? _13 : 0, navigationBarSize);
                    }
                    else {
                        this._driverInfo.navigationBarSize = 0;
                    }
                }
                // bar sizes have to be scaled on android
                (_31 = this._driverInfo).statusBarSize && (_31.statusBarSize = this._driverInfo.statusBarSize / this.pixelRatio);
                (_32 = this._driverInfo).navigationBarSize && (_32.navigationBarSize = this._driverInfo.navigationBarSize / this.pixelRatio);
                windowSize = utils.geometry.scale(windowSize, 1 / this.pixelRatio);
                (_33 = this._driverInfo).displaySize && (_33.displaySize = utils.geometry.scale(this._driverInfo.displaySize, 1 / this.pixelRatio));
            }
            if (this.isIOS) {
                if ((_14 = this.orientation) === null || _14 === void 0 ? void 0 : _14.startsWith('landscape'))
                    this._driverInfo.statusBarSize = 0;
            }
            // calculate viewport location
            (_15 = (_34 = this._driverInfo).viewportLocation) !== null && _15 !== void 0 ? _15 : (_34.viewportLocation = {
                x: this.orientation === 'landscape' ? this.navigationBarSize : 0,
                y: this.statusBarSize,
            });
            // calculate viewport size
            if (!this._driverInfo.viewportSize) {
                this._driverInfo.viewportSize = { ...this._driverInfo.displaySize };
                this._driverInfo.viewportSize.height -= this.statusBarSize;
                if (this.isAndroid) {
                    this._driverInfo.viewportSize[((_16 = this.orientation) === null || _16 === void 0 ? void 0 : _16.startsWith('landscape')) ? 'width' : 'height'] -=
                        this.navigationBarSize;
                }
            }
            // calculate safe area
            if (this.isIOS && !this._driverInfo.safeArea) {
                this._driverInfo.safeArea = { x: 0, y: 0, ...this._driverInfo.displaySize };
                const topElement = await this.element({ type: '-ios class chain', selector: '**/XCUIElementTypeNavigationBar' });
                if (topElement) {
                    const topRegion = await this._spec.getElementRegion(this.target, topElement.target);
                    const topOffset = topRegion.y + topRegion.height;
                    this._driverInfo.safeArea.y = topOffset;
                    this._driverInfo.safeArea.height -= topOffset;
                }
                const bottomElement = await this.element({ type: '-ios class chain', selector: '**/XCUIElementTypeTabBar' });
                if (bottomElement) {
                    const bottomRegion = await this._spec.getElementRegion(this.target, bottomElement.target);
                    const bottomOffset = bottomRegion.height;
                    this._driverInfo.safeArea.height -= bottomOffset;
                }
            }
            // TODO: if user opts into NML, skip initializing the helpers
            // init helper lib
            if (!((_17 = this._customConfig) === null || _17 === void 0 ? void 0 : _17.disableHelper)) {
                this._helper = this.isIOS
                    ? await helper_ios_1.HelperIOS.make({ spec: this._spec, driver: this, logger: this._logger })
                    : await helper_android_1.HelperAndroid.make({ spec: this._spec, driver: this, logger: this._logger });
            }
            this._logger.log(`Helper set to ${(_18 = this._helper) === null || _18 === void 0 ? void 0 : _18.name}`);
        }
        this._logger.log('Combined driver info', this._driverInfo);
        return this;
    }
    // begin world
    //
    // About the concept of a  "World":
    //
    // Since "context" is an overloaded term from frames, we have decided to use
    // the concept of a "world" when switching between mobile app contexts (e.g., native and webview(s))
    //
    // Notes:
    // - two new functions need to be added to a spec driver for this to work (`getCurrentWorld` and `switchWorld`)
    // - you can see a reference implementation of this in spec-driver-webdriverio
    // - if a world id is provided it will be used for switching
    // - if a world id is not provided, the first non-native world will be used
    //    (regardless of which world the driver is currently switched into)
    // - before switching, the current world context is stored so it can switched back to later
    //    (with the `restoreState` option)
    // - the native app world can be switched to (with the `goHome` option)
    async switchWorld(options) {
        var _a, _b;
        if ((options === null || options === void 0 ? void 0 : options.restoreState) && !this._previousWorld)
            return;
        if (!this._spec.getCurrentWorld || !this._spec.switchWorld) {
            this._logger.warn('world switching not implemented in the spec driver, skipping');
            return;
        }
        this._logger.log('switchWorld called with', options ? options : 'no options');
        const { id, home, next } = await this.getCurrentWorld();
        if (!this._previousWorld) {
            this._logger.log('storing current world id for future restoration', id);
            this._previousWorld = id;
        }
        const providedTarget = (options === null || options === void 0 ? void 0 : options.restoreState)
            ? this._previousWorld
            : (options === null || options === void 0 ? void 0 : options.goHome)
                ? home
                : (options === null || options === void 0 ? void 0 : options.id)
                    ? options.id
                    : next;
        this._logger.log('switching world with', providedTarget ? providedTarget : 'no id');
        try {
            await ((_b = (_a = this._spec).switchWorld) === null || _b === void 0 ? void 0 : _b.call(_a, this.target, providedTarget));
            await this.init();
        }
        catch (error) {
            throw new Error(`Unable to switch worlds, the original error was: ${error.message}`);
        }
    }
    async getWorlds(attempt = 1) {
        var _a, _b;
        if (!this._spec.getWorlds)
            return;
        this._logger.log('attempting to find worlds');
        await utils.general.sleep(500);
        const worlds = await ((_b = (_a = this._spec).getWorlds) === null || _b === void 0 ? void 0 : _b.call(_a, this.target));
        if (!worlds[1]) {
            if (attempt > 5) {
                this._logger.warn(`just one world found - ${worlds}. done looking.`);
                return worlds;
            }
            this._logger.log(`just one world found, retrying to see if there are others (attempt #${attempt})`);
            await this.getWorlds(attempt + 1);
        }
        this._logger.log(`worlds found - ${worlds}`);
        return worlds;
    }
    async getCurrentWorld() {
        var _a, _b;
        if (!this._spec.getCurrentWorld)
            return;
        const [origin, next] = await this.getWorlds();
        const currentWorld = await ((_b = (_a = this._spec).getCurrentWorld) === null || _b === void 0 ? void 0 : _b.call(_a, this.target));
        const result = {
            id: currentWorld,
            home: origin,
            next,
            isNative: currentWorld === origin,
            isWebView: currentWorld !== origin,
        };
        this._logger.log('current world', result);
        return result;
    }
    // end world
    async refreshContexts() {
        if (this.isNative)
            return this.currentContext;
        const spec = this._spec;
        let currentContext = this.currentContext.target;
        let contextInfo = await getContextInfo(currentContext);
        const path = [];
        if (spec.parentContext) {
            while (!contextInfo.isRoot) {
                currentContext = await spec.parentContext(currentContext);
                const contextReference = await findContextReference(currentContext, contextInfo);
                if (!contextReference)
                    throw new Error('Unable to find out the chain of frames');
                path.unshift(contextReference);
                contextInfo = await getContextInfo(currentContext);
            }
        }
        else {
            currentContext = await spec.mainContext(currentContext);
            path.push(...(await findContextPath(currentContext, contextInfo)));
        }
        this._currentContext = this._mainContext;
        return this.switchToChildContext(...path);
        function transformSelector(selector) {
            return specUtils.transformSelector(spec, selector, { isWeb: true });
        }
        async function getContextInfo(context) {
            const [documentElement, selector, isRoot, isCORS] = await spec.executeScript(context, snippets.getContextInfo);
            return { documentElement, selector, isRoot, isCORS };
        }
        async function getChildContextsInfo(context) {
            const framesInfo = await spec.executeScript(context, snippets.getChildFramesInfo);
            return framesInfo.map(([contextElement, isCORS]) => ({ contextElement, isCORS }));
        }
        async function isEqualElements(context, element1, element2) {
            return spec.executeScript(context, snippets.isEqualElements, [element1, element2]).catch(() => false);
        }
        async function findContextReference(context, contextInfo) {
            if (contextInfo.selector) {
                const contextElement = await spec.findElement(context, transformSelector({ type: 'xpath', selector: contextInfo.selector }));
                if (contextElement)
                    return contextElement;
            }
            for (const childContextInfo of await getChildContextsInfo(context)) {
                if (childContextInfo.isCORS !== contextInfo.isCORS)
                    continue;
                const childContext = await spec.childContext(context, childContextInfo.contextElement);
                const contentDocument = await spec.findElement(childContext, transformSelector('html'));
                const isWantedContext = await isEqualElements(childContext, contentDocument, contextInfo.documentElement);
                await spec.parentContext(childContext);
                if (isWantedContext)
                    return childContextInfo.contextElement;
            }
        }
        async function findContextPath(context, contextInfo, contextPath = []) {
            const contentDocument = await spec.findElement(context, transformSelector('html'));
            if (await isEqualElements(context, contentDocument, contextInfo.documentElement)) {
                return contextPath;
            }
            for (const childContextInfo of await getChildContextsInfo(context)) {
                const childContext = await spec.childContext(context, childContextInfo.contextElement);
                const possibleContextPath = [...contextPath, childContextInfo.contextElement];
                const wantedContextPath = await findContextPath(childContext, contextInfo, possibleContextPath);
                await spec.mainContext(context);
                if (wantedContextPath)
                    return wantedContextPath;
                for (const contextElement of contextPath) {
                    await spec.childContext(context, contextElement);
                }
            }
        }
    }
    async switchTo(context) {
        if (await this.currentContext.equals(context)) {
            this._currentContext = context;
            return;
        }
        const currentPath = this.currentContext.path;
        const requiredPath = context.path;
        let diffIndex = -1;
        for (const [index, context] of requiredPath.entries()) {
            if (currentPath[index] && !(await currentPath[index].equals(context))) {
                diffIndex = index;
                break;
            }
        }
        if (diffIndex === 0) {
            throw new Error('Cannot switch to the context, because it has different main context');
        }
        else if (diffIndex === -1) {
            if (currentPath.length === requiredPath.length) {
                // required and current paths are the same
                return this.currentContext;
            }
            else if (requiredPath.length > currentPath.length) {
                // current path is a sub-path of required path
                return this.switchToChildContext(...requiredPath.slice(currentPath.length));
            }
            else if (currentPath.length - requiredPath.length <= requiredPath.length) {
                // required path is a sub-path of current path
                return this.switchToParentContext(currentPath.length - requiredPath.length);
            }
            else {
                // required path is a sub-path of current path
                await this.switchToMainContext();
                return this.switchToChildContext(...requiredPath);
            }
        }
        else if (currentPath.length - diffIndex <= diffIndex) {
            // required path is different from current or they are partially intersected
            // chose an optimal way to traverse from current context to target context
            await this.switchToParentContext(currentPath.length - diffIndex);
            return this.switchToChildContext(...requiredPath.slice(diffIndex));
        }
        else {
            await this.switchToMainContext();
            return this.switchToChildContext(...requiredPath);
        }
    }
    async switchToMainContext() {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to the main context');
        await this._spec.mainContext(this.currentContext.target);
        return (this._currentContext = this._mainContext);
    }
    async switchToParentContext(elevation = 1) {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to a parent context with elevation:', elevation);
        if (this.currentContext.path.length <= elevation) {
            return this.switchToMainContext();
        }
        try {
            while (elevation > 0) {
                await this._spec.parentContext(this.currentContext.target);
                this._currentContext = this._currentContext.parent;
                elevation -= 1;
            }
        }
        catch (err) {
            this._logger.warn('Unable to switch to a parent context due to error', err);
            this._logger.log('Applying workaround to switch to the parent frame');
            const path = this.currentContext.path.slice(1, -elevation);
            await this.switchToMainContext();
            await this.switchToChildContext(...path);
            elevation = 0;
        }
        return this.currentContext;
    }
    async switchToChildContext(...references) {
        if (this.isNative)
            throw new Error('Contexts are supported only for web drivers');
        this._logger.log('Switching to a child context with depth:', references.length);
        for (const reference of references) {
            if (reference === this.mainContext)
                continue;
            const context = await this.currentContext.context(reference);
            await context.focus();
        }
        return this.currentContext;
    }
    async normalizeRegion(region) {
        if (this.isWeb)
            return region;
        let normalizedRegion = region;
        if (this.isAndroid) {
            normalizedRegion = utils.geometry.scale(normalizedRegion, 1 / this.pixelRatio);
        }
        if (this.isIOS && utils.geometry.isIntersected(normalizedRegion, this._driverInfo.safeArea)) {
            normalizedRegion = utils.geometry.intersect(normalizedRegion, this._driverInfo.safeArea);
        }
        normalizedRegion = utils.geometry.offsetNegative(normalizedRegion, this._driverInfo.viewportLocation);
        if (normalizedRegion.y < 0) {
            normalizedRegion.height += normalizedRegion.y;
            normalizedRegion.y = 0;
        }
        return normalizedRegion;
    }
    async getRegionInViewport(context, region) {
        await context.focus();
        return context.getRegionInViewport(region);
    }
    async element(selector) {
        return this.currentContext.element(selector);
    }
    async elements(selector) {
        return this.currentContext.elements(selector);
    }
    async execute(script, arg) {
        return this.currentContext.execute(script, arg);
    }
    async takeScreenshot() {
        const image = await this._spec.takeScreenshot(this.target);
        if (utils.types.isString(image)) {
            return Buffer.from(image.replace(/[\r\n]+/g, ''), 'base64');
        }
        return image;
    }
    async getViewportRegion() {
        var _a, _b;
        return {
            ...((_b = (_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.viewportLocation) !== null && _b !== void 0 ? _b : { x: 0, y: 0 }),
            ...(await this.getViewportSize()),
        };
    }
    async getViewportSize() {
        var _a;
        let size;
        if (this.isNative) {
            if ((_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.viewportSize) {
                this._logger.log('Extracting viewport size from native driver using cached value');
                size = this._driverInfo.viewportSize;
            }
            else {
                this._logger.log('Extracting viewport size from native driver');
                size = await this.getDisplaySize();
                size.height -= this.statusBarSize;
            }
            this._logger.log(`Rounding viewport size using`, this._customConfig.useCeilForViewportSize ? 'ceil' : 'round');
            if (this._customConfig.useCeilForViewportSize) {
                size = utils.geometry.ceil(size);
            }
            else {
                size = utils.geometry.round(size);
            }
        }
        else if (this._spec.getViewportSize) {
            this._logger.log('Extracting viewport size from web driver using spec method');
            size = await this._spec.getViewportSize(this.target);
        }
        else {
            this._logger.log('Extracting viewport size from web driver using js snippet');
            size = await this.mainContext.execute(snippets.getViewportSize);
        }
        this._logger.log('Extracted viewport size', size);
        return size;
    }
    async setViewportSize(size) {
        if (this.isMobile)
            return;
        if (this._spec.setViewportSize) {
            this._logger.log('Setting viewport size to', size, 'using spec method');
            await this._spec.setViewportSize(this.target, size);
            return;
        }
        this._logger.log('Setting viewport size to', size, 'using workaround');
        const requiredViewportSize = size;
        let currentViewportSize = await this.getViewportSize();
        if (utils.geometry.equals(currentViewportSize, requiredViewportSize))
            return;
        let currentWindowSize = await this._spec.getWindowSize(this.target);
        this._logger.log('Extracted window size', currentWindowSize);
        let attempt = 0;
        while (attempt++ < 3) {
            const requiredWindowSize = {
                width: currentWindowSize.width + (requiredViewportSize.width - currentViewportSize.width),
                height: currentWindowSize.height + (requiredViewportSize.height - currentViewportSize.height),
            };
            this._logger.log(`Attempt #${attempt} to set viewport size by setting window size to`, requiredWindowSize);
            await this._spec.setWindowSize(this.target, requiredWindowSize);
            const prevViewportSize = currentViewportSize;
            currentViewportSize = await this.getViewportSize();
            if (utils.geometry.equals(currentViewportSize, prevViewportSize)) {
                currentViewportSize = await this.getViewportSize();
            }
            currentWindowSize = requiredWindowSize;
            if (utils.geometry.equals(currentViewportSize, requiredViewportSize))
                return;
            this._logger.log(`Attempt #${attempt} to set viewport size failed. Current viewport:`, currentViewportSize);
        }
        throw new Error('Failed to set viewport size!');
    }
    async getDisplaySize() {
        var _a, _b;
        if (this.isWeb && !this.isMobile)
            return;
        if ((_a = this._driverInfo) === null || _a === void 0 ? void 0 : _a.displaySize) {
            this._logger.log('Extracting display size from native driver using cached value');
            return this._driverInfo.displaySize;
        }
        let size = await this._spec.getWindowSize(this.target);
        if (((_b = (await this.getOrientation())) === null || _b === void 0 ? void 0 : _b.startsWith('landscape')) && size.height > size.width) {
            size = { width: size.height, height: size.width };
        }
        const normalizedSize = this.isAndroid ? utils.geometry.scale(size, 1 / this.pixelRatio) : size;
        this._logger.log('Extracted and normalized display size:', normalizedSize);
        return normalizedSize;
    }
    async getOrientation() {
        if (this.isWeb && !this.isMobile)
            return;
        let orientation;
        if (this.isAndroid) {
            this._logger.log('Extracting device orientation using adb command on android');
            const rotation = await this.execute('mobile:shell', {
                command: "dumpsys window | grep 'mCurrentRotation' | cut -d = -f2",
            })
                .then(r => { var _a; return (_a = r === null || r === void 0 ? void 0 : r.trim) === null || _a === void 0 ? void 0 : _a.call(r); })
                .catch(() => null);
            if (rotation === 'ROTATION_0' || rotation === '0')
                orientation = 'portrait';
            else if (rotation === 'ROTATION_90' || rotation === '3')
                orientation = 'landscape-secondary';
            else if (rotation === 'ROTATION_180' || rotation === '2')
                orientation = 'portrait-secondary';
            else if (rotation === 'ROTATION_270' || rotation === '1')
                orientation = 'landscape';
        }
        if (!orientation) {
            this._logger.log('Extracting device orientation');
            orientation = await this._spec.getOrientation(this.target);
        }
        this._logger.log('Extracted device orientation:', orientation);
        return orientation;
    }
    async setOrientation(orientation) {
        if (this.isWeb && !this.isMobile)
            return;
        this._logger.log('Set device orientation:', orientation);
        await this._spec.setOrientation(this.target, orientation);
    }
    async getCookies() {
        var _a, _b, _c;
        if (this.isNative || !this.features.allCookies)
            return [];
        try {
            return (_c = (await ((_b = (_a = this._spec).getCookies) === null || _b === void 0 ? void 0 : _b.call(_a, this.target)))) !== null && _c !== void 0 ? _c : [];
        }
        catch (error) {
            this._driverInfo.features.allCookies = false;
            throw error;
        }
    }
    async getTitle() {
        if (this.isNative)
            return null;
        const title = await this._spec.getTitle(this.target);
        this._logger.log('Extracted title:', title);
        return title;
    }
    async getUrl() {
        if (this.isNative)
            return null;
        const url = await this._spec.getUrl(this.target);
        this._logger.log('Extracted url:', url);
        return url;
    }
    async visit(url) {
        await this._spec.visit(this.target, url);
    }
}
exports.Driver = Driver;
function isDriver(driver, spec) {
    return driver instanceof Driver || (spec === null || spec === void 0 ? void 0 : spec.isDriver(driver));
}
exports.isDriver = isDriver;
async function makeDriver(options) {
    const driver = new Driver(options);
    await driver.init();
    await driver.refreshContexts();
    return driver;
}
exports.makeDriver = makeDriver;
