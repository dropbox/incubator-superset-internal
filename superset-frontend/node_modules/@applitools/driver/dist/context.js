"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const element_1 = require("./element");
const utils = __importStar(require("@applitools/utils"));
const specUtils = __importStar(require("./spec-utils"));
const snippets = require('@applitools/snippets');
class Context {
    constructor(options) {
        var _a, _b, _c;
        this._state = {};
        if (options.context instanceof Context)
            return options.context;
        this._spec = options.spec;
        if (options.logger)
            this._logger = options.logger;
        if (options.context) {
            if ((_c = (_b = (_a = this._spec).isContext) === null || _b === void 0 ? void 0 : _b.call(_a, options.context)) !== null && _c !== void 0 ? _c : this._spec.isDriver(options.context)) {
                this._target = options.context;
            }
            else {
                throw new TypeError('Context constructor called with argument of unknown type of context!');
            }
        }
        if (this._isReference(options.reference)) {
            if (options.reference instanceof Context)
                return options.reference;
            if (!options.parent) {
                throw new TypeError('Cannot construct child context without reference to the parent');
            }
            this._reference = options.reference;
            this._parent = options.parent;
            this._scrollingElement = options.scrollingElement;
            this._driver = options.driver || this._parent.driver;
        }
        else if (!options.reference) {
            this._element = null;
            this._parent = null;
            this._scrollingElement = options.scrollingElement;
            this._driver = options.driver;
        }
        else {
            throw new TypeError('Context constructor called with argument of unknown type!');
        }
    }
    _isReference(reference) {
        return (reference instanceof Context ||
            utils.types.isInteger(reference) ||
            utils.types.isString(reference) ||
            reference instanceof element_1.Element ||
            this._spec.isElement(reference) ||
            specUtils.isSelector(this._spec, reference));
    }
    get target() {
        return this._target;
    }
    get driver() {
        return this._driver;
    }
    get parent() {
        var _a;
        return (_a = this._parent) !== null && _a !== void 0 ? _a : null;
    }
    get main() {
        var _a, _b;
        return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.main) !== null && _b !== void 0 ? _b : this;
    }
    get path() {
        var _a, _b;
        return [...((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : []), this];
    }
    get isMain() {
        return this.main === this;
    }
    get isCurrent() {
        return this.driver.currentContext === this;
    }
    get isInitialized() {
        return Boolean(this._element) || this.isMain;
    }
    get isRef() {
        return !this._target;
    }
    async _findElements(selector, options = {}) {
        await this.focus();
        const { parent, all, wait } = options;
        const transformedSelector = specUtils.transformSelector(this._spec, selector, this.driver);
        let elements = [];
        if (wait) {
            if (this._spec.waitForSelector) {
                const element = await this._spec.waitForSelector(this.target, specUtils.transformSelector(this._spec, selector, this.driver), parent, wait);
                if (element)
                    elements = [element];
            }
            else {
                let waiting = true;
                const timeout = setTimeout(() => (waiting = false), wait.timeout);
                while (waiting) {
                    const element = await this._spec.findElement(this.target, specUtils.transformSelector(this._spec, selector, this.driver), parent);
                    if (element) {
                        clearTimeout(timeout);
                        elements = [element];
                    }
                    await utils.general.sleep(wait.interval);
                }
            }
        }
        else if (all) {
            elements = await this._spec.findElements(this.target, transformedSelector, parent);
        }
        else {
            const element = await this._spec.findElement(this.target, transformedSelector, parent);
            if (element)
                elements = [element];
        }
        if (specUtils.isCommonSelector(this._spec, selector)) {
            if (elements.length > 0) {
                if (selector.child) {
                    elements = await elements.reduce((result, element) => {
                        return result.then(async (result) => {
                            return result.concat(await this._findElements(selector.child, { parent: element, all, wait }));
                        });
                    }, Promise.resolve([]));
                }
                else if (selector.shadow) {
                    elements = await elements.reduce((result, element) => {
                        return result.then(async (result) => {
                            const root = await this._spec.executeScript(this.target, snippets.getShadowRoot, [element]);
                            return result.concat(root ? await this._findElements(selector.shadow, { parent: root, all, wait }) : []);
                        });
                    }, Promise.resolve([]));
                }
                else if (selector.frame) {
                    elements = await elements.reduce((result, element) => {
                        return result.then(async (result) => {
                            const context = await this.context(element);
                            return result.concat(await context._findElements(selector.frame, { all, wait }));
                        });
                    }, Promise.resolve([]));
                }
            }
            if (elements.length === 0 && selector.fallback) {
                elements = await this._findElements(selector.fallback, parent);
            }
        }
        return elements;
    }
    async init() {
        if (this.isInitialized)
            return this;
        if (!this._reference)
            throw new TypeError('Cannot initialize context without a reference to the context element');
        await this.parent.focus();
        this._logger.log('Context initialization');
        if (utils.types.isInteger(this._reference)) {
            this._logger.log('Getting context element using index:', this._reference);
            const elements = await this.parent.elements('frame, iframe');
            if (this._reference > elements.length) {
                throw new TypeError(`Context element with index ${this._reference} is not found`);
            }
            this._element = elements[this._reference];
        }
        else if (utils.types.isString(this._reference) || specUtils.isSelector(this._spec, this._reference)) {
            if (utils.types.isString(this._reference)) {
                this._logger.log('Getting context element by name or id', this._reference);
                this._element = await this.parent
                    .element(`iframe[name="${this._reference}"], iframe#${this._reference}`)
                    .catch(() => null);
            }
            if (!this._element && specUtils.isSelector(this._spec, this._reference)) {
                this._logger.log('Getting context element by selector', this._reference);
                this._element = await this.parent.element(this._reference);
            }
            if (!this._element) {
                throw new TypeError(`Context element with name, id, or selector ${JSON.stringify(this._reference)}' is not found`);
            }
        }
        else if (this._spec.isElement(this._reference) || this._reference instanceof element_1.Element) {
            this._logger.log('Initialize context from reference element', this._reference);
            this._element = new element_1.Element({
                spec: this._spec,
                context: this.parent,
                element: this._reference,
                logger: this._logger,
            });
        }
        else {
            throw new TypeError('Reference type does not supported');
        }
        this._reference = null;
        return this;
    }
    async focus() {
        if (this.isCurrent) {
            return this;
        }
        else if (this.isMain) {
            await this.driver.switchToMainContext();
            return this;
        }
        if (this.isRef) {
            await this.init();
        }
        if (!this.parent.isCurrent) {
            await this.driver.switchTo(this);
            return this;
        }
        await this.parent.preserveInnerOffset();
        if (this.parent.isMain)
            await this.parent.preserveContextRegions();
        await this.preserveContextRegions();
        this._target = await this._spec.childContext(this.parent.target, this._element.target);
        this.driver.updateCurrentContext(this);
        return this;
    }
    async equals(context) {
        if (context === this || (this.isMain && context === null))
            return true;
        if (!this._element)
            return false;
        return this._element.equals(context instanceof Context ? await context.getContextElement() : context);
    }
    async context(reference) {
        if (reference instanceof Context) {
            if (reference.parent !== this && !(await this.equals(reference.parent))) {
                throw Error('Cannot attach a child context because it has a different parent');
            }
            return reference;
        }
        else if (this._isReference(reference)) {
            return new Context({ spec: this._spec, parent: this, driver: this.driver, reference, logger: this._logger });
        }
        else if (utils.types.has(reference, 'reference')) {
            const parent = reference.parent ? await this.context(reference.parent) : this;
            return new Context({
                spec: this._spec,
                parent,
                driver: this.driver,
                reference: reference.reference,
                scrollingElement: reference === null || reference === void 0 ? void 0 : reference.scrollingElement,
                logger: this._logger,
            });
        }
    }
    async element(elementOrSelector) {
        if (this._spec.isElement(elementOrSelector)) {
            return new element_1.Element({ spec: this._spec, context: this, element: elementOrSelector, logger: this._logger });
        }
        else if (!specUtils.isSelector(this._spec, elementOrSelector)) {
            throw new TypeError('Cannot find element using argument of unknown type!');
        }
        if (this.isRef) {
            return new element_1.Element({ spec: this._spec, context: this, selector: elementOrSelector, logger: this._logger });
        }
        this._logger.log('Finding element by selector: ', elementOrSelector);
        const [element] = await this._findElements(elementOrSelector, { all: false });
        return element
            ? new element_1.Element({ spec: this._spec, context: this, element, selector: elementOrSelector, logger: this._logger })
            : null;
    }
    async elements(selectorOrElement) {
        if (specUtils.isSelector(this._spec, selectorOrElement)) {
            if (this.isRef) {
                return [new element_1.Element({ spec: this._spec, context: this, selector: selectorOrElement, logger: this._logger })];
            }
            this._logger.log('Finding elements by selector: ', selectorOrElement);
            const elements = await this._findElements(selectorOrElement, { all: true });
            return elements.map((element, index) => {
                return new element_1.Element({
                    spec: this._spec,
                    context: this,
                    element,
                    selector: selectorOrElement,
                    index,
                    logger: this._logger,
                });
            });
        }
        else if (this._spec.isElement(selectorOrElement)) {
            return [new element_1.Element({ spec: this._spec, context: this, element: selectorOrElement, logger: this._logger })];
        }
        else {
            throw new TypeError('Cannot find elements using argument of unknown type!');
        }
    }
    async waitFor(selector, options) {
        const [element] = await this._findElements(selector, {
            wait: { state: 'exist', timeout: 10000, interval: 500, ...options },
        });
        return element ? new element_1.Element({ spec: this._spec, context: this, element, selector, logger: this._logger }) : null;
    }
    async execute(script, arg) {
        await this.focus();
        try {
            return await this._spec.executeScript(this.target, script, serialize.call(this, arg));
        }
        catch (err) {
            this._logger.warn('Error during script execution with argument', arg);
            this._logger.error(err);
            throw err;
        }
        function serialize(value) {
            var _a, _b;
            if (this._spec.isElement(value) || value instanceof element_1.Element) {
                return value instanceof element_1.Element ? value.toJSON() : value;
            }
            else if (utils.types.isArray(value)) {
                return value.map(value => serialize.call(this, value));
            }
            else if (utils.types.isObject(value)) {
                return Object.entries((_b = (_a = value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value)) !== null && _b !== void 0 ? _b : value).reduce((serialized, [key, value]) => {
                    return Object.assign(serialized, { [key]: serialize.call(this, value) });
                }, {});
            }
            else {
                return value;
            }
        }
    }
    async executePoll(script, arg) {
        this._logger.log('Executing poll script');
        const { main: mainScript, poll: pollScript } = utils.types.isString(script) || utils.types.isFunction(script) ? { main: script, poll: script } : script;
        const { main: mainArg, poll: pollArg, executionTimeout = 60000, pollTimeout = 1000, } = !utils.types.has(arg, ['main', 'poll']) ? { main: arg, poll: arg } : arg;
        let isExecutionTimedOut = false;
        const executionTimer = setTimeout(() => (isExecutionTimedOut = true), executionTimeout);
        try {
            let response = deserialize(await this.execute(mainScript, mainArg));
            let chunks = '';
            while (!isExecutionTimedOut) {
                if (response.status === 'ERROR') {
                    throw new Error(`Error during execute poll script: '${response.error}'`);
                }
                else if (response.status === 'SUCCESS') {
                    return response.value;
                }
                else if (response.status === 'SUCCESS_CHUNKED') {
                    chunks += response.value;
                    if (response.done)
                        return deserialize(chunks);
                }
                else if (response.status === 'WIP') {
                    await utils.general.sleep(pollTimeout);
                }
                this._logger.log('Polling...');
                response = deserialize(await this.execute(pollScript, pollArg));
            }
            throw new Error('Poll script execution is timed out');
        }
        finally {
            clearTimeout(executionTimer);
        }
        function deserialize(json) {
            try {
                return JSON.parse(json);
            }
            catch (err) {
                const firstChars = json.slice(0, 100);
                const lastChars = json.slice(-100);
                throw new Error(`Response is not a valid JSON string. length: ${json.length}, first 100 chars: "${firstChars}", last 100 chars: "${lastChars}". error: ${err}`);
            }
        }
    }
    async getContextElement() {
        if (this.isMain)
            return null;
        await this.init();
        return this._element;
    }
    async getScrollingElement() {
        if (!(this._scrollingElement instanceof element_1.Element)) {
            await this.focus();
            if (this._scrollingElement) {
                this._scrollingElement = await this.element(this._scrollingElement);
            }
            else if (this.driver.isWeb) {
                let selector;
                if (this.driver.isIOS && !this.driver.isEmulation) {
                    selector = 'html';
                    this._logger.log(`Using hardcoded default scrolling element for Safari on iOS - "${selector}"`);
                }
                else {
                    selector = await this.execute(snippets.getDocumentScrollingElement);
                    this._logger.log(`Using dynamic default scrolling element - "${selector}"`);
                }
                this._scrollingElement = await this.element({ type: 'css', selector });
            }
            else {
                this._scrollingElement = await this.element({ type: 'xpath', selector: '//*[@scrollable="true"]' });
            }
        }
        return this._scrollingElement;
    }
    async setScrollingElement(scrollingElement) {
        if (scrollingElement === undefined)
            return;
        else if (scrollingElement === null)
            this._scrollingElement = null;
        else {
            this._scrollingElement =
                scrollingElement instanceof element_1.Element ? scrollingElement : await this.element(scrollingElement);
        }
    }
    async blurElement(element) {
        try {
            return await this.execute(snippets.blurElement, [element]);
        }
        catch (err) {
            this._logger.warn('Cannot blur element', element);
            this._logger.error(err);
            return null;
        }
    }
    async focusElement(element) {
        try {
            return await this.execute(snippets.focusElement, [element]);
        }
        catch (err) {
            this._logger.warn('Cannot focus element', element);
            this._logger.error(err);
            return null;
        }
    }
    async getRegion() {
        var _a;
        if (this.isMain && this.isCurrent) {
            const viewportRegion = utils.geometry.region({ x: 0, y: 0 }, await this.driver.getViewportSize());
            this._state.region = this._scrollingElement
                ? utils.geometry.region({ x: 0, y: 0 }, utils.geometry.intersect(viewportRegion, await this._scrollingElement.getRegion()))
                : viewportRegion;
        }
        else if ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isCurrent) {
            await this.init();
            this._state.region = await this._element.getRegion();
        }
        return this._state.region;
    }
    async getClientRegion() {
        var _a;
        if (this.isMain && this.isCurrent) {
            const viewportRegion = utils.geometry.region({ x: 0, y: 0 }, await this.driver.getViewportSize());
            this._state.clientRegion = this._scrollingElement
                ? utils.geometry.region({ x: 0, y: 0 }, utils.geometry.intersect(viewportRegion, await this._scrollingElement.getClientRegion()))
                : viewportRegion;
        }
        else if ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isCurrent) {
            await this.init();
            this._state.clientRegion = await this._element.getClientRegion();
        }
        return this._state.clientRegion;
    }
    async getScrollingRegion() {
        if (this.isCurrent) {
            const scrollingElement = await this.getScrollingElement();
            this._state.scrollingRegion = await scrollingElement.getClientRegion();
        }
        return this._state.scrollingRegion;
    }
    async getContentSize() {
        return this.execute(snippets.getDocumentSize);
    }
    async getInnerOffset() {
        if (this.isCurrent) {
            const scrollingElement = await this.getScrollingElement();
            this._state.innerOffset = scrollingElement ? await scrollingElement.getInnerOffset() : { x: 0, y: 0 };
        }
        return this._state.innerOffset;
    }
    async getLocationInMainContext() {
        return this.path.reduce((location, context) => {
            return location.then(async (location) => {
                return utils.geometry.offset(location, utils.geometry.location(await context.getClientRegion()));
            });
        }, Promise.resolve({ x: 0, y: 0 }));
    }
    async getLocationInViewport() {
        var _a, _b;
        let location = utils.geometry.offsetNegative({ x: 0, y: 0 }, await this.getInnerOffset());
        if (this.isMain)
            return location;
        let currentContext = this;
        while (currentContext) {
            const contextLocation = utils.geometry.location(await currentContext.getClientRegion());
            const parentContextInnerOffset = (_b = (await ((_a = currentContext.parent) === null || _a === void 0 ? void 0 : _a.getInnerOffset()))) !== null && _b !== void 0 ? _b : { x: 0, y: 0 };
            location = utils.geometry.offsetNegative(utils.geometry.offset(location, contextLocation), parentContextInnerOffset);
            currentContext = currentContext.parent;
        }
        return location;
    }
    async getRegionInViewport(region) {
        var _a, _b;
        let currentContext = this;
        this._logger.log('Converting context region to viewport region', region);
        if (region)
            region = utils.geometry.offsetNegative(region, await currentContext.getInnerOffset());
        else
            region = { x: 0, y: 0, width: Infinity, height: Infinity };
        while (currentContext) {
            const contextRegion = await currentContext.getClientRegion();
            // const contextScrollingRegion = await currentContext.getScrollingRegion()
            const parentContextInnerOffset = (_b = (await ((_a = currentContext.parent) === null || _a === void 0 ? void 0 : _a.getInnerOffset()))) !== null && _b !== void 0 ? _b : { x: 0, y: 0 };
            // TODO revisit
            if (this.driver.isWeb ||
                (!utils.geometry.equals(contextRegion, region) && utils.geometry.contains(contextRegion, region))) {
                this._logger.log('Intersecting context region', contextRegion, 'with context region', region);
                region = utils.geometry.intersect(contextRegion, utils.geometry.offset(region, contextRegion));
                // region = utils.geometry.intersect(contextScrollingRegion, region)
                region = utils.geometry.offsetNegative(region, parentContextInnerOffset);
            }
            currentContext = currentContext.parent;
        }
        return region;
    }
    async getCookies() {
        var _a, _b, _c;
        if (this.driver.isNative)
            return [];
        await this.focus();
        return (_c = (_b = (_a = this._spec).getCookies) === null || _b === void 0 ? void 0 : _b.call(_a, this.target, true)) !== null && _c !== void 0 ? _c : [];
    }
    async preserveInnerOffset() {
        this._state.innerOffset = await this.getInnerOffset();
    }
    async preserveContextRegions() {
        this._state.region = await this.getRegion();
        this._state.clientRegion = await this.getClientRegion();
    }
    async preserveScrollingRegion() {
        this._state.scrollingRegion = await this.getScrollingRegion();
    }
}
exports.Context = Context;
