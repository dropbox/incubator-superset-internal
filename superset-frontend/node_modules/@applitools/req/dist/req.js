"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.req = exports.makeReq = exports.mergeOptions = void 0;
const url_1 = require("url"); // should be replaced with `urlToHttpOptions` after supporting node >=16
const abort_controller_1 = require("abort-controller");
const https_1 = require("https");
const proxy_agent_1 = __importDefault(require("proxy-agent"));
const node_fetch_1 = __importStar(require("node-fetch"));
const utils = __importStar(require("@applitools/utils"));
const stop = Symbol('stop retry');
/**
 * Helper function that will properly merge two {@link Options} objects
 */
function mergeOptions(baseOption, options) {
    const mergedOptions = {
        ...baseOption,
        ...options,
        query: { ...baseOption.query, ...options === null || options === void 0 ? void 0 : options.query },
        headers: { ...baseOption.headers, ...options === null || options === void 0 ? void 0 : options.headers },
        retry: [...(baseOption.retry ? [].concat(baseOption.retry) : []), ...((options === null || options === void 0 ? void 0 : options.retry) ? [].concat(options.retry) : [])],
        hooks: [...(baseOption.hooks ? [].concat(baseOption.hooks) : []), ...((options === null || options === void 0 ? void 0 : options.hooks) ? [].concat(options.hooks) : [])],
    };
    return mergedOptions.hooks.reduce((options, hooks) => { var _a; return ((_a = hooks.afterOptionsMerged) === null || _a === void 0 ? void 0 : _a.call(hooks, { options })) || options; }, mergedOptions);
}
exports.mergeOptions = mergeOptions;
/**
 * Helper function that will create {@link req} function with predefined options
 * @example const req = makeReq({baseUrl: 'http://localhost:2107'})
 */
function makeReq(baseOption) {
    return (location, options) => req(location, mergeOptions(baseOption, options));
}
exports.makeReq = makeReq;
async function req(input, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const fetch = (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : node_fetch_1.default;
    if (options === null || options === void 0 ? void 0 : options.hooks)
        options.hooks = utils.types.isArray(options.hooks) ? options.hooks : [options.hooks];
    if (options === null || options === void 0 ? void 0 : options.retry)
        options.retry = utils.types.isArray(options.retry) ? options.retry : [options.retry];
    if (options === null || options === void 0 ? void 0 : options.headers) {
        options.headers = Object.fromEntries(Object.entries(options.headers).filter(([_, value]) => value));
    }
    const beforeRequest = ({ request, ...rest }) => {
        var _a;
        return ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []).reduce(async (request, hooks) => {
            var _a;
            request = await request;
            const result = (await ((_a = hooks.beforeRequest) === null || _a === void 0 ? void 0 : _a.call(hooks, { request, ...rest }))) || null;
            return result !== null && result !== void 0 ? result : request;
        }, request);
    };
    const beforeRetry = ({ request, ...rest }) => {
        var _a;
        return ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []).reduce(async (request, hooks) => {
            var _a;
            request = await request;
            if (request === stop)
                return request;
            const result = (await ((_a = hooks.beforeRetry) === null || _a === void 0 ? void 0 : _a.call(hooks, { request, ...rest }))) || null;
            return result === stop ? result : result !== null && result !== void 0 ? result : request;
        }, request);
    };
    const afterResponse = ({ response, ...rest }) => {
        var _a, _b;
        return (_b = ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : [])) === null || _b === void 0 ? void 0 : _b.reduce(async (response, hooks) => {
            var _a;
            response = await response;
            const result = (await ((_a = hooks.afterResponse) === null || _a === void 0 ? void 0 : _a.call(hooks, { response, ...rest }))) || null;
            return result !== null && result !== void 0 ? result : response;
        }, response);
    };
    const afterError = ({ error, ...rest }) => {
        var _a, _b;
        return (_b = ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : [])) === null || _b === void 0 ? void 0 : _b.reduce(async (error, hooks) => {
            var _a;
            error = await error;
            return (await ((_a = hooks.afterError) === null || _a === void 0 ? void 0 : _a.call(hooks, { error, ...rest }))) || error;
        }, error);
    };
    const controller = new abort_controller_1.AbortController();
    const url = new URL(String((_b = input.url) !== null && _b !== void 0 ? _b : input), options === null || options === void 0 ? void 0 : options.baseUrl);
    if (options === null || options === void 0 ? void 0 : options.query) {
        Object.entries(options.query).forEach(([key, value]) => {
            if (!utils.types.isNull(value))
                url.searchParams.set(key, String(value));
        });
    }
    let request = new node_fetch_1.Request(url, {
        method: (_c = options === null || options === void 0 ? void 0 : options.method) !== null && _c !== void 0 ? _c : input.method,
        headers: {
            ...Object.fromEntries((_e = (_d = input.headers) === null || _d === void 0 ? void 0 : _d.entries()) !== null && _e !== void 0 ? _e : []),
            ...Object.fromEntries(new node_fetch_1.Headers(options === null || options === void 0 ? void 0 : options.headers).entries()),
        },
        body: utils.types.isPlainObject(options === null || options === void 0 ? void 0 : options.body) || utils.types.isArray(options === null || options === void 0 ? void 0 : options.body)
            ? JSON.stringify(options.body)
            : (_f = options === null || options === void 0 ? void 0 : options.body) !== null && _f !== void 0 ? _f : input.body,
        agent: url => {
            var _a, _b;
            const proxy = utils.types.isFunction(options === null || options === void 0 ? void 0 : options.proxy) ? options.proxy(url) : options === null || options === void 0 ? void 0 : options.proxy;
            if (proxy) {
                const proxyUrl = new URL(proxy.url);
                proxyUrl.username = (_a = proxy.username) !== null && _a !== void 0 ? _a : proxyUrl.username;
                proxyUrl.password = (_b = proxy.password) !== null && _b !== void 0 ? _b : proxyUrl.password;
                const agent = new proxy_agent_1.default({ ...(0, url_1.parse)(proxyUrl.href), rejectUnauthorized: false });
                const originalCallback = agent.callback.bind(agent);
                agent.callback = (request, options, callback) => originalCallback(request, { ...options, rejectUnauthorized: false }, callback);
                return agent;
            }
            else if (url.protocol === 'https:') {
                return new https_1.Agent({ rejectUnauthorized: false });
            }
        },
        signal: controller.signal,
    });
    request = await beforeRequest({ request, options });
    const timer = (options === null || options === void 0 ? void 0 : options.timeout) > 0 ? setTimeout(() => controller.abort(), options.timeout) : null;
    try {
        let response = await fetch(request);
        // if the request has to be retried due to status code
        const retry = (_g = options === null || options === void 0 ? void 0 : options.retry) === null || _g === void 0 ? void 0 : _g.find(retry => {
            var _a, _b;
            return (((_a = retry.statuses) === null || _a === void 0 ? void 0 : _a.includes(response.status)) || ((_b = retry.validate) === null || _b === void 0 ? void 0 : _b.call(retry, { response }))) &&
                (!retry.limit || !retry.attempt || retry.attempt < retry.limit);
        });
        if (retry) {
            (_h = retry.attempt) !== null && _h !== void 0 ? _h : (retry.attempt = 0);
            let delay = response.headers.has('Retry-After') ? Number(response.headers.get('Retry-After')) * 1000 : null;
            delay !== null && delay !== void 0 ? delay : (delay = utils.types.isArray(retry.timeout) ? retry.timeout[Math.min(retry.attempt, retry.timeout.length)] : retry.timeout);
            await utils.general.sleep(delay);
            retry.attempt += 1;
            const retryRequest = await beforeRetry({ request, response, attempt: retry.attempt, stop, options });
            if (retryRequest !== stop) {
                return req(retryRequest, options);
            }
        }
        response = await afterResponse({ request, response, options });
        return response;
    }
    catch (error) {
        // if the request has to be retried due to network error
        const retry = (_j = options === null || options === void 0 ? void 0 : options.retry) === null || _j === void 0 ? void 0 : _j.find(retry => {
            var _a, _b;
            return (((_a = retry.codes) === null || _a === void 0 ? void 0 : _a.includes(error.code)) || ((_b = retry.validate) === null || _b === void 0 ? void 0 : _b.call(retry, { error }))) &&
                (!retry.limit || !retry.attempt || retry.attempt < retry.limit);
        });
        if (retry) {
            (_k = retry.attempt) !== null && _k !== void 0 ? _k : (retry.attempt = 0);
            const delay = utils.types.isArray(retry.timeout)
                ? retry.timeout[Math.min(retry.attempt, retry.timeout.length)]
                : retry.timeout;
            await utils.general.sleep(delay);
            retry.attempt = retry.attempt + 1;
            const retryRequest = await beforeRetry({ request, error, attempt: retry.attempt, stop, options });
            if (retryRequest !== stop) {
                return req(retryRequest, options);
            }
        }
        error = await afterError({ request, error, options });
        throw error;
    }
    finally {
        clearTimeout(timer);
    }
}
exports.req = req;
exports.default = req;
