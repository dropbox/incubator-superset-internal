/// <reference types="node" />
/// <reference types="node" />
import globalFetch, { Request, Response } from 'node-fetch';
declare const stop: unique symbol;
export declare type Fetch = typeof globalFetch;
export declare type Options = {
    /**
     * Providing this value will allow usage of relative urls for input
     * @example 'http://localhost:2107/api/'
     */
    baseUrl?: string;
    /**
     * Uppercase method name. This will override method provided in `Request` object
     * @example 'GET'
     */
    method?: string;
    /**
     * Query parameters to add to the url, all undefined params won't be added.
     * It won't override the whole `search` part of the url, but instead merge with it
     * @example {string: 'value', number: 21, boolean: true, noop: undefined}
     */
    query?: Record<string, string | boolean | number | undefined>;
    /**
     * Headers to send in the request, all undefined headers won't be sent.
     * This will merge with headers provided in `Request` object
     * @example {'x-my-header': 'value', 'x-noop-header': undefined}
     */
    headers?: Record<string, string | undefined>;
    /**
     * Body of the request, plain objects will be transformed to JSON strings
     * @example {data: true}
     * @example Buffer.from('S3lyeWxv', 'base64')
     */
    body?: NodeJS.ReadableStream | ArrayBufferView | string | Record<string, any>;
    /**
     * Proxy settings for the request. Auth credentials specified in the object will override ones specified in url
     * @example {url: 'http://localhost:2107', username: 'kyrylo', password: 'pass'}
     */
    proxy?: Proxy | ((url: URL) => Proxy);
    /**
     * Connection timeout in ms
     * @example 7000
     */
    timeout?: number;
    /**
     * Retry settings for the request. If specified as an array the retries are applied in the order
     * @see Retry
     * @example {limit: 5, statuses: [500, 501], codes: ['ECONRESET'], timeout: 1000}
     */
    retry?: Retry | Retry[];
    /**
     * Hooks of the request
     * @see Hooks
     */
    hooks?: Hooks | Hooks[];
    fetch?: Fetch;
};
export declare type Retry = {
    /**
     * Max number of attempts for specified condition
     */
    limit?: number;
    /**
     * Timeout before retrying the request. If specified as an array each element specifies the timeout for specific attempt,
     * and the last one will be default for all next attempts
     * @example [1000, 1000, 5000, 10_000]
     */
    timeout?: number | number[];
    /**
     * Validation logic of the request outcome to retry on.
     * @example ({response, error}) => error || response.status >= 400
     */
    validate?: (options: {
        response?: Response;
        error?: Error;
    }) => boolean;
    /**
     * Status codes of the response to retry on.
     * @example [500]
     */
    statuses?: number[];
    /**
     * Error codes of the request to retry on.
     * @example ['ECONRESET']
     */
    codes?: string[];
    /**
     * Number of the current attempt for specified condition
     * @internal
     */
    attempt?: number;
};
export declare type Proxy = {
    url: string;
    username?: string;
    password?: string;
};
export declare type Hooks<TOptions extends Options = Options> = {
    /**
     * Hook that will be executed after options are merged, it will not be executed if no merge takes place
     * @example
     * ```
     * {
     *   afterOptionsMerged({options}) {
     *      options.timeout = 0
     *   }
     * }
     * ```
     */
    afterOptionsMerged?(options: {
        options: TOptions;
    }): TOptions | void;
    /**
     * Hook that will be executed before sending the request, after all, modifications of the `Request` object are already passed
     * @example
     * ```
     * {
     *   beforeRequest({request}) {
     *      request.headers.set('Expires', 'Tue, 24 Aug 2022 00:00:00 GMT')
     *   }
     * }
     * ```
     */
    beforeRequest?(options: {
        request: Request;
        options: TOptions;
    }): Request | void | Promise<Request | void>;
    /**
     * Hook that will be executed before retrying the request. If this hook will return {@link req.stop}
     * it will prevent request from retrying and execution of other hooks
     * @example
     * ```
     * {
     *   async beforeRetry({request, response, attempt}) {
     *      const data = await response?.json()
     *      if (data.error) return req.stop
     *      request.headers.set('x-attempt', attempt)
     *   }
     * }
     * ```
     */
    beforeRetry?(options: {
        request: Request;
        attempt: number;
        stop: typeof stop;
        response?: Response;
        error?: Error;
        options: TOptions;
    }): Request | typeof stop | void | Promise<Request | void | typeof stop>;
    /**
     * Hook that will be executed after getting the final response of the request (after all of the retries)
     * @example
     * ```
     * {
     *   async afterResponse({request, response, options}) {
     *      if (!response.ok) return req(request, options)
     *   }
     * }
     * ```
     */
    afterResponse?(options: {
        request: Request;
        response: Response;
        options: TOptions;
    }): Response | void | Promise<Response | void>;
    /**
     * Hook that will be executed after request will throw an error
     * @example
     * ```
     * {
     *   async afterError({request, error}) {
     *      error.request = request
     *   }
     * }
     * ```
     */
    afterError?(options: {
        request: Request;
        error: Error;
        options: TOptions;
    }): Error | void | Promise<Error | void>;
};
export declare type Req<TOptions extends Options = Options> = (input: string | URL | Request, options?: TOptions) => Promise<Response>;
/**
 * Helper function that will properly merge two {@link Options} objects
 */
export declare function mergeOptions<TOptions extends Options>(baseOption: TOptions, options: TOptions): TOptions;
/**
 * Helper function that will create {@link req} function with predefined options
 * @example const req = makeReq({baseUrl: 'http://localhost:2107'})
 */
export declare function makeReq<TOptions extends Options = Options>(baseOption?: Partial<Options>): Req<TOptions>;
export declare function req(input: string | URL | Request, options?: Options): Promise<Response>;
export default req;
