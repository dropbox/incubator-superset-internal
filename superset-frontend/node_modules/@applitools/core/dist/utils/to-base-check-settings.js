"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBaseCheckSettings = void 0;
const utils = __importStar(require("@applitools/utils"));
function toBaseCheckSettings({ settings, }) {
    const regionTypes = ['ignore', 'layout', 'strict', 'content', 'floating', 'accessibility'];
    const elementReferencesToCalculate = regionTypes.flatMap(regionType => {
        var _a;
        return ((_a = settings[`${regionType}Regions`]) !== null && _a !== void 0 ? _a : []).reduce((regions, reference) => {
            const { region } = utils.types.has(reference, 'region') ? reference : { region: reference };
            return !isRegion(region) ? regions.concat(region) : regions;
        }, []);
    });
    const elementReferenceToTarget = !isRegion(settings.region) ? settings.region : undefined;
    return { elementReferencesToCalculate, elementReferenceToTarget, getBaseCheckSettings };
    function getBaseCheckSettings({ calculatedRegions, preserveTransformation, }) {
        const transformedSettings = { ...settings };
        if (!preserveTransformation) {
            delete transformedSettings.region;
            delete transformedSettings.normalization;
        }
        else if (elementReferenceToTarget) {
            delete transformedSettings.region;
        }
        regionTypes.forEach(regionType => {
            if (!transformedSettings[`${regionType}Regions`])
                return;
            transformedSettings[`${regionType}Regions`] = transformedSettings[`${regionType}Regions`].flatMap(reference => {
                const { region, ...options } = utils.types.has(reference, 'region') ? reference : { region: reference };
                if (isRegion(region))
                    return reference;
                const { selector, regions } = calculatedRegions.shift();
                return regions.map(region => ({
                    region,
                    regionId: utils.types.isString(selector) ? selector : selector === null || selector === void 0 ? void 0 : selector.selector,
                    ...options,
                }));
            });
        });
        return transformedSettings;
    }
    function isRegion(region) {
        return utils.types.has(region, ['x', 'y', 'width', 'height']);
    }
}
exports.toBaseCheckSettings = toBaseCheckSettings;
