import { max as d3Max } from 'd3-array';
import caseInsensitiveSort from './caseInsensitiveSort';
/*
 * Computes the bin and value domains from numeric or categorical bins
 */

export default function computeDomainsFromBins(_ref) {
  var binsByIndex = _ref.binsByIndex,
      binType = _ref.binType,
      valueKey = _ref.valueKey,
      binValues = _ref.binValues;
  var binDomain;
  var valueDomain;
  Object.values(binsByIndex).forEach(function (bins) {
    var currValueMax = d3Max(bins, function (d) {
      return d[valueKey];
    });

    if (valueDomain) {
      valueDomain[1] = Math.max(currValueMax, valueDomain[1]);
    } else {
      valueDomain = [0, currValueMax];
    }

    if (binType === 'numeric') {
      if (binDomain) {
        binDomain[0] = Math.min(bins[0].bin0, binDomain[0]);
        binDomain[1] = Math.max(bins[bins.length - 1].bin1, binDomain[1]);
      } else {
        binDomain = [bins[0].bin0, bins[bins.length - 1].bin1];
      }
    } else {
      if (!binDomain) binDomain = {}; // use lookup to avoid lots of Array scans

      bins.forEach(function (bin) {
        binDomain[bin.bin] = true;
      });
    }
  });

  if (Array.isArray(binValues)) {
    var providedBinsCoverDomain = true;
    binValues.forEach(function (binValue) {
      if (!(binValue in binDomain)) {
        providedBinsCoverDomain = false;
      }
    });

    if (providedBinsCoverDomain) {
      binDomain = binValues;
    }
  }

  if (!Array.isArray(binDomain)) {
    binDomain = Object.keys(binDomain).sort(caseInsensitiveSort);
  }

  return {
    binDomain: binDomain,
    valueDomain: valueDomain
  };
}