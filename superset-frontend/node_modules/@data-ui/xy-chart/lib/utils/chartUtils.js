"use strict";

exports.__esModule = true;
exports.callOrValue = callOrValue;
exports.componentName = componentName;
exports.getChildWithName = getChildWithName;
exports.isDefined = isDefined;
exports.isAxis = isAxis;
exports.isBarSeries = isBarSeries;
exports.isBrush = isBrush;
exports.isCirclePackSeries = isCirclePackSeries;
exports.isCrossHair = isCrossHair;
exports.isReferenceLine = isReferenceLine;
exports.isSeries = isSeries;
exports.isStackedSeries = isStackedSeries;
exports.numTicksForHeight = numTicksForHeight;
exports.numTicksForWidth = numTicksForWidth;
exports.propOrFallback = propOrFallback;
exports.scaleInvert = scaleInvert;
exports.getDomainFromExtent = getDomainFromExtent;
exports.DEFAULT_CHART_MARGIN = void 0;

var _react = require("react");

/* eslint no-magic-numbers: 'off' */
function callOrValue(maybeFn) {
  if (typeof maybeFn === 'function') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return maybeFn.apply(void 0, args);
  }

  return maybeFn;
}

function componentName(component) {
  if (component && component.type) {
    return component.type.displayName || component.type.name || 'Component';
  }

  return '';
}

function getChildWithName(name, children) {
  var ChildOfInterest = _react.Children.toArray(children).filter(function (c) {
    return componentName(c) === name;
  });

  return ChildOfInterest.length ? ChildOfInterest[0] : null;
}

function isDefined(val) {
  return typeof val !== 'undefined' && val !== null;
}

function isAxis(name) {
  return /axis/gi.test(name);
}

function isBarSeries(name) {
  return /bar/gi.test(name);
}

function isBrush(name) {
  return name === 'Brush';
}

function isCirclePackSeries(name) {
  return name === 'CirclePackSeries';
}

function isCrossHair(name) {
  return /crosshair/gi.test(name);
}

function isReferenceLine(name) {
  return /reference/gi.test(name);
}

function isSeries(name) {
  return /series/gi.test(name);
}

function isStackedSeries(name) {
  return /stacked/gi.test(name);
}

function numTicksForHeight(height) {
  if (height <= 300) return 3;
  if (height <= 600) return 5;
  return 8;
}

function numTicksForWidth(width) {
  if (width <= 300) return 3;
  if (width <= 400) return 5;
  return 10;
}

function propOrFallback(props, propName, fallback) {
  return props && isDefined(props[propName]) ? props[propName] : fallback;
}

function scaleInvert(scale, value) {
  // Test if the scale is an ordinalScale or not,
  // Since an ordinalScale doesn't support invert function.
  if (!scale.invert) {
    var _scale$range = scale.range(),
        start = _scale$range[0],
        end = _scale$range[1];

    var i = 0;
    var width = scale.step() * (end - start) / Math.abs(end - start);

    if (width > 0) {
      while (value > start + width * (i + 1)) {
        i += 1;
      }
    } else {
      while (value < start + width * (i + 1)) {
        i += 1;
      }
    }

    return i;
  }

  return scale.invert(value);
}

function getDomainFromExtent(scale, start, end, tolerentDelta) {
  var domain;
  var invertedStart = scaleInvert(scale, start + (start < end ? -tolerentDelta : tolerentDelta));
  var invertedEnd = scaleInvert(scale, end + (end < start ? -tolerentDelta : tolerentDelta));
  var minValue = Math.min(invertedStart, invertedEnd);
  var maxValue = Math.max(invertedStart, invertedEnd);

  if (scale.invert) {
    domain = {
      start: minValue,
      end: maxValue
    };
  } else {
    var values = [];
    var scaleDomain = scale.domain();

    for (var i = minValue; i <= maxValue; i += 1) {
      values.push(scaleDomain[i]);
    }

    domain = {
      values: values
    };
  }

  return domain;
}

var DEFAULT_CHART_MARGIN = {
  top: 64,
  right: 64,
  bottom: 64,
  left: 64
};
exports.DEFAULT_CHART_MARGIN = DEFAULT_CHART_MARGIN;