"use strict";

exports.__esModule = true;
exports.default = collectScalesFromProps;

var _react = require("react");

var _collectDataFromChildSeries = _interopRequireDefault(require("./collectDataFromChildSeries"));

var _getChartDimensions2 = _interopRequireDefault(require("./getChartDimensions"));

var _getScaleForAccessor = _interopRequireDefault(require("./getScaleForAccessor"));

var _chartUtils = require("./chartUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getX = function getX(d) {
  return d && d.x;
};

var xString = function xString(d) {
  return getX(d).toString();
};

var getY = function getY(d) {
  return d && d.y;
};

var yString = function yString(d) {
  return getY(d).toString();
};

function collectScalesFromProps(props) {
  var xScaleObject = props.xScale,
      yScaleObject = props.yScale,
      children = props.children;

  var _getChartDimensions = (0, _getChartDimensions2.default)(props),
      innerWidth = _getChartDimensions.innerWidth,
      innerHeight = _getChartDimensions.innerHeight;

  var allData = (0, _collectDataFromChildSeries.default)(children); // TODO could collect data extents from child series
  // which would support passing arbitrary x/y accessors
  // const [xExtent, yExtent] = collectExtentsFromChildSeries(children);
  // issues:
  //  voronoi transforms data via scale(getXorY(d))
  //    => Could be solved by transforming in data collection
  //  tooltip/crosshair transforms data via scale(getXorY(d))
  //    => could be solved by transforming in the mousemove call so series own it?

  var xScale = (0, _getScaleForAccessor.default)(_extends({
    allData: allData,
    minAccessor: function minAccessor(d) {
      return typeof d.x0 === 'undefined' ? d.x : d.x0;
    },
    maxAccessor: function maxAccessor(d) {
      return typeof d.x1 === 'undefined' ? d.x : d.x1;
    },
    range: [0, innerWidth]
  }, xScaleObject));
  var yScale = (0, _getScaleForAccessor.default)(_extends({
    allData: allData,
    minAccessor: function minAccessor(d) {
      return typeof d.y0 === 'undefined' ? d.y : d.y0;
    },
    maxAccessor: function maxAccessor(d) {
      return typeof d.y1 === 'undefined' ? d.y : d.y1;
    },
    range: [innerHeight, 0]
  }, yScaleObject));

  _react.Children.forEach(children, function (Child) {
    // Child-specific scales or adjustments here
    var name = (0, _chartUtils.componentName)(Child);

    if ((0, _chartUtils.isBarSeries)(name)) {
      var horizontal = Child.props.horizontal;
      var categoryScaleObject = horizontal ? yScaleObject : xScaleObject;

      if (categoryScaleObject.type !== 'band') {
        var categoryScale = horizontal ? yScale : xScale;
        var range = horizontal ? innerHeight : innerWidth;
        var dummyBand = (0, _getScaleForAccessor.default)({
          allData: allData,
          minAccessor: horizontal ? yString : xString,
          maxAccessor: horizontal ? yString : xString,
          type: 'band',
          rangeRound: [0, range],
          paddingOuter: 1
        });
        var offset = dummyBand.bandwidth() / 2;
        categoryScale.range([offset, range - offset]);
        categoryScale.barWidth = dummyBand.bandwidth();
        categoryScale.offset = offset;
      }
    }

    if ((0, _chartUtils.isCirclePackSeries)(name)) {
      yScale.domain([-innerHeight / 2, innerHeight / 2]);
    }
  });

  return {
    xScale: xScale,
    yScale: yScale
  };
}