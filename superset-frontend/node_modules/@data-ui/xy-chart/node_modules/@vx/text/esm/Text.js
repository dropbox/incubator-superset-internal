function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import PropTypes from 'prop-types';
import React, { Component } from 'react';
import reduceCSSCalc from 'reduce-css-calc';
import getStringWidth from './util/getStringWidth';
var propTypes = {
  scaleToFit: PropTypes.bool,
  angle: PropTypes.number,
  textAnchor: PropTypes.oneOf(['start', 'middle', 'end', 'inherit']),
  verticalAnchor: PropTypes.oneOf(['start', 'middle', 'end']),
  style: PropTypes.object,
  innerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
  x: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  y: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  dx: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  dy: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  lineHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  capHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  children: PropTypes.any,
  width: PropTypes.number
};
var defaultProps = {
  x: 0,
  y: 0,
  dx: 0,
  dy: 0,
  lineHeight: '1em',
  capHeight: '0.71em',
  // Magic number from d3
  scaleToFit: false,
  textAnchor: 'start',
  verticalAnchor: 'end' // default SVG behavior

};

var Text =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Text, _Component);

  function Text(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      wordsByLines: []
    };
    return _this;
  } // eslint-disable-next-line camelcase


  var _proto = Text.prototype;

  _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
    this.updateWordsByLines(this.props, true);
  } // eslint-disable-next-line camelcase
  ;

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;
    this.updateWordsByLines(nextProps, needCalculate);
  };

  _proto.updateWordsByLines = function updateWordsByLines(props, needCalculate) {
    // Only perform calculations if using features that require them (multiline, scaleToFit)
    if (props.width || props.scaleToFit) {
      if (needCalculate) {
        var words = props.children ? props.children.toString().split(/(?:(?!\u00A0+)\s+)/) : [];
        this.wordsWithComputedWidth = words.map(function (word) {
          return {
            word: word,
            width: getStringWidth(word, props.style)
          };
        });
        this.spaceWidth = getStringWidth("\xA0", props.style);
      }

      var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);
      this.setState({
        wordsByLines: wordsByLines
      });
    } else {
      this.updateWordsWithoutCalculate(props);
    }
  };

  _proto.updateWordsWithoutCalculate = function updateWordsWithoutCalculate(props) {
    var words = props.children ? props.children.toString().split(/(?:(?!\u00A0+)\s+)/) : [];
    this.setState({
      wordsByLines: [{
        words: words
      }]
    });
  };

  _proto.calculateWordsByLines = function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {
    var scaleToFit = this.props.scaleToFit;
    return wordsWithComputedWidth.reduce(function (result, _ref) {
      var word = _ref.word,
          width = _ref.width;
      var currentLine = result[result.length - 1];

      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {
        // Word can be added to an existing line
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        // Add first word to line or word is too long to scaleToFit on existing line
        var newLine = {
          words: [word],
          width: width
        };
        result.push(newLine);
      }

      return result;
    }, []);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        dx = _this$props.dx,
        dy = _this$props.dy,
        textAnchor = _this$props.textAnchor,
        verticalAnchor = _this$props.verticalAnchor,
        scaleToFit = _this$props.scaleToFit,
        angle = _this$props.angle,
        lineHeight = _this$props.lineHeight,
        capHeight = _this$props.capHeight,
        innerRef = _this$props.innerRef,
        textProps = _objectWithoutPropertiesLoose(_this$props, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "innerRef"]);

    var wordsByLines = this.state.wordsByLines;
    var x = textProps.x,
        y = textProps.y;
    var startDy;

    switch (verticalAnchor) {
      case 'start':
        startDy = reduceCSSCalc("calc(" + capHeight + ")");
        break;

      case 'middle':
        startDy = reduceCSSCalc("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))");
        break;

      default:
        startDy = reduceCSSCalc("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
        break;
    }

    var transforms = [];

    if (scaleToFit && wordsByLines.length > 0) {
      var lineWidth = wordsByLines[0].width;
      var sx = this.props.width / lineWidth;
      var sy = sx;
      var originX = x - sx * x;
      var originY = y - sy * y;
      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
    }

    if (angle) {
      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
    }

    if (transforms.length > 0) {
      textProps.transform = transforms.join(' ');
    }

    return React.createElement("svg", {
      ref: innerRef,
      x: dx,
      y: dy,
      fontSize: textProps.fontSize,
      style: {
        overflow: 'visible'
      }
    }, React.createElement("text", _extends({}, textProps, {
      textAnchor: textAnchor
    }), wordsByLines.map(function (line, index) {
      return React.createElement("tspan", {
        x: x,
        dy: index === 0 ? startDy : lineHeight,
        key: index
      }, line.words.join(' '));
    })));
  };

  return Text;
}(Component);

Text.propTypes = propTypes;
Text.defaultProps = defaultProps;
export default Text;