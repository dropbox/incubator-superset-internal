function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

import React from 'react';
import PropTypes from 'prop-types';
import { GridColumns, GridRows } from '@vx/grid';
import { Group } from '@vx/group';
import { WithTooltip } from '@data-ui/shared';
import collectVoronoiData from '../utils/collectVoronoiData';
import findClosestDatums from '../utils/findClosestDatums';
import shallowCompareObjectEntries from '../utils/shallowCompareObjectEntries';
import Voronoi from './Voronoi';
import { componentName, isAxis, isCrossHair, isDefined, isReferenceLine, isSeries, isBrush, getChildWithName, numTicksForWidth, numTicksForHeight, propOrFallback, DEFAULT_CHART_MARGIN } from '../utils/chartUtils';
import collectScalesFromProps from '../utils/collectScalesFromProps';
import getChartDimensions from '../utils/getChartDimensions';
import { scaleShape, themeShape, stringNumberDateObjectPropType } from '../utils/propShapes';
export var CONTAINER_TRIGGER = 'container';
export var SERIES_TRIGGER = 'series';
export var VORONOI_TRIGGER = 'voronoi';
var Y_LABEL_OFFSET = 0.7;
export var propTypes = {
  ariaLabel: PropTypes.string.isRequired,
  children: PropTypes.node,
  disableMouseEvents: PropTypes.bool,
  eventTrigger: PropTypes.oneOf([CONTAINER_TRIGGER, SERIES_TRIGGER, VORONOI_TRIGGER]),
  eventTriggerRefs: PropTypes.func,
  height: PropTypes.number.isRequired,
  innerRef: PropTypes.func,
  margin: PropTypes.shape({
    top: PropTypes.number,
    right: PropTypes.number,
    bottom: PropTypes.number,
    left: PropTypes.number
  }),
  renderTooltip: PropTypes.func,
  showXGrid: PropTypes.bool,
  xGridValues: PropTypes.arrayOf(stringNumberDateObjectPropType),
  xGridOffset: PropTypes.number,
  showYGrid: PropTypes.bool,
  yGridValues: PropTypes.arrayOf(stringNumberDateObjectPropType),
  yGridOffset: PropTypes.number,
  showVoronoi: PropTypes.bool,
  snapTooltipToDataX: PropTypes.bool,
  snapTooltipToDataY: PropTypes.bool,
  theme: themeShape,
  width: PropTypes.number.isRequired,
  xScale: scaleShape.isRequired,
  yScale: scaleShape.isRequired,
  // these may be passed from WithTooltip
  onClick: PropTypes.func,
  // expects to be called like func({ event, datum })
  onMouseMove: PropTypes.func,
  // expects to be called like func({ event, datum })
  onMouseLeave: PropTypes.func,
  // expects to be called like func({ event, datum })
  tooltipData: PropTypes.shape({
    event: PropTypes.object,
    datum: PropTypes.object,
    series: PropTypes.object
  })
};
export var defaultProps = {
  children: null,
  disableMouseEvents: false,
  eventTrigger: SERIES_TRIGGER,
  eventTriggerRefs: null,
  innerRef: null,
  margin: DEFAULT_CHART_MARGIN,
  renderTooltip: null,
  showVoronoi: false,
  showXGrid: false,
  xGridValues: null,
  xGridOffset: null,
  showYGrid: false,
  yGridValues: null,
  yGridOffset: null,
  snapTooltipToDataX: false,
  snapTooltipToDataY: false,
  theme: {},
  onClick: null,
  onMouseMove: null,
  onMouseLeave: null,
  tooltipData: null
}; // accessors

var getX = function getX(d) {
  return d && d.x;
};

var getY = function getY(d) {
  return d && d.y;
};

var XYChart =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(XYChart, _React$PureComponent);

  function XYChart(props) {
    var _this;

    _this = _React$PureComponent.call(this, props) || this; // if renderTooltip is passed we return another XYChart wrapped in WithTooltip
    // therefore we don't want to compute state if the nested chart will do so

    _this.state = props.renderTooltip ? {} : XYChart.getStateFromProps(props);
    _this.getDatumCoords = _this.getDatumCoords.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleMouseLeave = _this.handleMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleMouseMove = _this.handleMouseMove.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleMouseDown = _this.handleMouseDown.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleContainerEvent = _this.handleContainerEvent.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = XYChart.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this$props = this.props,
        renderTooltip = _this$props.renderTooltip,
        eventTriggerRefs = _this$props.eventTriggerRefs;

    if (!renderTooltip && eventTriggerRefs) {
      eventTriggerRefs({
        mousemove: this.handleMouseMove,
        mouseleave: this.handleMouseLeave,
        click: this.handleClick
      });
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    var shouldComputeScales = false;

    if (['width', 'height', 'children'].some(function (prop) {
      return _this2.props[prop] !== nextProps[prop];
    } // eslint-disable-line react/destructuring-assignment
    )) {
      shouldComputeScales = true;
    }

    if (['margin', 'xScale', 'yScale'].some( // eslint-disable-next-line react/destructuring-assignment
    function (prop) {
      return !shallowCompareObjectEntries(_this2.props[prop], nextProps[prop]);
    })) {
      shouldComputeScales = true;
    }

    if (shouldComputeScales) this.setState(XYChart.getStateFromProps(nextProps));
  };

  XYChart.getStateFromProps = function getStateFromProps(props) {
    var _getChartDimensions = getChartDimensions(props),
        margin = _getChartDimensions.margin,
        innerWidth = _getChartDimensions.innerWidth,
        innerHeight = _getChartDimensions.innerHeight;

    var _collectScalesFromPro = collectScalesFromProps(props),
        xScale = _collectScalesFromPro.xScale,
        yScale = _collectScalesFromPro.yScale;

    var voronoiData = collectVoronoiData({
      children: props.children,
      getX: getX,
      getY: getY
    });
    return {
      innerHeight: innerHeight,
      innerWidth: innerWidth,
      margin: margin,
      xScale: xScale,
      yScale: yScale,
      voronoiData: voronoiData,
      voronoiX: function voronoiX(d) {
        return xScale(getX(d));
      },
      voronoiY: function voronoiY(d) {
        return yScale(getY(d));
      }
    };
  };

  _proto.getNumTicksAndGridValues = function getNumTicksAndGridValues(innerWidth, innerHeight) {
    var _this$props2 = this.props,
        children = _this$props2.children,
        xGridValues = _this$props2.xGridValues,
        yGridValues = _this$props2.yGridValues;
    var xAxis = getChildWithName('XAxis', children);
    var yAxis = getChildWithName('YAxis', children); // use num ticks and tickValues defined on Axes, if relevant

    return {
      numXTicks: propOrFallback(xAxis && xAxis.props, 'numTicks', numTicksForWidth(innerWidth)),
      numYTicks: propOrFallback(yAxis && yAxis.props, 'numTicks', numTicksForHeight(innerHeight)),
      xGridValues: xGridValues || (xAxis && xAxis.props && xAxis.props.tickValues ? xAxis.props.tickValues : null),
      yGridValues: yGridValues || (yAxis && yAxis.props && yAxis.props.tickValues ? yAxis.props.tickValues : null)
    };
  };

  _proto.getDatumCoords = function getDatumCoords(datum) {
    var _this$state = this.state,
        xScale = _this$state.xScale,
        yScale = _this$state.yScale,
        margin = _this$state.margin;
    var coords = {}; // tooltip operates in full width/height space so we must account for margins

    if (datum) coords.x = xScale(getX(datum)) + margin.left;
    if (datum) coords.y = yScale(getY(datum)) + margin.top;
    return coords;
  };

  _proto.handleContainerEvent = function handleContainerEvent(event) {
    var _this$state2 = this.state,
        xScale = _this$state2.xScale,
        yScale = _this$state2.yScale,
        margin = _this$state2.margin;
    var children = this.props.children;

    var _findClosestDatums = findClosestDatums({
      children: children,
      event: event,
      getX: getX,
      getY: getY,
      xScale: xScale,
      yScale: yScale,
      margin: margin
    }),
        closestDatum = _findClosestDatums.closestDatum,
        series = _findClosestDatums.series;

    if (closestDatum || Object.keys(series).length > 0) {
      event.persist();
      var args = {
        event: event,
        datum: closestDatum,
        series: series
      };
      if (event.type === 'mousemove') this.handleMouseMove(args);else if (event.type === 'click') this.handleClick(args);
    }
  };

  _proto.handleMouseDown = function handleMouseDown(event) {
    if (this.fireBrushStart) {
      this.fireBrushStart(event);
    }
  };

  _proto.handleMouseMove = function handleMouseMove(args) {
    var _this$props3 = this.props,
        snapTooltipToDataX = _this$props3.snapTooltipToDataX,
        snapTooltipToDataY = _this$props3.snapTooltipToDataY,
        onMouseMove = _this$props3.onMouseMove;
    var isFocusEvent = args.event && args.event.type === 'focus';

    if (onMouseMove) {
      var _this$getDatumCoords = this.getDatumCoords(args.datum),
          x = _this$getDatumCoords.x,
          y = _this$getDatumCoords.y;

      onMouseMove(_extends({}, args, {
        coords: _extends({}, (isFocusEvent || snapTooltipToDataX) && {
          x: x
        }, (isFocusEvent || snapTooltipToDataY) && {
          y: y
        }, args.coords)
      }));
    }
  };

  _proto.handleMouseLeave = function handleMouseLeave(args) {
    var onMouseLeave = this.props.onMouseLeave;
    if (onMouseLeave) onMouseLeave(args);
  };

  _proto.handleClick = function handleClick(args) {
    var _this$props4 = this.props,
        snapTooltipToDataX = _this$props4.snapTooltipToDataX,
        snapTooltipToDataY = _this$props4.snapTooltipToDataY,
        onClick = _this$props4.onClick;

    if (onClick) {
      var coords = this.getDatumCoords(args.datum);
      onClick(_extends({}, args, {
        coords: _extends({
          x: snapTooltipToDataX ? coords.x : undefined,
          y: snapTooltipToDataY ? coords.y : undefined
        }, args.coords)
      }));
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    var renderTooltip = this.props.renderTooltip;

    if (renderTooltip) {
      return React.createElement(WithTooltip, {
        renderTooltip: renderTooltip
      }, React.createElement(XYChart, _extends({}, this.props, {
        renderTooltip: null
      })));
    }

    var _this$props5 = this.props,
        ariaLabel = _this$props5.ariaLabel,
        eventTrigger = _this$props5.eventTrigger,
        children = _this$props5.children,
        showXGrid = _this$props5.showXGrid,
        showYGrid = _this$props5.showYGrid,
        theme = _this$props5.theme,
        height = _this$props5.height,
        width = _this$props5.width,
        innerRef = _this$props5.innerRef,
        tooltipData = _this$props5.tooltipData,
        showVoronoi = _this$props5.showVoronoi,
        xGridOffset = _this$props5.xGridOffset,
        yGridOffset = _this$props5.yGridOffset;
    var _this$state3 = this.state,
        innerWidth = _this$state3.innerWidth,
        innerHeight = _this$state3.innerHeight,
        margin = _this$state3.margin,
        voronoiData = _this$state3.voronoiData,
        voronoiX = _this$state3.voronoiX,
        voronoiY = _this$state3.voronoiY,
        xScale = _this$state3.xScale,
        yScale = _this$state3.yScale;

    var _this$getNumTicksAndG = this.getNumTicksAndGridValues(innerWidth, innerHeight),
        numXTicks = _this$getNumTicksAndG.numXTicks,
        numYTicks = _this$getNumTicksAndG.numYTicks,
        xGridValues = _this$getNumTicksAndG.xGridValues,
        yGridValues = _this$getNumTicksAndG.yGridValues;

    var CrossHairs = []; // ensure these are the top-most layer

    var Brush = null;
    var xAxisOrientation;
    var yAxisOrientation;
    return innerWidth > 0 && innerHeight > 0 && React.createElement("svg", {
      "aria-label": ariaLabel,
      role: "img",
      width: width,
      height: height,
      ref: innerRef
    }, React.createElement(Group, {
      left: margin.left,
      top: margin.top
    }, showXGrid && React.createElement(GridColumns, {
      scale: xScale,
      height: innerHeight,
      numTicks: numXTicks,
      stroke: theme.gridStyles && theme.gridStyles.stroke,
      strokeWidth: theme.gridStyles && theme.gridStyles.strokeWidth,
      tickValues: xGridValues,
      offset: isDefined(xGridOffset) ? xGridOffset : xScale.bandwidth && xScale.bandwidth() / 2 || 0
    }), showYGrid && React.createElement(GridRows, {
      scale: yScale,
      width: innerWidth,
      numTicks: numYTicks,
      stroke: theme.gridStyles && theme.gridStyles.stroke,
      strokeWidth: theme.gridStyles && theme.gridStyles.strokeWidth,
      tickValues: yGridValues,
      offset: isDefined(yGridOffset) ? yGridOffset : yScale.bandwidth && yScale.bandwidth() / 2 || 0
    }), React.Children.map(children, function (Child) {
      var name = componentName(Child);

      if (isAxis(name)) {
        var styleKey = name[0].toLowerCase();
        var labelOffset = typeof Child.props.labelOffset === 'number' ? Child.props.labelOffset : name === 'YAxis' && Y_LABEL_OFFSET * margin[Child.props.orientation] || 0;

        if (name === 'XAxis') {
          xAxisOrientation = Child.props.orientation;
        } else {
          yAxisOrientation = Child.props.orientation;
        }

        return React.cloneElement(Child, {
          innerHeight: innerHeight,
          innerWidth: innerWidth,
          height: height,
          width: width,
          labelOffset: labelOffset,
          numTicks: name === 'XAxis' ? numXTicks : numYTicks,
          scale: name === 'XAxis' ? xScale : yScale,
          rangePadding: Child.props.rangePadding || (name === 'XAxis' ? xScale.offset : undefined),
          axisStyles: _extends({}, theme[styleKey + "AxisStyles"], Child.props.axisStyles),
          tickStyles: _extends({}, theme[styleKey + "TickStyles"], Child.props.tickStyles)
        });
      } else if (isSeries(name)) {
        return React.cloneElement(Child, {
          xScale: xScale,
          yScale: yScale,
          margin: margin,
          onClick: Child.props.onClick || (Child.props.disableMouseEvents ? undefined : _this3.handleClick),
          onMouseLeave: Child.props.onMouseLeave || (Child.props.disableMouseEvents ? undefined : _this3.handleMouseLeave),
          onMouseMove: Child.props.onMouseMove || (Child.props.disableMouseEvents ? undefined : _this3.handleMouseMove)
        });
      } else if (isCrossHair(name)) {
        CrossHairs.push(Child);
        return null;
      } else if (isReferenceLine(name)) {
        return React.cloneElement(Child, {
          xScale: xScale,
          yScale: yScale
        });
      } else if (isBrush(name)) {
        Brush = Child;
        return null;
      }

      return Child;
    }), eventTrigger === VORONOI_TRIGGER && React.createElement(Voronoi, {
      data: voronoiData,
      x: voronoiX,
      y: voronoiY,
      width: innerWidth,
      height: innerHeight,
      onClick: this.handleClick,
      onMouseDown: this.handleMouseDown,
      onMouseMove: this.handleMouseMove,
      onMouseLeave: this.handleMouseLeave,
      showVoronoi: showVoronoi
    }), eventTrigger === CONTAINER_TRIGGER && React.createElement("rect", {
      x: 0,
      y: 0,
      width: innerWidth,
      height: innerHeight,
      fill: "transparent",
      fillOpacity: 0,
      onMouseDown: this.handleMouseDown,
      onClick: this.handleContainerEvent,
      onMouseMove: this.handleContainerEvent,
      onMouseLeave: this.handleMouseLeave
    }), Brush && React.cloneElement(Brush, {
      xScale: xScale,
      yScale: yScale,
      innerHeight: innerHeight,
      innerWidth: innerWidth,
      margin: margin,
      onMouseMove: this.handleContainerEvent,
      onMouseLeave: this.handleMouseLeave,
      onClick: this.handleContainerEvent,
      xAxisOrientation: xAxisOrientation,
      yAxisOrientation: yAxisOrientation
    }), tooltipData && CrossHairs.length > 0 && CrossHairs.map(function (CrossHair, i) {
      return React.cloneElement(CrossHair, {
        key: "crosshair-" + i,
        // eslint-disable-line react/no-array-index-key
        datum: tooltipData.datum,
        series: tooltipData.series,
        getScaledX: function getScaledX(d) {
          return xScale(getX(d) || 0) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);
        },
        getScaledY: function getScaledY(d) {
          return yScale(getY(d) || 0) + (yScale.bandwidth ? yScale.bandwidth() / 2 : 0);
        },
        xScale: xScale,
        yScale: yScale
      });
    })));
  };

  return XYChart;
}(React.PureComponent);

XYChart.propTypes = propTypes;
XYChart.defaultProps = defaultProps;
XYChart.displayName = 'XYChart';
export default XYChart;