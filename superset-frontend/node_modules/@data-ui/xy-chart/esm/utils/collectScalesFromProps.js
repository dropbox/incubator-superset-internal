function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { Children } from 'react';
import collectDataFromChildSeries from './collectDataFromChildSeries'; // import collectExtentsFromChildSeries from './collectExtentsFromChildSeries';

import getChartDimensions from './getChartDimensions';
import getScaleForAccessor from './getScaleForAccessor';
import { componentName, isBarSeries, isCirclePackSeries } from './chartUtils';

var getX = function getX(d) {
  return d && d.x;
};

var xString = function xString(d) {
  return getX(d).toString();
};

var getY = function getY(d) {
  return d && d.y;
};

var yString = function yString(d) {
  return getY(d).toString();
};

export default function collectScalesFromProps(props) {
  var xScaleObject = props.xScale,
      yScaleObject = props.yScale,
      children = props.children;

  var _getChartDimensions = getChartDimensions(props),
      innerWidth = _getChartDimensions.innerWidth,
      innerHeight = _getChartDimensions.innerHeight;

  var allData = collectDataFromChildSeries(children); // TODO could collect data extents from child series
  // which would support passing arbitrary x/y accessors
  // const [xExtent, yExtent] = collectExtentsFromChildSeries(children);
  // issues:
  //  voronoi transforms data via scale(getXorY(d))
  //    => Could be solved by transforming in data collection
  //  tooltip/crosshair transforms data via scale(getXorY(d))
  //    => could be solved by transforming in the mousemove call so series own it?

  var xScale = getScaleForAccessor(_extends({
    allData: allData,
    minAccessor: function minAccessor(d) {
      return typeof d.x0 === 'undefined' ? d.x : d.x0;
    },
    maxAccessor: function maxAccessor(d) {
      return typeof d.x1 === 'undefined' ? d.x : d.x1;
    },
    range: [0, innerWidth]
  }, xScaleObject));
  var yScale = getScaleForAccessor(_extends({
    allData: allData,
    minAccessor: function minAccessor(d) {
      return typeof d.y0 === 'undefined' ? d.y : d.y0;
    },
    maxAccessor: function maxAccessor(d) {
      return typeof d.y1 === 'undefined' ? d.y : d.y1;
    },
    range: [innerHeight, 0]
  }, yScaleObject));
  Children.forEach(children, function (Child) {
    // Child-specific scales or adjustments here
    var name = componentName(Child);

    if (isBarSeries(name)) {
      var horizontal = Child.props.horizontal;
      var categoryScaleObject = horizontal ? yScaleObject : xScaleObject;

      if (categoryScaleObject.type !== 'band') {
        var categoryScale = horizontal ? yScale : xScale;
        var range = horizontal ? innerHeight : innerWidth;
        var dummyBand = getScaleForAccessor({
          allData: allData,
          minAccessor: horizontal ? yString : xString,
          maxAccessor: horizontal ? yString : xString,
          type: 'band',
          rangeRound: [0, range],
          paddingOuter: 1
        });
        var offset = dummyBand.bandwidth() / 2;
        categoryScale.range([offset, range - offset]);
        categoryScale.barWidth = dummyBand.bandwidth();
        categoryScale.offset = offset;
      }
    }

    if (isCirclePackSeries(name)) {
      yScale.domain([-innerHeight / 2, innerHeight / 2]);
    }
  });
  return {
    xScale: xScale,
    yScale: yScale
  };
}