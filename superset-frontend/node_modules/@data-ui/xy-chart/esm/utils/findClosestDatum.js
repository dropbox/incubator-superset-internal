import { bisector, bisectLeft as d3BisectLeft } from 'd3-array';
import localPoint from '@vx/event/build/localPoint';
export default function findClosestDatum(_ref) {
  var data = _ref.data,
      getX = _ref.getX,
      xScale = _ref.xScale,
      event = _ref.event,
      _ref$marginLeft = _ref.marginLeft,
      marginLeft = _ref$marginLeft === void 0 ? 0 : _ref$marginLeft;
  if (!event || !event.target || !event.target.ownerSVGElement) return null;
  var bisect = bisector(getX).left; // if the g element has a transform we need to be in g coords not svg coords

  var svgCoords = localPoint(event.target.ownerSVGElement, event);
  var mouseX = svgCoords.x - marginLeft;
  var isOrdinalScale = typeof xScale.invert !== 'function';
  var d;

  if (isOrdinalScale) {
    // Ordinal scales don't have an invert function so we do it maually
    var xDomain = xScale.domain();
    var scaledXValues = xDomain.map(function (val) {
      return xScale(val);
    });
    var index = d3BisectLeft(scaledXValues, mouseX);
    var d0 = data[index - 1];
    var d1 = data[index];
    d = d0 || d1;
  } else {
    var dataX = xScale.invert(mouseX);

    var _index = bisect(data, dataX, 0);

    var _d = data[_index - 1];

    var _d2 = data[_index] || {};

    d = !_d || Math.abs(dataX - getX(_d)) > Math.abs(dataX - getX(_d2)) ? _d2 : _d;
  }

  return d;
}