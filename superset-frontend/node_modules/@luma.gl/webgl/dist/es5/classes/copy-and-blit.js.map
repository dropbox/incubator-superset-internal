{"version":3,"sources":["../../../src/classes/copy-and-blit.js"],"names":["readPixelsToArray","source","options","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","getFramebuffer","framebuffer","deleteFramebuffer","gl","handle","attachments","width","height","type","getPixelArray","prevHandle","bindFramebuffer","readPixels","delete","readPixelsToBuffer","targetByteOffset","gl2","components","byteCount","byteLength","Buffer","accessor","size","bind","unbind","copyToDataUrl","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","targetImage","dataUrl","Image","src","copyToTexture","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","texture","Texture","isFinite","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","blit","sourceX0","sourceY0","targetX0","targetY0","color","depth","stencil","filter","sourceX1","sourceY1","targetX1","targetY1","mask","srcFramebuffer","deleteSrcFramebuffer","dstFramebuffer","deleteDstFramebuffer","readBuffer","log","warn","undefined","prevDrawHandle","prevReadHandle","blitFramebuffer","Framebuffer","pixelArray","format","ArrayType","clamped"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {flipRows, scalePixels} from '../webgl-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(source, options = {}) {\n  const {sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA} = options;\n  let {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl2, {framebuffer}, () => {\n    gl2.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(source, target, options = {}) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(source, target, options = {}) {\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = GL.NEAREST\n  } = options;\n\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    mask = 0\n  } = options;\n\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  // @ts-ignore\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl2.readBuffer(readBuffer);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"],"file":"copy-and-blit.js"}