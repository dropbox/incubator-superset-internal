{"version":3,"sources":["../../../src/transform/texture-transform.js"],"names":["cloneTextureFrom","readPixelsToArray","getShaderVersion","Buffer","Texture2D","Framebuffer","_transform","transformModule","getPassthroughFS","typeToChannelCount","combineInjects","updateForTextures","getSizeUniforms","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","TextureTransform","constructor","gl","props","id","currentIndex","_swapTexture","targetTextureVarying","targetTextureType","samplerTextureMap","bindings","resources","_initialize","Object","seal","updateModelProps","updatedModelProps","_processVertexShader","assign","getDrawOptions","opts","sourceBuffers","sourceTextures","framebuffer","targetTexture","attributes","uniforms","parameters","discard","hasSourceTextures","hasTargetTexture","transform_elementID","elementIDBuffer","sampler","textureName","_setSourceTextureParameters","sizeUniforms","sourceTextureMap","viewport","width","height","swap","_getNextIndex","update","_setupTextures","getTargetTexture","getData","packed","pixels","ArrayType","channelCount","packedPixels","length","packCount","i","j","getFramebuffer","currentResources","delete","ownTexture","_targetTextureVarying","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_createNewTexture","_sourceTextures","_targetTexture","keys","_updateBindings","_updateElementIDBuffer","elementCount","elementIds","Float32Array","forEach","_","index","array","data","accessor","size","setData","_updateBinding","_swapTextures","nextIndex","binding","attachments","resizeAttachments","resize","name","setParameters","texture","pixelStore","vs","inject","combinedInject","fs","_fs","version","input","inputType","output","modules","concat"],"mappings":"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","sourcesContent":["/** @typedef {import('./transform').TransformProps} TransformProps */\nimport GL from '@luma.gl/constants';\n\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\n\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\n\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    // @ts-ignore\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  /** @param {TransformProps} props */\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    // @ts-ignore TODO - uniforms is not present\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"],"file":"texture-transform.js"}