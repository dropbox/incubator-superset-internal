Object.defineProperty(exports, "__esModule", {
  value: true
});

var _deepmerge = require('deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _globalCache = require('global-cache');

var _globalCache2 = _interopRequireDefault(_globalCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var styleInterface = void 0;
var themes = {};
var makeFromThemes = {};
var internalId = 0;

function registerTheme(name, overrides) {
  var theme = (0, _deepmerge2['default'])(themes['default'].theme, overrides);

  themes[name] = {
    theme: theme,
    styles: {}
  };

  // If we register a theme after stylesheets have been created, we have to
  // backfill them when we register the new theme.
  Object.keys(makeFromThemes).forEach(function (id) {
    themes[name].styles[id] = styleInterface.create(makeFromThemes[id](theme));
  });
}

function registerInterface(interfaceToRegister) {
  styleInterface = interfaceToRegister;
}

var generatorFor = function generatorFor(id) {
  return function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    var styles = themes[name].styles;
    // TODO(lmr):
    // we may at some point want to lazily register styles
    // for the non default theme. Think about strategies around this...
    // for now, this shouldn't be a big deal.

    return styles[id];
  };
};

function create(makeFromTheme) {
  // Get an id to associate with this stylesheet
  var id = internalId;
  internalId += 1;

  // run StyleSheet.create over each variation for each theme
  Object.keys(themes).forEach(function (name) {
    var _themes$name = themes[name],
        theme = _themes$name.theme,
        styles = _themes$name.styles;

    styles[id] = styleInterface.create(makeFromTheme(theme));
  });

  makeFromThemes[id] = makeFromTheme;

  return generatorFor(id);
}

function registerDefaultTheme(theme) {
  themes['default'] = {
    theme: theme,
    styles: {}
  };
}

function get() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

  return themes[name].theme;
}

function resolve() {
  for (var _len = arguments.length, styles = Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }

  return styleInterface.resolve(styles);
}

function flush() {
  if (styleInterface.flush) {
    styleInterface.flush();
  }
}

// Using globalCache in order to export a singleton. This file may be imported
// in several places, which otherwise stomps over any registered themes and
// resets to just the defaults.
exports['default'] = _globalCache2['default'].setIfMissingThenGet('react-with-styles ThemedStyleSheet', function () {
  return {
    registerDefaultTheme: registerDefaultTheme,
    registerTheme: registerTheme,
    registerInterface: registerInterface,
    create: create,
    get: get,
    resolve: resolve,
    flush: flush
  };
});