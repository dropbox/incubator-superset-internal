"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineAsyncIterableIterators = void 0;
const tslib_1 = require("tslib");
function combineAsyncIterableIterators(...iterators) {
    return tslib_1.__asyncGenerator(this, arguments, function* combineAsyncIterableIterators_1() {
        let [options] = iterators;
        if (typeof options.next === 'function') {
            options = Object.create(null);
        }
        else {
            iterators.shift();
        }
        const getNextAsyncIteratorValue = getNextAsyncIteratorFactory(options);
        try {
            const asyncIteratorsValues = new Map(iterators.map((it, idx) => [idx, getNextAsyncIteratorValue(it, idx)]));
            do {
                const { iterator, index } = yield tslib_1.__await(Promise.race(asyncIteratorsValues.values()));
                if (iterator.done) {
                    asyncIteratorsValues.delete(index);
                }
                else {
                    yield yield tslib_1.__await(iterator.value);
                    asyncIteratorsValues.set(index, getNextAsyncIteratorValue(iterators[index], index));
                }
            } while (asyncIteratorsValues.size > 0);
        }
        finally {
            yield tslib_1.__await(Promise.allSettled(iterators.map((it) => it.return())));
        }
    });
}
exports.combineAsyncIterableIterators = combineAsyncIterableIterators;
function getNextAsyncIteratorFactory(options) {
    return (asyncIterator, index) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const iterator = yield asyncIterator.next();
            return { index, iterator };
        }
        catch (err) {
            if (options.errorCallback) {
                options.errorCallback(err, index);
            }
            return Promise.reject(err);
        }
    });
}
//# sourceMappingURL=combine-async-iteratable-iterators.js.map