"use strict";

exports.__esModule = true;
exports.default = void 0;

var _parseDateTime = _interopRequireDefault(require("../parsers/parseDateTime"));

var _inferElementTypeFromUnionOfArrayTypes = _interopRequireDefault(require("../utils/inferElementTypeFromUnionOfArrayTypes"));

var _DateTime = require("../typeGuards/DateTime");

var _createFormatter = _interopRequireDefault(require("../parsers/format/createFormatter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ChannelEncoderAxis {
  constructor(channelEncoder) {
    _defineProperty(this, "channelEncoder", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "formatValue", void 0);

    this.channelEncoder = channelEncoder;
    this.config = channelEncoder.definition.axis;
    this.formatValue = (0, _createFormatter.default)(this.config);
  }

  getTitle() {
    return this.config.title;
  }

  hasTitle() {
    const {
      title
    } = this.config;
    return title !== null && typeof title !== 'undefined' && title !== '';
  }

  getTickLabels() {
    const {
      tickCount,
      values
    } = this.config;

    if (typeof values !== 'undefined') {
      return (0, _inferElementTypeFromUnionOfArrayTypes.default)(values).map(v => this.formatValue((0, _DateTime.isDateTime)(v) ? (0, _parseDateTime.default)(v) : v));
    }

    const {
      scale
    } = this.channelEncoder;

    if (scale && 'domain' in scale) {
      const ticks = 'ticks' in scale ? scale.ticks(tickCount) : scale.domain();
      return ticks.map(this.formatValue);
    }

    return [];
  }

}

exports.default = ChannelEncoderAxis;