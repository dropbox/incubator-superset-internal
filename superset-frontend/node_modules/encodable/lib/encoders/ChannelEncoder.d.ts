import { Value, PlainObject, Dataset, AllScale, ChannelType, ChannelInput, ChannelDef, StringLike } from '../types';
import ChannelEncoderAxis from './ChannelEncoderAxis';
import { CompleteChannelDef } from '../types/internal/CompleteChannelDef';
export default class ChannelEncoder<Def extends ChannelDef<Output>, Output extends Value = Value> {
    readonly name: string | Symbol | number;
    readonly channelType: ChannelType;
    readonly originalDefinition: Def;
    readonly definition: CompleteChannelDef<Output>;
    readonly scale?: AllScale<Output>;
    readonly axis?: ChannelEncoderAxis<Def, Output>;
    private readonly getValue;
    private readonly encodeFunc;
    readonly formatValue: (value: ChannelInput | StringLike) => string;
    constructor({ name, channelType, definition: originalDefinition, }: {
        name: string;
        channelType: ChannelType;
        definition: Def;
    });
    encodeValue: {
        (value: ChannelInput | Output): Output | null | undefined;
        (value: ChannelInput | Output, otherwise: Output): Output;
    };
    encodeDatum: {
        (datum: PlainObject): Output | null | undefined;
        (datum: PlainObject, otherwise: Output): Output;
    };
    formatDatum: (datum: PlainObject) => string;
    getValueFromDatum: <T extends string | number | boolean | Date | Output | null | undefined>(datum: PlainObject, otherwise?: T | undefined) => T;
    getDomainFromDataset: (data: Dataset<string>) => ChannelInput[];
    getDomain(): StringLike[] | (string | number | Date)[];
    setDomain(domain: ChannelInput[]): this;
    setDomainFromDataset(data: Dataset): this;
    getTitle(): string;
    isGroupBy(): boolean;
    isX(): boolean;
    isXOrY(): boolean;
    isY(): boolean;
    private hasCategoricalColorScale;
    hasLegend(): boolean;
    hasValueDefinition(): boolean;
    hasFieldDefinition(): boolean;
}
//# sourceMappingURL=ChannelEncoder.d.ts.map