"use strict";

exports.__esModule = true;
exports.default = void 0;

var _d3Array = require("d3-array");

var _types = require("../types");

var _ChannelDef = require("../typeGuards/ChannelDef");

var _Channel = require("../typeGuards/Channel");

var _ChannelEncoderAxis = _interopRequireDefault(require("./ChannelEncoderAxis"));

var _createGetterFromChannelDef = _interopRequireDefault(require("../parsers/createGetterFromChannelDef"));

var _completeChannelDef = _interopRequireDefault(require("../fillers/completeChannelDef"));

var _createScale = _interopRequireDefault(require("../parsers/scale/createScale"));

var _identity = _interopRequireDefault(require("../utils/identity"));

var _applyDomain = _interopRequireDefault(require("../parsers/scale/applyDomain"));

var _applyRange = _interopRequireDefault(require("../parsers/scale/applyRange"));

var _applyZero = _interopRequireDefault(require("../parsers/scale/applyZero"));

var _applyNice = _interopRequireDefault(require("../parsers/scale/applyNice"));

var _CompleteChannelDef = require("../typeGuards/CompleteChannelDef");

var _fallbackFormatter = _interopRequireDefault(require("../parsers/format/fallbackFormatter"));

var _createFormatter = _interopRequireDefault(require("../parsers/format/createFormatter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ChannelEncoder {
  constructor({
    name,
    channelType,
    definition: originalDefinition
  }) {
    _defineProperty(this, "name", void 0);

    _defineProperty(this, "channelType", void 0);

    _defineProperty(this, "originalDefinition", void 0);

    _defineProperty(this, "definition", void 0);

    _defineProperty(this, "scale", void 0);

    _defineProperty(this, "axis", void 0);

    _defineProperty(this, "getValue", void 0);

    _defineProperty(this, "encodeFunc", void 0);

    _defineProperty(this, "formatValue", void 0);

    _defineProperty(this, "encodeValue", (value, otherwise) => {
      if (typeof otherwise !== 'undefined' && (value === null || typeof value === 'undefined')) {
        return otherwise;
      } // eslint-disable-next-line @typescript-eslint/no-explicit-any


      return this.encodeFunc(value);
    });

    _defineProperty(this, "encodeDatum", (datum, otherwise) => typeof otherwise === 'undefined' ? this.encodeValue(this.getValueFromDatum(datum)) : this.encodeValue(this.getValueFromDatum(datum), otherwise));

    _defineProperty(this, "formatDatum", datum => this.formatValue(this.getValueFromDatum(datum)));

    _defineProperty(this, "getValueFromDatum", (datum, otherwise) => {
      const value = this.getValue(datum);
      return otherwise !== undefined && (value === null || value === undefined) ? otherwise : value;
    });

    _defineProperty(this, "getDomainFromDataset", data => {
      if ((0, _ChannelDef.isValueDef)(this.definition)) {
        const {
          value
        } = this.definition;
        return [value];
      }

      const {
        type
      } = this.definition;

      if (type === 'nominal' || type === 'ordinal') {
        return Array.from(new Set(data.map(d => this.getValueFromDatum(d))));
      }

      if (type === 'quantitative') {
        // Quantile scale needs all items
        // because it treats domain as a discrete set of sample values
        // for computing the quantiles
        if (this.definition.scale && this.definition.scale.type === 'quantile') {
          return data.map(d => this.getValueFromDatum(d));
        }

        const extent = (0, _d3Array.extent)(data, d => this.getValueFromDatum(d));
        return typeof extent[0] === 'undefined' ? [0, 1] : extent;
      }

      if (type === 'temporal') {
        const extent = (0, _d3Array.extent)(data, d => this.getValueFromDatum(d));
        return typeof extent[0] === 'undefined' ? [0, 1] : extent;
      }

      return [];
    });

    this.name = name;
    this.channelType = channelType;
    this.originalDefinition = originalDefinition;
    this.definition = (0, _completeChannelDef.default)(this.channelType, originalDefinition);
    this.getValue = (0, _createGetterFromChannelDef.default)(this.definition);
    this.formatValue = (0, _ChannelDef.isFieldDef)(this.definition) ? (0, _createFormatter.default)(this.definition) : _fallbackFormatter.default;

    if (this.definition.scale) {
      const scale = (0, _createScale.default)(this.definition.scale); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      this.encodeFunc = value => scale(value);

      this.scale = scale;
    } else {
      const {
        definition
      } = this;
      this.encodeFunc = (0, _CompleteChannelDef.isCompleteValueDef)(definition) ? () => definition.value : _identity.default;
    }

    if (this.definition.axis) {
      this.axis = new _ChannelEncoderAxis.default(this);
    }
  }

  getDomain() {
    if (this.scale && 'domain' in this.scale) {
      return this.scale.domain();
    }

    return [];
  }

  setDomain(domain) {
    if (this.definition.scale !== false && this.scale && !this.hasCategoricalColorScale() && 'domain' in this.scale) {
      const config = this.definition.scale;
      (0, _applyDomain.default)(config, this.scale, domain);
      (0, _applyRange.default)(config, this.scale);
      (0, _applyZero.default)(config, this.scale);
      (0, _applyNice.default)(config, this.scale);
    }

    return this;
  }

  setDomainFromDataset(data) {
    return this.scale && 'domain' in this.scale ? this.setDomain(this.getDomainFromDataset(data)) : this;
  }

  getTitle() {
    return this.definition.title;
  }

  isGroupBy() {
    if ((0, _ChannelDef.isTypedFieldDef)(this.definition)) {
      const {
        type
      } = this.definition;
      return this.channelType === 'Category' || this.channelType === 'Text' || this.channelType === 'Color' && (type === 'nominal' || type === 'ordinal') || (0, _Channel.isXOrY)(this.channelType) && (type === 'nominal' || type === 'ordinal');
    }

    return false;
  }

  isX() {
    return (0, _Channel.isX)(this.channelType);
  }

  isXOrY() {
    return (0, _Channel.isXOrY)(this.channelType);
  }

  isY() {
    return (0, _Channel.isY)(this.channelType);
  }

  hasCategoricalColorScale() {
    const config = this.definition.scale; // Scale type is ordinal with not given range
    // (may have optional scheme)
    // will become a categorical scale
    // of named color scheme.
    // A color scale from named color scheme may be shared among multiple components
    // in the same namespace by default, so changing its domain affect all components.
    // (Sounds like a bad idea.)
    // This function is currently only being used to check
    // whether to apply domain from dataset or not.
    // An ordinal scale with user-specified color scheme as range array
    // will return false from this function and be excluded from it.

    return this.scale && config && config.type === _types.ScaleType.ORDINAL && typeof config.range === 'undefined';
  }

  hasLegend() {
    return this.definition.legend !== false;
  }

  hasValueDefinition() {
    return (0, _CompleteChannelDef.isCompleteValueDef)(this.definition);
  }

  hasFieldDefinition() {
    return (0, _CompleteChannelDef.isCompleteFieldDef)(this.definition);
  }

}

exports.default = ChannelEncoder;