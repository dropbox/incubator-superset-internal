"use strict";

exports.__esModule = true;
exports.default = completeAxisConfig;

var _isEnabled = _interopRequireDefault(require("../utils/isEnabled"));

var _Channel = require("../typeGuards/Channel");

var _ChannelDef = require("../typeGuards/ChannelDef");

var _expandLabelOverlapStrategy = _interopRequireDefault(require("./expandLabelOverlapStrategy"));

var _scaleCategories = require("../parsers/scale/scaleCategories");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isChannelDefWithAxisSupport(channelType, channelDef) {
  return (0, _ChannelDef.isTypedFieldDef)(channelDef) && (0, _Channel.isXOrY)(channelType);
}

function completeAxisConfig(channelType, channelDef) {
  if (isChannelDefWithAxisSupport(channelType, channelDef) && (0, _isEnabled.default)(channelDef.axis)) {
    const axis = channelDef.axis === true || typeof channelDef.axis === 'undefined' ? {} : channelDef.axis;
    const isXChannel = (0, _Channel.isX)(channelType);
    const {
      format = channelDef.format,
      formatType = channelDef.formatType,
      formatInLocalTime = channelDef.formatInLocalTime,
      labelAngle = 0,
      labelFlush,
      labelOverlap,
      labelPadding = 4,
      orient = isXChannel ? 'bottom' : 'left',
      tickCount = 5,
      ticks = true,
      title = channelDef.title,
      titlePadding = 4
    } = axis;
    const output = { ...axis,
      format,
      formatType,
      labelAngle,
      labelFlush: typeof labelFlush === 'undefined' ? channelDef.scale && typeof channelDef.scale.type !== 'undefined' && _scaleCategories.continuousToContinuousScaleTypesSet.has(channelDef.scale.type) : labelFlush,
      labelOverlap: (0, _expandLabelOverlapStrategy.default)(channelType, labelOverlap),
      labelPadding,
      orient,
      tickCount,
      ticks,
      title,
      titlePadding
    };

    if (typeof formatInLocalTime !== 'undefined') {
      output.formatInLocalTime = formatInLocalTime;
    }

    return output;
  }

  return false;
}