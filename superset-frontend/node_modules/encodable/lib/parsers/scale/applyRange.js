"use strict";

exports.__esModule = true;
exports.default = applyRange;

var _color = require("@encodable/color");

var _Encodable = _interopRequireDefault(require("../../options/Encodable"));

var _ScaleConfig = require("../../typeGuards/ScaleConfig");

var _SchemeParams = require("../../typeGuards/SchemeParams");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyRange(config, scale) {
  const {
    range,
    domain
  } = config;

  if (typeof range === 'undefined') {
    if ('scheme' in config && typeof config.scheme !== 'undefined') {
      const {
        scheme
      } = config;
      let name;
      let count;

      if ((0, _ScaleConfig.isContinuousScaleConfig)(config) && domain) {
        count = domain.length;
      }

      let extent;

      if ((0, _SchemeParams.isSchemeParams)(scheme)) {
        name = scheme.name;

        if (scheme.count) {
          count = scheme.count;
        }

        extent = scheme.extent;
      } else {
        name = scheme;
      }

      const schemeObject = _Encodable.default.resolveColorScheme({
        name,
        type: 'sequential'
      });

      if (typeof schemeObject !== 'undefined' && schemeObject.type === 'sequential') {
        const wrappedScheme = (0, _color.wrapColorScheme)(schemeObject);
        scale.range(wrappedScheme.getColors(count, extent));
      }
    }
  } else {
    // TODO: add type guard should fix this problem
    // @ts-ignore
    scale.range(range);
  }
}