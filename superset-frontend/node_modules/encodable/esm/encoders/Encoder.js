function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { isTypedFieldDef, isValueDef } from '../typeGuards/ChannelDef';
import { isNotArray } from '../typeGuards/Base';
import ChannelEncoder from './ChannelEncoder';
export default class Encoder {
  constructor({
    channelTypes,
    encoding
  }) {
    _defineProperty(this, "encoding", void 0);

    _defineProperty(this, "channelTypes", void 0);

    _defineProperty(this, "channels", void 0);

    _defineProperty(this, "legends", void 0);

    this.channelTypes = channelTypes;
    this.encoding = encoding;
    const channelNames = this.getChannelNames(); // Create channel encoders

    const channels = {};
    channelNames.forEach(name => {
      const channelEncoding = encoding[name];

      if (Array.isArray(channelEncoding)) {
        const definitions = channelEncoding;
        channels[name] = definitions.map((definition, i) => new ChannelEncoder({
          channelType: channelTypes[name],
          definition,
          name: name + "[" + i + "]"
        }));
      } else {
        const definition = channelEncoding;
        channels[name] = new ChannelEncoder({
          channelType: channelTypes[name],
          definition,
          name: name
        });
      }
    });
    this.channels = channels; // Group the channels that use the same field together
    // so they can share the same legend.

    this.legends = {};
    channelNames.map(name => this.channels[name]).forEach(c => {
      if (isNotArray(c) && c.hasLegend() && isTypedFieldDef(c.definition)) {
        const {
          field
        } = c.definition;
        const channelEncoder = c;

        if (this.legends[field]) {
          this.legends[field].push(channelEncoder);
        } else {
          this.legends[field] = [channelEncoder];
        }
      }
    });
  }

  getChannelNames() {
    return Object.keys(this.channelTypes);
  }

  getChannelEncoders() {
    return this.getChannelNames().flatMap(name => this.channels[name]);
  }

  getGroupBys() {
    const fields = this.getChannelEncoders().filter(c => c.isGroupBy()).map(c => c.definition.field);
    return Array.from(new Set(fields));
  }

  createLegendItemsFactory(field) {
    const channelEncoders = this.getChannelEncoders().filter(e => isNotArray(e) && isValueDef(e.definition)).flat().concat(this.legends[field]);
    return domain => domain.map(input => ({
      input,
      output: channelEncoders.reduce((prev, curr) => {
        const map = prev;
        map[curr.name] = curr.encodeValue(input);
        return map;
      }, {})
    }));
  }

  getLegendInformation(data = []) {
    return Object.keys(this.legends) // for each field that was encoded
    .map(field => {
      // get all the channels that use this field
      const channelEncoders = this.legends[field];
      const firstEncoder = channelEncoders[0];
      const definition = firstEncoder.definition;
      const createLegendItems = this.createLegendItemsFactory(field);

      if (definition.type === 'nominal') {
        return {
          channelEncoders,
          createLegendItems,
          field,
          items: createLegendItems(firstEncoder.getDomainFromDataset(data)),
          type: definition.type
        };
      }

      return {
        channelEncoders,
        createLegendItems,
        field,
        type: definition.type
      };
    });
  }

  setDomainFromDataset(data) {
    this.getChannelEncoders().forEach(channelEncoder => {
      channelEncoder.setDomainFromDataset(data);
    });
    return this;
  }

  hasLegend() {
    return Object.keys(this.legends).length > 0;
  }

}