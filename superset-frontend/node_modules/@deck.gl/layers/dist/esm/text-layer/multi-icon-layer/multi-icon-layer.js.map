{"version":3,"sources":["../../../../src/text-layer/multi-icon-layer/multi-icon-layer.js"],"names":["log","IconLayer","fs","DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","getIconOffsets","type","value","x","offsets","alphaCutoff","smoothing","outlineWidth","outlineColor","MultiIconLayer","getShaders","initializeState","attributeManager","getAttributeManager","addInstanced","instanceOffsets","size","accessor","instancePickingColors","object","index","target","encodePickingColor","updateState","params","props","oldProps","map","Number","isFinite","setState","sdf","warn","id","draw","state","uniforms","buffer","outlineBuffer","Math","max","gamma","Boolean","getInstanceOffset","icons","Array","from","icon","getInstanceColorMode","getInstanceIconFrame","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {log} from '@deck.gl/core';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\n// TODO expose as layer properties\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\nconst defaultProps = {\n  getIconOffsets: {type: 'accessor', value: x => x.offsets},\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {type: 'color', value: [0, 0, 0, 255]}\n};\n\nexport default class MultiIconLayer extends IconLayer {\n  getShaders() {\n    return {...super.getShaders(), fs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n    let {outlineColor} = props;\n\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255);\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n\n      this.setState({\n        outlineColor\n      });\n    }\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(`${this.id}: fontSettings.sdf is required to render outline`)();\n    }\n  }\n\n  draw(params) {\n    const {sdf, smoothing, outlineWidth} = this.props;\n    const {outlineColor} = this.state;\n\n    params.uniforms = {\n      ...params.uniforms,\n      // Refer the following doc about gamma and buffer\n      // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n      buffer: DEFAULT_BUFFER,\n      outlineBuffer: outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1,\n      gamma: smoothing,\n      sdf: Boolean(sdf),\n      outlineColor\n    };\n    super.draw(params);\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\n\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;\n"],"file":"multi-icon-layer.js"}