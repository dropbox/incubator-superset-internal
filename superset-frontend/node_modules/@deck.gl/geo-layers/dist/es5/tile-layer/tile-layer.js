"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _tileset2d = _interopRequireWildcard(require("./tileset-2d"));

var _utils = require("./utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var defaultProps = {
  data: [],
  dataComparator: _utils.urlType.equals,
  renderSubLayers: {
    type: 'function',
    value: function value(props) {
      return new _layers.GeoJsonLayer(props);
    },
    compare: false
  },
  getTileData: {
    type: 'function',
    optional: true,
    value: null,
    compare: false
  },
  onViewportLoad: {
    type: 'function',
    optional: true,
    value: null,
    compare: false
  },
  onTileLoad: {
    type: 'function',
    value: function value(tile) {},
    compare: false
  },
  onTileUnload: {
    type: 'function',
    value: function value(tile) {},
    compare: false
  },
  onTileError: {
    type: 'function',
    value: function value(err) {
      return console.error(err);
    },
    compare: false
  },
  extent: {
    type: 'array',
    optional: true,
    value: null,
    compare: true
  },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: _tileset2d.STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  zoomOffset: 0
};

var TileLayer = function (_CompositeLayer) {
  (0, _inherits2.default)(TileLayer, _CompositeLayer);

  var _super = _createSuper(TileLayer);

  function TileLayer() {
    (0, _classCallCheck2.default)(this, TileLayer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(TileLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        tileset: null,
        isLoaded: false
      };
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      var _this$state$tileset;

      (_this$state$tileset = this.state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref) {
      var changeFlags = _ref.changeFlags;
      return changeFlags.somethingChanged;
    }
  }, {
    key: "updateState",
    value: function updateState(_ref2) {
      var props = _ref2.props,
          changeFlags = _ref2.changeFlags;
      var tileset = this.state.tileset;
      var createTileCache = !tileset || changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);

      if (createTileCache) {
        if (tileset) {
          tileset.finalize();
        }

        tileset = new _tileset2d.default(_objectSpread(_objectSpread({}, this._getTilesetOptions(props)), {}, {
          getTileData: this.getTileData.bind(this),
          onTileLoad: this._onTileLoad.bind(this),
          onTileError: this._onTileError.bind(this),
          onTileUnload: this._onTileUnload.bind(this)
        }));
        this.setState({
          tileset: tileset
        });
      } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {
        tileset.setOptions(this._getTilesetOptions(props));
        this.state.tileset.tiles.forEach(function (tile) {
          tile.layers = null;
        });
      }

      this._updateTileset();
    }
  }, {
    key: "_getTilesetOptions",
    value: function _getTilesetOptions(props) {
      var tileSize = props.tileSize,
          maxCacheSize = props.maxCacheSize,
          maxCacheByteSize = props.maxCacheByteSize,
          refinementStrategy = props.refinementStrategy,
          extent = props.extent,
          maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          maxRequests = props.maxRequests,
          zoomOffset = props.zoomOffset;
      return {
        maxCacheSize: maxCacheSize,
        maxCacheByteSize: maxCacheByteSize,
        maxZoom: maxZoom,
        minZoom: minZoom,
        tileSize: tileSize,
        refinementStrategy: refinementStrategy,
        extent: extent,
        maxRequests: maxRequests,
        zoomOffset: zoomOffset
      };
    }
  }, {
    key: "_updateTileset",
    value: function _updateTileset() {
      var tileset = this.state.tileset;
      var _this$props = this.props,
          zRange = _this$props.zRange,
          modelMatrix = _this$props.modelMatrix;
      var frameNumber = tileset.update(this.context.viewport, {
        zRange: zRange,
        modelMatrix: modelMatrix
      });
      var isLoaded = tileset.isLoaded;
      var loadingStateChanged = this.state.isLoaded !== isLoaded;
      var tilesetChanged = this.state.frameNumber !== frameNumber;

      if (isLoaded && (loadingStateChanged || tilesetChanged)) {
        this._onViewportLoad();
      }

      if (tilesetChanged) {
        this.setState({
          frameNumber: frameNumber
        });
      }

      this.state.isLoaded = isLoaded;
    }
  }, {
    key: "_onViewportLoad",
    value: function _onViewportLoad() {
      var tileset = this.state.tileset;
      var onViewportLoad = this.props.onViewportLoad;

      if (onViewportLoad) {
        onViewportLoad(tileset.selectedTiles);
      }
    }
  }, {
    key: "_onTileLoad",
    value: function _onTileLoad(tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileLoad(tile);

      if (tile.isVisible) {
        this.setNeedsUpdate();
      }
    }
  }, {
    key: "_onTileError",
    value: function _onTileError(error, tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileError(error);

      layer._updateTileset();

      if (tile.isVisible) {
        this.setNeedsUpdate();
      }
    }
  }, {
    key: "_onTileUnload",
    value: function _onTileUnload(tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileUnload(tile);
    }
  }, {
    key: "getTileData",
    value: function getTileData(tile) {
      var data = this.props.data;
      var _this$getCurrentLayer = this.getCurrentLayer().props,
          getTileData = _this$getCurrentLayer.getTileData,
          fetch = _this$getCurrentLayer.fetch;
      var signal = tile.signal;
      tile.url = (0, _utils.getURLFromTemplate)(data, tile);

      if (getTileData) {
        return getTileData(tile);
      }

      if (tile.url) {
        return fetch(tile.url, {
          propName: 'data',
          layer: this,
          signal: signal
        });
      }

      return null;
    }
  }, {
    key: "renderSubLayers",
    value: function renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
  }, {
    key: "getHighlightedObjectIndex",
    value: function getHighlightedObjectIndex() {
      return -1;
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref3) {
      var info = _ref3.info,
          sourceLayer = _ref3.sourceLayer;
      info.tile = sourceLayer.props.tile;
      return info;
    }
  }, {
    key: "_updateAutoHighlight",
    value: function _updateAutoHighlight(info) {
      if (info.sourceLayer) {
        info.sourceLayer.updateAutoHighlight(info);
      }
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this = this;

      var visible = this.props.visible;
      return this.state.tileset.tiles.map(function (tile) {
        var highlightedObjectIndex = _this.getHighlightedObjectIndex(tile);

        if (!tile.isLoaded) {} else if (!tile.layers) {
          var layers = _this.renderSubLayers(_objectSpread(_objectSpread({}, _this.props), {}, {
            id: "".concat(_this.id, "-").concat(tile.x, "-").concat(tile.y, "-").concat(tile.z),
            data: tile.data,
            visible: visible,
            _offset: 0,
            tile: tile
          }));

          tile.layers = (0, _core._flatten)(layers, Boolean).map(function (layer) {
            return layer.clone({
              tile: tile,
              highlightedObjectIndex: highlightedObjectIndex
            });
          });
        } else if (tile.layers[0] && tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex) {
          tile.layers = tile.layers.map(function (layer) {
            return layer.clone({
              highlightedObjectIndex: highlightedObjectIndex
            });
          });
        }

        return tile.layers;
      });
    }
  }, {
    key: "filterSubLayer",
    value: function filterSubLayer(_ref4) {
      var layer = _ref4.layer;
      return layer.props.tile.isVisible;
    }
  }, {
    key: "isLoaded",
    get: function get() {
      var tileset = this.state.tileset;
      return tileset.selectedTiles.every(function (tile) {
        return tile.layers && tile.layers.every(function (layer) {
          return layer.isLoaded;
        });
      });
    }
  }]);
  return TileLayer;
}(_core.CompositeLayer);

exports.default = TileLayer;
TileLayer.layerName = 'TileLayer';
TileLayer.defaultProps = defaultProps;
//# sourceMappingURL=tile-layer.js.map