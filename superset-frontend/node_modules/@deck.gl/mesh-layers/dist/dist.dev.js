(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("deck"), require("luma"));
	else if(typeof define === 'function' && define.amd)
		define(["deck", "luma"], factory);
	else if(typeof exports === 'object')
		exports["deck"] = factory(require("deck"), require("luma"));
	else
		root["deck"] = factory(root["deck"], root["luma"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__deck_gl_core__, __WEBPACK_EXTERNAL_MODULE__luma_gl_core__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/typeof.js":
/*!*********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/draco-loader.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/draco-loader.js ***!
  \*******************************************************************************************/
/*! exports provided: DracoLoader, _TypecheckDracoLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DracoLoader", function() { return DracoLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TypecheckDracoLoader", function() { return _TypecheckDracoLoader; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js");

const DEFAULT_DRACO_OPTIONS = {
  draco: {
    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js',
    libraryPath: 'libs/',
    extraAttributes: {},
    attributeNameEntry: undefined
  }
};
const DracoLoader = {
  name: 'Draco',
  id: 'draco',
  module: 'draco',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  worker: true,
  extensions: ['drc'],
  mimeTypes: ['application/octet-stream'],
  binary: true,
  tests: ['DRACO'],
  options: DEFAULT_DRACO_OPTIONS
};
const _TypecheckDracoLoader = DracoLoader;
//# sourceMappingURL=draco-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/draco-writer.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/draco-writer.js ***!
  \*******************************************************************************************/
/*! exports provided: DracoWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DracoWriter", function() { return DracoWriter; });
/* harmony import */ var _lib_draco_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/draco-builder */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-builder.js");
/* harmony import */ var _lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/draco-module-loader */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js");
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js");



const DEFAULT_DRACO_OPTIONS = {
  pointcloud: false,
  attributeNameEntry: 'name'
};
const DracoWriter = {
  name: 'DRACO',
  id: 'draco',
  module: 'draco',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_2__["VERSION"],
  extensions: ['drc'],
  encode,
  options: {
    draco: DEFAULT_DRACO_OPTIONS
  }
};

async function encode(data, options = {}) {
  const {
    draco
  } = await Object(_lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_1__["loadDracoEncoderModule"])(options);
  const dracoBuilder = new _lib_draco_builder__WEBPACK_IMPORTED_MODULE_0__["default"](draco);

  try {
    return dracoBuilder.encodeSync(data, options.draco);
  } finally {
    dracoBuilder.destroy();
  }
}
//# sourceMappingURL=draco-writer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/index.js":
/*!************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/index.js ***!
  \************************************************************************************/
/*! exports provided: DracoWriter, DracoWorkerLoader, DracoLoader, _TypecheckDracoLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DracoLoader", function() { return DracoLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TypecheckDracoLoader", function() { return _TypecheckDracoLoader; });
/* harmony import */ var _draco_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draco-loader */ "../../node_modules/@loaders.gl/draco/dist/esm/draco-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DracoWorkerLoader", function() { return _draco_loader__WEBPACK_IMPORTED_MODULE_0__["DracoLoader"]; });

/* harmony import */ var _lib_draco_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/draco-parser */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js");
/* harmony import */ var _lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/draco-module-loader */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js");
/* harmony import */ var _draco_writer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draco-writer */ "../../node_modules/@loaders.gl/draco/dist/esm/draco-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DracoWriter", function() { return _draco_writer__WEBPACK_IMPORTED_MODULE_3__["DracoWriter"]; });






const DracoLoader = { ..._draco_loader__WEBPACK_IMPORTED_MODULE_0__["DracoLoader"],
  parse
};

async function parse(arrayBuffer, options) {
  const {
    draco
  } = await Object(_lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_2__["loadDracoDecoderModule"])(options);
  const dracoParser = new _lib_draco_parser__WEBPACK_IMPORTED_MODULE_1__["default"](draco);

  try {
    return dracoParser.parseSync(arrayBuffer, options === null || options === void 0 ? void 0 : options.draco);
  } finally {
    dracoParser.destroy();
  }
}

const _TypecheckDracoLoader = DracoLoader;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-builder.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/lib/draco-builder.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DracoBuilder; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");

const GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {
  POSITION: 'POSITION',
  NORMAL: 'NORMAL',
  COLOR_0: 'COLOR',
  TEXCOORD_0: 'TEX_COORD'
};

const noop = () => {};

class DracoBuilder {
  constructor(draco) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "draco", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dracoEncoder", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dracoMeshBuilder", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dracoMetadataBuilder", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "log", void 0);

    this.draco = draco;
    this.dracoEncoder = new this.draco.Encoder();
    this.dracoMeshBuilder = new this.draco.MeshBuilder();
    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();
  }

  destroy() {
    this.destroyEncodedObject(this.dracoMeshBuilder);
    this.destroyEncodedObject(this.dracoEncoder);
    this.destroyEncodedObject(this.dracoMetadataBuilder);
    this.dracoMeshBuilder = null;
    this.dracoEncoder = null;
    this.draco = null;
  }

  destroyEncodedObject(object) {
    if (object) {
      this.draco.destroy(object);
    }
  }

  encodeSync(mesh, options = {}) {
    this.log = noop;

    this._setOptions(options);

    return options.pointcloud ? this._encodePointCloud(mesh, options) : this._encodeMesh(mesh, options);
  }

  _getAttributesFromMesh(mesh) {
    const attributes = { ...mesh,
      ...mesh.attributes
    };

    if (mesh.indices) {
      attributes.indices = mesh.indices;
    }

    return attributes;
  }

  _encodePointCloud(pointcloud, options) {
    const dracoPointCloud = new this.draco.PointCloud();

    if (options.metadata) {
      this._addGeometryMetadata(dracoPointCloud, options.metadata);
    }

    const attributes = this._getAttributesFromMesh(pointcloud);

    this._createDracoPointCloud(dracoPointCloud, attributes, options);

    const dracoData = new this.draco.DracoInt8Array();

    try {
      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);

      if (!(encodedLen > 0)) {
        throw new Error('Draco encoding failed.');
      }

      this.log("DRACO encoded ".concat(dracoPointCloud.num_points(), " points\n        with ").concat(dracoPointCloud.num_attributes(), " attributes into ").concat(encodedLen, " bytes"));
      return dracoInt8ArrayToArrayBuffer(dracoData);
    } finally {
      this.destroyEncodedObject(dracoData);
      this.destroyEncodedObject(dracoPointCloud);
    }
  }

  _encodeMesh(mesh, options) {
    const dracoMesh = new this.draco.Mesh();

    if (options.metadata) {
      this._addGeometryMetadata(dracoMesh, options.metadata);
    }

    const attributes = this._getAttributesFromMesh(mesh);

    this._createDracoMesh(dracoMesh, attributes, options);

    const dracoData = new this.draco.DracoInt8Array();

    try {
      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);

      if (encodedLen <= 0) {
        throw new Error('Draco encoding failed.');
      }

      this.log("DRACO encoded ".concat(dracoMesh.num_points(), " points\n        with ").concat(dracoMesh.num_attributes(), " attributes into ").concat(encodedLen, " bytes"));
      return dracoInt8ArrayToArrayBuffer(dracoData);
    } finally {
      this.destroyEncodedObject(dracoData);
      this.destroyEncodedObject(dracoMesh);
    }
  }

  _setOptions(options) {
    if ('speed' in options) {
      this.dracoEncoder.SetSpeedOptions(...options.speed);
    }

    if ('method' in options) {
      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];
      this.dracoEncoder.SetEncodingMethod(dracoMethod);
    }

    if ('quantization' in options) {
      for (const attribute in options.quantization) {
        const bits = options.quantization[attribute];
        const dracoPosition = this.draco[attribute];
        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);
      }
    }
  }

  _createDracoMesh(dracoMesh, attributes, options) {
    const optionalMetadata = options.attributesMetadata || {};

    try {
      const positions = this._getPositionAttribute(attributes);

      if (!positions) {
        throw new Error('positions');
      }

      const vertexCount = positions.length / 3;

      for (let attributeName in attributes) {
        const attribute = attributes[attributeName];
        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;

        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);

        if (uniqueId !== -1) {
          this._addAttributeMetadata(dracoMesh, uniqueId, {
            name: attributeName,
            ...(optionalMetadata[attributeName] || {})
          });
        }
      }
    } catch (error) {
      this.destroyEncodedObject(dracoMesh);
      throw error;
    }

    return dracoMesh;
  }

  _createDracoPointCloud(dracoPointCloud, attributes, options) {
    const optionalMetadata = options.attributesMetadata || {};

    try {
      const positions = this._getPositionAttribute(attributes);

      if (!positions) {
        throw new Error('positions');
      }

      const vertexCount = positions.length / 3;

      for (let attributeName in attributes) {
        const attribute = attributes[attributeName];
        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;

        const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);

        if (uniqueId !== -1) {
          this._addAttributeMetadata(dracoPointCloud, uniqueId, {
            name: attributeName,
            ...(optionalMetadata[attributeName] || {})
          });
        }
      }
    } catch (error) {
      this.destroyEncodedObject(dracoPointCloud);
      throw error;
    }

    return dracoPointCloud;
  }

  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {
    if (!ArrayBuffer.isView(attribute)) {
      return -1;
    }

    const type = this._getDracoAttributeType(attributeName);

    const size = attribute.length / vertexCount;

    if (type === 'indices') {
      const numFaces = attribute.length / 3;
      this.log("Adding attribute ".concat(attributeName, ", size ").concat(numFaces));
      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);
      return -1;
    }

    this.log("Adding attribute ".concat(attributeName, ", size ").concat(size));
    const builder = this.dracoMeshBuilder;
    const {
      buffer
    } = attribute;

    switch (attribute.constructor) {
      case Int8Array:
        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));

      case Int16Array:
        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));

      case Int32Array:
        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));

      case Uint8Array:
      case Uint8ClampedArray:
        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));

      case Uint16Array:
        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));

      case Uint32Array:
        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));

      case Float32Array:
      default:
        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));
    }
  }

  _getDracoAttributeType(attributeName) {
    switch (attributeName.toLowerCase()) {
      case 'indices':
        return 'indices';

      case 'position':
      case 'positions':
      case 'vertices':
        return this.draco.POSITION;

      case 'normal':
      case 'normals':
        return this.draco.NORMAL;

      case 'color':
      case 'colors':
        return this.draco.COLOR;

      case 'texcoord':
      case 'texcoords':
        return this.draco.TEX_COORD;

      default:
        return this.draco.GENERIC;
    }
  }

  _getPositionAttribute(attributes) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];

      const dracoType = this._getDracoAttributeType(attributeName);

      if (dracoType === this.draco.POSITION) {
        return attribute;
      }
    }

    return null;
  }

  _addGeometryMetadata(dracoGeometry, metadata) {
    const dracoMetadata = new this.draco.Metadata();

    this._populateDracoMetadata(dracoMetadata, metadata);

    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);
  }

  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {
    const dracoAttributeMetadata = new this.draco.Metadata();

    this._populateDracoMetadata(dracoAttributeMetadata, metadata);

    this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);
  }

  _populateDracoMetadata(dracoMetadata, metadata) {
    for (const [key, value] of getEntries(metadata)) {
      switch (typeof value) {
        case 'number':
          if (Math.trunc(value) === value) {
            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);
          } else {
            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);
          }

          break;

        case 'object':
          if (value instanceof Int32Array) {
            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);
          }

          break;

        case 'string':
        default:
          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);
      }
    }
  }

}

function dracoInt8ArrayToArrayBuffer(dracoData) {
  const byteLength = dracoData.size();
  const outputBuffer = new ArrayBuffer(byteLength);
  const outputData = new Int8Array(outputBuffer);

  for (let i = 0; i < byteLength; ++i) {
    outputData[i] = dracoData.GetValue(i);
  }

  return outputBuffer;
}

function getEntries(container) {
  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');
  return hasEntriesFunc ? container.entries() : Object.entries(container);
}
//# sourceMappingURL=draco-builder.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js ***!
  \******************************************************************************************************/
/*! exports provided: loadDracoDecoderModule, loadDracoEncoderModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadDracoDecoderModule", function() { return loadDracoDecoderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadDracoEncoderModule", function() { return loadDracoEncoderModule; });
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/index.js");

const DRACO_VERSION = '1.4.1';
const DRACO_JS_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION, "/draco_decoder.js");
const DRACO_WASM_WRAPPER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION, "/draco_wasm_wrapper.js");
const DRACO_WASM_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_VERSION, "/draco_decoder.wasm");
const DRACO_ENCODER_URL = "https://raw.githubusercontent.com/google/draco/".concat(DRACO_VERSION, "/javascript/draco_encoder.js");
let loadDecoderPromise;
let loadEncoderPromise;
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};

  if (modules.draco3d) {
    loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then(draco => {
      return {
        draco
      };
    });
  } else {
    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
  }

  return await loadDecoderPromise;
}
async function loadDracoEncoderModule(options) {
  const modules = options.modules || {};

  if (modules.draco3d) {
    loadEncoderPromise = loadEncoderPromise || modules.draco3d.createEncoderModule({}).then(draco => {
      return {
        draco
      };
    });
  } else {
    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);
  }

  return await loadEncoderPromise;
}

async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;

  switch (options.draco && options.draco.decoderType) {
    case 'js':
      DracoDecoderModule = await Object(_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])(DRACO_JS_DECODER_URL, 'draco', options);
      break;

    case 'wasm':
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([await Object(_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])(DRACO_WASM_WRAPPER_URL, 'draco', options), await Object(_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])(DRACO_WASM_DECODER_URL, 'draco', options)]);
  }

  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}

function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};

  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }

  return new Promise(resolve => {
    DracoDecoderModule({ ...options,
      onModuleLoaded: draco => resolve({
        draco
      })
    });
  });
}

async function loadDracoEncoder(options) {
  let DracoEncoderModule = await Object(_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])(DRACO_ENCODER_URL, 'draco', options);
  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;
  return new Promise(resolve => {
    DracoEncoderModule({
      onModuleLoaded: draco => resolve({
        draco
      })
    });
  });
}
//# sourceMappingURL=draco-module-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DracoParser; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/schema */ "../../node_modules/@loaders.gl/schema/dist/esm/index.js");
/* harmony import */ var _utils_schema_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/schema-attribute-utils */ "../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/schema-attribute-utils.js");



const GEOMETRY_TYPE = {
  TRIANGULAR_MESH: 0,
  POINT_CLOUD: 1
};
const DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: 'POSITION',
  NORMAL: 'NORMAL',
  COLOR: 'COLOR_0',
  TEX_COORD: 'TEXCOORD_0'
};
const DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
};
const INDEX_ITEM_SIZE = 4;
class DracoParser {
  constructor(draco) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "draco", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "decoder", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "metadataQuerier", void 0);

    this.draco = draco;
    this.decoder = new this.draco.Decoder();
    this.metadataQuerier = new this.draco.MetadataQuerier();
  }

  destroy() {
    this.draco.destroy(this.decoder);
    this.draco.destroy(this.metadataQuerier);
  }

  parseSync(arrayBuffer, options = {}) {
    const buffer = new this.draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);

    this._disableAttributeTransforms(options);

    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();

    try {
      let dracoStatus;

      switch (geometry_type) {
        case this.draco.TRIANGULAR_MESH:
          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          break;

        case this.draco.POINT_CLOUD:
          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          break;

        default:
          throw new Error('DRACO: Unknown geometry type.');
      }

      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());
        throw new Error(message);
      }

      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);

      const geometry = this._getMeshData(dracoGeometry, loaderData, options);

      const boundingBox = Object(_loaders_gl_schema__WEBPACK_IMPORTED_MODULE_1__["getMeshBoundingBox"])(geometry.attributes);
      const schema = Object(_utils_schema_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["makeSchemaFromAttributes"])(geometry.attributes, loaderData, geometry.indices);
      const data = {
        loader: 'draco',
        loaderData,
        header: {
          vertexCount: dracoGeometry.num_points(),
          boundingBox
        },
        ...geometry,
        schema
      };
      return data;
    } finally {
      this.draco.destroy(buffer);

      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry);
      }
    }
  }

  _getDracoLoaderData(dracoGeometry, geometry_type, options) {
    const metadata = this._getTopLevelMetadata(dracoGeometry);

    const attributes = this._getDracoAttributes(dracoGeometry, options);

    return {
      geometry_type,
      num_attributes: dracoGeometry.num_attributes(),
      num_points: dracoGeometry.num_points(),
      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
      metadata,
      attributes
    };
  }

  _getDracoAttributes(dracoGeometry, options) {
    const dracoAttributes = {};

    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);

      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);

      dracoAttributes[dracoAttribute.unique_id()] = {
        unique_id: dracoAttribute.unique_id(),
        attribute_type: dracoAttribute.attribute_type(),
        data_type: dracoAttribute.data_type(),
        num_components: dracoAttribute.num_components(),
        byte_offset: dracoAttribute.byte_offset(),
        byte_stride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        attribute_index: attributeId,
        metadata
      };

      const quantization = this._getQuantizationTransform(dracoAttribute, options);

      if (quantization) {
        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
      }

      const octahedron = this._getOctahedronTransform(dracoAttribute, options);

      if (octahedron) {
        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
      }
    }

    return dracoAttributes;
  }

  _getMeshData(dracoGeometry, loaderData, options) {
    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);

    const positionAttribute = attributes.POSITION;

    if (!positionAttribute) {
      throw new Error('DRACO: No position attribute found.');
    }

    if (dracoGeometry instanceof this.draco.Mesh) {
      switch (options.topology) {
        case 'triangle-strip':
          return {
            topology: 'triangle-strip',
            mode: 4,
            attributes,
            indices: {
              value: this._getTriangleStripIndices(dracoGeometry),
              size: 1
            }
          };

        case 'triangle-list':
        default:
          return {
            topology: 'triangle-list',
            mode: 5,
            attributes,
            indices: {
              value: this._getTriangleListIndices(dracoGeometry),
              size: 1
            }
          };
      }
    }

    return {
      topology: 'point-list',
      mode: 0,
      attributes
    };
  }

  _getMeshAttributes(loaderData, dracoGeometry, options) {
    const attributes = {};

    for (const loaderAttribute of Object.values(loaderData.attributes)) {
      const attributeName = this._deduceAttributeName(loaderAttribute, options);

      loaderAttribute.name = attributeName;

      const {
        value,
        size
      } = this._getAttributeValues(dracoGeometry, loaderAttribute);

      attributes[attributeName] = {
        value,
        size,
        byteOffset: loaderAttribute.byte_offset,
        byteStride: loaderAttribute.byte_stride,
        normalized: loaderAttribute.normalized
      };
    }

    return attributes;
  }

  _getTriangleListIndices(dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * INDEX_ITEM_SIZE;

    const ptr = this.draco._malloc(byteLength);

    try {
      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
    } finally {
      this.draco._free(ptr);
    }
  }

  _getTriangleStripIndices(dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array();

    try {
      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      return getUint32Array(dracoArray);
    } finally {
      this.draco.destroy(dracoArray);
    }
  }

  _getAttributeValues(dracoGeometry, attribute) {
    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
    const numComponents = attribute.num_components;
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(this.draco, TypedArrayCtor);
    let value;

    const ptr = this.draco._malloc(byteLength);

    try {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
    } finally {
      this.draco._free(ptr);
    }

    return {
      value,
      size: numComponents
    };
  }

  _deduceAttributeName(attribute, options) {
    const uniqueId = attribute.unique_id;

    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
      if (attributeUniqueId === uniqueId) {
        return attributeName;
      }
    }

    const thisAttributeType = attribute.attribute_type;

    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];

      if (attributeType === thisAttributeType) {
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }

    const entryName = options.attributeNameEntry || 'name';

    if (attribute.metadata[entryName]) {
      return attribute.metadata[entryName].string;
    }

    return "CUSTOM_ATTRIBUTE_".concat(uniqueId);
  }

  _getTopLevelMetadata(dracoGeometry) {
    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
    return this._getDracoMetadata(dracoMetadata);
  }

  _getAttributeMetadata(dracoGeometry, attributeId) {
    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._getDracoMetadata(dracoMetadata);
  }

  _getDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }

    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);

    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
    }

    return result;
  }

  _getDracoMetadataField(dracoMetadata, entryName) {
    const dracoArray = new this.draco.DracoInt32Array();

    try {
      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
      const intArray = getInt32Array(dracoArray);
      return {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray
      };
    } finally {
      this.draco.destroy(dracoArray);
    }
  }

  _disableAttributeTransforms(options) {
    const {
      quantizedAttributes = [],
      octahedronAttributes = []
    } = options;
    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];

    for (const dracoAttributeName of skipAttributes) {
      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
    }
  }

  _getQuantizationTransform(dracoAttribute, options) {
    const {
      quantizedAttributes = []
    } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const skip = quantizedAttributes.map(type => this.decoder[type]).includes(attribute_type);

    if (skip) {
      const transform = new this.draco.AttributeQuantizationTransform();

      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits(),
            range: transform.range(),
            min_values: new Float32Array([1, 2, 3]).map(i => transform.min_value(i))
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }

    return null;
  }

  _getOctahedronTransform(dracoAttribute, options) {
    const {
      octahedronAttributes = []
    } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const octahedron = octahedronAttributes.map(type => this.decoder[type]).includes(attribute_type);

    if (octahedron) {
      const transform = new this.draco.AttributeQuantizationTransform();

      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits()
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }

    return null;
  }

}

function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;

    case Int8Array:
      return draco.DT_INT8;

    case Int16Array:
      return draco.DT_INT16;

    case Int32Array:
      return draco.DT_INT32;

    case Uint8Array:
      return draco.DT_UINT8;

    case Uint16Array:
      return draco.DT_UINT16;

    case Uint32Array:
      return draco.DT_UINT32;

    default:
      return draco.DT_INVALID;
  }
}

function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);

  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }

  return intArray;
}

function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);

  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }

  return intArray;
}
//# sourceMappingURL=draco-parser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/schema-attribute-utils.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/lib/utils/schema-attribute-utils.js ***!
  \***************************************************************************************************************/
/*! exports provided: makeSchemaFromAttributes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeSchemaFromAttributes", function() { return makeSchemaFromAttributes; });
/* harmony import */ var _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/schema */ "../../node_modules/@loaders.gl/schema/dist/esm/index.js");

function makeSchemaFromAttributes(attributes, loaderData, indices) {
  const metadataMap = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);

  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }

  if (indices) {
    const indicesField = getArrowFieldFromAttribute('indices', indices);
    fields.push(indicesField);
  }

  return new _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__["Schema"](fields, metadataMap);
}

function transformAttributesLoaderData(loaderData) {
  const result = {};

  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || 'undefined'] = dracoAttribute;
  }

  return result;
}

function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;
  const type = Object(_loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__["getArrowTypeFromTypedArray"])(attribute.value);
  return new _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__["Field"](attributeName, new _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__["FixedSizeList"](attribute.size, new _loaders_gl_schema__WEBPACK_IMPORTED_MODULE_0__["Field"]('value', type)), false, metadataMap);
}

function makeMetadata(metadata) {
  const metadataMap = new Map();

  for (const key in metadata) {
    metadataMap.set("".concat(key, ".string"), JSON.stringify(metadata[key]));
  }

  return metadataMap;
}
//# sourceMappingURL=schema-attribute-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js ***!
  \************************************************************************************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
const VERSION =  true ? "3.0.6" : undefined;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/glb-loader.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/glb-loader.js ***!
  \****************************************************************************************/
/*! exports provided: GLBLoader, _TypecheckGLBLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBLoader", function() { return GLBLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TypecheckGLBLoader", function() { return _TypecheckGLBLoader; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_glb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-glb */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js");


const GLBLoader = {
  name: 'GLB',
  id: 'glb',
  module: 'gltf',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  parse,
  parseSync,
  options: {
    glb: {
      strict: false
    }
  }
};

async function parse(arrayBuffer, options) {
  return parseSync(arrayBuffer, options);
}

function parseSync(arrayBuffer, options) {
  const {
    byteOffset = 0
  } = options || {};
  const glb = {};
  Object(_lib_parsers_parse_glb__WEBPACK_IMPORTED_MODULE_1__["default"])(glb, arrayBuffer, byteOffset, options === null || options === void 0 ? void 0 : options.glb);
  return glb;
}

const _TypecheckGLBLoader = GLBLoader;
//# sourceMappingURL=glb-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/glb-writer.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/glb-writer.js ***!
  \****************************************************************************************/
/*! exports provided: GLBWriter, _TypecheckGLBLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBWriter", function() { return GLBWriter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TypecheckGLBLoader", function() { return _TypecheckGLBLoader; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_encoders_encode_glb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/encoders/encode-glb */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js");


const GLBWriter = {
  name: 'GLB',
  id: 'glb',
  module: 'gltf',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  encodeSync,
  options: {
    glb: {}
  }
};

function encodeSync(glb, options) {
  const {
    byteOffset = 0
  } = options;
  const byteLength = Object(_lib_encoders_encode_glb__WEBPACK_IMPORTED_MODULE_1__["default"])(glb, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encoders_encode_glb__WEBPACK_IMPORTED_MODULE_1__["default"])(glb, dataView, byteOffset, options);
  return arrayBuffer;
}

const _TypecheckGLBLoader = GLBWriter;
//# sourceMappingURL=glb-writer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js ***!
  \*****************************************************************************************/
/*! exports provided: GLTFLoader, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return GLTFLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_gltf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js");


const GLTFLoader = {
  name: 'glTF',
  id: 'gltf',
  module: 'gltf',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  extensions: ['gltf', 'glb'],
  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],
  text: true,
  binary: true,
  tests: ['glTF'],
  parse,
  options: {
    gltf: {
      normalize: true,
      loadBuffers: true,
      loadImages: true,
      decompressMeshes: true,
      postProcess: true
    },
    log: console
  },
  deprecatedOptions: {
    fetchImages: 'gltf.loadImages',
    createImages: 'gltf.loadImages',
    decompress: 'gltf.decompressMeshes',
    postProcess: 'gltf.postProcess',
    gltf: {
      decompress: 'gltf.decompressMeshes'
    }
  }
};
async function parse(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options,
    ...options
  };
  options.gltf = { ...GLTFLoader.options.gltf,
    ...options.gltf
  };
  const {
    byteOffset = 0
  } = options;
  const gltf = {};
  return await Object(_lib_parsers_parse_gltf__WEBPACK_IMPORTED_MODULE_1__["parseGLTF"])(gltf, arrayBuffer, byteOffset, options, context);
}
//# sourceMappingURL=gltf-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/gltf-writer.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/gltf-writer.js ***!
  \*****************************************************************************************/
/*! exports provided: GLTFWriter, _TypecheckGLBLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFWriter", function() { return GLTFWriter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TypecheckGLBLoader", function() { return _TypecheckGLBLoader; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_encoders_encode_gltf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/encoders/encode-gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-gltf.js");


const GLTFWriter = {
  name: 'glTF',
  id: 'gltf',
  module: 'gltf',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  encodeSync,
  options: {
    gltf: {}
  }
};

function encodeSync(gltf, options = {}) {
  const {
    byteOffset = 0
  } = options;
  const byteLength = Object(_lib_encoders_encode_gltf__WEBPACK_IMPORTED_MODULE_1__["encodeGLTFSync"])(gltf, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encoders_encode_gltf__WEBPACK_IMPORTED_MODULE_1__["encodeGLTFSync"])(gltf, dataView, byteOffset, options);
  return arrayBuffer;
}

const _TypecheckGLBLoader = GLTFWriter;
//# sourceMappingURL=gltf-writer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/index.js":
/*!***********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/index.js ***!
  \***********************************************************************************/
/*! exports provided: KHR_DRACO_MESH_COMPRESSION, GLTFLoader, GLTFWriter, GLBLoader, GLBWriter, GLTFScenegraph, postProcessGLTF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return _lib_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_0__["KHR_DRACO_MESH_COMPRESSION"]; });

/* harmony import */ var _gltf_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-loader */ "../../node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return _gltf_loader__WEBPACK_IMPORTED_MODULE_1__["GLTFLoader"]; });

/* harmony import */ var _gltf_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gltf-writer */ "../../node_modules/@loaders.gl/gltf/dist/esm/gltf-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFWriter", function() { return _gltf_writer__WEBPACK_IMPORTED_MODULE_2__["GLTFWriter"]; });

/* harmony import */ var _glb_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glb-loader */ "../../node_modules/@loaders.gl/gltf/dist/esm/glb-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBLoader", function() { return _glb_loader__WEBPACK_IMPORTED_MODULE_3__["GLBLoader"]; });

/* harmony import */ var _glb_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glb-writer */ "../../node_modules/@loaders.gl/gltf/dist/esm/glb-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBWriter", function() { return _glb_writer__WEBPACK_IMPORTED_MODULE_4__["GLBWriter"]; });

/* harmony import */ var _lib_api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFScenegraph", function() { return _lib_api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_api_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/api/post-process-gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "postProcessGLTF", function() { return _lib_api_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__["postProcessGLTF"]; });








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFScenegraph; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/images */ "../../node_modules/@loaders.gl/images/dist/esm/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js");





const DEFAULT_GLTF_JSON = {
  asset: {
    version: '2.0',
    generator: 'loaders.gl'
  },
  buffers: []
};
class GLTFScenegraph {
  constructor(gltf) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gltf", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "sourceBuffers", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "byteLength", void 0);

    this.gltf = gltf || {
      json: { ...DEFAULT_GLTF_JSON
      },
      buffers: []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;

    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }

  get json() {
    return this.gltf.json;
  }

  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }

  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }

  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find(name => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] || true : null;
  }

  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }

  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }

  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }

  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }

  getScene(index) {
    return this.getObject('scenes', index);
  }

  getNode(index) {
    return this.getObject('nodes', index);
  }

  getSkin(index) {
    return this.getObject('skins', index);
  }

  getMesh(index) {
    return this.getObject('meshes', index);
  }

  getMaterial(index) {
    return this.getObject('materials', index);
  }

  getAccessor(index) {
    return this.getObject('accessors', index);
  }

  getTexture(index) {
    return this.getObject('textures', index);
  }

  getSampler(index) {
    return this.getObject('samplers', index);
  }

  getImage(index) {
    return this.getObject('images', index);
  }

  getBufferView(index) {
    return this.getObject('bufferViews', index);
  }

  getBuffer(index) {
    return this.getObject('buffers', index);
  }

  getObject(array, index) {
    if (typeof index === 'object') {
      return index;
    }

    const object = this.json[array] && this.json[array][index];

    if (!object) {
      throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
    }

    return object;
  }

  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = this.gltf.buffers[bufferIndex];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["assert"])(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  getTypedArrayForAccessor(accessor) {
    accessor = this.getAccessor(accessor);
    const bufferView = this.getBufferView(accessor.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const {
      ArrayType,
      length
    } = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_4__["getAccessorArrayTypeAndLength"])(accessor, bufferView);
    const byteOffset = bufferView.byteOffset + accessor.byteOffset;
    return new ArrayType(arrayBuffer, byteOffset, length);
  }

  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }

  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }

  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }

  addObjectExtension(object, extensionName, data) {
    object.extensions = object.extensions || {};
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }

  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
  }

  removeObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    const extension = extensions[extensionName];
    delete extensions[extensionName];
    return extension;
  }

  addExtension(extensionName, extensionData = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["assert"])(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }

  addRequiredExtension(extensionName, extensionData = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["assert"])(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }

  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];

    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }

  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];

    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }

  removeExtension(extensionName) {
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }

    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }

    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
  }

  setDefaultScene(sceneIndex) {
    this.json.scene = sceneIndex;
  }

  addScene(scene) {
    const {
      nodeIndices
    } = scene;
    this.json.scenes = this.json.scenes || [];
    this.json.scenes.push({
      nodes: nodeIndices
    });
    return this.json.scenes.length - 1;
  }

  addNode(node) {
    const {
      meshIndex,
      matrix
    } = node;
    this.json.nodes = this.json.nodes || [];
    const nodeData = {
      mesh: meshIndex
    };

    if (matrix) {
      nodeData.matrix = matrix;
    }

    this.json.nodes.push(nodeData);
    return this.json.nodes.length - 1;
  }

  addMesh(mesh) {
    const {
      attributes,
      indices,
      material,
      mode = 4
    } = mesh;

    const accessors = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [{
        attributes: accessors,
        mode
      }]
    };

    if (indices) {
      const indicesAccessor = this._addIndices(indices);

      glTFMesh.primitives[0].indices = indicesAccessor;
    }

    if (Number.isFinite(material)) {
      glTFMesh.primitives[0].material = material;
    }

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [{
        attributes: accessorIndices,
        mode: 0
      }]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addImage(imageData, mimeTypeOpt) {
    const metadata = Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["getBinaryImageMetadata"])(imageData);
    const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
    const bufferViewIndex = this.addBufferView(imageData);
    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };
    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }

  addBufferView(buffer) {
    const byteLength = buffer.byteLength;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["assert"])(Number.isFinite(byteLength));
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);
    const glTFBufferView = {
      buffer: 0,
      byteOffset: this.byteLength,
      byteLength
    };
    this.byteLength += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__["padToNBytes"])(byteLength, 4);
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }

  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      type: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_4__["getAccessorTypeFromSize"])(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count,
      max: accessor.max,
      min: accessor.min
    };
    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }

  addBinaryBuffer(sourceBuffer, accessor = {
    size: 3
  }) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    let minMax = {
      min: accessor.min,
      max: accessor.max
    };

    if (!minMax.min || !minMax.max) {
      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
    }

    const accessorDefaults = {
      size: accessor.size,
      componentType: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_4__["getComponentTypeFromArray"])(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size),
      min: minMax.min,
      max: minMax.max
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  addTexture(texture) {
    const {
      imageIndex
    } = texture;
    const glTFTexture = {
      source: imageIndex
    };
    this.json.textures = this.json.textures || [];
    this.json.textures.push(glTFTexture);
    return this.json.textures.length - 1;
  }

  addMaterial(pbrMaterialInfo) {
    this.json.materials = this.json.materials || [];
    this.json.materials.push(pbrMaterialInfo);
    return this.json.materials.length - 1;
  }

  createBinaryChunk() {
    var _this$json, _this$json$buffers;

    this.gltf.buffers = [];
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;

    for (const sourceBuffer of this.sourceBuffers || []) {
      dstByteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__["copyToArray"])(sourceBuffer, targetArray, dstByteOffset);
    }

    if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
      this.json.buffers[0].byteLength = totalByteLength;
    } else {
      this.json.buffers = [{
        byteLength: totalByteLength
      }];
    }

    this.gltf.binary = arrayBuffer;
    this.sourceBuffers = [arrayBuffer];
  }

  _removeStringFromArray(array, string) {
    let found = true;

    while (found) {
      const index = array.indexOf(string);

      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }

  _addAttributes(attributes = {}) {
    const result = {};

    for (const attributeKey in attributes) {
      const attributeData = attributes[attributeKey];

      const attrName = this._getGltfAttributeName(attributeKey);

      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
      result[attrName] = accessor;
    }

    return result;
  }

  _addIndices(indices) {
    return this.addBinaryBuffer(indices, {
      size: 1
    });
  }

  _getGltfAttributeName(attributeName) {
    switch (attributeName.toLowerCase()) {
      case 'position':
      case 'positions':
      case 'vertices':
        return 'POSITION';

      case 'normal':
      case 'normals':
        return 'NORMAL';

      case 'color':
      case 'colors':
        return 'COLOR_0';

      case 'texcoord':
      case 'texcoords':
        return 'TEXCOORD_0';

      default:
        return attributeName;
    }
  }

  _getAccessorMinMax(buffer, size) {
    const result = {
      min: null,
      max: null
    };

    if (buffer.length < size) {
      return result;
    }

    result.min = [];
    result.max = [];
    const initValues = buffer.subarray(0, size);

    for (const value of initValues) {
      result.min.push(value);
      result.max.push(value);
    }

    for (let index = size; index < buffer.length; index += size) {
      for (let componentIndex = 0; componentIndex < size; componentIndex++) {
        result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);
        result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);
      }
    }

    return result;
  }

}
//# sourceMappingURL=gltf-scenegraph.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js ***!
  \*******************************************************************************************************/
/*! exports provided: normalizeGLTFV1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeGLTFV1", function() { return normalizeGLTFV1; });
/* harmony import */ var _extensions_KHR_binary_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/KHR_binary_gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js");

const GLTF_ARRAYS = {
  accessors: 'accessor',
  animations: 'animation',
  buffers: 'buffer',
  bufferViews: 'bufferView',
  images: 'image',
  materials: 'material',
  meshes: 'mesh',
  nodes: 'node',
  samplers: 'sampler',
  scenes: 'scene',
  skins: 'skin',
  textures: 'texture'
};
const GLTF_KEYS = {
  accessor: 'accessors',
  animations: 'animation',
  buffer: 'buffers',
  bufferView: 'bufferViews',
  image: 'images',
  material: 'materials',
  mesh: 'meshes',
  node: 'nodes',
  sampler: 'samplers',
  scene: 'scenes',
  skin: 'skins',
  texture: 'textures'
};

class GLTFV1Normalizer {
  constructor(gltf) {
    this.idToIndexMap = {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    };
  }

  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;

    switch (json.asset && json.asset.version) {
      case '2.0':
        return;

      case undefined:
      case '1.0':
        break;

      default:
        console.warn("glTF: Unknown version ".concat(json.asset.version));
        return;
    }

    if (!options.normalize) {
      throw new Error('glTF v1 is not supported.');
    }

    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');

    this._addAsset(json);

    this._convertTopLevelObjectsToArrays(json);

    _extensions_KHR_binary_gltf__WEBPACK_IMPORTED_MODULE_0__["decode"](gltf);

    this._convertObjectIdsToArrayIndices(json);

    this._updateObjects(json);

    this._updateMaterial(json);
  }

  _addAsset(json) {
    json.asset = json.asset || {};
    json.asset.version = '2.0';
    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';
  }

  _convertTopLevelObjectsToArrays(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }

  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];

    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }

    json[mapName] = [];

    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id;
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }

  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }

    if ('scene' in json) {
      json.scene = this._convertIdToIndex(json.scene, 'scene');
    }

    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }

    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }

    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }

    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }

  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, 'image');
    }
  }

  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const {
        attributes,
        indices,
        material
      } = primitive;

      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');
      }

      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, 'accessor');
      }

      if (material) {
        primitive.material = this._convertIdToIndex(material, 'material');
      }
    }
  }

  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));
    }

    if (node.meshes) {
      node.meshes = node.meshes.map(mesh => this._convertIdToIndex(mesh, 'mesh'));
    }
  }

  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));
    }
  }

  _convertIdsToIndices(json, topLevelArrayName) {
    if (!json[topLevelArrayName]) {
      console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));
      json[topLevelArrayName] = [];
    }

    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];

        const index = this._convertIdToIndex(id, key);

        object[key] = index;
      }
    }
  }

  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];

    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];

      if (!Number.isFinite(index)) {
        throw new Error("gltf v1: failed to resolve ".concat(key, " with id ").concat(id));
      }

      return index;
    }

    return id;
  }

  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      delete buffer.type;
    }
  }

  _updateMaterial(json) {
    for (const material of json.materials) {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const textureId = material.values && material.values.tex;
      const textureIndex = json.textures.findIndex(texture => texture.id === textureId);

      if (textureIndex !== -1) {
        material.pbrMetallicRoughness.baseColorTexture = {
          index: textureIndex
        };
      }
    }
  }

}

function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}
//# sourceMappingURL=normalize-gltf-v1.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js ***!
  \*******************************************************************************************************/
/*! exports provided: postProcessGLTF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postProcessGLTF", function() { return postProcessGLTF; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js");


const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
const GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};
const SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
const DEFAULT_SAMPLER = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT
};

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

class GLTFPostProcessor {
  postProcess(gltf, options = {}) {
    const {
      json,
      buffers = [],
      images = [],
      baseUri = ''
    } = gltf;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(json);
    this.baseUri = baseUri;
    this.json = json;
    this.buffers = buffers;
    this.images = images;

    this._resolveTree(this.json, options);

    return this.json;
  }

  _resolveTree(json, options = {}) {
    if (json.bufferViews) {
      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }

    if (json.images) {
      json.images = json.images.map((image, i) => this._resolveImage(image, i));
    }

    if (json.samplers) {
      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }

    if (json.textures) {
      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));
    }

    if (json.accessors) {
      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }

    if (json.materials) {
      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));
    }

    if (json.meshes) {
      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }

    if (json.nodes) {
      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));
    }

    if (json.skins) {
      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));
    }

    if (json.scenes) {
      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));
    }

    if (json.scene !== undefined) {
      json.scene = json.scenes[this.json.scene];
    }
  }

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null;
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  _get(array, index) {
    if (typeof index === 'object') {
      return index;
    }

    const object = this.json[array] && this.json[array][index];

    if (!object) {
      console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
    }

    return object;
  }

  _resolveScene(scene, index) {
    scene.id = scene.id || "scene-".concat(index);
    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));
    return scene;
  }

  _resolveNode(node, index) {
    node.id = node.id || "node-".concat(index);

    if (node.children) {
      node.children = node.children.map(child => this.getNode(child));
    }

    if (node.mesh !== undefined) {
      node.mesh = this.getMesh(node.mesh);
    } else if (node.meshes !== undefined && node.meshes.length) {
      node.mesh = node.meshes.reduce((accum, meshIndex) => {
        const mesh = this.getMesh(meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, {
        primitives: []
      });
    }

    if (node.camera !== undefined) {
      node.camera = this.getCamera(node.camera);
    }

    if (node.skin !== undefined) {
      node.skin = this.getSkin(node.skin);
    }

    return node;
  }

  _resolveSkin(skin, index) {
    skin.id = skin.id || "skin-".concat(index);
    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    return skin;
  }

  _resolveMesh(mesh, index) {
    mesh.id = mesh.id || "mesh-".concat(index);

    if (mesh.primitives) {
      mesh.primitives = mesh.primitives.map(primitive => {
        primitive = { ...primitive
        };
        const attributes = primitive.attributes;
        primitive.attributes = {};

        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }

        if (primitive.indices !== undefined) {
          primitive.indices = this.getAccessor(primitive.indices);
        }

        if (primitive.material !== undefined) {
          primitive.material = this.getMaterial(primitive.material);
        }

        return primitive;
      });
    }

    return mesh;
  }

  _resolveMaterial(material, index) {
    material.id = material.id || "material-".concat(index);

    if (material.normalTexture) {
      material.normalTexture = { ...material.normalTexture
      };
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }

    if (material.occlusionTexture) {
      material.occlustionTexture = { ...material.occlustionTexture
      };
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }

    if (material.emissiveTexture) {
      material.emmisiveTexture = { ...material.emmisiveTexture
      };
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }

    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];
    }

    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness
      };
      const mr = material.pbrMetallicRoughness;

      if (mr.baseColorTexture) {
        mr.baseColorTexture = { ...mr.baseColorTexture
        };
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }

      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture
        };
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }

    return material;
  }

  _resolveAccessor(accessor, index) {
    accessor.id = accessor.id || "accessor-".concat(index);

    if (accessor.bufferView !== undefined) {
      accessor.bufferView = this.getBufferView(accessor.bufferView);
    }

    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
    accessor.components = getSizeFromAccessorType(accessor.type);
    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;

    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const {
        ArrayType,
        byteLength
      } = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getAccessorArrayTypeAndLength"])(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
      const cutBufffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
      accessor.value = new ArrayType(cutBufffer);
    }

    return accessor;
  }

  _resolveTexture(texture, index) {
    texture.id = texture.id || "texture-".concat(index);
    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
    texture.source = this.getImage(texture.source);
    return texture;
  }

  _resolveSampler(sampler, index) {
    sampler.id = sampler.id || "sampler-".concat(index);
    sampler.parameters = {};

    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);

      if (glEnum !== undefined) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }

    return sampler;
  }

  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }

  _resolveImage(image, index) {
    image.id = image.id || "image-".concat(index);

    if (image.bufferView !== undefined) {
      image.bufferView = this.getBufferView(image.bufferView);
    }

    const preloadedImage = this.images[index];

    if (preloadedImage) {
      image.image = preloadedImage;
    }

    return image;
  }

  _resolveBufferView(bufferView, index) {
    bufferView.id = bufferView.id || "bufferView-".concat(index);
    const bufferIndex = bufferView.buffer;
    bufferView.buffer = this.buffers[bufferIndex];
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;

    if ('byteOffset' in bufferView) {
      byteOffset += bufferView.byteOffset;
    }

    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    return bufferView;
  }

  _resolveCamera(camera, index) {
    camera.id = camera.id || "camera-".concat(index);

    if (camera.perspective) {}

    if (camera.orthographic) {}

    return camera;
  }

}

function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}
//# sourceMappingURL=post-process-gltf.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return encodeGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");

const MAGIC_glTF = 0x46546c67;
const MAGIC_JSON = 0x4e4f534a;
const MAGIC_BIN = 0x004e4942;
const LE = true;
function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {
  const {
    magic = MAGIC_glTF,
    version = 2,
    json = {},
    binary
  } = glb;
  const byteOffsetStart = byteOffset;

  if (dataView) {
    dataView.setUint32(byteOffset + 0, magic, LE);
    dataView.setUint32(byteOffset + 4, version, LE);
    dataView.setUint32(byteOffset + 8, 0, LE);
  }

  const byteOffsetFileLength = byteOffset + 8;
  byteOffset += 12;
  const byteOffsetJsonHeader = byteOffset;

  if (dataView) {
    dataView.setUint32(byteOffset + 0, 0, LE);
    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE);
  }

  byteOffset += 8;
  const jsonString = JSON.stringify(json);
  byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedStringToDataView"])(dataView, byteOffset, jsonString, 4);

  if (dataView) {
    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8;
    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE);
  }

  if (binary) {
    const byteOffsetBinHeader = byteOffset;

    if (dataView) {
      dataView.setUint32(byteOffset + 0, 0, LE);
      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE);
    }

    byteOffset += 8;
    byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedArrayBufferToDataView"])(dataView, byteOffset, binary, 4);

    if (dataView) {
      const binByteLength = byteOffset - byteOffsetBinHeader - 8;
      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE);
    }
  }

  if (dataView) {
    const fileByteLength = byteOffset - byteOffsetStart;
    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE);
  }

  return byteOffset;
}
//# sourceMappingURL=encode-glb.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-gltf.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-gltf.js ***!
  \******************************************************************************************************/
/*! exports provided: encodeGLTFSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeGLTFSync", function() { return encodeGLTFSync; });
/* harmony import */ var _encode_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode-glb */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js");

function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {
  convertBuffersToBase64(gltf);
  return Object(_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(gltf, arrayBuffer, byteOffset, options);
}

function convertBuffersToBase64(gltf, {
  firstBuffer = 0
} = {}) {
  if (gltf.buffers && gltf.buffers.length > firstBuffer) {
    throw new Error('encodeGLTF: multiple buffers not yet implemented');
  }
}
//# sourceMappingURL=encode-gltf.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js ***!
  \************************************************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony import */ var _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");


function decode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;

  for (const node of json.images || []) {
    const extension = gltfScenegraph.removeObjectExtension(node, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);

    if (extension) {
      Object.assign(node, extension);
    }
  }

  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }

  gltfScenegraph.removeExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);
}
function encode() {
  throw new Error(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);
}
//# sourceMappingURL=KHR_binary_gltf.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js ***!
  \***********************************************************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _loaders_gl_draco__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/draco */ "../../node_modules/@loaders.gl/draco/dist/esm/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");
/* harmony import */ var _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony import */ var _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");
/* harmony import */ var _gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gltf-utils/gltf-attribute-utils */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js");





async function decode(gltfData, options, context) {
  var _options$gltf;

  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
    return;
  }

  const scenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__["default"](gltfData);
  const promises = [];

  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"])) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }

  await Promise.all(promises);
  scenegraph.removeExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);
}
function encode(gltfData, options = {}) {
  const scenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__["default"](gltfData);

  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);
  }
}

async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);

  if (!dracoExtension) {
    return;
  }

  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["sliceArrayBuffer"])(buffer.buffer, buffer.byteOffset);
  const {
    parse
  } = context;
  const dracoOptions = { ...options
  };
  delete dracoOptions['3d-tiles'];
  const decodedData = await parse(bufferCopy, _loaders_gl_draco__WEBPACK_IMPORTED_MODULE_0__["DracoLoader"], dracoOptions, context);
  const decodedAttributes = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__["getGLTFAccessors"])(decodedData.attributes);

  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);

      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }

  primitive.attributes = decodedAttributes;

  if (decodedData.indices) {
    primitive.indices = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__["getGLTFAccessor"])(decodedData.indices);
  }

  checkPrimitive(primitive);
}

function compressMesh(attributes, indices, mode = 4, options, context) {
  var _context$parseSync;

  if (!options.DracoWriter) {
    throw new Error('options.gltf.DracoWriter not provided');
  }

  const compressedData = options.DracoWriter.encodeSync({
    attributes
  });
  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
    attributes
  });

  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);

  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [{
      attributes: fauxAccessors,
      mode,
      extensions: {
        [_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]]: {
          bufferView: bufferViewIndex,
          attributes: fauxAccessors
        }
      }
    }]
  };
  return glTFMesh;
}

function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');
  }
}

function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}
//# sourceMappingURL=KHR_draco_mesh_compression.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_lights_punctual.js":
/*!****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_lights_punctual.js ***!
  \****************************************************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");
/* harmony import */ var _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony import */ var _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");



async function decode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);

  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
  }

  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);

    if (nodeExtension) {
      node.light = nodeExtension.light;
    }

    gltfScenegraph.removeObjectExtension(node, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
  }
}
async function encode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;

  if (json.lights) {
    const extension = gltfScenegraph.addExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }

  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"], light);
    }

    delete gltfScenegraph.json.lights;
  }
}
//# sourceMappingURL=KHR_lights_punctual.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_materials_unlit.js":
/*!****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_materials_unlit.js ***!
  \****************************************************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony import */ var _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");


async function decode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;
  gltfScenegraph.removeExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);

  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;

    if (extension) {
      material.unlit = true;
    }

    gltfScenegraph.removeObjectExtension(material, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);
  }
}
function encode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;

  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"], {});
        gltfScenegraph.addExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);
      }
    }
  }
}
//# sourceMappingURL=KHR_materials_unlit.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_techniques_webgl.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_techniques_webgl.js ***!
  \*****************************************************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/gltf-scenegraph */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js");
/* harmony import */ var _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-utils/gltf-constants */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js");


async function decode(gltfData) {
  const gltfScenegraph = new _api_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {
    json
  } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);

  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);

    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);

      if (materialExtension) {
        material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }

      gltfScenegraph.removeObjectExtension(material, _gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
    }

    gltfScenegraph.removeExtension(_gltf_utils_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
  }
}
async function encode(gltfData, options) {}

function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const {
    programs = [],
    shaders = [],
    techniques = []
  } = techniquesExtension;
  const textDecoder = new TextDecoder();
  shaders.forEach(shader => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error('KHR_techniques_webgl: no shader code');
    }
  });
  programs.forEach(program => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach(technique => {
    technique.program = programs[technique.program];
  });
  return techniques;
}

function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach(uniform => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach(uniform => {
    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}
//# sourceMappingURL=KHR_techniques_webgl.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/gltf-extensions.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/gltf-extensions.js ***!
  \************************************************************************************************************/
/*! exports provided: EXTENSIONS, decodeExtensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeExtensions", function() { return decodeExtensions; });
/* harmony import */ var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KHR_draco_mesh_compression */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js");
/* harmony import */ var _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KHR_materials_unlit */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_materials_unlit.js");
/* harmony import */ var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KHR_lights_punctual */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_lights_punctual.js");
/* harmony import */ var _KHR_techniques_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KHR_techniques_webgl */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_techniques_webgl.js");




const EXTENSIONS = {
  KHR_draco_mesh_compression: _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__,
  KHR_materials_unlit: _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_1__,
  KHR_lights_punctual: _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_2__,
  KHR_techniques_webgl: _KHR_techniques_webgl__WEBPACK_IMPORTED_MODULE_3__
};
async function decodeExtensions(gltf, options = {}, context) {
  for (const extensionName in EXTENSIONS) {
    var _options$gltf;

    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
    const exclude = extensionName in excludes && !excludes[extensionName];

    if (!exclude) {
      const extension = EXTENSIONS[extensionName];
      await extension.decode(gltf, options, context);
    }
  }
}
//# sourceMappingURL=gltf-extensions.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js ***!
  \************************************************************************************************************/
/*! exports provided: getTypedArrayForBufferView, getTypedArrayForImageData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayForBufferView", function() { return getTypedArrayForBufferView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayForImageData", function() { return getTypedArrayForImageData; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");

function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
function getTypedArrayForImageData(json, buffers, imageIndex) {
  const image = json.images[imageIndex];
  const bufferViewIndex = json.bufferViews[image.bufferView];
  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);
}
//# sourceMappingURL=get-typed-array.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js ***!
  \*****************************************************************************************************************/
/*! exports provided: getGLTFAccessors, getGLTFAccessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessors", function() { return getGLTFAccessors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessor", function() { return getGLTFAccessor; });
/* harmony import */ var _gltf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf-utils */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js");

function getGLTFAccessors(attributes) {
  const accessors = {};

  for (const name in attributes) {
    const attribute = attributes[name];

    if (name !== 'indices') {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name] = glTFAccessor;
    }
  }

  return accessors;
}
function getGLTFAccessor(attribute) {
  const {
    buffer,
    size,
    count
  } = getAccessorData(attribute);
  const glTFAccessor = {
    value: buffer,
    size,
    byteOffset: 0,
    count,
    type: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getAccessorTypeFromSize"])(size),
    componentType: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getComponentTypeFromArray"])(buffer)
  };
  return glTFAccessor;
}

function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;

  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }

  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }

    count = buffer.length / size;
  }

  return {
    buffer,
    size,
    count
  };
}

function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }

  if (Array.isArray(array)) {
    return new ArrayType(array);
  }

  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }

  return array;
}
//# sourceMappingURL=gltf-attribute-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js ***!
  \***********************************************************************************************************/
/*! exports provided: KHR_BINARY_GLTF, KHR_DRACO_MESH_COMPRESSION, KHR_LIGHTS_PUNCTUAL, KHR_MATERIALS_UNLIT, KHR_TECHNIQUES_WEBGL, EXT_MESHOPT_COMPRESSION, getBytesFromComponentType, getSizeFromAccessorType, getGLEnumFromSamplerParameter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_BINARY_GLTF", function() { return KHR_BINARY_GLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return KHR_DRACO_MESH_COMPRESSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_LIGHTS_PUNCTUAL", function() { return KHR_LIGHTS_PUNCTUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_MATERIALS_UNLIT", function() { return KHR_MATERIALS_UNLIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_TECHNIQUES_WEBGL", function() { return KHR_TECHNIQUES_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXT_MESHOPT_COMPRESSION", function() { return EXT_MESHOPT_COMPRESSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBytesFromComponentType", function() { return getBytesFromComponentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeFromAccessorType", function() { return getSizeFromAccessorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLEnumFromSamplerParameter", function() { return getGLEnumFromSamplerParameter; });
const KHR_BINARY_GLTF = 'KHR_binary_glTF';
const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';
const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';
const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';
const KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';
const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';
const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}
function getGLEnumFromSamplerParameter(parameter) {
  const GL_TEXTURE_MAG_FILTER = 0x2800;
  const GL_TEXTURE_MIN_FILTER = 0x2801;
  const GL_TEXTURE_WRAP_S = 0x2802;
  const GL_TEXTURE_WRAP_T = 0x2803;
  const PARAMETER_MAP = {
    magFilter: GL_TEXTURE_MAG_FILTER,
    minFilter: GL_TEXTURE_MIN_FILTER,
    wrapS: GL_TEXTURE_WRAP_S,
    wrapT: GL_TEXTURE_WRAP_T
  };
  return PARAMETER_MAP[parameter];
}
//# sourceMappingURL=gltf-constants.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js ***!
  \*******************************************************************************************************/
/*! exports provided: getAccessorTypeFromSize, getComponentTypeFromArray, getAccessorArrayTypeAndLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorTypeFromSize", function() { return getAccessorTypeFromSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponentTypeFromArray", function() { return getComponentTypeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorArrayTypeAndLength", function() { return getAccessorArrayTypeAndLength; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");

const TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];
const ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
const ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
const ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);

  if (!componentType) {
    throw new Error('Illegal typed array');
  }

  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {
    ArrayType,
    length,
    byteLength
  };
}
//# sourceMappingURL=gltf-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js ***!
  \********************************************************************************************************/
/*! exports provided: resolveUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveUrl", function() { return resolveUrl; });
function resolveUrl(url, options) {
  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');

  if (absolute) {
    return url;
  }

  const baseUrl = options.baseUri || options.uri;

  if (!baseUrl) {
    throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));
  }

  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;
}
//# sourceMappingURL=resolve-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js ***!
  \***************************************************************************************************/
/*! exports provided: isGLB, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLB", function() { return isGLB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");

const MAGIC_glTF = 0x676c5446;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
const GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
const GLB_V1_CONTENT_FORMAT_JSON = 0x0;
const LE = true;

function getMagicString(dataView, byteOffset = 0) {
  return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
}

function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const {
    magic = MAGIC_glTF
  } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LE);
  const byteLength = dataView.getUint32(byteOffset + 8, LE);
  Object.assign(glb, {
    header: {
      byteOffset,
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;

  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);

    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});

    default:
      throw new Error("Invalid GLB version ".concat(glb.version, ". Only supports v1 and v2."));
  }
}

function parseGLBV1(glb, dataView, byteOffset) {
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LE);
  const contentFormat = dataView.getUint32(byteOffset + 4, LE);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}

function parseGLBV2(glb, dataView, byteOffset, options) {
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}

function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LE);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LE);
    byteOffset += GLB_CHUNK_HEADER_SIZE;

    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;

      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;

      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }

        break;

      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }

        break;

      default:
        break;
    }

    byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padToNBytes"])(chunkLength, 4);
  }

  return byteOffset;
}

function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padToNBytes"])(chunkLength, 4);
}

function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
  });
  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padToNBytes"])(chunkLength, 4);
}
//# sourceMappingURL=parse-glb.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js ***!
  \****************************************************************************************************/
/*! exports provided: isGLTF, parseGLTF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLTF", function() { return isGLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLTF", function() { return parseGLTF; });
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/images */ "../../node_modules/@loaders.gl/images/dist/esm/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gltf-utils/resolve-url */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js");
/* harmony import */ var _gltf_utils_get_typed_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gltf-utils/get-typed-array */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js");
/* harmony import */ var _extensions_gltf_extensions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extensions/gltf-extensions */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/gltf-extensions.js");
/* harmony import */ var _api_normalize_gltf_v1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/normalize-gltf-v1 */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js");
/* harmony import */ var _api_post_process_gltf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/post-process-gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js");
/* harmony import */ var _parse_glb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse-glb */ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js");









function isGLTF(arrayBuffer, options) {
  const byteOffset = 0;
  return Object(_parse_glb__WEBPACK_IMPORTED_MODULE_8__["isGLB"])(arrayBuffer, byteOffset, options);
}
async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;

  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  Object(_api_normalize_gltf_v1__WEBPACK_IMPORTED_MODULE_6__["normalizeGLTFV1"])(gltf, {
    normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
  });
  const promises = [];

  if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }

  if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
    const promise = loadImages(gltf, options, context);
    promises.push(promise);
  }

  const promise = Object(_extensions_gltf_extensions__WEBPACK_IMPORTED_MODULE_5__["decodeExtensions"])(gltf, options, context);
  promises.push(promise);
  await Promise.all(promises);
  return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? Object(_api_post_process_gltf__WEBPACK_IMPORTED_MODULE_7__["postProcessGLTF"])(gltf, options) : gltf;
}

function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  if (data instanceof ArrayBuffer && !Object(_parse_glb__WEBPACK_IMPORTED_MODULE_8__["isGLB"])(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  if (typeof data === 'string') {
    gltf.json = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["parseJSON"])(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = Object(_parse_glb__WEBPACK_IMPORTED_MODULE_8__["default"])(glb, data, byteOffset, options.glb);
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(glb.type === 'glTF', "Invalid GLB magic string ".concat(glb.type));
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(false, 'GLTF: must be ArrayBuffer or string');
  }

  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);

  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const {
      binChunks
    } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }

  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}

async function loadBuffers(gltf, options, context) {
  for (let i = 0; i < gltf.json.buffers.length; ++i) {
    const buffer = gltf.json.buffers[i];

    if (buffer.uri) {
      var _context$fetch, _response$arrayBuffer;

      const {
        fetch
      } = context;
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(fetch);
      const uri = Object(_gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__["resolveUrl"])(buffer.uri, options);
      const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
      const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    }
  }
}

async function loadImages(gltf, options, context) {
  const images = gltf.json.images || [];
  const promises = [];

  for (let i = 0; i < images.length; ++i) {
    promises.push(loadImage(gltf, images[i], i, options, context));
  }

  return await Promise.all(promises);
}

async function loadImage(gltf, image, index, options, context) {
  const {
    fetch,
    parse
  } = context;
  let arrayBuffer;

  if (image.uri) {
    const uri = Object(_gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__["resolveUrl"])(image.uri, options);
    const response = await fetch(uri);
    arrayBuffer = await response.arrayBuffer();
  }

  if (Number.isFinite(image.bufferView)) {
    const array = Object(_gltf_utils_get_typed_array__WEBPACK_IMPORTED_MODULE_4__["getTypedArrayForBufferView"])(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["sliceArrayBuffer"])(array.buffer, array.byteOffset, array.byteLength);
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(arrayBuffer, 'glTF image has no data');
  const parsedImage = await parse(arrayBuffer, _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__["ImageLoader"], {}, context);
  gltf.images[index] = parsedImage;
}
//# sourceMappingURL=parse-gltf.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js ***!
  \**********************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'assert failed: gltf');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js ***!
  \***********************************************************************************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
const VERSION =  true ? "3.0.6" : undefined;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/image-loader.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/image-loader.js ***!
  \********************************************************************************************/
/*! exports provided: ImageLoader, _typecheckImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_typecheckImageLoader", function() { return _typecheckImageLoader; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js");
/* harmony import */ var _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/category-api/binary-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js");



const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];
const ImageLoader = {
  id: 'image',
  module: 'images',
  name: 'Images',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"],
  tests: [arrayBuffer => Boolean(Object(_lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMetadata"])(new DataView(arrayBuffer)))],
  options: {
    image: {
      type: 'auto',
      decode: true
    }
  }
};
const _typecheckImageLoader = ImageLoader;
//# sourceMappingURL=image-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/image-writer.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/image-writer.js ***!
  \********************************************************************************************/
/*! exports provided: ImageWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return ImageWriter; });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/encoders/encode-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js");


const ImageWriter = {
  name: 'Images',
  id: 'image',
  module: 'images',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  extensions: ['jpeg'],
  options: {
    image: {
      mimeType: 'image/png',
      jpegQuality: null
    }
  },
  encode: _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_1__["encodeImage"]
};
//# sourceMappingURL=image-writer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/index.js ***!
  \*************************************************************************************/
/*! exports provided: ImageLoader, ImageWriter, getBinaryImageMetadata, isImageTypeSupported, getDefaultImageType, isImage, getImageType, getImageSize, getImageData, loadImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "../../node_modules/@loaders.gl/images/dist/esm/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["ImageLoader"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "../../node_modules/@loaders.gl/images/dist/esm/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["ImageWriter"]; });

/* harmony import */ var _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/category-api/binary-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMetadata", function() { return _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMetadata"]; });

/* harmony import */ var _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/category-api/image-type */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__["isImageTypeSupported"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageType", function() { return _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__["getDefaultImageType"]; });

/* harmony import */ var _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/category-api/parsed-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageData"]; });

/* harmony import */ var _lib_texture_api_load_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/texture-api/load-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_texture_api_load_image__WEBPACK_IMPORTED_MODULE_5__["loadImage"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js ***!
  \*****************************************************************************************************************/
/*! exports provided: getBinaryImageMetadata, getBmpMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMetadata", function() { return getBinaryImageMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBmpMetadata", function() { return getBmpMetadata; });
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}

function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;

  if (!isPng) {
    return null;
  }

  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;

  if (!isGif) {
    return null;
  }

  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;

  if (!isBmp) {
    return null;
  }

  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;

  if (!isJpeg) {
    return null;
  }

  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;

  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }

    if (!tableMarkers.has(marker)) {
      return null;
    }

    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);

  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers,
    sofMarkers
  };
}

function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }

  throw new Error('toDataView');
}
//# sourceMappingURL=binary-image-api.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js ***!
  \***********************************************************************************************************/
/*! exports provided: isImageTypeSupported, getDefaultImageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return isImageTypeSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageType", function() { return getDefaultImageType; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js");

const {
  _parseImageNode
} = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];
const IMAGE_SUPPORTED = typeof Image !== 'undefined';
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;

    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;

    case 'image':
      return IMAGE_SUPPORTED;

    case 'data':
      return DATA_SUPPORTED;

    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }

  if (IMAGE_SUPPORTED) {
    return 'image';
  }

  if (DATA_SUPPORTED) {
    return 'data';
  }

  throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
//# sourceMappingURL=image-type.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js ***!
  \*****************************************************************************************************************/
/*! exports provided: isImage, deleteImage, getImageType, getImageSize, getImageData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteImage", function() { return deleteImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return getImageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return getImageData; });
function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;

    default:
  }
}
function getImageType(image) {
  const format = getImageTypeOrNull(image);

  if (!format) {
    throw new Error('Not an image');
  }

  return format;
}
function getImageSize(image) {
  return getImageData(image);
}
function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;

    case 'image':
    case 'imagebitmap':
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');

      if (!context) {
        throw new Error('getImageData');
      }

      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);

    default:
      throw new Error('getImageData');
  }
}

function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }

  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }

  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }

  return null;
}
//# sourceMappingURL=parsed-image-api.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js ***!
  \*********************************************************************************************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js");


const {
  _encodeImageNode
} = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];
async function encodeImage(image, options) {
  options = options || {};
  options.image = options.image || {};
  return _encodeImageNode ? _encodeImageNode(image, {
    type: options.image.mimeType
  }) : encodeImageInBrowser(image, options);
}
let qualityParamSupported = true;

async function encodeImageInBrowser(image, options) {
  const {
    mimeType,
    jpegQuality
  } = options.image;
  const {
    width,
    height
  } = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_1__["getImageSize"])(image);
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  drawImageToCanvas(image, canvas);
  const blob = await new Promise(resolve => {
    if (jpegQuality && qualityParamSupported) {
      try {
        canvas.toBlob(resolve, mimeType, jpegQuality);
        return;
      } catch (error) {
        qualityParamSupported = false;
      }
    }

    canvas.toBlob(resolve, mimeType);
  });

  if (!blob) {
    throw new Error('image encoding failed');
  }

  return await blob.arrayBuffer();
}

function drawImageToCanvas(image, canvas, x = 0, y = 0) {
  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    const context = canvas.getContext('bitmaprenderer');

    if (context) {
      context.transferFromImageBitmap(image);
      return canvas;
    }
  }

  const context = canvas.getContext('2d');

  if (image.data) {
    const clampedArray = new Uint8ClampedArray(image.data);
    const imageData = new ImageData(clampedArray, image.width, image.height);
    context.putImageData(imageData, 0, 0);
    return canvas;
  }

  context.drawImage(image, 0, 0);
  return canvas;
}
//# sourceMappingURL=encode-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseImage; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js");
/* harmony import */ var _category_api_image_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../category-api/image-type */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-to-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js");
/* harmony import */ var _parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse-to-image-bitmap */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js");
/* harmony import */ var _parse_to_node_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse-to-node-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js");






async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || 'auto';
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;

  switch (loadType) {
    case 'imagebitmap':
      image = await Object(_parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__["default"])(arrayBuffer, options, url);
      break;

    case 'image':
      image = await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_3__["default"])(arrayBuffer, options, url);
      break;

    case 'data':
      image = await Object(_parse_to_node_image__WEBPACK_IMPORTED_MODULE_5__["default"])(arrayBuffer, options);
      break;

    default:
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
  }

  if (imageType === 'data') {
    image = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__["getImageData"])(image);
  }

  return image;
}

function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      return Object(_category_api_image_type__WEBPACK_IMPORTED_MODULE_1__["getDefaultImageType"])();

    default:
      Object(_category_api_image_type__WEBPACK_IMPORTED_MODULE_1__["isImageTypeSupported"])(type);
      return type;
  }
}
//# sourceMappingURL=parse-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImageBitmap; });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-to-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js");


const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;

  if (Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["isSVG"])(url)) {
    const image = await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["getBlob"])(arrayBuffer, url);
  }

  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}

async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }

  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }

  return await createImageBitmap(blob);
}

function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }

  return true;
}
//# sourceMappingURL=parse-to-image-bitmap.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js ***!
  \**********************************************************************************************************/
/*! exports provided: default, loadToImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToImage", function() { return loadToImage; });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js");

async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["getBlobOrSVGDataUrl"])(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);

  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;

  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }

  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);

      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error) {
      reject(error);
    }
  });
}
//# sourceMappingURL=parse-to-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToNodeImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js");
/* harmony import */ var _category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/binary-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js");



function parseToNodeImage(arrayBuffer, options) {
  const {
    mimeType
  } = Object(_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMetadata"])(arrayBuffer) || {};
  const {
    _parseImageNode
  } = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(_parseImageNode);
  return _parseImageNode(arrayBuffer, mimeType, options);
}
//# sourceMappingURL=parse-to-node-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js ***!
  \*****************************************************************************************************/
/*! exports provided: isSVG, getBlobOrSVGDataUrl, getBlob */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSVG", function() { return isSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlobOrSVGDataUrl", function() { return getBlobOrSVGDataUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlob", function() { return getBlob; });
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    const xmlText = textDecoder.decode(arrayBuffer);
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }

  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }

  return new Blob([new Uint8Array(arrayBuffer)]);
}
//# sourceMappingURL=svg-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js":
/*!**************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js ***!
  \**************************************************************************************************************/
/*! exports provided: asyncDeepMap, mapSubtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asyncDeepMap", function() { return asyncDeepMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapSubtree", function() { return mapSubtree; });
const isObject = value => value && typeof value === 'object';

async function asyncDeepMap(tree, func, options = {}) {
  return await mapSubtree(tree, func, options);
}
async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }

  if (isObject(object)) {
    return await mapObject(object, func, options);
  }

  const url = object;
  return await func(url, options);
}

async function mapObject(object, func, options) {
  const promises = [];
  const values = {};

  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }

  await Promise.all(promises);
  return values;
}

async function mapArray(urlArray, func, options = {}) {
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}
//# sourceMappingURL=async-deep-map.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js ***!
  \*********************************************************************************************************/
/*! exports provided: deepLoad, shallowLoad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepLoad", function() { return deepLoad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowLoad", function() { return shallowLoad; });
/* harmony import */ var _async_deep_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async-deep-map */ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js");

async function deepLoad(urlTree, load, options) {
  return await Object(_async_deep_map__WEBPACK_IMPORTED_MODULE_0__["asyncDeepMap"])(urlTree, url => shallowLoad(url, load, options));
}
async function shallowLoad(url, load, options) {
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}
//# sourceMappingURL=deep-load.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js ***!
  \************************************************************************************************************/
/*! exports provided: generateUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUrl", function() { return generateUrl; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js");


function generateUrl(getUrl, options, urlOptions) {
  let url = getUrl;

  if (typeof getUrl === 'function') {
    url = getUrl({ ...options,
      ...urlOptions
    });
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof url === 'string');
  const {
    baseUrl
  } = options;

  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? "".concat(baseUrl).concat(url) : "".concat(baseUrl, "/").concat(url);
  }

  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["resolvePath"])(url);
}
//# sourceMappingURL=generate-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js ***!
  \**********************************************************************************************************/
/*! exports provided: loadImage, getImageUrls, getMipLevels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageUrls", function() { return getImageUrls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMipLevels", function() { return getMipLevels; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js");
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/parse-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js");
/* harmony import */ var _generate_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generate-url */ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deep-load */ "../../node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js");





async function loadImage(getUrl, options = {}) {
  const imageUrls = await getImageUrls(getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["deepLoad"])(imageUrls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);
}
async function getImageUrls(getUrl, options, urlOptions = {}) {
  const mipLevels = options && options.image && options.image.mipLevels || 0;
  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, urlOptions);
}

async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];

  if (mipLevels === 'auto') {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, { ...urlOptions,
      lod: 0
    });
    const image = await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["shallowLoad"])(url, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);
    const {
      width,
      height
    } = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__["getImageSize"])(image);
    mipLevels = getMipLevels({
      width,
      height
    });
    urls.push(url);
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(mipLevels > 0);

  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, { ...urlOptions,
      lod: mipLevel
    });
    urls.push(url);
  }

  return urls;
}

function getMipLevels({
  width,
  height
}) {
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}
//# sourceMappingURL=load-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js ***!
  \************************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js ***!
  \*************************************************************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};

const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;
const isWorker = typeof importScripts === 'function';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js ***!
  \*************************************************************************************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
const VERSION =  true ? "3.0.6" : undefined;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/index.js ***!
  \*******************************************************************************************/
/*! exports provided: assert, isBrowser, isWorker, nodeVersion, self, window, global, document, createLoaderWorker, parseWithWorker, canParseWithWorker, parseJSON, toArrayBuffer, sliceArrayBuffer, concatenateArrayBuffers, concatenateTypedArrays, compareArrayBuffers, padToNBytes, copyToArray, copyArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, getFirstCharacters, getMagicString, makeTextEncoderIterator, makeTextDecoderIterator, makeLineIterator, makeNumberedLineIterator, forEach, concatenateArrayBuffersAsync, RequestScheduler, path, setPathPrefix, getPathPrefix, resolvePath, _addAliases, fs, isBuffer, toBuffer, bufferToArrayBuffer, JSONLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/env-utils/assert */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"]; });

/* harmony import */ var _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env-utils/globals */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["nodeVersion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony import */ var _lib_worker_loader_utils_create_loader_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/worker-loader-utils/create-loader-worker */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createLoaderWorker", function() { return _lib_worker_loader_utils_create_loader_worker__WEBPACK_IMPORTED_MODULE_2__["createLoaderWorker"]; });

/* harmony import */ var _lib_worker_loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/worker-loader-utils/parse-with-worker */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseWithWorker", function() { return _lib_worker_loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_3__["parseWithWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canParseWithWorker", function() { return _lib_worker_loader_utils_parse_with_worker__WEBPACK_IMPORTED_MODULE_3__["canParseWithWorker"]; });

/* harmony import */ var _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/parser-utils/parse-json */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_4__["parseJSON"]; });

/* harmony import */ var _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/binary-utils/array-buffer-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["toArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["sliceArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["concatenateArrayBuffers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateTypedArrays", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["concatenateTypedArrays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_5__["compareArrayBuffers"]; });

/* harmony import */ var _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/binary-utils/memory-copy-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padToNBytes", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_6__["padToNBytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_6__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_6__["copyArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/binary-utils/binary-copy-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_7__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_7__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/binary-utils/encode-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_8__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_8__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_8__["copyBinaryToDataView"]; });

/* harmony import */ var _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/binary-utils/get-first-characters */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_9__["getFirstCharacters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_9__["getMagicString"]; });

/* harmony import */ var _lib_iterators_text_iterators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/iterators/text-iterators */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return _lib_iterators_text_iterators__WEBPACK_IMPORTED_MODULE_10__["makeTextEncoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return _lib_iterators_text_iterators__WEBPACK_IMPORTED_MODULE_10__["makeTextDecoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return _lib_iterators_text_iterators__WEBPACK_IMPORTED_MODULE_10__["makeLineIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return _lib_iterators_text_iterators__WEBPACK_IMPORTED_MODULE_10__["makeNumberedLineIterator"]; });

/* harmony import */ var _lib_iterators_async_iteration__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/iterators/async-iteration */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _lib_iterators_async_iteration__WEBPACK_IMPORTED_MODULE_11__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffersAsync", function() { return _lib_iterators_async_iteration__WEBPACK_IMPORTED_MODULE_11__["concatenateArrayBuffersAsync"]; });

/* harmony import */ var _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/request-utils/request-scheduler */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RequestScheduler", function() { return _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/path-utils/path */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/path-utils/file-aliases */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_14__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_14__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_14__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_addAliases", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_14__["addAliases"]; });

/* harmony import */ var _lib_node_fs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/node/fs */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "fs", function() { return _lib_node_fs__WEBPACK_IMPORTED_MODULE_15__; });
/* harmony import */ var _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/binary-utils/buffer-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_16__["isBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_16__["toBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_16__["bufferToArrayBuffer"]; });

/* harmony import */ var _json_loader__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./json-loader */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return _json_loader__WEBPACK_IMPORTED_MODULE_17__["JSONLoader"]; });






















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js ***!
  \*************************************************************************************************/
/*! exports provided: JSONLoader, _typecheckJSONLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_typecheckJSONLoader", function() { return _typecheckJSONLoader; });
const VERSION =  true ? "3.0.6" : undefined;
const JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync,
  parse: async arrayBuffer => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};

function parseTextSync(text) {
  return JSON.parse(text);
}

const _typecheckJSONLoader = JSONLoader;
//# sourceMappingURL=json-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js ***!
  \*************************************************************************************************************************/
/*! exports provided: toArrayBuffer, compareArrayBuffers, concatenateArrayBuffers, concatenateTypedArrays, sliceArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return compareArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateTypedArrays", function() { return concatenateTypedArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return sliceArrayBuffer; });
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer-utils.node */ 3);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__);

function toArrayBuffer(data) {
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"]) {
    data = _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"](data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  throw new Error('toArrayBuffer');
}
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;

  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }

  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);

  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}
function concatenateArrayBuffers(...sources) {
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;

  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }

  return result.buffer;
}
function concatenateTypedArrays(...typedArrays) {
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;

  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }

  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;

  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }

  return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
//# sourceMappingURL=array-buffer-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js":
/*!************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js ***!
  \************************************************************************************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padToNBytes"])(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}
function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}
//# sourceMappingURL=binary-copy-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js ***!
  \*******************************************************************************************************************/
/*! exports provided: isBuffer, toBuffer, bufferToArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return toBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return bufferToArrayBuffer; });
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer-utils.node */ 3);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__);

function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
  return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"] ? _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"](data) : data;
}
function bufferToArrayBuffer(data) {
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"]) {
    return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"](data);
  }

  return data;
}
//# sourceMappingURL=buffer-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js ***!
  \*******************************************************************************************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  const padding = paddedLength - length;
  let whitespace = '';

  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}
function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}
function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }

  return byteOffset + byteLength;
}
//# sourceMappingURL=encode-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js ***!
  \***************************************************************************************************************************/
/*! exports provided: getFirstCharacters, getMagicString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return getFirstCharacters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return getMagicString; });
function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  const dataView = new DataView(arrayBuffer);
  let magic = '';

  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}
//# sourceMappingURL=get-first-characters.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js":
/*!************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js ***!
  \************************************************************************************************************************/
/*! exports provided: padToNBytes, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padToNBytes", function() { return padToNBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js");

function padToNBytes(byteLength, padding) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(byteLength >= 0);
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset, byteLength = sourceBuffer.byteLength) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
//# sourceMappingURL=memory-copy-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js ***!
  \**********************************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js ***!
  \***********************************************************************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;
const isWorker = typeof importScripts === 'function';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js ***!
  \*******************************************************************************************************************/
/*! exports provided: forEach, concatenateArrayBuffersAsync, concatenateStringsAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffersAsync", function() { return concatenateArrayBuffersAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateStringsAsync", function() { return concatenateStringsAsync; });
/* harmony import */ var _binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/array-buffer-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js");

async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();

    if (done) {
      iterator.return();
      return;
    }

    const cancel = visitor(value);

    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];

  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }

  return Object(_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
  const strings = [];

  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }

  return strings.join('');
}
//# sourceMappingURL=async-iteration.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js ***!
  \******************************************************************************************************************/
/*! exports provided: makeTextDecoderIterator, makeTextEncoderIterator, makeLineIterator, makeNumberedLineIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return makeTextDecoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return makeTextEncoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return makeLineIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return makeNumberedLineIterator; });
async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {
  const textDecoder = new TextDecoder(undefined, options);

  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
      stream: true
    });
  }
}
async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();

  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}
async function* makeLineIterator(textIterator) {
  let previous = '';

  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;

    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;

  for await (const line of lineIterator) {
    yield {
      counter,
      line
    };
    counter++;
  }
}
//# sourceMappingURL=text-iterators.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js ***!
  \*************************************************************************************************/
/*! exports provided: isSupported, open, close, read, readFile, readFileSync, writeFile, writeFileSync, _readToArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupported", function() { return isSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "open", function() { return open; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "close", function() { return close; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "read", function() { return read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFile", function() { return readFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_readToArrayBuffer", function() { return _readToArrayBuffer; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 4);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer-utils.node */ 5);
/* harmony import */ var _buffer_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ "../../node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);




const error = fsFunction => () => {
  throw new Error("".concat(fsFunction, " not available in browser"));
};

const isSupported = Boolean(fs__WEBPACK_IMPORTED_MODULE_0___default.a);
const open = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.open ? Object(util__WEBPACK_IMPORTED_MODULE_2__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.open) : error('fs.open');
const close = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.close ? Object(util__WEBPACK_IMPORTED_MODULE_2__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.close) : error('fs.close');
const read = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.read ? Object(util__WEBPACK_IMPORTED_MODULE_2__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.read) : error('fs.read');
const readFile = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFile ? Object(util__WEBPACK_IMPORTED_MODULE_2__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFile) : error('fs.readFile');
const readFileSync = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync ? fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync : error('fs.readFileSync');
const writeFile = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFile ? Object(util__WEBPACK_IMPORTED_MODULE_2__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFile) : error('fs.writeFile');
const writeFileSync = fs__WEBPACK_IMPORTED_MODULE_0___default.a !== null && fs__WEBPACK_IMPORTED_MODULE_0___default.a !== void 0 && fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync ? fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync : error('fs.writeFileSync');
async function _readToArrayBuffer(fd, start, length) {
  const buffer = Buffer.alloc(length);
  const {
    bytesRead
  } = await read(fd, buffer, 0, length, start);

  if (bytesRead !== length) {
    throw new Error('fs.read failed');
  }

  return Object(_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"])(buffer);
}
//# sourceMappingURL=fs.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js ***!
  \*****************************************************************************************************************/
/*! exports provided: parseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return parseJSON; });
/* harmony import */ var _binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/get-first-characters */ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js");

function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat(Object(_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__["getFirstCharacters"])(string), "\""));
  }
}
//# sourceMappingURL=parse-json.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js ***!
  \*****************************************************************************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }

  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }

  return filename;
}
//# sourceMappingURL=file-aliases.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js ***!
  \*********************************************************************************************************/
/*! exports provided: dirname, join */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirname", function() { return dirname; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "join", function() { return join; });
function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join(...parts) {
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }

    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }

    return part;
  });
  return parts.join(separator);
}
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RequestScheduler; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/stats */ "../../node_modules/@probe.gl/stats/dist/esm/index.js");


const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};
class RequestScheduler {
  constructor(props = {}) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "stats", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "activeRequestCount", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "requestQueue", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "requestMap", new Map());

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "deferredUpdate", null);

    this.props = { ...DEFAULT_PROPS,
      ...props
    };
    this.stats = new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__["Stats"]({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  scheduleRequest(handle, getPriority = () => 0) {
    if (!this.props.throttleRequests) {
      return Promise.resolve({
        done: () => {}
      });
    }

    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }

    const request = {
      handle,
      priority: 0,
      getPriority
    };
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);

    this._issueNewRequests();

    return promise;
  }

  _issueRequest(request) {
    const {
      handle,
      resolve
    } = request;
    let isDone = false;

    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;

        this._issueNewRequests();
      }
    };

    this.activeRequestCount++;
    return resolve ? resolve({
      done
    }) : Promise.resolve({
      done
    });
  }

  _issueNewRequests() {
    if (!this.deferredUpdate) {
      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }

  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

    if (freeSlots === 0) {
      return;
    }

    this._updateAllRequests();

    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();

      if (request) {
        this._issueRequest(request);
      }
    }
  }

  _updateAllRequests() {
    const requestQueue = this.requestQueue;

    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];

      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }

    requestQueue.sort((a, b) => a.priority - b.priority);
  }

  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);

    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }

    return true;
  }

}
//# sourceMappingURL=request-scheduler.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js ***!
  \**********************************************************************************************************************************/
/*! exports provided: createLoaderWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLoaderWorker", function() { return createLoaderWorker; });
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/index.js");

let requestId = 0;
function createLoaderWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].onmessage = async (type, payload) => {
    switch (type) {
      case 'process':
        try {
          const {
            input,
            options = {}
          } = payload;
          const result = await parseData({
            loader,
            arrayBuffer: input,
            options,
            context: {
              parse: parseOnMainThread
            }
          });
          _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].postMessage('done', {
            result
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : '';
          _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].postMessage('error', {
            error: message
          });
        }

        break;

      default:
    }
  };
}

function parseOnMainThread(arrayBuffer, options) {
  return new Promise((resolve, reject) => {
    const id = requestId++;

    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].removeEventListener(onMessage);
          resolve(payload.result);
          break;

        case 'error':
          _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].removeEventListener(onMessage);
          reject(payload.error);
          break;

        default:
      }
    };

    _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerBody"].postMessage('process', payload);
  });
}

async function parseData({
  loader,
  arrayBuffer,
  options,
  context
}) {
  let data;
  let parser;

  if (loader.parseSync || loader.parse) {
    data = arrayBuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arrayBuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error("Could not load data with ".concat(loader.name, " loader"));
  }

  options = { ...options,
    modules: loader && loader.options && loader.options.modules || {},
    worker: false
  };
  return await parser(data, { ...options
  }, context, loader);
}
//# sourceMappingURL=create-loader-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: canParseWithWorker, parseWithWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParseWithWorker", function() { return canParseWithWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithWorker", function() { return parseWithWorker; });
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/index.js");

function canParseWithWorker(loader, options) {
  if (!_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerFarm"].isSupported()) {
    return false;
  }

  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = Object(_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["getWorkerURL"])(loader, options);
  const workerFarm = _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["WorkerFarm"].getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options
  });
  const result = await job.result;
  return await result.result;
}

async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;

    case 'error':
      job.error(payload.error);
      break;

    case 'process':
      const {
        id,
        input,
        options
      } = payload;

      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }

      break;

    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}
//# sourceMappingURL=parse-with-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js ***!
  \********************************************************************************************************/
/*! exports provided: getMeshSize, getMeshBoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return getMeshBoundingBox; });
function getMeshSize(attributes) {
  let size = 0;

  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;

  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }

  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}
//# sourceMappingURL=mesh-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/index.js ***!
  \*************************************************************************************/
/*! exports provided: TableBatchBuilder, RowTableBatchAggregator, ColumnarTableBatchAggregator, convertToObjectRow, convertToArrayRow, getMeshSize, getMeshBoundingBox, Schema, Field, DataType, Null, Binary, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeMillisecond, TimeSecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList, deduceTableSchema, getTypeInfo, getArrowTypeFromTypedArray, AsyncQueue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/table/table-batch-builder */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/table-batch-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TableBatchBuilder", function() { return _lib_table_table_batch_builder__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_table_row_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/table/row-table-batch-aggregator */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/row-table-batch-aggregator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RowTableBatchAggregator", function() { return _lib_table_row_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_table_columnar_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/table/columnar-table-batch-aggregator */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/columnar-table-batch-aggregator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnarTableBatchAggregator", function() { return _lib_table_columnar_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _lib_utils_row_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/utils/row-utils */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToObjectRow", function() { return _lib_utils_row_utils__WEBPACK_IMPORTED_MODULE_3__["convertToObjectRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToArrayRow", function() { return _lib_utils_row_utils__WEBPACK_IMPORTED_MODULE_3__["convertToArrayRow"]; });

/* harmony import */ var _category_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./category/mesh/mesh-utils */ "../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return _category_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__["getMeshSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return _category_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_4__["getMeshBoundingBox"]; });

/* harmony import */ var _lib_schema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/schema */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Schema", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Schema"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Field"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["DataType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Null"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Binary", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Binary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Bool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Int"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Int8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Int16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Int32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Int64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Uint8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Uint16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Uint32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Uint64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Float"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Float16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Float32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Float64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Utf8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Date"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["DateDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["DateMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Timestamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimestampSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimestampMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimestampMicrosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["TimestampNanosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["Interval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["IntervalDayTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["IntervalYearMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return _lib_schema__WEBPACK_IMPORTED_MODULE_5__["FixedSizeList"]; });

/* harmony import */ var _lib_schema_utils_deduce_table_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/schema-utils/deduce-table-schema */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/deduce-table-schema.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return _lib_schema_utils_deduce_table_schema__WEBPACK_IMPORTED_MODULE_6__["deduceTableSchema"]; });

/* harmony import */ var _lib_schema_utils_get_type_info__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/schema-utils/get-type-info */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/get-type-info.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return _lib_schema_utils_get_type_info__WEBPACK_IMPORTED_MODULE_7__["getTypeInfo"]; });

/* harmony import */ var _lib_schema_utils_type_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/schema-utils/type-utils */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/type-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getArrowTypeFromTypedArray", function() { return _lib_schema_utils_type_utils__WEBPACK_IMPORTED_MODULE_8__["getArrowTypeFromTypedArray"]; });

/* harmony import */ var _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/utils/async-queue */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncQueue", function() { return _lib_utils_async_queue__WEBPACK_IMPORTED_MODULE_9__["default"]; });











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/deduce-table-schema.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/deduce-table-schema.js ***!
  \********************************************************************************************************************/
/*! exports provided: deduceTableSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deduceTableSchema", function() { return deduceTableSchema; });
function deduceTableSchema(table, schema) {
  const deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  const schema = {};

  for (const field in columnarTable) {
    const column = columnarTable[field];

    if (ArrayBuffer.isView(column)) {
      schema[field] = column.constructor;
    } else if (column.length) {
      const value = column[0];
      schema[field] = deduceTypeFromValue(value);
    }

    schema[field] = schema[field] || null;
  }

  return schema;
}

function deduceSchemaForRowTable(rowTable) {
  const schema = {};

  if (rowTable.length) {
    const row = rowTable[0];

    for (const field in row) {
      const value = row[field];
      schema[field] = deduceTypeFromValue(value);
    }
  }

  return schema;
}

function deduceTypeFromValue(value) {
  if (value instanceof Date) {
    return Date;
  } else if (value instanceof Number) {
    return Float32Array;
  } else if (typeof value === 'string') {
    return String;
  }

  return null;
}
//# sourceMappingURL=deduce-table-schema.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/get-type-info.js":
/*!**************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/get-type-info.js ***!
  \**************************************************************************************************************/
/*! exports provided: getTypeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypeInfo", function() { return getTypeInfo; });
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../schema */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/index.js");

function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}
let ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};

    for (const key in _schema__WEBPACK_IMPORTED_MODULE_0__["Type"]) {
      ReverseType[_schema__WEBPACK_IMPORTED_MODULE_0__["Type"][key]] = key;
    }
  }

  return ReverseType[typeKey];
}
//# sourceMappingURL=get-type-info.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/type-utils.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/type-utils.js ***!
  \***********************************************************************************************************/
/*! exports provided: getArrowTypeFromTypedArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrowTypeFromTypedArray", function() { return getArrowTypeFromTypedArray; });
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../schema */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/index.js");

function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Int8"]();

    case Uint8Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Uint8"]();

    case Int16Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Int16"]();

    case Uint16Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Uint16"]();

    case Int32Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Int32"]();

    case Uint32Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Uint32"]();

    case Float32Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Float32"]();

    case Float64Array:
      return new _schema__WEBPACK_IMPORTED_MODULE_0__["Float64"]();

    default:
      throw new Error('array type not supported');
  }
}
//# sourceMappingURL=type-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js ***!
  \****************************************************************************************************/
/*! exports provided: Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
let Type;

(function (Type) {
  Type[Type["NONE"] = 0] = "NONE";
  Type[Type["Null"] = 1] = "Null";
  Type[Type["Int"] = 2] = "Int";
  Type[Type["Float"] = 3] = "Float";
  Type[Type["Binary"] = 4] = "Binary";
  Type[Type["Utf8"] = 5] = "Utf8";
  Type[Type["Bool"] = 6] = "Bool";
  Type[Type["Decimal"] = 7] = "Decimal";
  Type[Type["Date"] = 8] = "Date";
  Type[Type["Time"] = 9] = "Time";
  Type[Type["Timestamp"] = 10] = "Timestamp";
  Type[Type["Interval"] = 11] = "Interval";
  Type[Type["List"] = 12] = "List";
  Type[Type["Struct"] = 13] = "Struct";
  Type[Type["Union"] = 14] = "Union";
  Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
  Type[Type["Map"] = 17] = "Map";
  Type[Type["Dictionary"] = -1] = "Dictionary";
  Type[Type["Int8"] = -2] = "Int8";
  Type[Type["Int16"] = -3] = "Int16";
  Type[Type["Int32"] = -4] = "Int32";
  Type[Type["Int64"] = -5] = "Int64";
  Type[Type["Uint8"] = -6] = "Uint8";
  Type[Type["Uint16"] = -7] = "Uint16";
  Type[Type["Uint32"] = -8] = "Uint32";
  Type[Type["Uint64"] = -9] = "Uint64";
  Type[Type["Float16"] = -10] = "Float16";
  Type[Type["Float32"] = -11] = "Float32";
  Type[Type["Float64"] = -12] = "Float64";
  Type[Type["DateDay"] = -13] = "DateDay";
  Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
  Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
  Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type[Type["TimeSecond"] = -19] = "TimeSecond";
  Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type[Type["DenseUnion"] = -23] = "DenseUnion";
  Type[Type["SparseUnion"] = -24] = "SparseUnion";
  Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (Type = {}));
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class Field {
  constructor(name, type, nullable = false, metadata = new Map()) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "name", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "nullable", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "metadata", void 0);

    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  get typeId() {
    return this.type && this.type.typeId;
  }

  clone() {
    return new Field(this.name, this.type, this.nullable, this.metadata);
  }

  compareTo(other) {
    return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
  }

  toString() {
    return "".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? ", metadata: ".concat(this.metadata) : '');
  }

}
//# sourceMappingURL=field.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Schema; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js");


class Schema {
  constructor(fields, metadata) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "fields", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "metadata", void 0);

    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(Array.isArray(fields));
    checkNames(fields);
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  compareTo(other) {
    if (this.metadata !== other.metadata) {
      return false;
    }

    if (this.fields.length !== other.fields.length) {
      return false;
    }

    for (let i = 0; i < this.fields.length; ++i) {
      if (!this.fields[i].compareTo(other.fields[i])) {
        return false;
      }
    }

    return true;
  }

  select(...columnNames) {
    const nameMap = Object.create(null);

    for (const name of columnNames) {
      nameMap[name] = true;
    }

    const selectedFields = this.fields.filter(field => nameMap[field.name]);
    return new Schema(selectedFields, this.metadata);
  }

  selectAt(...columnIndices) {
    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);
    return new Schema(selectedFields, this.metadata);
  }

  assign(schemaOrFields) {
    let fields;
    let metadata = this.metadata;

    if (schemaOrFields instanceof Schema) {
      const otherSchema = schemaOrFields;
      fields = otherSchema.fields;
      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
    } else {
      fields = schemaOrFields;
    }

    const fieldMap = Object.create(null);

    for (const field of this.fields) {
      fieldMap[field.name] = field;
    }

    for (const field of fields) {
      fieldMap[field.name] = field;
    }

    const mergedFields = Object.values(fieldMap);
    return new Schema(mergedFields, metadata);
  }

}

function checkNames(fields) {
  const usedNames = {};

  for (const field of fields) {
    if (usedNames[field.name]) {
      console.warn('Schema: duplicated field name', field.name, field);
    }

    usedNames[field.name] = true;
  }
}

function mergeMaps(m1, m2) {
  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}
//# sourceMappingURL=schema.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js ***!
  \****************************************************************************************************/
/*! exports provided: Type, DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Binary, Utf8, Date, DateDay, DateMillisecond, Time, TimeSecond, TimeMillisecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return DataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return Null; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return Bool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return Int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return Int8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return Int16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return Int32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return Int64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return Uint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return Uint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return Uint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return Uint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return Float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return Float16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return Float32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return Float64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Binary", function() { return Binary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return Utf8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return Date; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return DateDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return DateMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return Time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return TimeSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return TimeMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return Timestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return TimestampSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return TimestampMillisecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return TimestampMicrosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return TimestampNanosecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return Interval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return IntervalDayTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return IntervalYearMonth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return FixedSizeList; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _enum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enum */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"]; });



let _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7;



class DataType {
  static isNull(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Null;
  }

  static isInt(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Int;
  }

  static isFloat(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Float;
  }

  static isBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Binary;
  }

  static isUtf8(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Utf8;
  }

  static isBool(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Bool;
  }

  static isDecimal(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Decimal;
  }

  static isDate(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Date;
  }

  static isTime(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Time;
  }

  static isTimestamp(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Timestamp;
  }

  static isInterval(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Interval;
  }

  static isList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].List;
  }

  static isStruct(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Struct;
  }

  static isUnion(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Union;
  }

  static isFixedSizeBinary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].FixedSizeBinary;
  }

  static isFixedSizeList(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].FixedSizeList;
  }

  static isMap(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Map;
  }

  static isDictionary(x) {
    return x && x.typeId === _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Dictionary;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].NONE;
  }

  compareTo(other) {
    return this === other;
  }

}
class Null extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Null;
  }

  get [Symbol.toStringTag]() {
    return 'Null';
  }

  toString() {
    return 'Null';
  }

}
class Bool extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Bool;
  }

  get [Symbol.toStringTag]() {
    return 'Bool';
  }

  toString() {
    return 'Bool';
  }

}
_Symbol$toStringTag = Symbol.toStringTag;
class Int extends DataType {
  constructor(isSigned, bitWidth) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isSigned", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "bitWidth", void 0);

    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Int;
  }

  get [_Symbol$toStringTag]() {
    return 'Int';
  }

  toString() {
    return "".concat(this.isSigned ? 'I' : 'Ui', "nt").concat(this.bitWidth);
  }

}
class Int8 extends Int {
  constructor() {
    super(true, 8);
  }

}
class Int16 extends Int {
  constructor() {
    super(true, 16);
  }

}
class Int32 extends Int {
  constructor() {
    super(true, 32);
  }

}
class Int64 extends Int {
  constructor() {
    super(true, 64);
  }

}
class Uint8 extends Int {
  constructor() {
    super(false, 8);
  }

}
class Uint16 extends Int {
  constructor() {
    super(false, 16);
  }

}
class Uint32 extends Int {
  constructor() {
    super(false, 32);
  }

}
class Uint64 extends Int {
  constructor() {
    super(false, 64);
  }

}
const Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
_Symbol$toStringTag2 = Symbol.toStringTag;
class Float extends DataType {
  constructor(precision) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "precision", void 0);

    this.precision = precision;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Float;
  }

  get [_Symbol$toStringTag2]() {
    return 'Float';
  }

  toString() {
    return "Float".concat(this.precision);
  }

}
class Float16 extends Float {
  constructor() {
    super(Precision.HALF);
  }

}
class Float32 extends Float {
  constructor() {
    super(Precision.SINGLE);
  }

}
class Float64 extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }

}
class Binary extends DataType {
  constructor() {
    super();
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Binary;
  }

  toString() {
    return 'Binary';
  }

  get [Symbol.toStringTag]() {
    return 'Binary';
  }

}
class Utf8 extends DataType {
  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Utf8;
  }

  get [Symbol.toStringTag]() {
    return 'Utf8';
  }

  toString() {
    return 'Utf8';
  }

}
const DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
_Symbol$toStringTag3 = Symbol.toStringTag;
class Date extends DataType {
  constructor(unit) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "unit", void 0);

    this.unit = unit;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Date;
  }

  get [_Symbol$toStringTag3]() {
    return 'Date';
  }

  toString() {
    return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
  }

}
class DateDay extends Date {
  constructor() {
    super(DateUnit.DAY);
  }

}
class DateMillisecond extends Date {
  constructor() {
    super(DateUnit.MILLISECOND);
  }

}
const TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
_Symbol$toStringTag4 = Symbol.toStringTag;
class Time extends DataType {
  constructor(unit, bitWidth) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "unit", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "bitWidth", void 0);

    this.unit = unit;
    this.bitWidth = bitWidth;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Time;
  }

  toString() {
    return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
  }

  get [_Symbol$toStringTag4]() {
    return 'Time';
  }

}
class TimeSecond extends Time {
  constructor() {
    super(TimeUnit.SECOND, 32);
  }

}
class TimeMillisecond extends Time {
  constructor() {
    super(TimeUnit.MILLISECOND, 32);
  }

}
_Symbol$toStringTag5 = Symbol.toStringTag;
class Timestamp extends DataType {
  constructor(unit, timezone = null) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "unit", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "timezone", void 0);

    this.unit = unit;
    this.timezone = timezone;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Timestamp;
  }

  get [_Symbol$toStringTag5]() {
    return 'Timestamp';
  }

  toString() {
    return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : '', ">");
  }

}
class TimestampSecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.SECOND, timezone);
  }

}
class TimestampMillisecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MILLISECOND, timezone);
  }

}
class TimestampMicrosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.MICROSECOND, timezone);
  }

}
class TimestampNanosecond extends Timestamp {
  constructor(timezone = null) {
    super(TimeUnit.NANOSECOND, timezone);
  }

}
const IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
_Symbol$toStringTag6 = Symbol.toStringTag;
class Interval extends DataType {
  constructor(unit) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "unit", void 0);

    this.unit = unit;
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].Interval;
  }

  get [_Symbol$toStringTag6]() {
    return 'Interval';
  }

  toString() {
    return "Interval<".concat(IntervalUnit[this.unit], ">");
  }

}
class IntervalDayTime extends Interval {
  constructor() {
    super(IntervalUnit.DAY_TIME);
  }

}
class IntervalYearMonth extends Interval {
  constructor() {
    super(IntervalUnit.YEAR_MONTH);
  }

}
_Symbol$toStringTag7 = Symbol.toStringTag;
class FixedSizeList extends DataType {
  constructor(listSize, child) {
    super();

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "listSize", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "children", void 0);

    this.listSize = listSize;
    this.children = [child];
  }

  get typeId() {
    return _enum__WEBPACK_IMPORTED_MODULE_1__["Type"].FixedSizeList;
  }

  get valueType() {
    return this.children[0].type;
  }

  get valueField() {
    return this.children[0];
  }

  get [_Symbol$toStringTag7]() {
    return 'FixedSizeList';
  }

  toString() {
    return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
  }

}
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/index.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/schema/index.js ***!
  \************************************************************************************************/
/*! exports provided: Schema, Field, Type, DataType, Null, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Binary, Utf8, Date, DateDay, DateMillisecond, Time, TimeSecond, TimeMillisecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _impl_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impl/schema */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Schema", function() { return _impl_schema__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _impl_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/field */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return _impl_field__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _impl_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/type */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["DataType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Null"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bool", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Bool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Int"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Int8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Int16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Int32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Int64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Uint8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Uint16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Uint32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Uint64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Float"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float16", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Float16"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Float32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Float64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Binary", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Binary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Utf8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Date", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Date"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateDay", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["DateDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateMillisecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["DateMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeSecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeMillisecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timestamp", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Timestamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampSecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimestampSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMillisecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimestampMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampMicrosecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimestampMicrosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimestampNanosecond", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["TimestampNanosecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["Interval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalDayTime", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["IntervalDayTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalYearMonth", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["IntervalYearMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedSizeList", function() { return _impl_type__WEBPACK_IMPORTED_MODULE_2__["FixedSizeList"]; });





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/base-table-batch-aggregator.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/table/base-table-batch-aggregator.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RowTableBatchAggregator; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");

const DEFAULT_ROW_COUNT = 100;
class RowTableBatchAggregator {
  constructor(schema, options) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "schema", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "options", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "length", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rows", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "cursor", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_headers", []);

    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  rowCount() {
    return this.length;
  }

  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }

  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }

  getBatch() {
    let rows = this.rows;

    if (!rows) {
      return null;
    }

    rows = rows.slice(0, this.length);
    this.rows = null;
    const batch = {
      shape: this.options.shape,
      batchType: 'data',
      data: rows,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    };
    return batch;
  }

}
//# sourceMappingURL=base-table-batch-aggregator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/columnar-table-batch-aggregator.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/table/columnar-table-batch-aggregator.js ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnarTableBatchAggregator; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");

const DEFAULT_ROW_COUNT = 100;
class ColumnarTableBatchAggregator {
  constructor(schema, options) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "schema", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "length", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "allocated", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "columns", {});

    this.schema = schema;

    this._reallocateColumns();
  }

  rowCount() {
    return this.length;
  }

  addArrayRow(row) {
    this._reallocateColumns();

    let i = 0;

    for (const fieldName in this.columns) {
      this.columns[fieldName][this.length] = row[i++];
    }

    this.length++;
  }

  addObjectRow(row) {
    this._reallocateColumns();

    for (const fieldName in row) {
      this.columns[fieldName][this.length] = row[fieldName];
    }

    this.length++;
  }

  getBatch() {
    this._pruneColumns();

    const columns = Array.isArray(this.schema) ? this.columns : {};

    if (!Array.isArray(this.schema)) {
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        columns[field.name] = this.columns[field.index];
      }
    }

    this.columns = {};
    const batch = {
      shape: 'columnar-table',
      batchType: 'data',
      data: columns,
      schema: this.schema,
      length: this.length
    };
    return batch;
  }

  _reallocateColumns() {
    if (this.length < this.allocated) {
      return;
    }

    this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT;
    this.columns = {};

    for (const fieldName in this.schema) {
      const field = this.schema[fieldName];
      const ArrayType = field.type || Float32Array;
      const oldColumn = this.columns[field.index];

      if (oldColumn && ArrayBuffer.isView(oldColumn)) {
        const typedArray = new ArrayType(this.allocated);
        typedArray.set(oldColumn);
        this.columns[field.index] = typedArray;
      } else if (oldColumn) {
        oldColumn.length = this.allocated;
        this.columns[field.index] = oldColumn;
      } else {
        this.columns[field.index] = new ArrayType(this.allocated);
      }
    }
  }

  _pruneColumns() {
    for (const [columnName, column] of Object.entries(this.columns)) {
      this.columns[columnName] = column.slice(0, this.length);
    }
  }

}
//# sourceMappingURL=columnar-table-batch-aggregator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/row-table-batch-aggregator.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/table/row-table-batch-aggregator.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RowTableBatchAggregator; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_row_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/row-utils */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js");


const DEFAULT_ROW_COUNT = 100;
class RowTableBatchAggregator {
  constructor(schema, options) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "schema", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "options", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "length", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "objectRows", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "arrayRows", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "cursor", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_headers", []);

    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  rowCount() {
    return this.length;
  }

  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    switch (this.options.shape) {
      case 'object-row-table':
        const rowObject = Object(_utils_row_utils__WEBPACK_IMPORTED_MODULE_1__["convertToObjectRow"])(row, this._headers);
        this.addObjectRow(rowObject, cursor);
        break;

      case 'array-row-table':
        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);
        this.arrayRows[this.length] = row;
        this.length++;
        break;
    }
  }

  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }

    switch (this.options.shape) {
      case 'array-row-table':
        const rowArray = Object(_utils_row_utils__WEBPACK_IMPORTED_MODULE_1__["convertToArrayRow"])(row, this._headers);
        this.addArrayRow(rowArray, cursor);
        break;

      case 'object-row-table':
        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);
        this.objectRows[this.length] = row;
        this.length++;
        break;
    }
  }

  getBatch() {
    let rows = this.arrayRows || this.objectRows;

    if (!rows) {
      return null;
    }

    rows = rows.slice(0, this.length);
    this.arrayRows = null;
    this.objectRows = null;
    return {
      shape: this.options.shape,
      batchType: 'data',
      data: rows,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    };
  }

}
//# sourceMappingURL=row-table-batch-aggregator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/table-batch-builder.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/table/table-batch-builder.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TableBatchBuilder; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _base_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-table-batch-aggregator */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/base-table-batch-aggregator.js");
/* harmony import */ var _row_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./row-table-batch-aggregator */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/row-table-batch-aggregator.js");
/* harmony import */ var _columnar_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./columnar-table-batch-aggregator */ "../../node_modules/@loaders.gl/schema/dist/esm/lib/table/columnar-table-batch-aggregator.js");




const DEFAULT_OPTIONS = {
  shape: 'array-row-table',
  batchSize: 'auto',
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
const ERR_MESSAGE = 'TableBatchBuilder';
class TableBatchBuilder {
  constructor(schema, options) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "schema", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "options", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "aggregator", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "batchCount", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "bytesUsed", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isChunkComplete", false);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "lastBatchEmittedMs", Date.now());

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "totalLength", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "totalBytes", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "rowBytes", 0);

    this.schema = schema;
    this.options = { ...DEFAULT_OPTIONS,
      ...options
    };
  }

  limitReached() {
    var _this$options, _this$options2;

    if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
      return true;
    }

    if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
      return true;
    }

    return false;
  }

  addRow(row) {
    if (this.limitReached()) {
      return;
    }

    this.totalLength++;
    this.rowBytes = this.rowBytes || this._estimateRowMB(row);
    this.totalBytes += this.rowBytes;

    if (Array.isArray(row)) {
      this.addArrayRow(row);
    } else {
      this.addObjectRow(row);
    }
  }

  addArrayRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();

      this.aggregator = new TableBatchType(this.schema, this.options);
    }

    this.aggregator.addArrayRow(row);
  }

  addObjectRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();

      this.aggregator = new TableBatchType(this.schema, this.options);
    }

    this.aggregator.addObjectRow(row);
  }

  chunkComplete(chunk) {
    if (chunk instanceof ArrayBuffer) {
      this.bytesUsed += chunk.byteLength;
    }

    if (typeof chunk === 'string') {
      this.bytesUsed += chunk.length;
    }

    this.isChunkComplete = true;
  }

  getFullBatch(options) {
    return this._isFull() ? this._getBatch(options) : null;
  }

  getFinalBatch(options) {
    return this._getBatch(options);
  }

  _estimateRowMB(row) {
    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
  }

  _isFull() {
    if (!this.aggregator || this.aggregator.rowCount() === 0) {
      return false;
    }

    if (this.options.batchSize === 'auto') {
      if (!this.isChunkComplete) {
        return false;
      }
    } else if (this.options.batchSize > this.aggregator.rowCount()) {
      return false;
    }

    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
      return false;
    }

    this.isChunkComplete = false;
    this.lastBatchEmittedMs = Date.now();
    return true;
  }

  _getBatch(options) {
    if (!this.aggregator) {
      return null;
    }

    if (options !== null && options !== void 0 && options.bytesUsed) {
      this.bytesUsed = options.bytesUsed;
    }

    const normalizedBatch = this.aggregator.getBatch();
    normalizedBatch.count = this.batchCount;
    normalizedBatch.bytesUsed = this.bytesUsed;
    Object.assign(normalizedBatch, options);
    this.batchCount++;
    this.aggregator = null;
    return normalizedBatch;
  }

  _getTableBatchType() {
    switch (this.options.shape) {
      case 'row-table':
        return _base_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_1__["default"];

      case 'array-row-table':
      case 'object-row-table':
        return _row_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_2__["default"];

      case 'columnar-table':
        return _columnar_table_batch_aggregator__WEBPACK_IMPORTED_MODULE_3__["default"];

      case 'arrow-table':
        if (!TableBatchBuilder.ArrowBatch) {
          throw new Error(ERR_MESSAGE);
        }

        return TableBatchBuilder.ArrowBatch;

      default:
        throw new Error(ERR_MESSAGE);
    }
  }

}

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(TableBatchBuilder, "ArrowBatch", void 0);
//# sourceMappingURL=table-batch-builder.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js ***!
  \************************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js ***!
  \*****************************************************************************************************/
/*! exports provided: default, takeAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncQueue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeAsync", function() { return takeAsync; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");


let _Symbol$asyncIterator;

class ArrayQueue extends Array {
  enqueue(value) {
    return this.push(value);
  }

  dequeue() {
    return this.shift();
  }

}

_Symbol$asyncIterator = Symbol.asyncIterator;
class AsyncQueue {
  constructor() {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_values", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_settlers", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_closed", void 0);

    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  close() {
    while (this._settlers.length > 0) {
      this._settlers.dequeue().resolve({
        done: true
      });
    }

    this._closed = true;
  }

  [_Symbol$asyncIterator]() {
    return this;
  }

  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }

    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }

      const settler = this._settlers.dequeue();

      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.enqueue(value);
    }
  }

  next() {
    if (this._values.length > 0) {
      const value = this._values.dequeue();

      if (value instanceof Error) {
        return Promise.reject(value);
      }

      return Promise.resolve({
        value
      });
    }

    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }

      return Promise.resolve({
        done: true
      });
    }

    return new Promise((resolve, reject) => {
      this._settlers.enqueue({
        resolve,
        reject
      });
    });
  }

}
async function takeAsync(asyncIterable, count = Infinity) {
  const result = [];
  const iterator = asyncIterable[Symbol.asyncIterator]();

  while (result.length < count) {
    const {
      value,
      done
    } = await iterator.next();

    if (done) {
      break;
    }

    result.push(value);
  }

  return result;
}
//# sourceMappingURL=async-queue.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js ***!
  \***************************************************************************************************/
/*! exports provided: convertToObjectRow, convertToArrayRow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToObjectRow", function() { return convertToObjectRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToArrayRow", function() { return convertToArrayRow; });
function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  const objectRow = {};

  for (let i = 0; i < headers.length; i++) {
    objectRow[headers[i]] = arrayRow[i];
  }

  return objectRow;
}
function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  const arrayRow = new Array(headers.length);

  for (let i = 0; i < headers.length; i++) {
    arrayRow[i] = objectRow[headers[i]];
  }

  return arrayRow;
}
//# sourceMappingURL=row-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/index.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/index.js ***!
  \*******************************************************************************************/
/*! exports provided: assert, isBrowser, isWorker, WorkerJob, WorkerThread, WorkerFarm, WorkerPool, WorkerBody, processOnWorker, canProcessOnWorker, createWorker, getWorkerURL, validateWorkerVersion, getTransferList, getLibraryUrl, loadLibrary, AsyncQueue, ChildProcessProxy, NullWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NullWorker", function() { return NullWorker; });
/* harmony import */ var _lib_env_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/env-utils/version */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js");
/* harmony import */ var _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"]; });

/* harmony import */ var _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/env-utils/globals */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_2__["isWorker"]; });

/* harmony import */ var _lib_worker_farm_worker_job__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/worker-farm/worker-job */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WorkerJob", function() { return _lib_worker_farm_worker_job__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lib_worker_farm_worker_thread__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/worker-farm/worker-thread */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WorkerThread", function() { return _lib_worker_farm_worker_thread__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_worker_farm_worker_farm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/worker-farm/worker-farm */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WorkerFarm", function() { return _lib_worker_farm_worker_farm__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_worker_farm_worker_pool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/worker-farm/worker-pool */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WorkerPool", function() { return _lib_worker_farm_worker_pool__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/worker-farm/worker-body */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WorkerBody", function() { return _lib_worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_worker_api_process_on_worker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/worker-api/process-on-worker */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "processOnWorker", function() { return _lib_worker_api_process_on_worker__WEBPACK_IMPORTED_MODULE_8__["processOnWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canProcessOnWorker", function() { return _lib_worker_api_process_on_worker__WEBPACK_IMPORTED_MODULE_8__["canProcessOnWorker"]; });

/* harmony import */ var _lib_worker_api_create_worker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/worker-api/create-worker */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _lib_worker_api_create_worker__WEBPACK_IMPORTED_MODULE_9__["createWorker"]; });

/* harmony import */ var _lib_worker_api_get_worker_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/worker-api/get-worker-url */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return _lib_worker_api_get_worker_url__WEBPACK_IMPORTED_MODULE_10__["getWorkerURL"]; });

/* harmony import */ var _lib_worker_api_validate_worker_version__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/worker-api/validate-worker-version */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateWorkerVersion", function() { return _lib_worker_api_validate_worker_version__WEBPACK_IMPORTED_MODULE_11__["validateWorkerVersion"]; });

/* harmony import */ var _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/worker-utils/get-transfer-list */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_12__["getTransferList"]; });

/* harmony import */ var _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/library-utils/library-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_13__["getLibraryUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_13__["loadLibrary"]; });

/* harmony import */ var _lib_async_queue_async_queue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/async-queue/async-queue */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AsyncQueue", function() { return _lib_async_queue_async_queue__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/process-utils/child-process-proxy */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ChildProcessProxy", function() { return _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_15__["default"]; });

















const NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _lib_env_utils_version__WEBPACK_IMPORTED_MODULE_0__["VERSION"],
  options: {
    null: {}
  }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncQueue; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");


let _Symbol$asyncIterator;

_Symbol$asyncIterator = Symbol.asyncIterator;
class AsyncQueue {
  constructor() {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_values", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_settlers", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_closed", void 0);

    this._values = [];
    this._settlers = [];
    this._closed = false;
  }

  [_Symbol$asyncIterator]() {
    return this;
  }

  push(value) {
    return this.enqueue(value);
  }

  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }

    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }

      const settler = this._settlers.shift();

      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.push(value);
    }
  }

  close() {
    while (this._settlers.length > 0) {
      const settler = this._settlers.shift();

      settler.resolve({
        done: true
      });
    }

    this._closed = true;
  }

  next() {
    if (this._values.length > 0) {
      const value = this._values.shift();

      if (value instanceof Error) {
        return Promise.reject(value);
      }

      return Promise.resolve({
        done: false,
        value
      });
    }

    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }

      return Promise.resolve({
        done: true,
        value: undefined
      });
    }

    return new Promise((resolve, reject) => {
      this._settlers.push({
        resolve,
        reject
      });
    });
  }

}
//# sourceMappingURL=async-queue.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js ***!
  \**********************************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js ***!
  \***********************************************************************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, isMobile, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;
const isWorker = typeof importScripts === 'function';
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js ***!
  \***********************************************************************************************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
const DEFAULT_VERSION = 'beta';
const VERSION =  true ? "3.0.6" : undefined;

if (false) {}
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js ***!
  \*********************************************************************************************************************/
/*! exports provided: loadLibrary, getLibraryUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return loadLibrary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return getLibraryUrl; });
/* harmony import */ var _env_utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js");
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/require-utils.node */ 1);
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env-utils/version */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js");




const LATEST = 'beta';
const VERSION =  true ? "3.0.6" : undefined;
const loadLibraryPromises = {};
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }

  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }

  const modules = options.modules || {};

  if (modules[library]) {
    return modules[library];
  }

  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }

  if (options.CDN) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    return "../src/libs/".concat(library);
  }

  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}

async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }

  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"] && (await _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"](libraryUrl));
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    return importScripts(libraryUrl);
  }

  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}

function loadLibraryFromString(scriptSource, id) {
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"] && _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"](scriptSource, id);
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    eval.call(_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"], scriptSource);
    return null;
  }

  const script = document.createElement('script');
  script.id = id;

  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }

  document.body.appendChild(script);
  return null;
}
//# sourceMappingURL=library-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ChildProcessProxy; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _process_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./process-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/process-utils.js");



const DEFAULT_PROPS = {
  command: '',
  arguments: [],
  port: 5000,
  autoPort: true,
  wait: 2000,
  onSuccess: processProxy => {
    console.log("Started ".concat(processProxy.props.command));
  }
};
class ChildProcessProxy {
  constructor({
    id = 'browser-driver'
  } = {}) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", { ...DEFAULT_PROPS
    });

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "childProcess", null);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "port", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "successTimer", void 0);

    this.id = id;
  }

  async start(props) {
    props = { ...DEFAULT_PROPS,
      ...props
    };
    this.props = props;
    const args = [...props.arguments];
    this.port = Number(props.port);

    if (props.portArg) {
      if (props.autoPort) {
        this.port = await Object(_process_utils__WEBPACK_IMPORTED_MODULE_2__["getAvailablePort"])(props.port);
      }

      args.push(props.portArg, String(this.port));
    }

    return await new Promise((resolve, reject) => {
      try {
        this._setTimeout(() => {
          if (props.onSuccess) {
            props.onSuccess(this);
          }

          resolve({});
        });

        console.log("Spawning ".concat(props.command, " ").concat(props.arguments.join(' ')));
        const childProcess = Object(child_process__WEBPACK_IMPORTED_MODULE_1__["spawn"])(props.command, args, props.spawn);
        this.childProcess = childProcess;
        childProcess.stdout.on('data', data => {
          console.log(data.toString());
        });
        childProcess.stderr.on('data', data => {
          console.log("Child process wrote to stderr: \"".concat(data, "\"."));

          this._clearTimeout();

          reject(new Error(data));
        });
        childProcess.on('error', error => {
          console.log("Child process errored with ".concat(error));

          this._clearTimeout();

          reject(error);
        });
        childProcess.on('close', code => {
          console.log("Child process exited with ".concat(code));
          this.childProcess = null;

          this._clearTimeout();

          resolve({});
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async stop() {
    if (this.childProcess) {
      this.childProcess.kill();
      this.childProcess = null;
    }
  }

  async exit(statusCode = 0) {
    try {
      await this.stop();
      process.exit(statusCode);
    } catch (error) {
      console.error(error.message || error);
      process.exit(1);
    }
  }

  _setTimeout(callback) {
    if (Number(this.props.wait) > 0) {
      this.successTimer = setTimeout(callback, this.props.wait);
    }
  }

  _clearTimeout() {
    if (this.successTimer) {
      clearTimeout(this.successTimer);
    }
  }

}
//# sourceMappingURL=child-process-proxy.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/process-utils.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/process-utils.js ***!
  \*********************************************************************************************************************/
/*! exports provided: getAvailablePort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAvailablePort", function() { return getAvailablePort; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);

function getAvailablePort(defaultPort = 3000) {
  return new Promise(resolve => {
    child_process__WEBPACK_IMPORTED_MODULE_0___default.a.exec('lsof -i -P -n | grep LISTEN', (error, stdout) => {
      if (error) {
        resolve(defaultPort);
        return;
      }

      const portsInUse = [];
      const regex = /:(\d+) \(LISTEN\)/;
      stdout.split('\n').forEach(line => {
        const match = regex.exec(line);

        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      let port = defaultPort;

      while (portsInUse.includes(port)) {
        port++;
      }

      resolve(port);
    });
  });
}
//# sourceMappingURL=process-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js ***!
  \******************************************************************************************************************/
/*! exports provided: createWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return createWorker; });
/* harmony import */ var _async_queue_async_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../async-queue/async-queue */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js");
/* harmony import */ var _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../worker-farm/worker-body */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js");


let requestId = 0;
let inputBatches;
let options;
function createWorker(process, processInBatches) {
  if (typeof self === 'undefined') {
    return;
  }

  const context = {
    process: processOnMainThread
  };

  _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].onmessage = async (type, payload) => {
    try {
      switch (type) {
        case 'process':
          if (!process) {
            throw new Error('Worker does not support atomic processing');
          }

          const result = await process(payload.input, payload.options || {}, context);
          _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].postMessage('done', {
            result
          });
          break;

        case 'process-in-batches':
          if (!processInBatches) {
            throw new Error('Worker does not support batched processing');
          }

          inputBatches = new _async_queue_async_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
          options = payload.options || {};
          const resultIterator = processInBatches(inputBatches, options, context === null || context === void 0 ? void 0 : context.processInBatches);

          for await (const batch of resultIterator) {
            _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].postMessage('output-batch', {
              result: batch
            });
          }

          _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].postMessage('done', {});
          break;

        case 'input-batch':
          inputBatches.push(payload.input);
          break;

        case 'input-done':
          inputBatches.close();
          break;

        default:
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : '';
      _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].postMessage('error', {
        error: message
      });
    }
  };
}

function processOnMainThread(arrayBuffer, options = {}) {
  return new Promise((resolve, reject) => {
    const id = requestId++;

    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].removeEventListener(onMessage);
          resolve(payload.result);
          break;

        case 'error':
          _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].removeEventListener(onMessage);
          reject(payload.error);
          break;

        default:
      }
    };

    _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _worker_farm_worker_body__WEBPACK_IMPORTED_MODULE_1__["default"].postMessage('process', payload);
  });
}
//# sourceMappingURL=create-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js ***!
  \*******************************************************************************************************************/
/*! exports provided: getWorkerName, getWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerName", function() { return getWorkerName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return getWorkerURL; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/version */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js");


const NPM_TAG = 'latest';
const VERSION =  true ? "3.0.6" : undefined;
function getWorkerName(worker) {
  const warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;

  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }

  if (!url) {
    let version = worker.version;

    if (version === 'latest') {
      version = NPM_TAG;
    }

    const versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }

  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(url);
  return url;
}
//# sourceMappingURL=get-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js ***!
  \**********************************************************************************************************************/
/*! exports provided: canProcessOnWorker, processOnWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canProcessOnWorker", function() { return canProcessOnWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processOnWorker", function() { return processOnWorker; });
/* harmony import */ var _worker_farm_worker_farm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worker-farm/worker-farm */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js");
/* harmony import */ var _worker_utils_remove_nontransferable_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../worker-utils/remove-nontransferable-options */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/remove-nontransferable-options.js");
/* harmony import */ var _get_worker_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-worker-url */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js");



function canProcessOnWorker(worker, options) {
  if (!_worker_farm_worker_farm__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function processOnWorker(worker, data, options = {}, context = {}) {
  const name = Object(_get_worker_url__WEBPACK_IMPORTED_MODULE_2__["getWorkerName"])(worker);
  const url = Object(_get_worker_url__WEBPACK_IMPORTED_MODULE_2__["getWorkerURL"])(worker, options);
  const workerFarm = _worker_farm_worker_farm__WEBPACK_IMPORTED_MODULE_0__["default"].getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
  const transferableOptions = Object(_worker_utils_remove_nontransferable_options__WEBPACK_IMPORTED_MODULE_1__["removeNontransferableOptions"])(options);
  job.postMessage('process', {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}

async function onMessage(context, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;

    case 'error':
      job.error(payload.error);
      break;

    case 'process':
      const {
        id,
        input,
        options
      } = payload;

      try {
        if (!context.process) {
          job.postMessage('error', {
            id,
            error: 'Worker not set up to process on main thread'
          });
          return;
        }

        const result = await context.process(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }

      break;

    default:
      console.warn("process-on-worker: unknown message ".concat(type));
  }
}
//# sourceMappingURL=process-on-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js ***!
  \****************************************************************************************************************************/
/*! exports provided: validateWorkerVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateWorkerVersion", function() { return validateWorkerVersion; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/version */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js");


function validateWorkerVersion(worker, coreVersion = _env_utils_version__WEBPACK_IMPORTED_MODULE_1__["VERSION"]) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(worker, 'no worker provided');
  const workerVersion = worker.version;

  if (!coreVersion || !workerVersion) {
    return false;
  }

  return true;
}

function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
//# sourceMappingURL=validate-worker-version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerBody; });
/* harmony import */ var _worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worker-utils/get-transfer-list */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js");

const onMessageWrapperMap = new Map();
class WorkerBody {
  static set onmessage(onMessage) {
    self.onmessage = message => {
      if (!isKnownMessage(message)) {
        return;
      }

      const {
        type,
        payload
      } = message.data;
      onMessage(type, payload);
    };
  }

  static addEventListener(onMessage) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage);

    if (!onMessageWrapper) {
      onMessageWrapper = message => {
        if (!isKnownMessage(message)) {
          return;
        }

        const {
          type,
          payload
        } = message.data;
        onMessage(type, payload);
      };
    }

    self.addEventListener('message', onMessageWrapper);
  }

  static removeEventListener(onMessage) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage);
    onMessageWrapperMap.delete(onMessage);
    self.removeEventListener('message', onMessageWrapper);
  }

  static postMessage(type, payload) {
    if (self) {
      const data = {
        source: 'loaders.gl',
        type,
        payload
      };
      const transferList = Object(_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(payload);
      self.postMessage(data, transferList);
    }
  }

}

function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}
//# sourceMappingURL=worker-body.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerFarm; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _worker_pool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-pool */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js");
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-thread */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js");



const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  onDebug: () => {},
  reuseWorkers: true
};
class WorkerFarm {
  static isSupported() {
    return _worker_thread__WEBPACK_IMPORTED_MODULE_2__["default"].isSupported();
  }

  static getWorkerFarm(props = {}) {
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});

    WorkerFarm._workerFarm.setProps(props);

    return WorkerFarm._workerFarm;
  }

  constructor(props) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "workerPools", new Map());

    this.props = { ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }

  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
  }

  setProps(props) {
    this.props = { ...this.props,
      ...props
    };

    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }

  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);

    if (!workerPool) {
      workerPool = new _worker_pool__WEBPACK_IMPORTED_MODULE_1__["default"]({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }

    return workerPool;
  }

  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }

}

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(WorkerFarm, "_workerFarm", void 0);
//# sourceMappingURL=worker-farm.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js":
/*!****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerJob; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");


class WorkerJob {
  constructor(jobName, workerThread) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "name", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "workerThread", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isRunning", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "result", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_resolve", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_reject", void 0);

    this.name = jobName;
    this.workerThread = workerThread;
    this.isRunning = true;

    this._resolve = () => {};

    this._reject = () => {};

    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }

  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }

  done(value) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.isRunning);
    this.isRunning = false;

    this._resolve(value);
  }

  error(error) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.isRunning);
    this.isRunning = false;

    this._reject(error);
  }

}
//# sourceMappingURL=worker-job.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerPool; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _env_utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/globals */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js");
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-thread */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js");
/* harmony import */ var _worker_job__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-job */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js");




class WorkerPool {
  constructor(props) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "name", 'unnamed');

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "source", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "url", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "maxConcurrency", 1);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "maxMobileConcurrency", 1);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onDebug", () => {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "reuseWorkers", true);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", {});

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "jobQueue", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "idleQueue", []);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "count", 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isDestroyed", false);

    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  setProps(props) {
    this.props = { ...this.props,
      ...props
    };

    if (props.name !== undefined) {
      this.name = props.name;
    }

    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }

    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }

    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }

  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });

    this._startQueuedJob();

    return await startPromise;
  }

  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }

    const workerThread = this._getAvailableWorker();

    if (!workerThread) {
      return;
    }

    const queuedJob = this.jobQueue.shift();

    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _worker_job__WEBPACK_IMPORTED_MODULE_3__["default"](queuedJob.name, workerThread);

      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);

      workerThread.onError = error => queuedJob.onError(job, error);

      queuedJob.onStart(job);

      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }

  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }

    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }

  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }

    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new _worker_thread__WEBPACK_IMPORTED_MODULE_2__["default"]({
        name,
        source: this.source,
        url: this.url
      });
    }

    return null;
  }

  _getMaxConcurrency() {
    return _env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isMobile"] ? this.maxMobileConcurrency : this.maxConcurrency;
  }

}
//# sourceMappingURL=worker-pool.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerThread; });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _worker_utils_get_loadable_worker_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../worker-utils/get-loadable-worker-url */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js");
/* harmony import */ var _worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../worker-utils/get-transfer-list */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js");





const NOOP = () => {};

class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined';
  }

  constructor(props) {
    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "name", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "source", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "url", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "terminated", false);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "worker", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onMessage", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onError", void 0);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_loadableURL", '');

    const {
      name,
      source,
      url
    } = props;
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;

    this.onError = error => console.log(error);

    this.worker = this._createBrowserWorker();
  }

  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }

  get isRunning() {
    return Boolean(this.onMessage);
  }

  postMessage(data, transferList) {
    transferList = transferList || Object(_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_3__["getTransferList"])(data);
    this.worker.postMessage(data, transferList);
  }

  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += "worker ".concat(this.name, ". ");

    if (event.message) {
      message += "".concat(event.message, " in ");
    }

    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }

    return new Error(message);
  }

  _createBrowserWorker() {
    this._loadableURL = Object(_worker_utils_get_loadable_worker_url__WEBPACK_IMPORTED_MODULE_2__["getLoadableWorkerURL"])({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });

    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };

    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };

    worker.onmessageerror = event => console.error(event);

    return worker;
  }

}
//# sourceMappingURL=worker-thread.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js ***!
  \******************************************************************************************************************************/
/*! exports provided: getLoadableWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLoadableWorkerURL", function() { return getLoadableWorkerURL; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js");

const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);

  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }

    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }

  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(workerURL);
  return workerURL;
}

function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }

  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}

function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}

function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}
//# sourceMappingURL=get-loadable-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js":
/*!************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js ***!
  \************************************************************************************************************************/
/*! exports provided: getTransferList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || new Set();

  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : [];
}

function isTransferable(object) {
  if (!object) {
    return false;
  }

  if (object instanceof ArrayBuffer) {
    return true;
  }

  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }

  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }

  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }

  return false;
}
//# sourceMappingURL=get-transfer-list.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/remove-nontransferable-options.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/remove-nontransferable-options.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: removeNontransferableOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNontransferableOptions", function() { return removeNontransferableOptions; });
function removeNontransferableOptions(object) {
  return JSON.parse(stringifyJSON(object));
}

function stringifyJSON(v) {
  const cache = new Set();
  return JSON.stringify(v, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return undefined;
        }
      }

      cache.add(value);
    }

    return value;
  });
}
//# sourceMappingURL=remove-nontransferable-options.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/constants/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/constants/dist/esm/index.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  DEPTH_BUFFER_BIT: 0x00000100,
  STENCIL_BUFFER_BIT: 0x00000400,
  COLOR_BUFFER_BIT: 0x00004000,
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,
  ZERO: 0,
  ONE: 1,
  SRC_COLOR: 0x0300,
  ONE_MINUS_SRC_COLOR: 0x0301,
  SRC_ALPHA: 0x0302,
  ONE_MINUS_SRC_ALPHA: 0x0303,
  DST_ALPHA: 0x0304,
  ONE_MINUS_DST_ALPHA: 0x0305,
  DST_COLOR: 0x0306,
  ONE_MINUS_DST_COLOR: 0x0307,
  SRC_ALPHA_SATURATE: 0x0308,
  CONSTANT_COLOR: 0x8001,
  ONE_MINUS_CONSTANT_COLOR: 0x8002,
  CONSTANT_ALPHA: 0x8003,
  ONE_MINUS_CONSTANT_ALPHA: 0x8004,
  FUNC_ADD: 0x8006,
  FUNC_SUBTRACT: 0x800a,
  FUNC_REVERSE_SUBTRACT: 0x800b,
  BLEND_EQUATION: 0x8009,
  BLEND_EQUATION_RGB: 0x8009,
  BLEND_EQUATION_ALPHA: 0x883d,
  BLEND_DST_RGB: 0x80c8,
  BLEND_SRC_RGB: 0x80c9,
  BLEND_DST_ALPHA: 0x80ca,
  BLEND_SRC_ALPHA: 0x80cb,
  BLEND_COLOR: 0x8005,
  ARRAY_BUFFER_BINDING: 0x8894,
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
  LINE_WIDTH: 0x0b21,
  ALIASED_POINT_SIZE_RANGE: 0x846d,
  ALIASED_LINE_WIDTH_RANGE: 0x846e,
  CULL_FACE_MODE: 0x0b45,
  FRONT_FACE: 0x0b46,
  DEPTH_RANGE: 0x0b70,
  DEPTH_WRITEMASK: 0x0b72,
  DEPTH_CLEAR_VALUE: 0x0b73,
  DEPTH_FUNC: 0x0b74,
  STENCIL_CLEAR_VALUE: 0x0b91,
  STENCIL_FUNC: 0x0b92,
  STENCIL_FAIL: 0x0b94,
  STENCIL_PASS_DEPTH_FAIL: 0x0b95,
  STENCIL_PASS_DEPTH_PASS: 0x0b96,
  STENCIL_REF: 0x0b97,
  STENCIL_VALUE_MASK: 0x0b93,
  STENCIL_WRITEMASK: 0x0b98,
  STENCIL_BACK_FUNC: 0x8800,
  STENCIL_BACK_FAIL: 0x8801,
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
  STENCIL_BACK_REF: 0x8ca3,
  STENCIL_BACK_VALUE_MASK: 0x8ca4,
  STENCIL_BACK_WRITEMASK: 0x8ca5,
  VIEWPORT: 0x0ba2,
  SCISSOR_BOX: 0x0c10,
  COLOR_CLEAR_VALUE: 0x0c22,
  COLOR_WRITEMASK: 0x0c23,
  UNPACK_ALIGNMENT: 0x0cf5,
  PACK_ALIGNMENT: 0x0d05,
  MAX_TEXTURE_SIZE: 0x0d33,
  MAX_VIEWPORT_DIMS: 0x0d3a,
  SUBPIXEL_BITS: 0x0d50,
  RED_BITS: 0x0d52,
  GREEN_BITS: 0x0d53,
  BLUE_BITS: 0x0d54,
  ALPHA_BITS: 0x0d55,
  DEPTH_BITS: 0x0d56,
  STENCIL_BITS: 0x0d57,
  POLYGON_OFFSET_UNITS: 0x2a00,
  POLYGON_OFFSET_FACTOR: 0x8038,
  TEXTURE_BINDING_2D: 0x8069,
  SAMPLE_BUFFERS: 0x80a8,
  SAMPLES: 0x80a9,
  SAMPLE_COVERAGE_VALUE: 0x80aa,
  SAMPLE_COVERAGE_INVERT: 0x80ab,
  COMPRESSED_TEXTURE_FORMATS: 0x86a3,
  VENDOR: 0x1f00,
  RENDERER: 0x1f01,
  VERSION: 0x1f02,
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
  BROWSER_DEFAULT_WEBGL: 0x9244,
  STATIC_DRAW: 0x88e4,
  STREAM_DRAW: 0x88e0,
  DYNAMIC_DRAW: 0x88e8,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  BUFFER_SIZE: 0x8764,
  BUFFER_USAGE: 0x8765,
  CURRENT_VERTEX_ATTRIB: 0x8626,
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,
  CULL_FACE: 0x0b44,
  FRONT: 0x0404,
  BACK: 0x0405,
  FRONT_AND_BACK: 0x0408,
  BLEND: 0x0be2,
  DEPTH_TEST: 0x0b71,
  DITHER: 0x0bd0,
  POLYGON_OFFSET_FILL: 0x8037,
  SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
  SAMPLE_COVERAGE: 0x80a0,
  SCISSOR_TEST: 0x0c11,
  STENCIL_TEST: 0x0b90,
  NO_ERROR: 0,
  INVALID_ENUM: 0x0500,
  INVALID_VALUE: 0x0501,
  INVALID_OPERATION: 0x0502,
  OUT_OF_MEMORY: 0x0505,
  CONTEXT_LOST_WEBGL: 0x9242,
  CW: 0x0900,
  CCW: 0x0901,
  DONT_CARE: 0x1100,
  FASTEST: 0x1101,
  NICEST: 0x1102,
  GENERATE_MIPMAP_HINT: 0x8192,
  BYTE: 0x1400,
  UNSIGNED_BYTE: 0x1401,
  SHORT: 0x1402,
  UNSIGNED_SHORT: 0x1403,
  INT: 0x1404,
  UNSIGNED_INT: 0x1405,
  FLOAT: 0x1406,
  DOUBLE: 0x140a,
  DEPTH_COMPONENT: 0x1902,
  ALPHA: 0x1906,
  RGB: 0x1907,
  RGBA: 0x1908,
  LUMINANCE: 0x1909,
  LUMINANCE_ALPHA: 0x190a,
  UNSIGNED_SHORT_4_4_4_4: 0x8033,
  UNSIGNED_SHORT_5_5_5_1: 0x8034,
  UNSIGNED_SHORT_5_6_5: 0x8363,
  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31,
  COMPILE_STATUS: 0x8b81,
  DELETE_STATUS: 0x8b80,
  LINK_STATUS: 0x8b82,
  VALIDATE_STATUS: 0x8b83,
  ATTACHED_SHADERS: 0x8b85,
  ACTIVE_ATTRIBUTES: 0x8b89,
  ACTIVE_UNIFORMS: 0x8b86,
  MAX_VERTEX_ATTRIBS: 0x8869,
  MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
  MAX_VARYING_VECTORS: 0x8dfc,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
  SHADER_TYPE: 0x8b4f,
  SHADING_LANGUAGE_VERSION: 0x8b8c,
  CURRENT_PROGRAM: 0x8b8d,
  NEVER: 0x0200,
  ALWAYS: 0x0207,
  LESS: 0x0201,
  EQUAL: 0x0202,
  LEQUAL: 0x0203,
  GREATER: 0x0204,
  GEQUAL: 0x0206,
  NOTEQUAL: 0x0205,
  KEEP: 0x1e00,
  REPLACE: 0x1e01,
  INCR: 0x1e02,
  DECR: 0x1e03,
  INVERT: 0x150a,
  INCR_WRAP: 0x8507,
  DECR_WRAP: 0x8508,
  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  TEXTURE_2D: 0x0de1,
  TEXTURE: 0x1702,
  TEXTURE_CUBE_MAP: 0x8513,
  TEXTURE_BINDING_CUBE_MAP: 0x8514,
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
  TEXTURE0: 0x84c0,
  ACTIVE_TEXTURE: 0x84e0,
  REPEAT: 0x2901,
  CLAMP_TO_EDGE: 0x812f,
  MIRRORED_REPEAT: 0x8370,
  TEXTURE_WIDTH: 0x1000,
  TEXTURE_HEIGHT: 0x1001,
  FLOAT_VEC2: 0x8b50,
  FLOAT_VEC3: 0x8b51,
  FLOAT_VEC4: 0x8b52,
  INT_VEC2: 0x8b53,
  INT_VEC3: 0x8b54,
  INT_VEC4: 0x8b55,
  BOOL: 0x8b56,
  BOOL_VEC2: 0x8b57,
  BOOL_VEC3: 0x8b58,
  BOOL_VEC4: 0x8b59,
  FLOAT_MAT2: 0x8b5a,
  FLOAT_MAT3: 0x8b5b,
  FLOAT_MAT4: 0x8b5c,
  SAMPLER_2D: 0x8b5e,
  SAMPLER_CUBE: 0x8b60,
  LOW_FLOAT: 0x8df0,
  MEDIUM_FLOAT: 0x8df1,
  HIGH_FLOAT: 0x8df2,
  LOW_INT: 0x8df3,
  MEDIUM_INT: 0x8df4,
  HIGH_INT: 0x8df5,
  FRAMEBUFFER: 0x8d40,
  RENDERBUFFER: 0x8d41,
  RGBA4: 0x8056,
  RGB5_A1: 0x8057,
  RGB565: 0x8d62,
  DEPTH_COMPONENT16: 0x81a5,
  STENCIL_INDEX: 0x1901,
  STENCIL_INDEX8: 0x8d48,
  DEPTH_STENCIL: 0x84f9,
  RENDERBUFFER_WIDTH: 0x8d42,
  RENDERBUFFER_HEIGHT: 0x8d43,
  RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
  RENDERBUFFER_RED_SIZE: 0x8d50,
  RENDERBUFFER_GREEN_SIZE: 0x8d51,
  RENDERBUFFER_BLUE_SIZE: 0x8d52,
  RENDERBUFFER_ALPHA_SIZE: 0x8d53,
  RENDERBUFFER_DEPTH_SIZE: 0x8d54,
  RENDERBUFFER_STENCIL_SIZE: 0x8d55,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
  COLOR_ATTACHMENT0: 0x8ce0,
  DEPTH_ATTACHMENT: 0x8d00,
  STENCIL_ATTACHMENT: 0x8d20,
  DEPTH_STENCIL_ATTACHMENT: 0x821a,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 0x8cd5,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
  FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
  FRAMEBUFFER_BINDING: 0x8ca6,
  RENDERBUFFER_BINDING: 0x8ca7,
  READ_FRAMEBUFFER: 0x8ca8,
  DRAW_FRAMEBUFFER: 0x8ca9,
  MAX_RENDERBUFFER_SIZE: 0x84e8,
  INVALID_FRAMEBUFFER_OPERATION: 0x0506,
  UNPACK_FLIP_Y_WEBGL: 0x9240,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
  READ_BUFFER: 0x0c02,
  UNPACK_ROW_LENGTH: 0x0cf2,
  UNPACK_SKIP_ROWS: 0x0cf3,
  UNPACK_SKIP_PIXELS: 0x0cf4,
  PACK_ROW_LENGTH: 0x0d02,
  PACK_SKIP_ROWS: 0x0d03,
  PACK_SKIP_PIXELS: 0x0d04,
  TEXTURE_BINDING_3D: 0x806a,
  UNPACK_SKIP_IMAGES: 0x806d,
  UNPACK_IMAGE_HEIGHT: 0x806e,
  MAX_3D_TEXTURE_SIZE: 0x8073,
  MAX_ELEMENTS_VERTICES: 0x80e8,
  MAX_ELEMENTS_INDICES: 0x80e9,
  MAX_TEXTURE_LOD_BIAS: 0x84fd,
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8b49,
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8b4a,
  MAX_ARRAY_TEXTURE_LAYERS: 0x88ff,
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
  MAX_VARYING_COMPONENTS: 0x8b4b,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8b8b,
  RASTERIZER_DISCARD: 0x8c89,
  VERTEX_ARRAY_BINDING: 0x85b5,
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
  MAX_ELEMENT_INDEX: 0x8d6b,
  RED: 0x1903,
  RGB8: 0x8051,
  RGBA8: 0x8058,
  RGB10_A2: 0x8059,
  TEXTURE_3D: 0x806f,
  TEXTURE_WRAP_R: 0x8072,
  TEXTURE_MIN_LOD: 0x813a,
  TEXTURE_MAX_LOD: 0x813b,
  TEXTURE_BASE_LEVEL: 0x813c,
  TEXTURE_MAX_LEVEL: 0x813d,
  TEXTURE_COMPARE_MODE: 0x884c,
  TEXTURE_COMPARE_FUNC: 0x884d,
  SRGB: 0x8c40,
  SRGB8: 0x8c41,
  SRGB8_ALPHA8: 0x8c43,
  COMPARE_REF_TO_TEXTURE: 0x884e,
  RGBA32F: 0x8814,
  RGB32F: 0x8815,
  RGBA16F: 0x881a,
  RGB16F: 0x881b,
  TEXTURE_2D_ARRAY: 0x8c1a,
  TEXTURE_BINDING_2D_ARRAY: 0x8c1d,
  R11F_G11F_B10F: 0x8c3a,
  RGB9_E5: 0x8c3d,
  RGBA32UI: 0x8d70,
  RGB32UI: 0x8d71,
  RGBA16UI: 0x8d76,
  RGB16UI: 0x8d77,
  RGBA8UI: 0x8d7c,
  RGB8UI: 0x8d7d,
  RGBA32I: 0x8d82,
  RGB32I: 0x8d83,
  RGBA16I: 0x8d88,
  RGB16I: 0x8d89,
  RGBA8I: 0x8d8e,
  RGB8I: 0x8d8f,
  RED_INTEGER: 0x8d94,
  RGB_INTEGER: 0x8d98,
  RGBA_INTEGER: 0x8d99,
  R8: 0x8229,
  RG8: 0x822b,
  R16F: 0x822d,
  R32F: 0x822e,
  RG16F: 0x822f,
  RG32F: 0x8230,
  R8I: 0x8231,
  R8UI: 0x8232,
  R16I: 0x8233,
  R16UI: 0x8234,
  R32I: 0x8235,
  R32UI: 0x8236,
  RG8I: 0x8237,
  RG8UI: 0x8238,
  RG16I: 0x8239,
  RG16UI: 0x823a,
  RG32I: 0x823b,
  RG32UI: 0x823c,
  R8_SNORM: 0x8f94,
  RG8_SNORM: 0x8f95,
  RGB8_SNORM: 0x8f96,
  RGBA8_SNORM: 0x8f97,
  RGB10_A2UI: 0x906f,
  TEXTURE_IMMUTABLE_FORMAT: 0x912f,
  TEXTURE_IMMUTABLE_LEVELS: 0x82df,
  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
  UNSIGNED_INT_10F_11F_11F_REV: 0x8c3b,
  UNSIGNED_INT_5_9_9_9_REV: 0x8c3e,
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8dad,
  UNSIGNED_INT_24_8: 0x84fa,
  HALF_FLOAT: 0x140b,
  RG: 0x8227,
  RG_INTEGER: 0x8228,
  INT_2_10_10_10_REV: 0x8d9f,
  CURRENT_QUERY: 0x8865,
  QUERY_RESULT: 0x8866,
  QUERY_RESULT_AVAILABLE: 0x8867,
  ANY_SAMPLES_PASSED: 0x8c2f,
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8d6a,
  MAX_DRAW_BUFFERS: 0x8824,
  DRAW_BUFFER0: 0x8825,
  DRAW_BUFFER1: 0x8826,
  DRAW_BUFFER2: 0x8827,
  DRAW_BUFFER3: 0x8828,
  DRAW_BUFFER4: 0x8829,
  DRAW_BUFFER5: 0x882a,
  DRAW_BUFFER6: 0x882b,
  DRAW_BUFFER7: 0x882c,
  DRAW_BUFFER8: 0x882d,
  DRAW_BUFFER9: 0x882e,
  DRAW_BUFFER10: 0x882f,
  DRAW_BUFFER11: 0x8830,
  DRAW_BUFFER12: 0x8831,
  DRAW_BUFFER13: 0x8832,
  DRAW_BUFFER14: 0x8833,
  DRAW_BUFFER15: 0x8834,
  MAX_COLOR_ATTACHMENTS: 0x8cdf,
  COLOR_ATTACHMENT1: 0x8ce1,
  COLOR_ATTACHMENT2: 0x8ce2,
  COLOR_ATTACHMENT3: 0x8ce3,
  COLOR_ATTACHMENT4: 0x8ce4,
  COLOR_ATTACHMENT5: 0x8ce5,
  COLOR_ATTACHMENT6: 0x8ce6,
  COLOR_ATTACHMENT7: 0x8ce7,
  COLOR_ATTACHMENT8: 0x8ce8,
  COLOR_ATTACHMENT9: 0x8ce9,
  COLOR_ATTACHMENT10: 0x8cea,
  COLOR_ATTACHMENT11: 0x8ceb,
  COLOR_ATTACHMENT12: 0x8cec,
  COLOR_ATTACHMENT13: 0x8ced,
  COLOR_ATTACHMENT14: 0x8cee,
  COLOR_ATTACHMENT15: 0x8cef,
  SAMPLER_3D: 0x8b5f,
  SAMPLER_2D_SHADOW: 0x8b62,
  SAMPLER_2D_ARRAY: 0x8dc1,
  SAMPLER_2D_ARRAY_SHADOW: 0x8dc4,
  SAMPLER_CUBE_SHADOW: 0x8dc5,
  INT_SAMPLER_2D: 0x8dca,
  INT_SAMPLER_3D: 0x8dcb,
  INT_SAMPLER_CUBE: 0x8dcc,
  INT_SAMPLER_2D_ARRAY: 0x8dcf,
  UNSIGNED_INT_SAMPLER_2D: 0x8dd2,
  UNSIGNED_INT_SAMPLER_3D: 0x8dd3,
  UNSIGNED_INT_SAMPLER_CUBE: 0x8dd4,
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8dd7,
  MAX_SAMPLES: 0x8d57,
  SAMPLER_BINDING: 0x8919,
  PIXEL_PACK_BUFFER: 0x88eb,
  PIXEL_UNPACK_BUFFER: 0x88ec,
  PIXEL_PACK_BUFFER_BINDING: 0x88ed,
  PIXEL_UNPACK_BUFFER_BINDING: 0x88ef,
  COPY_READ_BUFFER: 0x8f36,
  COPY_WRITE_BUFFER: 0x8f37,
  COPY_READ_BUFFER_BINDING: 0x8f36,
  COPY_WRITE_BUFFER_BINDING: 0x8f37,
  FLOAT_MAT2x3: 0x8b65,
  FLOAT_MAT2x4: 0x8b66,
  FLOAT_MAT3x2: 0x8b67,
  FLOAT_MAT3x4: 0x8b68,
  FLOAT_MAT4x2: 0x8b69,
  FLOAT_MAT4x3: 0x8b6a,
  UNSIGNED_INT_VEC2: 0x8dc6,
  UNSIGNED_INT_VEC3: 0x8dc7,
  UNSIGNED_INT_VEC4: 0x8dc8,
  UNSIGNED_NORMALIZED: 0x8c17,
  SIGNED_NORMALIZED: 0x8f9c,
  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88fd,
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88fe,
  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8c7f,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8c80,
  TRANSFORM_FEEDBACK_VARYINGS: 0x8c83,
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8c84,
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8c85,
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8c88,
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8c8a,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8c8b,
  INTERLEAVED_ATTRIBS: 0x8c8c,
  SEPARATE_ATTRIBS: 0x8c8d,
  TRANSFORM_FEEDBACK_BUFFER: 0x8c8e,
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8c8f,
  TRANSFORM_FEEDBACK: 0x8e22,
  TRANSFORM_FEEDBACK_PAUSED: 0x8e23,
  TRANSFORM_FEEDBACK_ACTIVE: 0x8e24,
  TRANSFORM_FEEDBACK_BINDING: 0x8e25,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
  FRAMEBUFFER_DEFAULT: 0x8218,
  DEPTH24_STENCIL8: 0x88f0,
  DRAW_FRAMEBUFFER_BINDING: 0x8ca6,
  READ_FRAMEBUFFER_BINDING: 0x8caa,
  RENDERBUFFER_SAMPLES: 0x8cab,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8cd4,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8d56,
  UNIFORM_BUFFER: 0x8a11,
  UNIFORM_BUFFER_BINDING: 0x8a28,
  UNIFORM_BUFFER_START: 0x8a29,
  UNIFORM_BUFFER_SIZE: 0x8a2a,
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8a2b,
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8a2d,
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8a2e,
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8a2f,
  MAX_UNIFORM_BLOCK_SIZE: 0x8a30,
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8a31,
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8a33,
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8a34,
  ACTIVE_UNIFORM_BLOCKS: 0x8a36,
  UNIFORM_TYPE: 0x8a37,
  UNIFORM_SIZE: 0x8a38,
  UNIFORM_BLOCK_INDEX: 0x8a3a,
  UNIFORM_OFFSET: 0x8a3b,
  UNIFORM_ARRAY_STRIDE: 0x8a3c,
  UNIFORM_MATRIX_STRIDE: 0x8a3d,
  UNIFORM_IS_ROW_MAJOR: 0x8a3e,
  UNIFORM_BLOCK_BINDING: 0x8a3f,
  UNIFORM_BLOCK_DATA_SIZE: 0x8a40,
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8a42,
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8a43,
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8a44,
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8a46,
  OBJECT_TYPE: 0x9112,
  SYNC_CONDITION: 0x9113,
  SYNC_STATUS: 0x9114,
  SYNC_FLAGS: 0x9115,
  SYNC_FENCE: 0x9116,
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
  UNSIGNALED: 0x9118,
  SIGNALED: 0x9119,
  ALREADY_SIGNALED: 0x911a,
  TIMEOUT_EXPIRED: 0x911b,
  CONDITION_SATISFIED: 0x911c,
  WAIT_FAILED: 0x911d,
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
  COLOR: 0x1800,
  DEPTH: 0x1801,
  STENCIL: 0x1802,
  MIN: 0x8007,
  MAX: 0x8008,
  DEPTH_COMPONENT24: 0x81a6,
  STREAM_READ: 0x88e1,
  STREAM_COPY: 0x88e2,
  STATIC_READ: 0x88e5,
  STATIC_COPY: 0x88e6,
  DYNAMIC_READ: 0x88e9,
  DYNAMIC_COPY: 0x88ea,
  DEPTH_COMPONENT32F: 0x8cac,
  DEPTH32F_STENCIL8: 0x8cad,
  INVALID_INDEX: 0xffffffff,
  TIMEOUT_IGNORED: -1,
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,
  UNMASKED_VENDOR_WEBGL: 0x9245,
  UNMASKED_RENDERER_WEBGL: 0x9246,
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84fe,
  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,
  COMPRESSED_R11_EAC: 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
  COMPRESSED_RGB8_ETC2: 0x9274,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,
  COMPRESSED_SRGB8_ETC2: 0x9276,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,
  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,
  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,
  UNSIGNED_INT_24_8_WEBGL: 0x84fa,
  HALF_FLOAT_OES: 0x8d61,
  RGBA32F_EXT: 0x8814,
  RGB32F_EXT: 0x8815,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
  UNSIGNED_NORMALIZED_EXT: 0x8c17,
  MIN_EXT: 0x8007,
  MAX_EXT: 0x8008,
  SRGB_EXT: 0x8c40,
  SRGB_ALPHA_EXT: 0x8c42,
  SRGB8_ALPHA8_EXT: 0x8c43,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,
  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8b8b,
  COLOR_ATTACHMENT0_WEBGL: 0x8ce0,
  COLOR_ATTACHMENT1_WEBGL: 0x8ce1,
  COLOR_ATTACHMENT2_WEBGL: 0x8ce2,
  COLOR_ATTACHMENT3_WEBGL: 0x8ce3,
  COLOR_ATTACHMENT4_WEBGL: 0x8ce4,
  COLOR_ATTACHMENT5_WEBGL: 0x8ce5,
  COLOR_ATTACHMENT6_WEBGL: 0x8ce6,
  COLOR_ATTACHMENT7_WEBGL: 0x8ce7,
  COLOR_ATTACHMENT8_WEBGL: 0x8ce8,
  COLOR_ATTACHMENT9_WEBGL: 0x8ce9,
  COLOR_ATTACHMENT10_WEBGL: 0x8cea,
  COLOR_ATTACHMENT11_WEBGL: 0x8ceb,
  COLOR_ATTACHMENT12_WEBGL: 0x8cec,
  COLOR_ATTACHMENT13_WEBGL: 0x8ced,
  COLOR_ATTACHMENT14_WEBGL: 0x8cee,
  COLOR_ATTACHMENT15_WEBGL: 0x8cef,
  DRAW_BUFFER0_WEBGL: 0x8825,
  DRAW_BUFFER1_WEBGL: 0x8826,
  DRAW_BUFFER2_WEBGL: 0x8827,
  DRAW_BUFFER3_WEBGL: 0x8828,
  DRAW_BUFFER4_WEBGL: 0x8829,
  DRAW_BUFFER5_WEBGL: 0x882a,
  DRAW_BUFFER6_WEBGL: 0x882b,
  DRAW_BUFFER7_WEBGL: 0x882c,
  DRAW_BUFFER8_WEBGL: 0x882d,
  DRAW_BUFFER9_WEBGL: 0x882e,
  DRAW_BUFFER10_WEBGL: 0x882f,
  DRAW_BUFFER11_WEBGL: 0x8830,
  DRAW_BUFFER12_WEBGL: 0x8831,
  DRAW_BUFFER13_WEBGL: 0x8832,
  DRAW_BUFFER14_WEBGL: 0x8833,
  DRAW_BUFFER15_WEBGL: 0x8834,
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8cdf,
  MAX_DRAW_BUFFERS_WEBGL: 0x8824,
  VERTEX_ARRAY_BINDING_OES: 0x85b5,
  QUERY_COUNTER_BITS_EXT: 0x8864,
  CURRENT_QUERY_EXT: 0x8865,
  QUERY_RESULT_EXT: 0x8866,
  QUERY_RESULT_AVAILABLE_EXT: 0x8867,
  TIME_ELAPSED_EXT: 0x88bf,
  TIMESTAMP_EXT: 0x8e28,
  GPU_DISJOINT_EXT: 0x8fbb
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js ***!
  \*************************************************************************************************/
/*! exports provided: KeyFrames */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyFrames", function() { return KeyFrames; });
class KeyFrames {
  constructor(keyFrames) {
    this._lastTime = -1;
    this.startIndex = -1;
    this.endIndex = -1;
    this.factor = 0;
    this.times = [];
    this.values = [];
    this.setKeyFrames(keyFrames);
    this.setTime(0);
  }

  setKeyFrames(keyFrames) {
    const numKeys = keyFrames.length;
    this.times.length = numKeys;
    this.values.length = numKeys;

    for (let i = 0; i < numKeys; ++i) {
      this.times[i] = keyFrames[i][0];
      this.values[i] = keyFrames[i][1];
    }

    this._calculateKeys(this._lastTime);
  }

  setTime(time) {
    time = Math.max(0, time);

    if (time !== this._lastTime) {
      this._calculateKeys(time);

      this._lastTime = time;
    }
  }

  getStartTime() {
    return this.times[this.startIndex];
  }

  getEndTime() {
    return this.times[this.endIndex];
  }

  getStartData() {
    return this.values[this.startIndex];
  }

  getEndData() {
    return this.values[this.endIndex];
  }

  _calculateKeys(time) {
    let index = 0;
    const numKeys = this.times.length;

    for (index = 0; index < numKeys - 2; ++index) {
      if (this.times[index + 1] > time) {
        break;
      }
    }

    this.startIndex = index;
    this.endIndex = index + 1;
    const startTime = this.times[this.startIndex];
    const endTime = this.times[this.endIndex];
    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
  }

}
//# sourceMappingURL=key-frames.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/animation/timeline.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/animation/timeline.js ***!
  \***********************************************************************************************/
/*! exports provided: Timeline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return Timeline; });
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
  constructor() {
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }

  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };

    this._setChannelTime(channel, this.time);

    this.channels.set(handle, channel);
    return handle;
  }

  removeChannel(handle) {
    this.channels.delete(handle);

    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }

  isFinished(handle) {
    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return false;
    }

    return this.time >= channel.delay + channel.duration * channel.repeat;
  }

  getTime(handle) {
    if (handle === undefined) {
      return this.time;
    }

    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return -1;
    }

    return channel.time;
  }

  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();

    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }

    const animations = this.animations.values();

    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }

  play() {
    this.playing = true;
  }

  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }

  reset() {
    this.setTime(0);
  }

  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }

  detachAnimation(handle) {
    this.animations.delete(handle);
  }

  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }

      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }

  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;

    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }

}
//# sourceMappingURL=timeline.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ConeGeometry; });
/* harmony import */ var _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./truncated-cone-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


class ConeGeometry extends _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])('cone-geometry'),
      radius = 1,
      cap = true
    } = props;
    super({ ...props,
      id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    });
  }

}
//# sourceMappingURL=cone-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CubeGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


const CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
const CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
const CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
const CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
const ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};
class CubeGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])('cube-geometry')
    } = props;
    super({ ...props,
      id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: { ...ATTRIBUTES,
        ...props.attributes
      }
    });
  }

}
//# sourceMappingURL=cube-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CylinderGeometry; });
/* harmony import */ var _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./truncated-cone-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


class CylinderGeometry extends _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])('cylinder-geometry'),
      radius = 1
    } = props;
    super({ ...props,
      id,
      bottomRadius: radius,
      topRadius: radius
    });
  }

}
//# sourceMappingURL=cylinder-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IcoSphereGeometry; });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");



const ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
const ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
class IcoSphereGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["uid"])('ico-sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateIcosaHedron(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI = Math.PI;
  const PI2 = PI * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();

  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = "".concat(mini, "|").concat(maxi);

      if (key in pointMemo) {
        return pointMemo[key];
      }

      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();

  for (let i = 0; i < iterations; i++) {
    const indices2 = [];

    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }

    indices = indices2;
  }

  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;

  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Vector3"](vec1).cross(vec2).normalize();
    let newIndex;

    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }

    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }

  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
//# sourceMappingURL=ico-sphere-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PlaneGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony import */ var _geometry_geometry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry-utils */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");



class PlaneGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["uid"])('plane-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselatePlane(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

function tesselatePlane(props) {
  const {
    type = 'x,y',
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(',');
  let c1len = props["".concat(coords[0], "len")] || 1;
  const c2len = props["".concat(coords[1], "len")] || 1;
  const subdivisions1 = props["n".concat(coords[0])] || 1;
  const subdivisions2 = props["n".concat(coords[1])] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);

  if (flipCull) {
    c1len = -c1len;
  }

  let i2 = 0;
  let i3 = 0;

  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;

      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;

        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;

        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;

        default:
          throw new Error('PlaneGeometry: unknown type');
      }

      i2 += 2;
      i3 += 3;
    }
  }

  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }

  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? Object(_geometry_geometry_utils__WEBPACK_IMPORTED_MODULE_1__["unpackIndexedGeometry"])(geometry) : geometry;
}
//# sourceMappingURL=plane-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphereGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


class SphereGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])('sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateSphere(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    const value = radius;

    radius = (n1, n2, n3, u, v) => value;
  }

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);

  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }

  const numVertsAround = nlong + 1;

  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }

  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
//# sourceMappingURL=sphere-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TruncatedConeGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


const INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};
class TruncatedConeGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])('truncated-code-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateTruncatedCone(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = 'y',
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;

  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;

    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }

    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin = msin(j * mpi * 2 / nradial);
      const cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }

  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }

  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
//# sourceMappingURL=truncated-cone-geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js ***!
  \****************************************************************************************************/
/*! exports provided: unpackIndexedGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpackIndexedGeometry", function() { return unpackIndexedGeometry; });
function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;

  if (!indices) {
    return geometry;
  }

  const vertexCount = indices.value.length;
  const unpackedAttributes = {};

  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value,
      size
    } = attribute;

    if (constant || !size) {
      continue;
    }

    const unpackedValue = new value.constructor(vertexCount * size);

    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];

      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }

    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }

  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
//# sourceMappingURL=geometry-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js ***!
  \**********************************************************************************************/
/*! exports provided: DRAW_MODE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DRAW_MODE", function() { return DRAW_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Geometry; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");

const DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
class Geometry {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }

  constructor(props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["uid"])('geometry'),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};

    this._setAttributes(attributes, indices);

    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }

  get mode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }

  _print(attributeName) {
    return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
  }

  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }

    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];
      attribute = ArrayBuffer.isView(attribute) ? {
        value: attribute
      } : attribute;
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));

      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }

      if (attributeName === 'indices') {
        Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }

    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }

    return this;
  }

  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }

    let vertexCount = Infinity;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        value,
        size,
        constant
      } = attribute;

      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(Number.isFinite(vertexCount));
    return vertexCount;
  }

}
//# sourceMappingURL=geometry.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/index.js":
/*!**********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/index.js ***!
  \**********************************************************************************/
/*! exports provided: AnimationLoop, Model, ProgramManager, Transform, Geometry, ConeGeometry, CubeGeometry, CylinderGeometry, IcoSphereGeometry, PlaneGeometry, SphereGeometry, TruncatedConeGeometry, Timeline, KeyFrames, ClipSpace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_animation_loop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/animation-loop */ "../../node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationLoop", function() { return _lib_animation_loop__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/model */ "../../node_modules/@luma.gl/engine/dist/esm/lib/model.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return _lib_model__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_program_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/program-manager */ "../../node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgramManager", function() { return _lib_program_manager__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _transform_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform/transform */ "../../node_modules/@luma.gl/engine/dist/esm/transform/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return _transform_transform__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return _geometry_geometry__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _geometries_cone_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometries/cone-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return _geometries_cone_geometry__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _geometries_cube_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geometries/cube-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return _geometries_cube_geometry__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _geometries_cylinder_geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geometries/cylinder-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return _geometries_cylinder_geometry__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _geometries_ico_sphere_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./geometries/ico-sphere-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcoSphereGeometry", function() { return _geometries_ico_sphere_geometry__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _geometries_plane_geometry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./geometries/plane-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return _geometries_plane_geometry__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _geometries_sphere_geometry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geometries/sphere-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return _geometries_sphere_geometry__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _geometries_truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./geometries/truncated-cone-geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TruncatedConeGeometry", function() { return _geometries_truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _animation_timeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./animation/timeline */ "../../node_modules/@luma.gl/engine/dist/esm/animation/timeline.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return _animation_timeline__WEBPACK_IMPORTED_MODULE_12__["Timeline"]; });

/* harmony import */ var _animation_key_frames__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./animation/key-frames */ "../../node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyFrames", function() { return _animation_key_frames__WEBPACK_IMPORTED_MODULE_13__["KeyFrames"]; });

/* harmony import */ var _utils_clip_space__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/clip-space */ "../../node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClipSpace", function() { return _utils_clip_space__WEBPACK_IMPORTED_MODULE_14__["default"]; });
















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationLoop; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_2__);



const isPage = Object(probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["isBrowser"])() && typeof document !== 'undefined';
let statIdCounter = 0;
class AnimationLoop {
  constructor(props = {}) {
    const {
      onCreateContext = opts => Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["createGLContext"])(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},
      onError,
      gl = null,
      glOptions = {},
      debug = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["lumaStats"].get("animation-loop-".concat(statIdCounter++))
    } = props;
    let {
      useDevicePixels = true
    } = props;

    if ('useDevicePixelRatio' in props) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].deprecated('useDevicePixelRatio', 'useDevicePixels')();
      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  delete() {
    this.stop();

    this._setDisplay(null);
  }

  setNeedsRedraw(reason) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }

  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }

    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }

    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }

    return this;
  }

  start(opts = {}) {
    if (this._running) {
      return this;
    }

    this._running = true;

    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }

      this._createWebGLContext(opts);

      this._createFramebuffer();

      this._startEventHandling();

      this._initializeCallbackData();

      this._updateCallbackData();

      this._resizeCanvasDrawingBuffer();

      this._resizeViewport();

      this._gpuTimeQuery = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Query"].isSupported(this.gl, ['timers']) ? new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Query"](this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then(appContext => {
      if (this._running) {
        this._addCallbackData(appContext || {});

        if (appContext !== false) {
          this._startLoop();
        }
      }
    });

    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }

    return this;
  }

  redraw() {
    if (this.isContextLost()) {
      return this;
    }

    this._beginTimers();

    this._setupFrame();

    this._updateCallbackData();

    this._renderFrame(this.animationProps);

    this._clearNeedsRedraw();

    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }

    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);

      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }

    this._endTimers();

    return this;
  }

  stop() {
    if (this._running) {
      this._finalizeCallbackData();

      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["cancelAnimationFrame"])(this._animationFrameId);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }

    return this;
  }

  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }

  detachTimeline() {
    this.timeline = null;
  }

  waitForRender() {
    this.setNeedsRedraw('waitForRender');

    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }

    return this._nextFramePromise;
  }

  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }

  isContextLost() {
    return this.gl.isContextLost();
  }

  onCreateContext(...args) {
    return this.props.onCreateContext(...args);
  }

  onInitialize(...args) {
    return this.props.onInitialize(...args);
  }

  onRender(...args) {
    return this.props.onRender(...args);
  }

  onFinalize(...args) {
    return this.props.onFinalize(...args);
  }

  getHTMLControlValue(id, defaultValue = 1) {
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }

  setViewParameters() {
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();
    return this;
  }

  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }

      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["cancelAnimationFrame"])(this._animationFrameId);
    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }

  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {
        if (isPage && document.readyState === 'complete') {
          resolve(document);
          return;
        }

        window.addEventListener('load', () => {
          resolve(document);
        });
      }) : Promise.resolve({});
    }

    return this._pageLoadPromise;
  }

  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }

    if (display) {
      display.animationLoop = this;
    }

    this.display = display;
  }

  _requestAnimationFrame(renderFrameCallback) {
    if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {
      return;
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["requestAnimationFrame"])(renderFrameCallback);
  }

  _renderFrame(...args) {
    if (this.display) {
      this.display._renderFrame(...args);

      return;
    }

    this.onRender(...args);
  }

  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }

  _setupFrame() {
    this._resizeCanvasDrawingBuffer();

    this._resizeViewport();

    this._resizeFramebuffer();
  }

  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }

  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();

    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }

    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }

    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }

    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }

  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }

  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }

  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["instrumentGLContext"])(this.props.gl, opts) : this.onCreateContext(opts);

    if (!Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL"])(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }

    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["resetParameters"])(this.gl);

    this._createInfoDiv();
  }

  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);

      if (html) {
        div.innerHTML = html;
      }
    }
  }

  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;

    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }

    return {
      width,
      height,
      aspect
    };
  }

  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }

  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["resizeGLContext"])(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }

  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this.gl);
    }
  }

  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }

  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();

    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }

    this.cpuTime.timeStart();
  }

  _endTimers() {
    this.cpuTime.timeEnd();

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }

  _startEventHandling() {
    const {
      canvas
    } = this.gl;

    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }

  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }

  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }

}
//# sourceMappingURL=animation-loop.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js ***!
  \********************************************************************************************/
/*! exports provided: getBuffersFromGeometry, inferAttributeAccessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBuffersFromGeometry", function() { return getBuffersFromGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferAttributeAccessor", function() { return inferAttributeAccessor; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");

const GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;

  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);

    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = { ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }

  if (indices) {
    const data = indices.value || indices;
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
      data,
      target: 34963
    }), accessor];
  }

  return buffers;
}

function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}

function inferAttributeAccessor(attributeName, attribute) {
  let category;

  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;

    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;

    default:
  }

  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;

    case 'uvs':
      attribute.size = attribute.size || 2;
      break;

    default:
  }

  Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
//# sourceMappingURL=model-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/lib/model.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/lib/model.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Model; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _program_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./program-manager */ "../../node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _model_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model-utils */ "../../node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js");





const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
const ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';

const NOOP = () => {};

const DRAW_PARAMS = {};
class Model {
  constructor(gl, props = {}) {
    const {
      id = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["uid"])('model')
    } = props;
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL"])(gl));
    this.id = id;
    this.gl = gl;
    this.id = props.id || Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["uid"])('Model');
    this.lastLogTime = 0;
    this.animated = false;
    this.initialize(props);
  }

  initialize(props) {
    this.props = {};
    this.programManager = props.programManager || _program_manager__WEBPACK_IMPORTED_MODULE_1__["default"].getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;
    const {
      program = null,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;
    this.userData = {};
    this.needsRedraw = true;
    this._attributes = {};
    this.attributes = {};
    this.uniforms = {};
    this.pickable = true;

    this._checkProgram();

    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
    this.vertexCount = props.vertexCount || 0;
    this.geometryBuffers = {};
    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;

    this._setModelProps(props);

    this.geometry = {};
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }

  setProps(props) {
    this._setModelProps(props);
  }

  delete() {
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }

    if (this._managedProgram) {
      this.programManager.release(this.program);
      this._managedProgram = false;
    }

    this.vertexArray.delete();

    this._deleteGeometryBuffers();
  }

  getDrawMode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  getInstanceCount() {
    return this.instanceCount;
  }

  getAttributes() {
    return this.attributes;
  }

  getProgram() {
    return this.program;
  }

  setProgram(props) {
    const {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this._programDirty = true;
  }

  getUniforms() {
    return this.uniforms;
  }

  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }

  setVertexCount(vertexCount) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }

  setInstanceCount(instanceCount) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }

  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();

    this._deleteGeometryBuffers();

    this.geometryBuffers = Object(_model_utils__WEBPACK_IMPORTED_MODULE_3__["getBuffersFromGeometry"])(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }

  setAttributes(attributes = {}) {
    if (Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["isObjectEmpty"])(attributes)) {
      return this;
    }

    const normalizedAttributes = {};

    for (const name in attributes) {
      const attribute = attributes[name];
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }

    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }

  setUniforms(uniforms = {}) {
    Object.assign(this.uniforms, uniforms);
    return this;
  }

  getModuleUniforms(opts) {
    this._checkProgram();

    const getUniforms = this.programManager.getUniforms(this.program);

    if (getUniforms) {
      return getUniforms(opts);
    }

    return {};
  }

  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }

  clear(opts) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["clear"])(this.program.gl, opts);
    return this;
  }

  draw(opts = {}) {
    this._checkProgram();

    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray
    } = opts;
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);
    let logPriority;

    if (_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].priority >= LOG_DRAW_PRIORITY) {
      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
    }

    const drawParams = this.vertexArray.getDrawParams();
    const {
      isIndexed = drawParams.isIndexed,
      indexType = drawParams.indexType,
      indexOffset = drawParams.indexOffset,
      vertexArrayInstanced = drawParams.isInstanced
    } = this.props;

    if (vertexArrayInstanced && !this.isInstanced) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].warn('Found instanced attributes on non-instanced model', this.id)();
    }

    const {
      isInstanced,
      instanceCount
    } = this;
    const {
      onBeforeRender = NOOP,
      onAfterRender = NOOP
    } = this.props;
    onBeforeRender();
    this.program.setUniforms(this.uniforms);
    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
      logPriority,
      uniforms: null,
      framebuffer,
      parameters,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray,
      transformFeedback,
      isIndexed,
      indexType,
      isInstanced,
      instanceCount,
      offset: isIndexed ? indexOffset : 0
    }));
    onAfterRender();

    if (_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].priority >= LOG_DRAW_PRIORITY) {
      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
    }

    return didDraw;
  }

  transform(opts = {}) {
    const {
      discard = true,
      feedbackBuffers,
      unbindModels = []
    } = opts;
    let {
      parameters
    } = opts;

    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }

    if (discard) {
      parameters = Object.assign({}, parameters, {
        [35977]: discard
      });
    }

    unbindModels.forEach(model => model.vertexArray.unbindBuffers());

    try {
      this.draw(Object.assign({}, opts, {
        parameters
      }));
    } finally {
      unbindModels.forEach(model => model.vertexArray.bindBuffers());
    }

    return this;
  }

  render(uniforms = {}) {
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();
    return this.setUniforms(uniforms).draw();
  }

  _setModelProps(props) {
    Object.assign(this.props, props);

    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }

    if ('pickable' in props) {
      this.pickable = props.pickable;
    }

    if ('instanceCount' in props) {
      this.instanceCount = props.instanceCount;
    }

    if ('geometry' in props) {
      this.setGeometry(props.geometry);
    }

    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }

    if ('_feedbackBuffers' in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }

  _checkProgram() {
    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;

    if (!needsUpdate) {
      return;
    }

    let {
      program
    } = this.programProps;

    if (program) {
      this._managedProgram = false;
    } else {
      const {
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = this.programProps;
      program = this.programManager.get({
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      });

      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }

      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(program instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["Program"], 'Model needs a program');
    this._programDirty = false;

    if (program === this.program) {
      return;
    }

    this.program = program;

    if (this.vertexArray) {
      this.vertexArray.setProps({
        program: this.program,
        attributes: this.vertexArray.attributes
      });
    } else {
      this.vertexArray = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["VertexArray"](this.gl, {
        program: this.program
      });
    }

    this.setUniforms(Object.assign({}, this.getModuleUniforms()));
  }

  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];

      if (buffer instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["Buffer"]) {
        buffer.delete();
      }
    }
  }

  _setAnimationProps(animationProps) {
    if (this.animated) {
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["assert"])(animationProps, 'Model.draw(): animated uniforms but no animationProps');
    }
  }

  _setFeedbackBuffers(feedbackBuffers = {}) {
    if (Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["isObjectEmpty"])(feedbackBuffers)) {
      return this;
    }

    const {
      gl
    } = this.program;
    this.transformFeedback = this.transformFeedback || new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["TransformFeedback"](gl, {
      program: this.program
    });
    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }

  _logDrawCallStart(logLevel) {
    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;

    if (Date.now() - this.lastLogTime < logDrawTimeout) {
      return undefined;
    }

    this.lastLogTime = Date.now();
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
      collapsed: _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].level <= 2
    })();
    return logLevel;
  }

  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
    if (logLevel === undefined) {
      return;
    }

    const attributeTable = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["getDebugTableForVertexArray"])({
      vertexArray,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    });
    const {
      table: uniformTable,
      unusedTable,
      unusedCount
    } = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["getDebugTableForUniforms"])({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });
    const {
      table: missingTable,
      count: missingCount
    } = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["getDebugTableForUniforms"])({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });

    if (missingCount > 0) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].log('MISSING UNIFORMS', Object.keys(missingTable))();
    }

    if (unusedCount > 0) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].log('UNUSED UNIFORMS', Object.keys(unusedTable))();
    }

    const configTable = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["getDebugTableForProgramConfiguration"])(this.vertexArray.configuration);
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].table(logLevel, attributeTable)();
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].table(logLevel, uniformTable)();
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].table(logLevel + 1, configTable)();

    if (framebuffer) {
      framebuffer.log({
        logLevel: LOG_DRAW_PRIORITY,
        message: "Rendered to ".concat(framebuffer.id)
      });
    }

    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__["log"].groupEnd(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id))();
  }

}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProgramManager; });
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


class ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
    return gl.luma.defaultProgramManager;
  }

  constructor(gl) {
    this.gl = gl;
    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._hookFunctions = [];
    this._defaultModules = [];
    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0;
    this._useCounts = {};
  }

  addDefaultModule(module) {
    if (!this._defaultModules.find(m => m.name === module.name)) {
      this._defaultModules.push(module);
    }

    this.stateHash++;
  }

  removeDefaultModule(module) {
    const moduleName = typeof module === 'string' ? module : module.name;
    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);
    this.stateHash++;
  }

  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, {
        hook
      });
    }

    this._hookFunctions.push(hook);

    this.stateHash++;
  }

  get(props = {}) {
    const {
      vs = '',
      fs = '',
      defines = {},
      inject = {},
      varyings = [],
      bufferMode = 0x8c8d,
      transpileToGLSL100 = false
    } = props;

    const modules = this._getModuleList(props.modules);

    const vsHash = this._getHash(vs);

    const fsHash = this._getHash(fs);

    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();
    const varyingHashes = varyings.map(v => this._getHash(v));
    const defineKeys = Object.keys(defines).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];

    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines[key]));
    }

    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }

    const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join('/'), "M").concat(moduleHashes.join('/'), "I").concat(injectHashes.join('/'), "V").concat(varyingHashes.join('/'), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? 'T' : '');

    if (!this._programCache[hash]) {
      const assembled = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__["assembleShaders"])(this.gl, {
        vs,
        fs,
        modules,
        inject,
        defines,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100
      });
      this._programCache[hash] = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Program"](this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });

      this._getUniforms[hash] = assembled.getUniforms || (x => {});

      this._useCounts[hash] = 0;
    }

    this._useCounts[hash]++;
    return this._programCache[hash];
  }

  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }

  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;

    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();

      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }

  _getHash(key) {
    if (this._hashes[key] === undefined) {
      this._hashes[key] = this._hashCounter++;
    }

    return this._hashes[key];
  }

  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count = 0;

    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = module.name;
      modules[count++] = module;
      seen[name] = true;
    }

    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = module.name;

      if (!seen[name]) {
        modules[count++] = module;
        seen[name] = true;
      }
    }

    modules.length = count;
    return modules;
  }

}
//# sourceMappingURL=program-manager.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferTransform; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");



class BufferTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }

  updateModelProps(props = {}) {
    const {
      varyings
    } = this;

    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }

    return props;
  }

  getDrawOptions(opts = {}) {
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }

  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update(opts = {}) {
    this._setupBuffers(opts);
  }

  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;

    if (!bufferOrParams) {
      return null;
    }

    return bufferOrParams instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"] ? bufferOrParams : bufferOrParams.buffer;
  }

  getData(options = {}) {
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);

    if (buffer) {
      return buffer.getData();
    }

    return null;
  }

  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }

  _initialize(props = {}) {
    this._setupBuffers(props);

    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);

    if (this.varyings.length > 0) {
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl));
    }
  }

  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};

    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }

    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];

        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }

    Object.assign(feedbackBuffers, props.feedbackBuffers);

    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];

      if (typeof bufferOrRef === 'string') {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }

    return feedbackBuffers;
  }

  _setupBuffers(props = {}) {
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);

    const feedbackBuffers = this._getFeedbackBuffers(props);

    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }

  _setupTransformFeedback(binding, {
    model
  }) {
    const {
      program
    } = model;
    binding.transformFeedback = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["TransformFeedback"](this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }

  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }

    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);

    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }

    return binding;
  }

  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }

    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);

    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(feedbackBuffers[dstName] instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"]);
    }

    return {
      sourceBuffers,
      feedbackBuffers
    };
  }

  _createNewBuffer(name, opts) {
    const buffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"](this.gl, opts);

    if (this.resources[name]) {
      this.resources[name].delete();
    }

    this.resources[name] = buffer;
    return buffer;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

}
//# sourceMappingURL=buffer-transform.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureTransform; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");
/* harmony import */ var _transform_shader_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transform-shader-utils */ "../../node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js");



const SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  updateModelProps(props = {}) {
    const updatedModelProps = this._processVertexShader(props);

    return Object.assign({}, props, updatedModelProps);
  }

  getDrawOptions(opts = {}) {
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;

    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;

      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }

      this._setSourceTextureParameters();

      const sizeUniforms = Object(_transform_shader_utils__WEBPACK_IMPORTED_MODULE_2__["getSizeUniforms"])({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }

    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }

    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }

  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update(opts = {}) {
    this._setupTextures(opts);
  }

  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }

  getData({
    packed = false
  } = {}) {
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["readPixelsToArray"])(framebuffer);

    if (!packed) {
      return pixels;
    }

    const ArrayType = pixels.constructor;
    const channelCount = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["typeToChannelCount"])(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;

    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }

    return packedPixels;
  }

  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }

  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }

  _initialize(props = {}) {
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;

    this._setupTextures(props);
  }

  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;

    if (textureOrReference instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture2D"]) {
      return textureOrReference;
    }

    const refTexture = sourceTextures[textureOrReference];

    if (!refTexture) {
      return null;
    }

    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }

  _setupTextures(props = {}) {
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;

    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });

    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;

    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });

    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }

  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }

    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });

    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }

    this.elementCount = elementCount;
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }

  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;

    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }

    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);

    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;

      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](this.gl, {
          id: "transform-framebuffer",
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }

    return binding;
  }

  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];

    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }

  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }

    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }

  _createNewTexture(refTexture) {
    const texture = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cloneTextureFrom"])(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });

    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    this.ownTexture = texture;
    return texture;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

  _processVertexShader(props = {}) {
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = Object(_transform_shader_utils__WEBPACK_IMPORTED_MODULE_2__["updateForTextures"])({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["combineInjects"])([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs = props._fs || Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getPassthroughFS"])({
      version: Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getShaderVersion"])(vs),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["_transform"]].concat(props.modules || []) : props.modules;
    return {
      vs,
      fs,
      modules,
      uniforms,
      inject: combinedInject
    };
  }

}
//# sourceMappingURL=texture-transform.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js ***!
  \*************************************************************************************************************/
/*! exports provided: updateForTextures, getSizeUniforms, getVaryingType, processAttributeDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateForTextures", function() { return updateForTextures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeUniforms", function() { return getSizeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVaryingType", function() { return getVaryingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processAttributeDefinition", function() { return processAttributeDefinition; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");


const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';
function updateForTextures({
  vs,
  sourceTextureMap,
  targetTextureVarying,
  targetTexture
}) {
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);

        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["combineInjects"])([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }

      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["combineInjects"])([finalInject, inject]);
    }

    updatedVs = updateVsLines.join('\n');
  }

  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms({
  sourceTextureMap,
  targetTextureVarying,
  targetTexture
}) {
  const uniforms = {};
  let width;
  let height;

  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }

  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }

  return uniforms;
}

function getAttributeDefinition(line) {
  return Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getQualifierDetails"])(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}

function getVaryingType(line, varying) {
  const qualaiferDetails = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getQualifierDetails"])(line, ['varying', 'out']);

  if (!qualaiferDetails) {
    return null;
  }

  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);

  if (!attributeData) {
    return null;
  }

  const {
    type,
    name
  } = attributeData;

  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["typeToChannelSuffix"])(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }

  return null;
}
//# sourceMappingURL=transform-shader-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/transform/transform.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/transform/transform.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Transform; });
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");
/* harmony import */ var _buffer_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer-transform */ "../../node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js");
/* harmony import */ var _texture_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-transform */ "../../node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/model */ "../../node_modules/@luma.gl/engine/dist/esm/lib/model.js");






class Transform {
  static isSupported(gl) {
    return Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;

    this._initialize(props);

    Object.seal(this);
  }

  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;

    if (model) {
      model.delete();
    }

    if (bufferTransform) {
      bufferTransform.delete();
    }

    if (textureTransform) {
      textureTransform.delete();
    }
  }

  run(opts = {}) {
    const {
      clearRenderTarget = true
    } = opts;

    const updatedOpts = this._updateDrawOptions(opts);

    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }

    this.model.transform(updatedOpts);
  }

  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["assert"])(swapped, 'Nothing to swap');
  }

  getBuffer(varyingName = null) {
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }

  getData(opts = {}) {
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);

      if (data) {
        return data;
      }
    }

    return null;
  }

  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }

  update(opts = {}) {
    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }

    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }

  _initialize(props = {}) {
    const {
      gl
    } = this;

    this._buildResourceTransforms(gl, props);

    props = this._updateModelProps(props);
    this.model = new _lib_model__WEBPACK_IMPORTED_MODULE_5__["default"](gl, Object.assign({}, props, {
      fs: props.fs || Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__["getPassthroughFS"])({
        version: Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["getShaderVersion"])(props.vs)
      }),
      id: props.id || 'transform-model',
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }

  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }

    return updatedProps;
  }

  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _buffer_transform__WEBPACK_IMPORTED_MODULE_1__["default"](gl, props);
    }

    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _texture_transform__WEBPACK_IMPORTED_MODULE_2__["default"](gl, props);
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["assert"])(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');
  }

  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }

    return updatedOpts;
  }

}

function canCreateBufferTransform(props) {
  if (!Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(props.feedbackBuffers) || !Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }

  return false;
}

function canCreateTextureTransform(props) {
  if (!Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }

  return false;
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClipSpace; });
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/model */ "../../node_modules/@luma.gl/engine/dist/esm/lib/model.js");
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry */ "../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");


const CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
class ClipSpace extends _lib_model__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);
    super(gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__["default"]({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    }));
    this.setVertexCount(4);
  }

}
//# sourceMappingURL=clip-space.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createGLTFModel; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");
/* harmony import */ var _scenegraph_model_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scenegraph/model-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js");
/* harmony import */ var _gltf_material_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gltf-material-parser */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js");





const vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
const fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";

function addVersionToShader(gl, source) {
  if (Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl)) {
    return "#version 300 es\n".concat(source);
  }

  return source;
}

function createGLTFModel(gl, options) {
  const {
    id,
    drawMode,
    vertexCount,
    attributes,
    modelOptions
  } = options;
  const materialParser = new _gltf_material_parser__WEBPACK_IMPORTED_MODULE_4__["default"](gl, options);
  _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].info(4, 'createGLTFModel defines: ', materialParser.defines)();
  const managedResources = [];
  managedResources.push(...materialParser.generatedTextures);
  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));
  const model = new _scenegraph_model_node__WEBPACK_IMPORTED_MODULE_3__["default"](gl, Object.assign({
    id,
    drawMode,
    vertexCount,
    modules: [_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["pbr"]],
    defines: materialParser.defines,
    parameters: materialParser.parameters,
    vs: addVersionToShader(gl, vs),
    fs: addVersionToShader(gl, fs),
    managedResources
  }, modelOptions));
  model.setProps({
    attributes
  });
  model.setUniforms(materialParser.uniforms);
  return model;
}
//# sourceMappingURL=create-gltf-model.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createGLTFObjects; });
/* harmony import */ var _gltf_instantiator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf-instantiator */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js");

function createGLTFObjects(gl, gltf, options) {
  const instantiator = new _gltf_instantiator__WEBPACK_IMPORTED_MODULE_0__["default"](gl, options);
  const scenes = instantiator.instantiate(gltf);
  const animator = instantiator.createAnimator();
  return {
    scenes,
    animator
  };
}
//# sourceMappingURL=create-gltf-objects.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js ***!
  \*****************************************************************************************************/
/*! exports provided: ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_TYPE_TO_COMPONENTS", function() { return ATTRIBUTE_TYPE_TO_COMPONENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", function() { return ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFAnimator; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");


const ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};

function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const length = components * accessor.count;
    const {
      buffer,
      byteOffset
    } = accessor.bufferView.data;
    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);

    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];

      for (let i = 0; i < array.length; i += components) {
        slicedArray.push(Array.from(array.slice(i, i + components)));
      }

      accessor._animation = slicedArray;
    }
  }

  return accessor._animation;
}

const helperMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();

  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }

  if (gltfNode.rotation) {
    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }

  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}

const quaternion = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();

function linearInterpolate(target, path, start, stop, ratio) {
  if (path === 'rotation') {
    quaternion.slerp({
      start,
      target: stop,
      ratio
    });

    for (let i = 0; i < quaternion.length; i++) {
      target[path][i] = quaternion[i];
    }
  } else {
    for (let i = 0; i < start.length; i++) {
      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];
    }
  }
}

function cubicsplineInterpolate(target, path, {
  p0,
  outTangent0,
  inTangent1,
  p1,
  tDiff,
  ratio: t
}) {
  for (let i = 0; i < target[path].length; i++) {
    const m0 = outTangent0[i] * tDiff;
    const m1 = inTangent1[i] * tDiff;
    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}

function stepInterpolate(target, path, value) {
  for (let i = 0; i < value.length; i++) {
    target[path][i] = value[i];
  }
}

function interpolate(time, {
  input,
  interpolation,
  output
}, target, path) {
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex(t => t >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);

  if (!Array.isArray(target[path])) {
    switch (path) {
      case 'translation':
        target[path] = [0, 0, 0];
        break;

      case 'rotation':
        target[path] = [0, 0, 0, 1];
        break;

      case 'scale':
        target[path] = [1, 1, 1];
        break;

      default:
        _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].warn("Bad animation path ".concat(path))();
    }
  }

  Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(target[path].length === output[previousIndex].length);
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];

  switch (interpolation) {
    case 'STEP':
      stepInterpolate(target, path, output[previousIndex]);
      break;

    case 'LINEAR':
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }

      break;

    case 'CUBICSPLINE':
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, {
          p0,
          outTangent0,
          inTangent1,
          p1,
          tDiff,
          ratio
        });
      }

      break;

    default:
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].warn("Interpolation ".concat(interpolation, " not supported"))();
      break;
  }
}

class GLTFAnimation {
  constructor(props) {
    this.startTime = 0;
    this.playing = true;
    this.speed = 1;
    this.channels = [];
    Object.assign(this, props);
  }

  animate(timeMs) {
    if (!this.playing) {
      return;
    }

    const absTime = timeMs / 1000;
    const time = (absTime - this.startTime) * this.speed;
    this.channels.forEach(({
      sampler,
      target,
      path
    }) => {
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }

}

class GLTFAnimator {
  constructor(gltf) {
    this.animations = gltf.animations.map((animation, index) => {
      const name = animation.name || "Animation-".concat(index);
      const samplers = animation.samplers.map(({
        input,
        interpolation = 'LINEAR',
        output
      }) => ({
        input: accessorToJsArray(gltf.accessors[input]),
        interpolation,
        output: accessorToJsArray(gltf.accessors[output])
      }));
      const channels = animation.channels.map(({
        sampler,
        target
      }) => ({
        sampler: samplers[sampler],
        target: gltf.nodes[target.node],
        path: target.path
      }));
      return new GLTFAnimation({
        name,
        channels
      });
    });
  }

  animate(time) {
    this.setTime(time);
  }

  setTime(time) {
    this.animations.forEach(animation => animation.animate(time));
  }

  getAnimations() {
    return this.animations;
  }

}
//# sourceMappingURL=gltf-animator.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-environment.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-environment.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFEnvironment; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/images */ "../../node_modules/@loaders.gl/images/dist/esm/index.js");


class GLTFEnvironment {
  constructor(gl, {
    brdfLutUrl,
    getTexUrl,
    specularMipLevels = 10
  }) {
    this.gl = gl;
    this.brdfLutUrl = brdfLutUrl;
    this.getTexUrl = getTexUrl;
    this.specularMipLevels = specularMipLevels;
  }

  makeCube({
    id,
    getTextureForFace,
    parameters
  }) {
    const pixels = {};
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["TextureCube"].FACES.forEach(face => {
      pixels[face] = getTextureForFace(face);
    });
    return new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["TextureCube"](this.gl, {
      id,
      mipmaps: false,
      parameters,
      pixels
    });
  }

  getDiffuseEnvSampler() {
    if (!this._DiffuseEnvSampler) {
      this._DiffuseEnvSampler = this.makeCube({
        id: 'DiffuseEnvSampler',
        getTextureForFace: dir => Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["loadImage"])(this.getTexUrl('diffuse', dir, 0)),
        parameters: {
          [10242]: 33071,
          [10243]: 33071,
          [10241]: 9729,
          [10240]: 9729
        }
      });
    }

    return this._DiffuseEnvSampler;
  }

  getSpecularEnvSampler() {
    if (!this._SpecularEnvSampler) {
      this._SpecularEnvSampler = this.makeCube({
        id: 'SpecularEnvSampler',
        getTextureForFace: dir => {
          const imageArray = [];

          for (let lod = 0; lod <= this.specularMipLevels - 1; lod++) {
            imageArray.push(Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["loadImage"])(this.getTexUrl('specular', dir, lod)));
          }

          return imageArray;
        },
        parameters: {
          [10242]: 33071,
          [10243]: 33071,
          [10241]: 9987,
          [10240]: 9729
        }
      });
    }

    return this._SpecularEnvSampler;
  }

  getBrdfTexture() {
    if (!this._BrdfTexture) {
      this._BrdfTexture = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.gl, {
        id: 'brdfLUT',
        parameters: {
          [10242]: 33071,
          [10243]: 33071,
          [10241]: 9729,
          [10240]: 9729
        },
        data: Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["loadImage"])(this.brdfLutUrl)
      });
    }

    return this._BrdfTexture;
  }

  delete() {
    if (this._DiffuseEnvSampler) {
      this._DiffuseEnvSampler.delete();

      this._DiffuseEnvSampler = null;
    }

    if (this._SpecularEnvSampler) {
      this._SpecularEnvSampler.delete();

      this._SpecularEnvSampler = null;
    }

    if (this._BrdfTexture) {
      this._BrdfTexture.delete();

      this._BrdfTexture = null;
    }
  }

}
//# sourceMappingURL=gltf-environment.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFInstantiator; });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scenegraph/group-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js");
/* harmony import */ var _gltf_animator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf-animator */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js");
/* harmony import */ var _create_gltf_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./create-gltf-model */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js");





const ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
const DEFAULT_OPTIONS = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: null,
  lights: true,
  useTangents: false
};
class GLTFInstantiator {
  constructor(gl, options = {}) {
    this.gl = gl;
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
  }

  instantiate(gltf) {
    this.gltf = gltf;
    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));
    return scenes;
  }

  createAnimator() {
    if (Array.isArray(this.gltf.animations)) {
      return new _gltf_animator__WEBPACK_IMPORTED_MODULE_3__["default"](this.gltf);
    }

    return null;
  }

  createScene(gltfScene) {
    const gltfNodes = gltfScene.nodes || [];
    const nodes = gltfNodes.map(node => this.createNode(node));
    const scene = new _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_2__["default"]({
      id: gltfScene.name || gltfScene.id,
      children: nodes
    });
    return scene;
  }

  createNode(gltfNode) {
    if (!gltfNode._node) {
      const gltfChildren = gltfNode.children || [];
      const children = gltfChildren.map(child => this.createNode(child));

      if (gltfNode.mesh) {
        children.push(this.createMesh(gltfNode.mesh));
      }

      const node = new _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_2__["default"]({
        id: gltfNode.name || gltfNode.id,
        children
      });

      if (gltfNode.matrix) {
        node.setMatrix(gltfNode.matrix);
      } else {
        node.matrix.identity();

        if (gltfNode.translation) {
          node.matrix.translate(gltfNode.translation);
        }

        if (gltfNode.rotation) {
          const rotationMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]().fromQuaternion(gltfNode.rotation);
          node.matrix.multiplyRight(rotationMatrix);
        }

        if (gltfNode.scale) {
          node.matrix.scale(gltfNode.scale);
        }
      }

      gltfNode._node = node;
    }

    return gltfNode._node;
  }

  createMesh(gltfMesh) {
    if (!gltfMesh._mesh) {
      const gltfPrimitives = gltfMesh.primitives || [];
      const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));
      const mesh = new _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_2__["default"]({
        id: gltfMesh.name || gltfMesh.id,
        children: primitives
      });
      gltfMesh._mesh = mesh;
    }

    return gltfMesh._mesh;
  }

  getVertexCount(attributes) {
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].warn('getVertexCount() not found')();
  }

  createPrimitive(gltfPrimitive, i, gltfMesh) {
    return Object(_create_gltf_model__WEBPACK_IMPORTED_MODULE_4__["default"])(this.gl, Object.assign({
      id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i),
      drawMode: gltfPrimitive.mode || 4,
      vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
      attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
      material: gltfPrimitive.material
    }, this.options));
  }

  createAttributes(attributes, indices) {
    const loadedAttributes = {};
    Object.keys(attributes).forEach(attrName => {
      loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
    });

    if (indices) {
      loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
    }

    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].info(4, 'glTF Attributes', {
      attributes,
      indices,
      generated: loadedAttributes
    })();
    return loadedAttributes;
  }

  createBuffer(attribute, target) {
    if (!attribute.bufferView) {
      attribute.bufferView = {};
    }

    const {
      bufferView
    } = attribute;

    if (!bufferView.lumaBuffers) {
      bufferView.lumaBuffers = {};
    }

    if (!bufferView.lumaBuffers[target]) {
      bufferView.lumaBuffers[target] = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"](this.gl, {
        id: "from-".concat(bufferView.id),
        data: bufferView.data || attribute.value,
        target
      });
    }

    return bufferView.lumaBuffers[target];
  }

  createAccessor(accessor, buffer) {
    return new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Accessor"]({
      buffer,
      offset: accessor.byteOffset || 0,
      stride: accessor.bufferView.byteStride || 0,
      type: accessor.componentType,
      size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]
    });
  }

  createSampler(gltfSampler) {
    return gltfSampler;
  }

  needsPOT() {
    return false;
  }

}
//# sourceMappingURL=gltf-instantiator.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFMaterialParser; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");

class GLTFMaterialParser {
  constructor(gl, {
    attributes,
    material,
    pbrDebug,
    imageBasedLightingEnvironment,
    lights,
    useTangents
  }) {
    this.gl = gl;
    this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    };

    if (Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["hasFeature"])(gl, _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_TEXTURE_LOD)) {
      this.defines.USE_TEX_LOD = 1;
    }

    this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    };
    this.parameters = {};
    this.generatedTextures = [];

    if (imageBasedLightingEnvironment) {
      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
      this.uniforms.u_ScaleIBLAmbient = [1, 1];
    }

    if (pbrDebug) {
      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
    }

    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');
    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');
    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');
    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');
    this.defineIfPresent(lights, 'USE_LIGHTS');
    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');

    if (material) {
      this.parseMaterial(material);
    }
  }

  defineIfPresent(value, name) {
    if (value) {
      this.defines[name] = 1;
    }
  }

  parseTexture(gltfTexture, name, define = null) {
    const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
    const image = gltfTexture.texture.source.image;
    let textureOptions;
    let specialTextureParameters = {};

    if (image.compressed) {
      textureOptions = image;
      specialTextureParameters = {
        [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
      };
    } else {
      textureOptions = {
        data: image
      };
    }

    const texture = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.gl, {
      id: gltfTexture.name || gltfTexture.id,
      parameters: { ...parameters,
        ...specialTextureParameters
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: false
      },
      ...textureOptions
    });
    this.uniforms[name] = texture;
    this.defineIfPresent(define, define);
    this.generatedTextures.push(texture);
  }

  parsePbrMetallicRoughness(pbrMetallicRoughness) {
    if (pbrMetallicRoughness.baseColorTexture) {
      this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');
    }

    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];

    if (pbrMetallicRoughness.metallicRoughnessTexture) {
      this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');
    }

    const {
      metallicFactor = 1,
      roughnessFactor = 1
    } = pbrMetallicRoughness;
    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
  }

  parseMaterial(material) {
    this.uniforms.pbr_uUnlit = Boolean(material.unlit);

    if (material.pbrMetallicRoughness) {
      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
    }

    if (material.normalTexture) {
      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');
      const {
        scale = 1
      } = material.normalTexture;
      this.uniforms.u_NormalScale = scale;
    }

    if (material.occlusionTexture) {
      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');
      const {
        strength = 1
      } = material.occlusionTexture;
      this.uniforms.u_OcclusionStrength = strength;
    }

    if (material.emissiveTexture) {
      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');
      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
    }

    if (material.alphaMode === 'MASK') {
      const {
        alphaCutoff = 0.5
      } = material;
      this.defines.ALPHA_CUTOFF = 1;
      this.uniforms.u_AlphaCutoff = alphaCutoff;
    } else if (material.alphaMode === 'BLEND') {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].warn('BLEND alphaMode might not work well because it requires mesh sorting')();
      Object.assign(this.parameters, {
        blend: true,
        blendEquation: this.gl.FUNC_ADD,
        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
      });
    }
  }

}
//# sourceMappingURL=gltf-material-parser.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid-shaders.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid-shaders.js ***!
  \**************************************************************************************************************************/
/*! exports provided: HISTOPYRAMID_BUILD_VS_UTILS, HISTOPYRAMID_BUILD_VS, HISTOPYRAMID_BASE_BUILD_VS, HISTOPYRAMID_TRAVERSAL_UTILS, HISTOPYRAMID_TRAVERSAL_VS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTOPYRAMID_BUILD_VS_UTILS", function() { return HISTOPYRAMID_BUILD_VS_UTILS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTOPYRAMID_BUILD_VS", function() { return HISTOPYRAMID_BUILD_VS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTOPYRAMID_BASE_BUILD_VS", function() { return HISTOPYRAMID_BASE_BUILD_VS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTOPYRAMID_TRAVERSAL_UTILS", function() { return HISTOPYRAMID_TRAVERSAL_UTILS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTOPYRAMID_TRAVERSAL_VS", function() { return HISTOPYRAMID_TRAVERSAL_VS; });
const HISTOPYRAMID_BUILD_VS_UTILS = "// Get current pixel indices for a given size\nvec2 histoPyramid_getPixelIndices(vec2 size) {\n  vec2 pixelOffset = transform_getPixelSizeHalf(size);\n  vec2 pixelIndices = transform_getPixelIndices(size, pixelOffset);\n  return pixelIndices;\n}\n\n// returns the top left texture coordiante corresponding to 2X2 block in higher level texture.\n// size: lower level texture size\n// scale: usually (2, 2)\n// offset: offset with-in 2X2 block of higher level texture\nvec2 histoPyramid_getTexCoord(vec2 size, vec2 scale, vec2 offset) {\n  // use actual (scaled) texture size to calcualte offset (multiplied by scale)\n  vec2 scaledSize = size * scale;\n\n  // use minified texture size to find corresponding pixel index in out texture\n  vec2 pixelIndices = histoPyramid_getPixelIndices(size);\n\n  // now scale the indices to point to correct 2X2 block\n  pixelIndices = pixelIndices * scale;\n\n  // generate tex coordinate using actual size\n  vec2 texCoord = pixelIndices / scaledSize;\n  vec2 inPixelOffset = transform_getPixelSizeHalf(scaledSize);\n\n  return texCoord + (offset / scaledSize) + inPixelOffset;\n}\n\n// returns pixel value from higher level texture based on scale and offset\n// texSampler: higher level texture sampler\n// size: lower level texture size\n// scale: usually (2, 2)\n// offset: offset with-in 2X2 block of higher level texture\nvec4 histoPyramid_getInput(sampler2D texSampler, vec2 size, vec2 scale, vec2 offset) {\n  vec2 texCoord = histoPyramid_getTexCoord(size, scale, offset);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const HISTOPYRAMID_BUILD_VS = "attribute vec4 inTexture;\nvarying vec4 outTexture;\n\nvoid main()\n{\n  vec2 size = transform_uSize_outTexture;\n  vec2 scale = vec2(2., 2.);\n  vec4 pixel = histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 0));\n  vec4 rightPixel = histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 0));\n  vec4 bottomPixel = histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 1));\n  vec4 rightBottomPixel = histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 1));\n  // outTexture = pixel + rightPixel + bottomPixel + rightBottomPixel;\n  outTexture = vec4(\n    pixel.r + pixel.g + pixel.b + pixel.a,\n    rightPixel.r + rightPixel.g + rightPixel.b + rightPixel.a,\n    bottomPixel.r + bottomPixel.g + bottomPixel.b + bottomPixel.a,\n    rightBottomPixel.r + rightBottomPixel.g + rightBottomPixel.b + rightBottomPixel.a\n  );\n}\n";
const HISTOPYRAMID_BASE_BUILD_VS = "attribute vec4 inTexture;\nvarying vec4 outTexture;\nuniform int channel;\nuniform vec4 padingPixelValue;\n\nvoid main()\n{\n  vec2 size = transform_uSize_outTexture;\n  // vec2 scale = vec2(2., 2.);\n  vec2 scale = transform_uSize_inTexture / transform_uSize_outTexture;\n\n  // Verify if reference to a input texture pixel is out of bounds, if so treat the pixel as (0, 0)\n  vec2 pixelIndices = histoPyramid_getPixelIndices(size);\n  // now scale the indices padded size to point to correct 2X2 block\n  pixelIndices = pixelIndices * vec2(2, 2);\n\n  vec2 baseLevelSize = transform_uSize_inTexture;\n\n  // For all pixels outside of original texture size, return paddingPixelValue\n  bool xInside = pixelIndices.x < baseLevelSize.x;\n  bool yInside = pixelIndices.y < baseLevelSize.y;\n  bool xPlusOneInside = pixelIndices.x + 1. < baseLevelSize.x;\n  bool yPlusOneInside = pixelIndices.y + 1. < baseLevelSize.y;\n\n  vec4 pixel = (xInside && yInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 0))\n    : padingPixelValue;\n\n  vec4 rightPixel = (xPlusOneInside && yInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 0))\n    : padingPixelValue;\n\n  vec4 topPixel = (xInside && yPlusOneInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(0, 1))\n    : padingPixelValue;\n\n  vec4 rightTopPixel = (xPlusOneInside && yPlusOneInside)\n    ? histoPyramid_getInput(transform_uSampler_inTexture, size, scale, vec2(1, 1))\n    : padingPixelValue;\n\n  if (channel == 0) {\n    outTexture = vec4(pixel.r, rightPixel.r, topPixel.r, rightTopPixel.r);\n  }\n  if (channel == 1) {\n    outTexture = vec4(pixel.g, rightPixel.g, topPixel.g, rightTopPixel.g);\n  }\n  if (channel == 2) {\n    outTexture = vec4(pixel.b, rightPixel.b, topPixel.b, rightTopPixel.b);\n  }\n  if (channel == 3) {\n    outTexture = vec4(pixel.a, rightPixel.a, topPixel.a, rightTopPixel.a);\n  }\n}\n";
const HISTOPYRAMID_TRAVERSAL_UTILS = "// Check 2X2 texture block to find relative index the given key index falls into\n// 2X2 block is represented by a single RGBA weight\nint histopyramid_traversal_findRangeIndex(float currentKey, vec4 weights, out float lowerBound) {\n  lowerBound = 0.;\n  float higherBound = 0.;\n  int relativeIndex = 0;\n  for (int i = 0; i < 4; i++) {\n    higherBound = lowerBound + weights[i];\n    relativeIndex = i;\n    if (currentKey >= lowerBound && currentKey < higherBound) {\n      break;\n    }\n    lowerBound = higherBound;\n  }\n  return relativeIndex;\n}\n\n// Maps index in 2X2 block to texture coordiante\n// Assumes the traversal order of lower-left -> lower->right -> upper-left -> upper->right\nvec2 histopyramid_traversal_mapIndexToCoord(int index) {\n  // relativeIndex ->  relativeCoordiante\n  // 0 -> (0, 0)\n  // 1 -> (1, 0)\n  // 2 -> (0, 1)\n  // 3 -> (1, 1)\n  float relativeX = mod(float(index), 2.);\n  float relativeY = (index > 1) ? 1. : 0.;\n  return vec2(relativeX, relativeY);\n}\n\n// Reads weight value from flat histopyramid\nvec4 histopyramid_traversal_getWeight(sampler2D flatPyramid, vec2 size, int level, int numLevels, vec2 offset) {\n  // horizontal offset in flat pyramid for current level\n  float xOffset = pow(2., float(numLevels)) - pow(2., float(numLevels - level));\n  vec2 lowerLeft = vec2(xOffset, 0.);\n  vec2 pixelIndices = lowerLeft + offset;\n\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 coord = pixelIndices / size + pixelSizeHalf;\n\n  return texture2D(flatPyramid, coord);\n}\n";
const HISTOPYRAMID_TRAVERSAL_VS = "attribute float keyIndex;\nattribute vec4 flatPyramidTexture;\nvarying vec4 locationAndIndex;\nconst int MAX_LEVELS = 12; // assuming max texture size of 4K\n\nuniform int numLevels;\n\nvoid main()\n{\n  vec2 p = vec2(0., 0.);\n  float currentKey = keyIndex;\n  // for(int level = numLevels - 1; level <= 0; level--) {\n  for(int i = 1; i <= MAX_LEVELS; i++) {\n    int level = numLevels - i;\n    // #1. Get the current pixel values based on current level and current p\n    vec4 weights = histopyramid_traversal_getWeight(transform_uSampler_flatPyramidTexture, transform_uSize_flatPyramidTexture, level, numLevels, p);\n\n    // #2. Check the all weights in current 2X2 (4 values in RGBA channels) and determine the relative coordinate\n    float lowerBound = 0.;\n    int relativeIndex = histopyramid_traversal_findRangeIndex(currentKey, weights, lowerBound);\n    vec2 relativeCoord = histopyramid_traversal_mapIndexToCoord(relativeIndex);\n\n    //#3. Update P and key-index\n    p = 2.0 * p + relativeCoord;\n    currentKey -= lowerBound;\n    if (level == 0) { break; } // Work around for const expression restriction on for loops\n  }\n  locationAndIndex = vec4(p, currentKey, keyIndex);\n}\n";
//# sourceMappingURL=histopyramid-shaders.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid.js ***!
  \******************************************************************************************************************/
/*! exports provided: buildHistopyramidBaseLevel, getHistoPyramid, histoPyramidGenerateIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildHistopyramidBaseLevel", function() { return buildHistopyramidBaseLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHistoPyramid", function() { return getHistoPyramid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "histoPyramidGenerateIndices", function() { return histoPyramidGenerateIndices; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _luma_gl_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/engine */ "../../node_modules/@luma.gl/engine/dist/esm/index.js");
/* harmony import */ var _histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./histopyramid-shaders */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid-shaders.js");




function nextPowerOfTwo(x) {
  const p = Math.ceil(Math.log2(x));
  return Math.pow(2, p);
}

const channelToIndexMap = {
  r: 0,
  x: 0,
  g: 1,
  y: 1,
  b: 2,
  z: 2,
  a: 3,
  w: 3
};
function buildHistopyramidBaseLevel(gl, opts) {
  const {
    texture,
    channel = 'r',
    _readData = false
  } = opts;
  let {
    width,
    height
  } = texture;
  width = nextPowerOfTwo(width);
  height = nextPowerOfTwo(height);
  const size = (width > height ? width : height) / 2;
  const baseTexture = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cloneTextureFrom"])(texture, {
    width: size,
    height: size
  });
  const transform = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_1__["Transform"](gl, {
    _sourceTextures: {
      inTexture: texture
    },
    _targetTexture: baseTexture,
    _targetTextureVarying: 'outTexture',
    vs: "".concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_BUILD_VS_UTILS"]).concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_BASE_BUILD_VS"]),
    elementCount: baseTexture.width * baseTexture.height
  });
  transform.run({
    uniforms: {
      channel: channelToIndexMap[channel] || 0,
      padingPixelValue: [0, 0, 0, 0]
    }
  });
  let textureData;

  if (_readData || size === 1) {
    textureData = transform.getData({
      packed: true
    });
  }

  const flatPyramidSize = size * 2;
  const flatPyramidTexture = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cloneTextureFrom"])(texture, {
    width: flatPyramidSize,
    height: flatPyramidSize,
    parameters: {
      [10240]: 9728,
      [10241]: 9728
    }
  });
  const framebuffer = transform.getFramebuffer();
  Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["copyToTexture"])(framebuffer, flatPyramidTexture, {
    targetX: 0,
    width: size,
    height: size
  });
  return {
    textureData,
    baseTexture,
    flatPyramidTexture
  };
}
function getHistoPyramid(gl, opts) {
  const {
    textureData,
    baseTexture,
    flatPyramidTexture
  } = buildHistopyramidBaseLevel(gl, opts);
  const {
    width
  } = baseTexture;
  const levelCount = Math.log2(width) + 1;
  const pyramidTextures = [baseTexture];
  let topLevelData = textureData;

  if (levelCount > 1) {
    for (let i = 1; i < levelCount; i++) {
      const size = width / Math.pow(2, i);
      pyramidTextures.push(Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cloneTextureFrom"])(baseTexture, {
        width: size,
        height: size
      }));
    }

    const transform = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_1__["Transform"](gl, {
      _sourceTextures: {
        inTexture: pyramidTextures[0]
      },
      _targetTexture: pyramidTextures[1],
      _targetTextureVarying: 'outTexture',
      vs: "".concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_BUILD_VS_UTILS"]).concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_BUILD_VS"]),
      elementCount: pyramidTextures[1].width * pyramidTextures[1].height
    });
    let flatOffset = width;

    for (let i = 1; i < levelCount; i++) {
      const outSize = [pyramidTextures[i].width, pyramidTextures[i].height];
      transform.update({
        _sourceTextures: {
          inTexture: pyramidTextures[i - 1]
        },
        _targetTexture: pyramidTextures[i],
        elementCount: pyramidTextures[i].width * pyramidTextures[i].height
      });
      transform.run();
      const framebuffer = transform.getFramebuffer();
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["copyToTexture"])(framebuffer, flatPyramidTexture, {
        targetX: flatOffset,
        width: outSize[0],
        height: outSize[1]
      });
      flatOffset += outSize[0];
    }

    topLevelData = transform.getData();
  }

  return {
    pyramidTextures,
    flatPyramidTexture,
    levelCount,
    topLevelData
  };
}
function histoPyramidGenerateIndices(gl, opts) {
  const {
    flatPyramidTexture,
    levelCount,
    topLevelData
  } = getHistoPyramid(gl, opts);
  const keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];
  const keyIndex = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, new Float32Array(keyIndexCount).map((_, index) => index));
  const locationAndIndex = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, keyIndexCount * 4 * 4);
  const transform = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_1__["Transform"](gl, {
    sourceBuffers: {
      keyIndex
    },
    _sourceTextures: {
      flatPyramidTexture
    },
    feedbackBuffers: {
      locationAndIndex
    },
    varyings: ['locationAndIndex'],
    vs: "".concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_TRAVERSAL_UTILS"]).concat(_histopyramid_shaders__WEBPACK_IMPORTED_MODULE_2__["HISTOPYRAMID_TRAVERSAL_VS"]),
    elementCount: keyIndexCount
  });
  transform.run({
    uniforms: {
      numLevels: levelCount
    }
  });
  return {
    locationAndIndexBuffer: locationAndIndex
  };
}
//# sourceMappingURL=histopyramid.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/gpu-point-in-polygon.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/gpu-point-in-polygon.js ***!
  \******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GPUPointInPolygon; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/engine */ "../../node_modules/@luma.gl/engine/dist/esm/index.js");
/* harmony import */ var _texture_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture-filter */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/texture-filter.js");
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/shaders.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./polygon */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js");






const TEXTURE_SIZE = 512;
class GPUPointInPolygon {
  constructor(gl, opts = {}) {
    this.gl = gl;
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl));
    this.textureSize = TEXTURE_SIZE;

    this._setupResources();

    this.update(opts);
  }

  update({
    polygons,
    textureSize
  } = {}) {
    if (textureSize) {
      this.textureSize = textureSize;
    }

    if (!polygons || polygons.length === 0) {
      return;
    }

    const {
      vertices,
      indices,
      vertexCount,
      ids
    } = triangulatePolygons(polygons);

    this._updateResources(vertices, indices, ids, vertexCount);
  }

  filter({
    positionBuffer,
    filterValueIndexBuffer,
    count
  }) {
    this.filterTransform.update({
      sourceBuffers: {
        a_position: positionBuffer
      },
      feedbackBuffers: {
        filterValueIndex: filterValueIndexBuffer
      },
      elementCount: count
    });
    const {
      polygonTexture,
      boundingBox
    } = this;
    this.filterTransform.run({
      moduleSettings: {
        boundingBox,
        texture: polygonTexture
      }
    });
  }

  _setupResources() {
    const {
      gl
    } = this;
    this.polygonTexture = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](gl, {
      format: 6407,
      type: 5121,
      dataFormat: 6407,
      border: 0,
      mipmaps: false,
      parameters: {
        [10240]: 9728,
        [10241]: 9728,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.positionBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
      accessor: {
        type: 5126,
        size: 2
      }
    });
    this.idBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
      accessor: {
        type: 5126,
        size: 1
      }
    });
    this.indexBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](gl, {
      target: 34963,
      accessor: {
        type: 5123
      }
    });
    this.polyTextureTransform = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_2__["Transform"](gl, {
      id: "polygon-texture-creation-transform",
      elementCount: 0,
      _targetTexture: this.polygonTexture,
      _targetTextureVarying: 'v_polygonColor',
      vs: _shaders__WEBPACK_IMPORTED_MODULE_4__["POLY_TEX_VS"],
      drawMode: 4,
      isIndexed: true,
      sourceBuffers: {
        a_position: this.positionBuffer,
        a_polygonID: this.idBuffer,
        indices: this.indexBuffer
      }
    });
    this.filterTransform = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_2__["Transform"](gl, {
      id: 'filter transform',
      vs: _shaders__WEBPACK_IMPORTED_MODULE_4__["FILTER_VS"],
      modules: [_texture_filter__WEBPACK_IMPORTED_MODULE_3__["default"]],
      varyings: ['filterValueIndex']
    });
  }

  _updateResources(vertices, indices, ids, vertexCount) {
    const boundingBox = getBoundingBox(vertices, vertexCount);
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const width = xMax - xMin;
    const height = yMax - yMin;
    const whRatio = width / height;
    const {
      textureSize
    } = this;
    let texWidth = textureSize;
    let texHeight = textureSize;

    if (whRatio > 1) {
      texHeight = texWidth / whRatio;
    } else {
      texWidth = texHeight * whRatio;
    }

    this.boundingBox = boundingBox;
    this.polygonTexture.resize({
      width: texWidth,
      height: texHeight,
      mipmaps: false
    });
    this.positionBuffer.setData(new Float32Array(vertices));
    this.idBuffer.setData(new Float32Array(ids));
    this.indexBuffer.setData(new Uint16Array(indices));
    this.polyTextureTransform.update({
      elementCount: indices.length,
      _targetTexture: this.polygonTexture
    });
    this.polyTextureTransform.run({
      uniforms: {
        boundingBoxOriginSize: [xMin, yMin, width, height]
      }
    });
  }

}

function getBoundingBox(positions, vertexCount) {
  let yMin = Infinity;
  let yMax = -Infinity;
  let xMin = Infinity;
  let xMax = -Infinity;
  let y;
  let x;

  for (let i = 0; i < vertexCount; i++) {
    x = positions[i * 2];
    y = positions[i * 2 + 1];
    yMin = y < yMin ? y : yMin;
    yMax = y > yMax ? y : yMax;
    xMin = x < xMin ? x : xMin;
    xMax = x > xMax ? x : xMax;
  }

  return [xMin, yMin, xMax, yMax];
}

function triangulatePolygons(polygons) {
  const SIZE = 2;
  const vertices = [];
  const indices = [];
  const ids = [];
  let count = 0;
  let polygonId = 0;

  for (let i = 0; i < polygons.length; i++) {
    const normalized = _polygon__WEBPACK_IMPORTED_MODULE_5__["normalize"](polygons[i], SIZE);
    const curVertices = normalized.positions || normalized;
    const curCount = curVertices.length / SIZE;
    const curIds = new Array(curCount).fill(polygonId);
    vertices.push(...curVertices);
    ids.push(...curIds);
    const curIndices = _polygon__WEBPACK_IMPORTED_MODULE_5__["getSurfaceIndices"](normalized, SIZE);
    const indexCount = curIndices.length;

    for (let j = 0; j < indexCount; j++) {
      curIndices[j] += count;
    }

    count += curCount;
    indices.push(...curIndices);
    polygonId++;
  }

  Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"])(count < 65536);
  const vertexCount = _polygon__WEBPACK_IMPORTED_MODULE_5__["getVertexCount"](vertices, SIZE);
  return {
    vertices,
    indices,
    ids,
    vertexCount
  };
}
//# sourceMappingURL=gpu-point-in-polygon.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js ***!
  \*****************************************************************************************************************/
/*! exports provided: getVertexCount, normalize, getSurfaceIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertexCount", function() { return getVertexCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurfaceIndices", function() { return getSurfaceIndices; });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ "../../node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);

const PI_4 = Math.PI / 4;
const DEGREES_TO_RADIANS_HALF = Math.PI / 360;

function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;

  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}

function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}

function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}

function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }

  return true;
}

function copyNestedRing(target, targetStartIndex, simplePolygon, size) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;

  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }

  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }

  return targetIndex;
}

function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;

  if (srcLength <= 0) {
    return targetStartIndex;
  }

  let targetIndex = targetStartIndex;

  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }

  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }

  return targetIndex;
}

function getNestedVertexCount(simplePolygon) {
  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;
}

function getFlatVertexCount(positions, size, startIndex = 0, endIndex) {
  endIndex = endIndex || positions.length;

  if (startIndex >= endIndex) {
    return 0;
  }

  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;
}

function getVertexCount(polygon, positionSize, normalization = true) {
  if (!normalization) {
    polygon = polygon.positions || polygon;
    return polygon.length / positionSize;
  }

  validate(polygon);

  if (polygon.positions) {
    const {
      positions,
      holeIndices
    } = polygon;

    if (holeIndices) {
      let vertexCount = 0;

      for (let i = 0; i <= holeIndices.length; i++) {
        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);
      }

      return vertexCount;
    }

    polygon = positions;
  }

  if (Number.isFinite(polygon[0])) {
    return getFlatVertexCount(polygon, positionSize);
  }

  if (!isSimple(polygon)) {
    let vertexCount = 0;

    for (const simplePolygon of polygon) {
      vertexCount += getNestedVertexCount(simplePolygon);
    }

    return vertexCount;
  }

  return getNestedVertexCount(polygon);
}
function normalize(polygon, positionSize, vertexCount) {
  validate(polygon);
  vertexCount = vertexCount || getVertexCount(polygon, positionSize);
  const positions = new Float64Array(vertexCount * positionSize);
  const holeIndices = [];

  if (polygon.positions) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;

    if (srcHoleIndices) {
      let targetIndex = 0;

      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);
        holeIndices.push(targetIndex);
      }

      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }

    polygon = srcPositions;
  }

  if (Number.isFinite(polygon[0])) {
    copyFlatRing(positions, 0, polygon, positionSize);
    return positions;
  }

  if (!isSimple(polygon)) {
    let targetIndex = 0;

    for (const simplePolygon of polygon) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);
      holeIndices.push(targetIndex);
    }

    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }

  copyNestedRing(positions, 0, polygon, positionSize);
  return positions;
}
function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {
  let holeIndices = null;

  if (normalizedPolygon.holeIndices) {
    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);
  }

  let positions = normalizedPolygon.positions || normalizedPolygon;

  if (preproject) {
    const n = positions.length;
    positions = positions.slice();

    for (let i = 0; i < n; i += positionSize) {
      const y = positions[i + 1];
      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));
    }
  }

  return earcut__WEBPACK_IMPORTED_MODULE_0___default()(positions, holeIndices, positionSize);
}
//# sourceMappingURL=polygon.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/shaders.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/shaders.js ***!
  \*****************************************************************************************************************/
/*! exports provided: POLY_TEX_VS, FILTER_VS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLY_TEX_VS", function() { return POLY_TEX_VS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILTER_VS", function() { return FILTER_VS; });
const POLY_TEX_VS = "uniform vec4 boundingBoxOriginSize; //[xMin, yMin, xSize, ySize]\nattribute vec2 a_position;\nattribute float a_polygonID;\nvarying vec4 v_polygonColor;\nvoid main()\n{\n    // translate from bbox to NDC\n    vec2 pos = a_position - boundingBoxOriginSize.xy;\n    pos = pos / boundingBoxOriginSize.zw;\n    pos = pos * 2.0 - vec2(1.0);\n    gl_Position = vec4(pos, 0.0, 1.0);\n    v_polygonColor = vec4(a_polygonID, 1.0, 1.0, 1.0);\n}\n";
const FILTER_VS = "#version 300 es\nin vec2 a_position;\nout vec2 filterValueIndex; //[x: 0 (outside polygon)/1 (inside), y: position index]\nvoid main()\n{\n  filterValueIndex = textureFilter_filter(a_position);\n}\n";
//# sourceMappingURL=shaders.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/texture-filter.js":
/*!************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/texture-filter.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const vs = "\nuniform vec4 textureFilter_uBoundingBox; //[xMin, yMin, xSize, ySize]\nuniform sampler2D textureFilter_uTexture;\nvec2 textureFilter_filter(vec2 position) {\n  vec2 filterValueIndex;\n  // Transfrom 'pos' to texture coordinate\n  vec2 pos = position - textureFilter_uBoundingBox.xy;\n  pos = pos / textureFilter_uBoundingBox.zw;\n  filterValueIndex.y = float(gl_VertexID);\n  if (pos.x < 0. || pos.x > 1. || pos.y < 0. || pos.y > 1.) {\n    filterValueIndex.x = -1.;\n  } else {\n    // Red channel is ID, Green channel inside/outside polygon\n    vec4 color = texture(textureFilter_uTexture, pos.xy);\n    filterValueIndex.x = color.g > 0. ? color.r : -1.;\n  }\n  return filterValueIndex;\n}\n";

function getUniforms(opts = {}) {
  const uniforms = {};

  if (opts.boundingBox) {
    const [xMin, yMin, xMax, yMax] = opts.boundingBox;
    uniforms.textureFilter_uBoundingBox = [xMin, yMin, xMax - xMin, yMax - yMin];
  }

  if (opts.texture) {
    uniforms.textureFilter_uTexture = opts.texture;
  }

  return uniforms;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'texture-filter',
  vs,
  getUniforms
});
//# sourceMappingURL=texture-filter.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/index.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/index.js ***!
  \****************************************************************************************/
/*! exports provided: Display, VRDisplay, GLTFEnvironment, createGLTFObjects, GLTFMaterialParser, ScenegraphNode, GroupNode, ModelNode, buildHistopyramidBaseLevel, getHistoPyramid, histoPyramidGenerateIndices, GPUPointInPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webvr_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webvr/display */ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/display.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Display", function() { return _webvr_display__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _webvr_vr_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webvr/vr-display */ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/vr-display.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRDisplay", function() { return _webvr_vr_display__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _gltf_gltf_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gltf/gltf-environment */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-environment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFEnvironment", function() { return _gltf_gltf_environment__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _gltf_create_gltf_objects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf/create-gltf-objects */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLTFObjects", function() { return _gltf_create_gltf_objects__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _gltf_gltf_material_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gltf/gltf-material-parser */ "../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialParser", function() { return _gltf_gltf_material_parser__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _scenegraph_scenegraph_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scenegraph/scenegraph-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScenegraphNode", function() { return _scenegraph_scenegraph_node__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scenegraph/group-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupNode", function() { return _scenegraph_group_node__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _scenegraph_model_node__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scenegraph/model-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModelNode", function() { return _scenegraph_model_node__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _gpgpu_histopyramid_histopyramid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gpgpu/histopyramid/histopyramid */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildHistopyramidBaseLevel", function() { return _gpgpu_histopyramid_histopyramid__WEBPACK_IMPORTED_MODULE_8__["buildHistopyramidBaseLevel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHistoPyramid", function() { return _gpgpu_histopyramid_histopyramid__WEBPACK_IMPORTED_MODULE_8__["getHistoPyramid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histoPyramidGenerateIndices", function() { return _gpgpu_histopyramid_histopyramid__WEBPACK_IMPORTED_MODULE_8__["histoPyramidGenerateIndices"]; });

/* harmony import */ var _gpgpu_point_in_polygon_gpu_point_in_polygon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gpgpu/point-in-polygon/gpu-point-in-polygon */ "../../node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/gpu-point-in-polygon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GPUPointInPolygon", function() { return _gpgpu_point_in_polygon_gpu_point_in_polygon__WEBPACK_IMPORTED_MODULE_9__["default"]; });











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GroupNode; });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scenegraph-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js");



class GroupNode extends _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(props = {}) {
    props = Array.isArray(props) ? {
      children: props
    } : props;
    const {
      children = []
    } = props;
    _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["log"].assert(children.every(child => child instanceof _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__["default"]), 'every child must an instance of ScenegraphNode');
    super(props);
    this.children = children;
  }

  add(...children) {
    for (const child of children) {
      if (Array.isArray(child)) {
        this.add(...child);
      } else {
        this.children.push(child);
      }
    }

    return this;
  }

  remove(child) {
    const children = this.children;
    const indexOf = children.indexOf(child);

    if (indexOf > -1) {
      children.splice(indexOf, 1);
    }

    return this;
  }

  removeAll() {
    this.children = [];
    return this;
  }

  delete() {
    this.children.forEach(child => child.delete());
    this.removeAll();
    super.delete();
  }

  traverse(visitor, {
    worldMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]()
  } = {}) {
    const modelMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](worldMatrix).multiplyRight(this.matrix);

    for (const child of this.children) {
      if (child instanceof GroupNode) {
        child.traverse(visitor, {
          worldMatrix: modelMatrix
        });
      } else {
        visitor(child, {
          worldMatrix: modelMatrix
        });
      }
    }
  }

}
//# sourceMappingURL=group-node.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelNode; });
/* harmony import */ var _luma_gl_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/engine */ "../../node_modules/@luma.gl/engine/dist/esm/index.js");
/* harmony import */ var _scenegraph_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scenegraph-node */ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js");


class ModelNode extends _scenegraph_node__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    super(props);
    this.onBeforeRender = null;
    this.AfterRender = null;

    if (gl instanceof _luma_gl_engine__WEBPACK_IMPORTED_MODULE_0__["Model"]) {
      this.model = gl;

      this._setModelNodeProps(props);
    } else {
      this.model = new _luma_gl_engine__WEBPACK_IMPORTED_MODULE_0__["Model"](gl, props);
    }

    this.managedResources = props.managedResources || [];
  }

  setProps(props) {
    super.setProps(props);

    this._setModelNodeProps(props);

    return this;
  }

  delete() {
    if (this.model) {
      this.model.delete();
      this.model = null;
    }

    this.managedResources.forEach(resource => resource.delete());
    this.managedResources = [];
  }

  draw(...args) {
    return this.model.draw(...args);
  }

  setUniforms(...args) {
    this.model.setUniforms(...args);
    return this;
  }

  setAttributes(...args) {
    this.model.setAttributes(...args);
    return this;
  }

  updateModuleSettings(...args) {
    this.model.updateModuleSettings(...args);
    return this;
  }

  _setModelNodeProps(props) {
    this.model.setProps(props);
  }

}
//# sourceMappingURL=model-node.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScenegraphNode; });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");


class ScenegraphNode {
  constructor(props = {}) {
    const {
      id
    } = props;
    this.id = id || Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["uid"])(this.constructor.name);
    this.display = true;
    this.position = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    this.rotation = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    this.scale = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 1, 1);
    this.matrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    this.userData = {};
    this.props = {};

    this._setScenegraphNodeProps(props);
  }

  delete() {}

  setProps(props) {
    this._setScenegraphNodeProps(props);

    return this;
  }

  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }

  setPosition(position) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(position.length === 3, 'setPosition requires vector argument');
    this.position = position;
    return this;
  }

  setRotation(rotation) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(rotation.length === 3, 'setRotation requires vector argument');
    this.rotation = rotation;
    return this;
  }

  setScale(scale) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(scale.length === 3, 'setScale requires vector argument');
    this.scale = scale;
    return this;
  }

  setMatrix(matrix, copyMatrix = true) {
    if (copyMatrix) {
      this.matrix.copy(matrix);
    } else {
      this.matrix = matrix;
    }
  }

  setMatrixComponents({
    position,
    rotation,
    scale,
    update = true
  }) {
    if (position) {
      this.setPosition(position);
    }

    if (rotation) {
      this.setRotation(rotation);
    }

    if (scale) {
      this.setScale(scale);
    }

    if (update) {
      this.updateMatrix();
    }

    return this;
  }

  updateMatrix() {
    const pos = this.position;
    const rot = this.rotation;
    const scale = this.scale;
    this.matrix.identity();
    this.matrix.translate(pos);
    this.matrix.rotateXYZ(rot);
    this.matrix.scale(scale);
    return this;
  }

  update(options = {}) {
    const {
      position,
      rotation,
      scale
    } = options;

    if (position) {
      this.setPosition(position);
    }

    if (rotation) {
      this.setRotation(rotation);
    }

    if (scale) {
      this.setScale(scale);
    }

    this.updateMatrix();
    return this;
  }

  getCoordinateUniforms(viewMatrix, modelMatrix) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["assert"])(viewMatrix);
    modelMatrix = modelMatrix || this.matrix;
    const worldMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](viewMatrix).multiplyRight(modelMatrix);
    const worldInverse = worldMatrix.invert();
    const worldInverseTranspose = worldInverse.transpose();
    return {
      viewMatrix,
      modelMatrix,
      objectMatrix: modelMatrix,
      worldMatrix,
      worldInverseMatrix: worldInverse,
      worldInverseTransposeMatrix: worldInverseTranspose
    };
  }

  _setScenegraphNodeProps(props) {
    if ('display' in props) {
      this.display = props.display;
    }

    if ('position' in props) {
      this.setPosition(props.position);
    }

    if ('rotation' in props) {
      this.setRotation(props.rotation);
    }

    if ('scale' in props) {
      this.setScale(props.scale);
    }

    if ('matrix' in props) {
      this.setMatrix(props.matrix);
    }

    Object.assign(this.props, props);
  }

}
//# sourceMappingURL=scenegraph-node.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/display.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/webvr/display.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Display; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");

class Display {
  constructor() {
    this.animationLoop = null;
  }

  getViews(options) {
    const {
      width,
      height
    } = options;
    return [{
      params: {
        viewport: [0, 0, width, height],
        scissor: [0, 0, width, height],
        scissorTest: true
      }
    }];
  }

  submitFrame() {
    return true;
  }

  requestAnimationFrame(renderFrame) {
    return false;
  }

  delete() {}

  _renderFrame(options) {
    const views = this.getViews(options);

    if (!views) {
      return false;
    }

    const {
      gl
    } = this.animationLoop;

    for (const view of views) {
      Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, view.params, () => this.animationLoop.onRender({ ...options,
        ...view
      }));
    }

    this.submitFrame();
    return true;
  }

}
//# sourceMappingURL=display.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/vr-button.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/webvr/vr-button.js ***!
  \**************************************************************************************************/
/*! exports provided: createEnterVRButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEnterVRButton", function() { return createEnterVRButton; });
function createEnterVRButton({
  canvas,
  title
}) {
  const {
    top,
    left,
    width,
    height
  } = canvas.getBoundingClientRect();
  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = "".concat(top, "px");
  container.style.left = "".concat(left, "px");
  container.style.width = "".concat(width, "px");
  container.style.height = "".concat(height, "px");
  container.style.pointerEvents = 'none';
  container.style.zIndex = '999';
  document.body.appendChild(container);
  const button = document.createElement('button');
  button.style.padding = '16px';
  button.style.border = '1px solid #fff';
  button.style.borderRadius = '8px';
  button.style.background = 'rgba(0,0,0,0.5)';
  button.style.color = '#fff';
  button.style.font = 'normal 20px sans-serif';
  button.style.cursor = 'pointer';
  button.style.margin = '20px auto';
  button.style.display = 'block';
  button.style.pointerEvents = 'all';
  button.textContent = title;
  container.appendChild(button);
  return button;
}
//# sourceMappingURL=vr-button.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/vr-display.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/experimental/dist/esm/webvr/vr-display.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VRDisplay; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./display */ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/display.js");
/* harmony import */ var _vr_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vr-button */ "../../node_modules/@luma.gl/experimental/dist/esm/webvr/vr-button.js");



class VRDisplay extends _display__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported() {
    return typeof navigator !== 'undefined' && 'getVRDisplays' in navigator && 'VRFrameData' in window;
  }

  constructor(props) {
    super(props);
    this._vrSupported = VRDisplay.isSupported();

    if (this._vrSupported) {
      this.vrFrameData = new window.VRFrameData();
      this.vrPresenting = false;
      this.vrFrame = false;
      window.addEventListener('vrdisplaypresentchange', this._vrDisplayPresentChange.bind(this));
    }
  }

  delete() {
    super.delete();

    this._removeVRButton();
  }

  getViews(options) {
    if (this._vrSupported) {
      this._addVRButton();
    }

    if (this.vrPresenting && this.vrFrame) {
      this.vrDisplay.getFrameData(this.vrFrameData);
      const {
        leftProjectionMatrix,
        leftViewMatrix,
        rightProjectionMatrix,
        rightViewMatrix
      } = this.vrFrameData;
      const {
        width,
        height
      } = options;
      return [{
        displayEye: 'left',
        projectionMatrix: leftProjectionMatrix,
        viewMatrix: leftViewMatrix,
        params: {
          viewport: [0, 0, width * 0.5, height],
          scissor: [0, 0, width * 0.5, height],
          scissorTest: true
        }
      }, {
        displayEye: 'right',
        projectionMatrix: rightProjectionMatrix,
        viewMatrix: rightViewMatrix,
        params: {
          viewport: [width * 0.5, 0, width * 0.5, height],
          scissor: [width * 0.5, 0, width * 0.5, height],
          scissorTest: true
        }
      }];
    }

    return super.getViews(options);
  }

  submitFrame() {
    if (this.vrPresenting && this.vrFrame) {
      this.vrDisplay.submitFrame();
      return true;
    }

    return false;
  }

  requestAnimationFrame(renderFrame) {
    if (this.vrPresenting) {
      this.vrDisplay.requestAnimationFrame(() => {
        this.vrFrame = true;
        renderFrame();
        this.vrFrame = false;
      });
      return true;
    }

    return false;
  }

  async _addVRButton() {
    if (this.vrButton) {
      return;
    }

    const canvas = this._getCanvas();

    if (!canvas) {
      return;
    }

    const displays = await navigator.getVRDisplays();

    if (displays && displays.length) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].info(2, 'Found VR Displays', displays)();
      this.vrDisplay = displays[0];
      this.vrButton = Object(_vr_button__WEBPACK_IMPORTED_MODULE_2__["createEnterVRButton"])({
        canvas,
        title: "Enter VR (".concat(this.vrDisplay.displayName, ")")
      });

      this.vrButton.onclick = () => this._startDisplay();
    }
  }

  _getCanvas() {
    return this.animationLoop.canvas || this.animationLoop.gl && this.animationLoop.gl.canvas;
  }

  _removeVRButton() {
    if (this.vrButton) {}
  }

  _startDisplay() {
    this.vrDisplay.requestPresent([{
      source: this._getCanvas()
    }]);
  }

  _vrDisplayPresentChange() {
    if (this.vrDisplay.isPresenting) {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].info(2, 'Entering VR')();
      this.vrPresenting = true;
      this.vrButton.style.display = 'none';
    } else {
      _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"].info(2, 'Exiting VR')();
      this.vrPresenting = false;
      this.vrButton.style.display = 'block';
    }
  }

}
//# sourceMappingURL=vr-display.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/context/context.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/context/context.js ***!
  \*********************************************************************************************/
/*! exports provided: createGLContext, instrumentGLContext, getContextDebugInfo, resizeGLContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return createGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return instrumentGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return getContextDebugInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return resizeGLContext; });
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state-tracker/track-context-state */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/log */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");
/* harmony import */ var _utils_device_pixels__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/device-pixels */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");






const isBrowser = Object(probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["isBrowser"])();
const isPage = isBrowser && typeof document !== 'undefined';
const CONTEXT_DEFAULTS = {
  webgl2: true,
  webgl1: true,
  throwOnError: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};
function createGLContext(options = {}) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_3__["assert"])(isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;

  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }

    console.error(message);
    return null;
  }

  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl, options = {}) {
  if (!gl || gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug
  } = options;

  if (manageState) {
    Object(_state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_1__["trackContextState"])(gl, {
      copyState: false,
      log: (...args) => _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].log(1, ...args)()
    });
  }

  if (isBrowser && debug) {
    if (!probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].makeDebugContext) {
      _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].makeDebugContext(gl, options);
      _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].level = Math.max(_utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].level, 1);
    }
  }

  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl, options = {}) {
  if (gl.canvas) {
    const devicePixelRatio = Object(_utils_device_pixels__WEBPACK_IMPORTED_MODULE_4__["getDevicePixelRatio"])(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }

  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');

  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}

function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;

  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;

  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;

  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }

  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context: ").concat(errorMessage || 'Unknown error'));
  }

  if (options.onContextLost) {
    canvas.addEventListener('webglcontextlost', options.onContextLost, false);
  }

  if (options.onContextRestored) {
    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);
  }

  return gl;
}

function getCanvas({
  canvas,
  width = 800,
  height = 600,
  onError
}) {
  let targetCanvas;

  if (typeof canvas === 'string') {
    const isPageLoaded = isPage && document.readyState === 'complete';

    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }

    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement('canvas');
    targetCanvas.id = 'lumagl-canvas';
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%';
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }

  return targetCanvas;
}

function logInfo(gl) {
  const webGL = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_5__["isWebGL2"])(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  const debug = gl.debug ? ' debug' : '';
  _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}

function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return 2;
  }

  return 1;
}

function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;

  if (!clientWidth || !clientHeight) {
    _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].log(1, 'Canvas clientWidth/clientHeight is 0')();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }

  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;

  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;

    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _utils_log__WEBPACK_IMPORTED_MODULE_2__["log"].warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }

    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/index.js":
/*!***********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/index.js ***!
  \***********************************************************************************/
/*! exports provided: log, isWebGL, isWebGL2, getWebGL2Context, assertWebGLContext, assertWebGL2Context, polyfillContext, getParameters, setParameters, resetParameters, withParameters, trackContextState, pushContextState, popContextState, createGLContext, resizeGLContext, instrumentGLContext, getContextDebugInfo, cssToDeviceRatio, cssToDevicePixels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/log */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _utils_log__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getWebGL2Context", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["getWebGL2Context"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGL2Context"]; });

/* harmony import */ var _polyfill_polyfill_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfill/polyfill-context */ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polyfillContext", function() { return _polyfill_polyfill_context__WEBPACK_IMPORTED_MODULE_2__["polyfillContext"]; });

/* harmony import */ var _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-tracker/unified-parameter-api */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["setParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _state_tracker_unified_parameter_api__WEBPACK_IMPORTED_MODULE_3__["withParameters"]; });

/* harmony import */ var _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state-tracker/track-context-state */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["trackContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["pushContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return _state_tracker_track_context_state__WEBPACK_IMPORTED_MODULE_4__["popContextState"]; });

/* harmony import */ var _context_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context/context */ "../../node_modules/@luma.gl/gltools/dist/esm/context/context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["createGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["resizeGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["instrumentGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return _context_context__WEBPACK_IMPORTED_MODULE_5__["getContextDebugInfo"]; });

/* harmony import */ var _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/device-pixels */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__["cssToDeviceRatio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_6__["cssToDevicePixels"]; });








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js ***!
  \*************************************************************************************************************/
/*! exports provided: getParameterPolyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameterPolyfill", function() { return getParameterPolyfill; });
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");

const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const GL_UNMASKED_RENDERER_WEBGL = 0x9246;

const getWebGL2ValueOrZero = gl => !Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? 0 : undefined;

const WEBGL_PARAMETERS = {
  [3074]: gl => !Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? 36064 : undefined,
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => !Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? GL_DONT_CARE : undefined,
  [35977]: getWebGL2ValueOrZero,
  [32937]: getWebGL2ValueOrZero,
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },
  [32883]: getWebGL2ValueOrZero,
  [35071]: getWebGL2ValueOrZero,
  [37447]: getWebGL2ValueOrZero,
  [36063]: (gl, getParameter) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }

    return undefined;
  },
  [35379]: getWebGL2ValueOrZero,
  [35374]: getWebGL2ValueOrZero,
  [35377]: getWebGL2ValueOrZero,
  [34852]: gl => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }

    return undefined;
  },
  [36203]: gl => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
  [33001]: gl => gl.getExtension(OES_element_index) ? 16777216 : 65535,
  [33000]: gl => 16777216,
  [37157]: getWebGL2ValueOrZero,
  [35373]: getWebGL2ValueOrZero,
  [35657]: getWebGL2ValueOrZero,
  [36183]: getWebGL2ValueOrZero,
  [37137]: getWebGL2ValueOrZero,
  [34045]: getWebGL2ValueOrZero,
  [35978]: getWebGL2ValueOrZero,
  [35979]: getWebGL2ValueOrZero,
  [35968]: getWebGL2ValueOrZero,
  [35376]: getWebGL2ValueOrZero,
  [35375]: getWebGL2ValueOrZero,
  [35659]: getWebGL2ValueOrZero,
  [37154]: getWebGL2ValueOrZero,
  [35371]: getWebGL2ValueOrZero,
  [35658]: getWebGL2ValueOrZero,
  [35076]: getWebGL2ValueOrZero,
  [35077]: getWebGL2ValueOrZero,
  [35380]: getWebGL2ValueOrZero
};
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}
//# sourceMappingURL=get-parameter-polyfill.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js ***!
  \*******************************************************************************************************/
/*! exports provided: polyfillContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfillContext", function() { return polyfillContext; });
/* harmony import */ var _polyfill_vertex_array_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill-vertex-array-object */ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");
/* harmony import */ var _polyfill_table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfill-table */ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js");



function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;

  if (!luma.polyfilled) {
    Object(_polyfill_vertex_array_object__WEBPACK_IMPORTED_MODULE_0__["polyfillVertexArrayObject"])(gl);
    initializeExtensions(gl);
    installPolyfills(gl, _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_POLYFILLS"]);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }

  return gl;
}
const global_ = typeof global !== 'undefined' ? global : window;
global_.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS = gl.getSupportedExtensions() || [];

  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}

function installOverrides(gl, {
  target,
  target2
}) {
  Object.keys(_polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"]).forEach(key => {
    if (typeof _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"][key] === 'function') {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};
      const polyfill = _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_OVERRIDES"][key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}

function polyfillExtension(gl, {
  extension,
  target,
  target2
}) {
  const defaults = _polyfill_table__WEBPACK_IMPORTED_MODULE_2__["WEBGL2_CONTEXT_POLYFILLS"][extension];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["assert"])(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ''
  } = meta;
  const ext = gl.getExtension(extension);

  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;

    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = (...args) => ext[extKey](...args);
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
//# sourceMappingURL=polyfill-context.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js ***!
  \*****************************************************************************************************/
/*! exports provided: WEBGL2_CONTEXT_POLYFILLS, WEBGL2_CONTEXT_OVERRIDES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_POLYFILLS", function() { return WEBGL2_CONTEXT_POLYFILLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_OVERRIDES", function() { return WEBGL2_CONTEXT_OVERRIDES; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");
/* harmony import */ var _get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-parameter-polyfill */ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js");



const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

function getExtensionData(gl, extension) {
  return {
    webgl2: Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl),
    ext: gl.getExtension(extension)
  };
}

const WEBGL2_CONTEXT_POLYFILLS = {
  [OES_vertex_array_object]: {
    meta: {
      suffix: 'OES'
    },
    createVertexArray: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
    },

    vertexAttribDivisor(location, divisor) {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(divisor === 0, 'WebGL instanced rendering not supported');
    },

    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {
      suffix: 'EXT'
    },
    createQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
    },
    deleteQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
    },
    beginQuery: () => {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
    },
    endQuery: () => {},

    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },

    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },

    getQueryObject: () => {}
  }
};
const WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: (gl, originalFunc, attachment) => {
    if (Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    const {
      webgl2,
      ext
    } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;

    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;

      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;

      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      switch (pname) {
        case 35967:
          return 35981;

        case 35971:
          return 0;

        case 35382:
          return 0;

        default:
      }
    }

    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);

        default:
      }
    }

    return gl.getInternalformatParameter(target, format, pname);
  },

  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        const {
          extensions
        } = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;

      default:
    }

    return originalFunc(target, pname);
  },

  getParameter: _get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_2__["getParameterPolyfill"],

  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }

};
//# sourceMappingURL=polyfill-table.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js ***!
  \*******************************************************************************************************************/
/*! exports provided: polyfillVertexArrayObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfillVertexArrayObject", function() { return polyfillVertexArrayObject; });
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_0__);

const glErrorShadow = {};

function error(msg) {
  if (probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console && probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console.error) {
    probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console.error(msg);
  }
}

function log(msg) {
  if (probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console && probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console.log) {
    probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["global"].console.log(msg);
  }
}

function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;

  if (opt_msg !== undefined) {
    error(opt_msg);
  }
}

function wrapGLError(gl) {
  const f = gl.getError;

  gl.getError = function getError() {
    let err;

    do {
      err = f.apply(gl);

      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);

    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }

    return 0;
  };
}

const WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);

  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }

  this.maxAttrib = 0;
};

WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = 5126;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = '';
  this.recache();
};

WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');
};

const OESVertexArrayObject = function OESVertexArrayObject(gl) {
  const self = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };

  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }

      return self.currentVertexArrayObject;
    }

    return original.getParameter.apply(this, arguments);
  };

  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };

  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };

  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case 34962:
        self.currentArrayBuffer = buffer;
        break;

      case 34963:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;

      default:
    }

    return original.bindBuffer.apply(this, arguments);
  };

  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];

    switch (pname) {
      case 34975:
        return attrib.buffer;

      case 34338:
        return attrib.enabled;

      case 34339:
        return attrib.size;

      case 34340:
        return attrib.stride;

      case 34341:
        return attrib.type;

      case 34922:
        return attrib.normalized;

      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };

  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };

  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, 'OES_vertex_array_object');
  }

  if (gl.canvas) {
    gl.canvas.addEventListener('webglcontextrestored', () => {
      log('OESVertexArrayObject emulation library context restored');
      self.reset_();
    }, true);
  }

  this.reset_();
};

OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;

OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== undefined;

  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }

  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(34921);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};

OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};

OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};

OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }

  return false;
};

OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;

  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(1282, 'bindVertexArrayOES: attempt to bind deleted arrayObject');
    return;
  }

  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;

  if (oldVAO === newVAO) {
    return;
  }

  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
  }

  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }

    if (attrib.enabled) {
      let bufferChanged = false;

      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, 34962, attrib.buffer);
          currentBinding = attrib.buffer;
        }

        bufferChanged = true;
      }

      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      }
    }
  }

  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
  }
};

function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === 'function') {
    return;
  }

  const original_getSupportedExtensions = gl.getSupportedExtensions;

  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];

    if (list.indexOf('OES_vertex_array_object') < 0) {
      list.push('OES_vertex_array_object');
    }

    return list;
  };

  const original_getExtension = gl.getExtension;

  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);

    if (ext) {
      return ext;
    }

    if (name !== 'OES_vertex_array_object') {
      return null;
    }

    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }

    return this.__OESVertexArrayObject;
  };
}
//# sourceMappingURL=polyfill-vertex-array-object.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js ***!
  \***************************************************************************************************************/
/*! exports provided: trackContextState, pushContextState, popContextState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return trackContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return pushContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return popContextState; });
/* harmony import */ var _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-parameter-tables */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js");
/* harmony import */ var _unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unified-parameter-api */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js");





function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function get(...params) {
    const pname = params[0];

    if (!(pname in gl.state.cache)) {
      gl.state.cache[pname] = originalGetterFunc(...params);
    }

    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...params);
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}

function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function set(...params) {
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);

    if (valueChanged) {
      originalSetterFunc(...params);
    }

    return oldValue;
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}

function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);

  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}

class GLState {
  constructor(gl, {
    copyState = false,
    log = () => {}
  } = {}) {
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? Object(_unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__["getParameters"])(gl) : Object.assign({}, _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  push(values = {}) {
    this.stateStack.push({});
  }

  pop() {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    Object(_unified_parameter_api__WEBPACK_IMPORTED_MODULE_1__["setParameters"])(this.gl, oldValues);
    this.stateStack.pop();
  }

  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

    for (const key in values) {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];

      if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_3__["deepArrayEqual"])(value, cached)) {
        valueChanged = true;
        oldValue = cached;

        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }

        this.cache[key] = value;
      }
    }

    return {
      valueChanged,
      oldValue
    };
  }

}

function trackContextState(gl, options = {}) {
  const {
    enable = true,
    copyState
  } = options;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(copyState !== undefined);

  if (!gl.state) {
    const global_ = typeof global !== 'undefined' ? global : window;
    const {
      polyfillContext
    } = global_;

    if (polyfillContext) {
      polyfillContext(gl);
    }

    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);

    for (const key in _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_HOOKED_SETTERS"]) {
      const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_HOOKED_SETTERS"][key];
      installSetterSpy(gl, key, setter);
    }

    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }

  gl.state.push();
}
function popContextState(gl) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(gl.state);
  gl.state.pop();
}
//# sourceMappingURL=track-context-state.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js ***!
  \*****************************************************************************************************************/
/*! exports provided: setParameters, getParameters, resetParameters, withParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return setParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return getParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return resetParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return withParameters; });
/* harmony import */ var _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-parameter-tables */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js");
/* harmony import */ var _track_context_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track-context-state */ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js");





function setParameters(gl, values) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["assert"])(Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_3__["isWebGL"])(gl), 'setParameters requires a WebGL context');

  if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(values)) {
    return;
  }

  const compositeSetters = {};

  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_SETTERS"][key];

    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }

  const cache = gl.state && gl.state.cache;

  if (cache) {
    for (const key in compositeSetters) {
      const compositeSetter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_COMPOSITE_PARAMETER_SETTERS"][key];
      compositeSetter(gl, values, cache);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"];

  if (typeof parameters === 'number') {
    const key = parameters;
    const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }

  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};

  for (const key of parameterKeys) {
    const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }

  return state;
}
function resetParameters(gl) {
  setParameters(gl, _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]);
}
function withParameters(gl, parameters, func) {
  if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(parameters)) {
    return func(gl);
  }

  const {
    nocatch = true
  } = parameters;
  Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["pushContextState"])(gl);
  setParameters(gl, parameters);
  let value;

  if (nocatch) {
    value = func(gl);
    Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["popContextState"])(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      Object(_track_context_state__WEBPACK_IMPORTED_MODULE_1__["popContextState"])(gl);
    }
  }

  return value;
}
//# sourceMappingURL=unified-parameter-api.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js ***!
  \******************************************************************************************************************/
/*! exports provided: GL_PARAMETER_DEFAULTS, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_HOOKED_SETTERS, GL_PARAMETER_GETTERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_DEFAULTS", function() { return GL_PARAMETER_DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_SETTERS", function() { return GL_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_COMPOSITE_PARAMETER_SETTERS", function() { return GL_COMPOSITE_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_HOOKED_SETTERS", function() { return GL_HOOKED_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_GETTERS", function() { return GL_PARAMETER_GETTERS; });
/* harmony import */ var _utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/webgl-checks */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js");

const GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  [2930]: true,
  [3024]: true,
  [36006]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32938]: 1.0,
  [32939]: false,
  [3089]: false,
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 0xffffffff,
  [36005]: 0xffffffff,
  [2962]: 519,
  [2967]: 0,
  [2963]: 0xffffffff,
  [34816]: 519,
  [36003]: 0,
  [36004]: 0xffffffff,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  [2978]: [0, 0, 1024, 1024],
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};

const enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);

const hint = (gl, value, key) => gl.hint(key, value);

const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);

const drawFramebuffer = (gl, value) => {
  const target = Object(_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};

const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(36008, value);
};

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

const GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: 'blendEquation',
  [34877]: 'blendEquation',
  [32969]: 'blendFunc',
  [32968]: 'blendFunc',
  [32971]: 'blendFunc',
  [32970]: 'blendFunc',
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [36006]: drawFramebuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: 'polygonOffset',
  [10752]: 'polygonOffset',
  [35977]: enable,
  [32938]: 'sampleCoverage',
  [32939]: 'sampleCoverage',
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: 'stencilFuncFront',
  [2967]: 'stencilFuncFront',
  [2963]: 'stencilFuncFront',
  [34816]: 'stencilFuncBack',
  [36003]: 'stencilFuncBack',
  [36004]: 'stencilFuncBack',
  [2964]: 'stencilOpFront',
  [2965]: 'stencilOpFront',
  [2966]: 'stencilOpFront',
  [34817]: 'stencilOpBack',
  [34818]: 'stencilOpBack',
  [34819]: 'stencilOpBack',
  [2978]: (gl, value) => gl.viewport(...value),
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [36010]: readFramebuffer,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};

function getValue(glEnum, values, cache) {
  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}

const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
  polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
};
const GL_HOOKED_SETTERS = {
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint) => update({
    [pname]: hint
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });

      case 36009:
        return update({
          [36006]: framebuffer
        });

      case 36008:
        return update({
          [36010]: framebuffer
        });

      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};

const isEnabled = (gl, key) => gl.isEnabled(key);

const GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
//# sourceMappingURL=webgl-parameter-tables.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/utils/assert.js ***!
  \******************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js ***!
  \*************************************************************************************************/
/*! exports provided: cssToDeviceRatio, cssToDevicePixels, getDevicePixelRatio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return cssToDeviceRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return cssToDevicePixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDevicePixelRatio", function() { return getDevicePixelRatio; });
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;

  if (gl.canvas && luma) {
    const {
      clientWidth
    } = luma.canvasSizeInfo;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }

  return 1;
}
function cssToDevicePixels(gl, cssPixel, yInvert = true) {
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;

  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }

  return useDevicePixels ? windowRatio : 1;
}

function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;

  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }

  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}

function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}

function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
//# sourceMappingURL=device-pixels.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/utils/log.js ***!
  \***************************************************************************************/
/*! exports provided: log */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");

const log = new probe_gl__WEBPACK_IMPORTED_MODULE_0__["Log"]({
  id: 'luma.gl'
});
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/utils/utils.js ***!
  \*****************************************************************************************/
/*! exports provided: isObjectEmpty, deepArrayEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return isObjectEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepArrayEqual", function() { return deepArrayEqual; });
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }

  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }

  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js ***!
  \************************************************************************************************/
/*! exports provided: ERR_WEBGL, ERR_WEBGL2, isWebGL, isWebGL2, getWebGL2Context, assertWebGLContext, assertWebGL2Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL", function() { return ERR_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL2", function() { return ERR_WEBGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return isWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return isWebGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWebGL2Context", function() { return getWebGL2Context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return assertWebGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return assertWebGL2Context; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js");

const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
const ERR_WEBGL2 = 'Requires WebGL2';
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    return true;
  }

  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
//# sourceMappingURL=webgl-checks.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/index.js ***!
  \***************************************************************************************/
/*! exports provided: assembleShaders, combineInjects, normalizeShaderModule, getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4, random, fp32, fp64, fp64arithmetic, project, lights, dirlight, picking, gouraudLighting, phongLighting, pbr, tiltShift, triangleBlur, zoomBlur, brightnessContrast, denoise, hueSaturation, noise, sepia, vibrance, vignette, colorHalftone, dotScreen, edgeWork, hexagonalPixelate, ink, magnify, bulgePinch, swirl, _warp, fxaa, _transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/assemble-shaders */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_0__["assembleShaders"]; });

/* harmony import */ var _lib_inject_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/inject-shader */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineInjects", function() { return _lib_inject_shader__WEBPACK_IMPORTED_MODULE_1__["combineInjects"]; });

/* harmony import */ var _lib_shader_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/shader-module */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalizeShaderModule", function() { return _lib_shader_module__WEBPACK_IMPORTED_MODULE_2__["normalizeShaderModule"]; });

/* harmony import */ var _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/shader-utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getQualifierDetails", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__["getQualifierDetails"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPassthroughFS", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__["getPassthroughFS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelSuffix", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__["typeToChannelSuffix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelCount", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__["typeToChannelCount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToVec4", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_3__["convertToVec4"]; });

/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["random"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["fp32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["fp64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64arithmetic", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["fp64arithmetic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["project"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["lights"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["dirlight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["picking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gouraudLighting", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["gouraudLighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "phongLighting", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["phongLighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["pbr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tiltShift", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["tiltShift"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triangleBlur", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["triangleBlur"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomBlur", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["zoomBlur"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brightnessContrast", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["brightnessContrast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "denoise", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["denoise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hueSaturation", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["hueSaturation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noise", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["noise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sepia", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["sepia"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vibrance", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["vibrance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vignette", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["vignette"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colorHalftone", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["colorHalftone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dotScreen", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["dotScreen"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "edgeWork", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["edgeWork"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexagonalPixelate", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["hexagonalPixelate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ink", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["ink"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "magnify", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["magnify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulgePinch", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["bulgePinch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "swirl", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["swirl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_warp", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["_warp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fxaa", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["fxaa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_transform", function() { return _modules__WEBPACK_IMPORTED_MODULE_4__["_transform"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js ***!
  \******************************************************************************************************/
/*! exports provided: assembleShaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return assembleShaders; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js");
/* harmony import */ var _resolve_modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-modules */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js");
/* harmony import */ var _platform_defines__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform-defines */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js");
/* harmony import */ var _inject_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inject-shader */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js");
/* harmony import */ var _transpile_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transpile-shader */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js");






const INJECT_SHADER_DECLARATIONS = "\n\n".concat(_inject_shader__WEBPACK_IMPORTED_MODULE_3__["DECLARATION_INJECT_MARKER"], "\n\n");
const SHADER_TYPE = {
  [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: 'vertex',
  [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: 'fragment'
};
const FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function assembleShaders(gl, opts) {
  const {
    vs,
    fs
  } = opts;
  const modules = Object(_resolve_modules__WEBPACK_IMPORTED_MODULE_1__["resolveModules"])(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"],
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"],
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}

function assembleShader(gl, {
  id,
  source,
  type,
  modules,
  defines = {},
  hookFunctions = [],
  inject = {},
  transpileToGLSL100 = false,
  prologue = true,
  log
}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(typeof source === 'string', 'shader source must be a string');
  const isVertex = type === _constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"];
  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;

  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  } else {
    versionLine = "#version ".concat(glslVersion);
  }

  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat(Object(_platform_defines__WEBPACK_IMPORTED_MODULE_2__["getPlatformShaderDefines"])(gl), "\n").concat(Object(_platform_defines__WEBPACK_IMPORTED_MODULE_2__["getVersionDefines"])(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};

  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);

    if (match) {
      const hash = match[2];
      const name = match[3];

      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }

  for (const module of modules) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }

    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];

    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);

      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }

  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = Object(_inject_shader__WEBPACK_IMPORTED_MODULE_3__["default"])(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = Object(_inject_shader__WEBPACK_IMPORTED_MODULE_3__["default"])(assembledSource, type, mainInjections);
  assembledSource = Object(_transpile_shader__WEBPACK_IMPORTED_MODULE_4__["default"])(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}

function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};

    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }

    return uniforms;
  };
}

function getShaderType({
  type
}) {
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}

function getShaderName({
  id,
  source,
  type
}) {
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}

function getApplicationDefines(defines = {}) {
  let count = 0;
  let sourceText = '';

  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }

    count++;
    const value = defines[define];

    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }

  if (count === 0) {
    sourceText += '\n';
  }

  return sourceText;
}

function getHookFunctions(hookFunctions, hookInjections) {
  let result = '';

  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");

    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }

    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);

      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }

    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }

    result += '}\n';
  }

  return result;
}

function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach(hook => {
    let opts;

    if (typeof hook !== 'string') {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }

    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
//# sourceMappingURL=assemble-shaders.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js ***!
  \***********************************************************************************************/
/*! exports provided: VERTEX_SHADER, FRAGMENT_SHADER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js ***!
  \********************************************************************************************************/
/*! exports provided: parsePropTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePropTypes", function() { return parsePropTypes; });
const TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }

  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }

  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};

  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }

  return propTypes;
}

function parsePropType(propDef) {
  let type = getTypeOf(propDef);

  if (type === 'object') {
    if (!propDef) {
      return {
        type: 'object',
        value: null
      };
    }

    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }

    if (!('value' in propDef)) {
      return {
        type: 'object',
        value: propDef
      };
    }

    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }

  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}

function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }

  return typeof value;
}
//# sourceMappingURL=prop-types.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js ***!
  \***************************************************************************************************/
/*! exports provided: DECLARATION_INJECT_MARKER, default, combineInjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DECLARATION_INJECT_MARKER", function() { return DECLARATION_INJECT_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return injectShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineInjects", function() { return combineInjects; });
/* harmony import */ var _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/module-injectors */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js");



const MODULE_INJECTORS = {
  [_constants__WEBPACK_IMPORTED_MODULE_1__["VERTEX_SHADER"]]: _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__["MODULE_INJECTORS_VS"],
  [_constants__WEBPACK_IMPORTED_MODULE_1__["FRAGMENT_SHADER"]]: _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__["MODULE_INJECTORS_FS"]
};
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];
function injectShader(source, type, inject, injectStandardStubs = false) {
  const isVertex = type === _constants__WEBPACK_IMPORTED_MODULE_1__["VERTEX_SHADER"];

  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;

    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }

    const fragmentString = "".concat(fragments.join('\n'), "\n");

    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }

        break;

      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }

        break;

      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }

        break;

      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }

        break;

      default:
        source = source.replace(key, match => match + fragmentString);
    }
  }

  source = source.replace(DECLARATION_INJECT_MARKER, '');

  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[type]);
  }

  return source;
}
function combineInjects(injects) {
  const result = {};
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
//# sourceMappingURL=inject-shader.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js ***!
  \******************************************************************************************************/
/*! exports provided: getPlatformShaderDefines, getVersionDefines */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlatformShaderDefines", function() { return getPlatformShaderDefines; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVersionDefines", function() { return getVersionDefines; });
/* harmony import */ var _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/webgl-info */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js");

function getPlatformShaderDefines(gl) {
  const debugInfo = Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["getContextInfo"])(gl);

  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";

    case 'intel':
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";

    case 'amd':
      return "#define AMD_GPU\n";

    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";

  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }

  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_DERIVATIVES) && Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["canCompileGLGSExtension"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }

  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DATA) && Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["canCompileGLGSExtension"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }

  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }

  return versionDefines;
}
//# sourceMappingURL=platform-defines.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js ***!
  \*****************************************************************************************************/
/*! exports provided: resolveModules, TEST_EXPORTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveModules", function() { return resolveModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEST_EXPORTS", function() { return TEST_EXPORTS; });
/* harmony import */ var _shader_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader-module */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js");


function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}

function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);
}

function getDependencyGraph({
  modules,
  level,
  moduleMap,
  moduleDepth
}) {
  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }

  for (const module of modules) {
    moduleMap[module.name] = module;

    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }

  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}

function instantiateModules(modules, seen) {
  return modules.map(module => {
    if (module instanceof _shader_module__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      return module;
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof module !== 'string', "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(module.name, 'shader module has no name');
    module = new _shader_module__WEBPACK_IMPORTED_MODULE_0__["default"](module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}

const TEST_EXPORTS = {
  getShaderDependencies,
  getDependencyGraph
};
//# sourceMappingURL=resolve-modules.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js ***!
  \***************************************************************************************************/
/*! exports provided: default, normalizeShaderModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeShaderModule", function() { return normalizeShaderModule; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js");
/* harmony import */ var _filters_prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filters/prop-types */ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js");


const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';
class ShaderModule {
  constructor({
    name,
    vs,
    fs,
    dependencies = [],
    uniforms,
    getUniforms,
    deprecations = [],
    defines = {},
    inject = {},
    vertexShader,
    fragmentShader
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;
    this.injections = normalizeInjections(inject);

    if (uniforms) {
      this.uniforms = Object(_filters_prop_types__WEBPACK_IMPORTED_MODULE_1__["parsePropTypes"])(uniforms);
    }
  }

  getModuleSource(type) {
    let moduleSource;

    switch (type) {
      case VERTEX_SHADER:
        moduleSource = this.vs || '';
        break;

      case FRAGMENT_SHADER:
        moduleSource = this.fs || '';
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
    }

    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
  }

  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }

    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }

    return {};
  }

  getDefines() {
    return this.defines;
  }

  checkDeprecations(shaderSource, log) {
    this.deprecations.forEach(def => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log.deprecated(def.old, def.new)();
        } else {
          log.removed(def.old, def.new)();
        }
      }
    });
  }

  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach(def => {
      switch (def.type) {
        case 'function':
          def.regex = new RegExp("\\b".concat(def.old, "\\("));
          break;

        default:
          def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
      }
    });
    return deprecations;
  }

  _defaultGetUniforms(opts = {}) {
    const uniforms = {};
    const propTypes = this.uniforms;

    for (const key in propTypes) {
      const propDef = propTypes[key];

      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
        }

        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }

    return uniforms;
  }

}
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;

    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }

  return module;
}

function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };

  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);

    if (typeof injection === 'string') {
      injection = {
        order: 0,
        injection
      };
    }

    result[stage][hook] = injection;
  }

  return result;
}
//# sourceMappingURL=shader-module.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transpileShader; });
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), 'g');
}

const ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, '#version 300 es\n'], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, 'textureLod('], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, 'texture(']];
const ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];
const ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];
const ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, '#version 100'], [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('], [/\btexture\(/g, 'texture2D('], [/\btextureLod\(/g, 'texture2DLodEXT(']];
const ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];
const ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];
const ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';
const ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);

    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);

    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}

function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }

  return source;
}

function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);

  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  } else {
    const outputName = 'fragmentColor';
    source = source.replace(REGEX_START_OF_MAIN, match => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  }

  return source;
}

function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);

  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp("\\b".concat(outputName, "\\b"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);
  }

  return source;
}
//# sourceMappingURL=transpile-shader.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js ***!
  \***********************************************************************************************************/
/*! exports provided: dirlight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return dirlight; });
/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../project/project */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js");

const DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
const DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};

  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }

  return uniforms;
}

const vs = null;
const fs = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
const dirlight = {
  name: 'dirlight',
  vs,
  fs,
  getUniforms,
  dependencies: [_project_project__WEBPACK_IMPORTED_MODULE_0__["project"]]
};
//# sourceMappingURL=dirlight.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js ***!
  \***************************************************************************************************/
/*! exports provided: fp32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return fp32; });
const fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const fp32 = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
//# sourceMappingURL=fp32.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n");
//# sourceMappingURL=fp64-arithmetic.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n");
//# sourceMappingURL=fp64-functions.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js ***!
  \*********************************************************************************************************/
/*! exports provided: fp64ify, fp64LowPart, fp64ifyMatrix4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64ify", function() { return fp64ify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64LowPart", function() { return fp64LowPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64ifyMatrix4", function() { return fp64ifyMatrix4; });
function fp64ify(a, out = [], startIndex = 0) {
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a) {
  return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);

  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }

  return matrixFP64;
}
//# sourceMappingURL=fp64-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js ***!
  \***************************************************************************************************/
/*! exports provided: fp64ify, fp64LowPart, fp64ifyMatrix4, fp64arithmetic, fp64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64arithmetic", function() { return fp64arithmetic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return fp64; });
/* harmony import */ var _fp64_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fp64-utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64ify", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64LowPart", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64ifyMatrix4", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ifyMatrix4"]; });

/* harmony import */ var _fp64_arithmetic_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fp64-arithmetic.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js");
/* harmony import */ var _fp64_functions_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fp64-functions.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js");



const CONST_UNIFORMS = {
  ONE: 1.0
};


function getUniforms() {
  return CONST_UNIFORMS;
}

const fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: _fp64_arithmetic_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  fs: null,
  getUniforms,
  fp64ify: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ify"],
  fp64LowPart: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"],
  fp64ifyMatrix4: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ifyMatrix4"]
};
const fp64 = {
  name: 'fp64',
  vs: _fp64_functions_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
  fs: null,
  dependencies: [fp64arithmetic],
  fp64ify: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ify"],
  fp64LowPart: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"],
  fp64ifyMatrix4: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ifyMatrix4"]
};
//# sourceMappingURL=fp64.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js ***!
  \***************************************************************************************************/
/*! exports provided: fxaa */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fxaa", function() { return fxaa; });
/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
const fs = "\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture2D(t, p)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n\n\n    FxaaFloat2 pos,\n\n\n\n\n    FxaaTex tex,\n\n\n\n\n    FxaaFloat2 fxaaQualityRcpFrame,\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualitySubpix,\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThreshold,\n\n\n\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n    if(earlyExit)\n        return rgbyM;\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    #endif\n                        }\n                        #endif\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        texture,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n";
const fxaa = {
  name: 'fxaa',
  uniforms: {},
  fs,
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=fxaa.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: brightnessContrast */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brightnessContrast", function() { return brightnessContrast; });
const fs = "uniform float brightness;\nuniform float contrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightness;\n  if (contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {\n  return brightnessContrast_filterColor(color);\n}\n";
const uniforms = {
  brightness: {
    value: 0,
    min: -1,
    max: 1
  },
  contrast: {
    value: 0,
    min: -1,
    max: 1
  }
};
const brightnessContrast = {
  name: 'brightnessContrast',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=brightnesscontrast.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js ***!
  \**********************************************************************************************************************/
/*! exports provided: denoise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denoise", function() { return denoise; });
const fs = "uniform float strength;\n\nvec4 denoise_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - strength, 4.);\n\n  vec4 center = texture2D(texture, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n";
const uniforms = {
  strength: {
    value: 0.5,
    min: 0,
    max: 0.1,
    adjust: strength => 0.53 + 200 * Math.pow(1 - strength, 4)
  }
};
const denoise = {
  name: 'denoise',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }, {
    sampler: true
  }]
};
//# sourceMappingURL=denoise.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js ***!
  \****************************************************************************************************************************/
/*! exports provided: hueSaturation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hueSaturation", function() { return hueSaturation; });
const fs = "uniform float hue;\nuniform float saturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  float angle = hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n";
const uniforms = {
  hue: {
    value: 0,
    min: -1,
    max: 1
  },
  saturation: {
    value: 0,
    min: -1,
    max: 1
  }
};
const hueSaturation = {
  name: 'hueSaturation',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=huesaturation.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js ***!
  \********************************************************************************************************************/
/*! exports provided: noise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noise", function() { return noise; });
const fs = "uniform float amount;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return noise_filterColor(color, texCoord);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const noise = {
  name: 'noise',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=noise.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js ***!
  \********************************************************************************************************************/
/*! exports provided: sepia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sepia", function() { return sepia; });
const fs = "uniform float amount;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\n  color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\n  color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const sepia = {
  name: 'sepia',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=sepia.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js ***!
  \***********************************************************************************************************************/
/*! exports provided: vibrance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vibrance", function() { return vibrance; });
const fs = "uniform float amount;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0,
    min: -1,
    max: 1
  }
};
const vibrance = {
  name: 'vibrance',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=vibrance.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js ***!
  \***********************************************************************************************************************/
/*! exports provided: vignette */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vignette", function() { return vignette; });
const fs = "uniform float radius;\nuniform float amount;\n\nvec4 vignette_filterColor(vec4 color, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, radius * 0.799, dist * (amount + radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vignette_filterColor(color, texCoord);\n}\n";
const uniforms = {
  radius: {
    value: 0.5,
    min: 0,
    max: 1
  },
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const vignette = {
  name: 'vignette',
  fs,
  uniforms,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=vignette.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js ***!
  \**********************************************************************************************************************/
/*! exports provided: tiltShift */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tiltShift", function() { return tiltShift; });
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/random */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js");

const fs = "uniform float blurRadius;\nuniform float gradientRadius;\nuniform vec2 start;\nuniform vec2 end;\nuniform bool invert;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((end - start) * texSize);\n  return invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((start.y - end.y) * texSize.y, (end.x - start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - start * texSize, normal)) / gradientRadius) * blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  blurRadius: {
    value: 15,
    min: 0,
    max: 50
  },
  gradientRadius: {
    value: 200,
    min: 0,
    max: 400
  },
  start: [0, 0],
  end: [1, 1],
  invert: {
    value: false,
    private: true
  }
};
const tiltShift = {
  name: 'tiltShift',
  uniforms,
  fs,
  dependencies: [_utils_random__WEBPACK_IMPORTED_MODULE_0__["random"]],
  passes: [{
    sampler: true,
    uniforms: {
      invert: false
    }
  }, {
    sampler: true,
    uniforms: {
      invert: true
    }
  }]
};
//# sourceMappingURL=tiltshift.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js ***!
  \*************************************************************************************************************************/
/*! exports provided: triangleBlur */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangleBlur", function() { return triangleBlur; });
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/random */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js");

const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 triangleBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = delta * radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + adjustedDelta * percent);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  radius: {
    value: 20,
    min: 0,
    softMax: 100
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const triangleBlur = {
  name: 'triangleBlur',
  uniforms,
  fs,
  dependencies: [_utils_random__WEBPACK_IMPORTED_MODULE_0__["random"]],
  passes: [{
    sampler: true,
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: true,
    uniforms: {
      delta: [0, 1]
    }
  }]
};
//# sourceMappingURL=triangleblur.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js ***!
  \*********************************************************************************************************************/
/*! exports provided: zoomBlur */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomBlur", function() { return zoomBlur; });
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/random */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js");

const fs = "\nuniform vec2 center;\nuniform float strength;\n\nvec4 zoomBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = center * texSize - texCoord * texSize;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  strength: {
    value: 0.3,
    min: 0,
    softMax: 1
  }
};
const zoomBlur = {
  name: 'zoomBlur',
  uniforms,
  fs,
  dependencies: [_utils_random__WEBPACK_IMPORTED_MODULE_0__["random"]],
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=zoomblur.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js ***!
  \*************************************************************************************************************************/
/*! exports provided: colorHalftone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorHalftone", function() { return colorHalftone; });
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat scale = 3.1514 / size;\n\nfloat pattern(float angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\tcmy * 10.0 - 3.0 + vec3(\n    pattern(angle + 0.26179, texSize, texCoord),\n\t  pattern(angle + 1.30899, texSize, texCoord),\n    pattern(angle, texSize, texCoord)\n  ),\n\t0.0,\n\t1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 4,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const colorHalftone = {
  name: 'colorHalftone',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=colorhalftone.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js ***!
  \*********************************************************************************************************************/
/*! exports provided: dotScreen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dotScreen", function() { return dotScreen; });
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / size;\n\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 3,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const dotScreen = {
  name: 'dotScreen',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
//# sourceMappingURL=dotscreen.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js ***!
  \********************************************************************************************************************/
/*! exports provided: edgeWork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "edgeWork", function() { return edgeWork; });
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/random */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js");

const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture2D(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture2D(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n";
const uniforms = {
  radius: {
    value: 2,
    min: 1,
    softMax: 50
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const edgeWork = {
  name: 'edgeWork',
  uniforms,
  fs,
  dependencies: [_utils_random__WEBPACK_IMPORTED_MODULE_0__["random"]],
  passes: [{
    sampler: 'edgeWork_sampleColor1',
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: 'edgeWork_sampleColor2',
    uniforms: {
      delta: [0, 1]
    }
  }]
};
//# sourceMappingURL=edgework.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js ***!
  \*****************************************************************************************************************************/
/*! exports provided: hexagonalPixelate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexagonalPixelate", function() { return hexagonalPixelate; });
const fs = "uniform vec2 center;\nuniform float scale;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - center * texSize) / scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= scale / texSize;\n\n  return texture2D(texture, choice + center);\n}\n";
const uniforms = {
  center: {
    value: [0.5, 0.5],
    hint: 'screenspace'
  },
  scale: {
    value: 10,
    min: 1,
    softMin: 5,
    softMax: 50
  }
};
const hexagonalPixelate = {
  name: 'hexagonalPixelate',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=hexagonalpixelate.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js ***!
  \***************************************************************************************************************/
/*! exports provided: ink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ink", function() { return ink; });
const fs = "uniform float strength;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = strength * strength * strength * strength * strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n";
const uniforms = {
  strength: {
    value: 0.25,
    min: 0,
    softMax: 1
  }
};
const ink = {
  name: 'ink',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=ink.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js ***!
  \*******************************************************************************************************************/
/*! exports provided: magnify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "magnify", function() { return magnify; });
const fs = "uniform vec2 screenXY;\nuniform float radiusPixels;\nuniform float zoom;\nuniform float borderWidthPixels;\nuniform vec4 borderColor;\n\nvec4 magnify_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(screenXY.x, 1.0 - screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < radiusPixels) {\n    return texture2D(texture, (texCoord - pos) / zoom + pos);\n  }\n\n  if (dist <= radiusPixels + borderWidthPixels) {\n    return borderColor;\n  }\n  return texture2D(texture, texCoord);\n}\n";
const uniforms = {
  screenXY: [0, 0],
  radiusPixels: 200,
  zoom: 2.0,
  borderWidthPixels: 0.0,
  borderColor: [255, 255, 255, 255]
};
const magnify = {
  name: 'magnify',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=magnify.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js ***!
  \***********************************************************************************************************************/
/*! exports provided: bulgePinch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bulgePinch", function() { return bulgePinch; });
/* harmony import */ var _warp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./warp */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js");

const fs = "uniform float radius;\nuniform float strength;\nuniform vec2 center;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = distance / radius;\n    if (strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  strength: {
    value: 0.5,
    min: -1,
    max: 1
  }
};
const bulgePinch = {
  name: 'bulgePinch',
  fs,
  uniforms,
  dependencies: [_warp__WEBPACK_IMPORTED_MODULE_0__["warp"]],
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=bulgepinch.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js ***!
  \******************************************************************************************************************/
/*! exports provided: swirl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swirl", function() { return swirl; });
/* harmony import */ var _warp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./warp */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js");

const fs = "uniform float radius;\nuniform float angle;\nuniform vec2 center;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = (radius - distance) / radius;\n    float theta = percent * percent * angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  angle: {
    value: 3,
    softMin: -25,
    softMax: 25
  }
};
const swirl = {
  name: 'swirl',
  fs,
  uniforms,
  dependencies: [_warp__WEBPACK_IMPORTED_MODULE_0__["warp"]],
  passes: [{
    sampler: true
  }]
};
//# sourceMappingURL=swirl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js ***!
  \*****************************************************************************************************************/
/*! exports provided: warp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warp", function() { return warp; });
const fs = "vec4 warp_sampleColor(sampler2D texture, vec2 texSize, vec2 coord) {\n  vec4 color = texture2D(texture, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n\n  return color;\n}\n";
const warp = {
  name: 'warp',
  fs
};
//# sourceMappingURL=warp.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/index.js ***!
  \***********************************************************************************************/
/*! exports provided: random, fp32, fp64, fp64arithmetic, project, lights, dirlight, picking, gouraudLighting, phongLighting, pbr, tiltShift, triangleBlur, zoomBlur, brightnessContrast, denoise, hueSaturation, noise, sepia, vibrance, vignette, colorHalftone, dotScreen, edgeWork, hexagonalPixelate, ink, magnify, bulgePinch, swirl, _warp, fxaa, _transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/random */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _utils_random__WEBPACK_IMPORTED_MODULE_0__["random"]; });

/* harmony import */ var _fp32_fp32__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fp32/fp32 */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return _fp32_fp32__WEBPACK_IMPORTED_MODULE_1__["fp32"]; });

/* harmony import */ var _fp64_fp64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fp64/fp64 */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return _fp64_fp64__WEBPACK_IMPORTED_MODULE_2__["fp64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64arithmetic", function() { return _fp64_fp64__WEBPACK_IMPORTED_MODULE_2__["fp64arithmetic"]; });

/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./project/project */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _project_project__WEBPACK_IMPORTED_MODULE_3__["project"]; });

/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lights/lights */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return _lights_lights__WEBPACK_IMPORTED_MODULE_4__["lights"]; });

/* harmony import */ var _dirlight_dirlight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dirlight/dirlight */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return _dirlight_dirlight__WEBPACK_IMPORTED_MODULE_5__["dirlight"]; });

/* harmony import */ var _picking_picking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./picking/picking */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return _picking_picking__WEBPACK_IMPORTED_MODULE_6__["picking"]; });

/* harmony import */ var _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./phong-lighting/phong-lighting */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gouraudLighting", function() { return _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_7__["gouraudLighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "phongLighting", function() { return _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_7__["phongLighting"]; });

/* harmony import */ var _pbr_pbr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pbr/pbr */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return _pbr_pbr__WEBPACK_IMPORTED_MODULE_8__["pbr"]; });

/* harmony import */ var _image_blur_filters_tiltshift__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./image-blur-filters/tiltshift */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tiltShift", function() { return _image_blur_filters_tiltshift__WEBPACK_IMPORTED_MODULE_9__["tiltShift"]; });

/* harmony import */ var _image_blur_filters_triangleblur__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./image-blur-filters/triangleblur */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triangleBlur", function() { return _image_blur_filters_triangleblur__WEBPACK_IMPORTED_MODULE_10__["triangleBlur"]; });

/* harmony import */ var _image_blur_filters_zoomblur__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./image-blur-filters/zoomblur */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomBlur", function() { return _image_blur_filters_zoomblur__WEBPACK_IMPORTED_MODULE_11__["zoomBlur"]; });

/* harmony import */ var _image_adjust_filters_brightnesscontrast__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./image-adjust-filters/brightnesscontrast */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brightnessContrast", function() { return _image_adjust_filters_brightnesscontrast__WEBPACK_IMPORTED_MODULE_12__["brightnessContrast"]; });

/* harmony import */ var _image_adjust_filters_denoise__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./image-adjust-filters/denoise */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "denoise", function() { return _image_adjust_filters_denoise__WEBPACK_IMPORTED_MODULE_13__["denoise"]; });

/* harmony import */ var _image_adjust_filters_huesaturation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./image-adjust-filters/huesaturation */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hueSaturation", function() { return _image_adjust_filters_huesaturation__WEBPACK_IMPORTED_MODULE_14__["hueSaturation"]; });

/* harmony import */ var _image_adjust_filters_noise__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./image-adjust-filters/noise */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noise", function() { return _image_adjust_filters_noise__WEBPACK_IMPORTED_MODULE_15__["noise"]; });

/* harmony import */ var _image_adjust_filters_sepia__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./image-adjust-filters/sepia */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sepia", function() { return _image_adjust_filters_sepia__WEBPACK_IMPORTED_MODULE_16__["sepia"]; });

/* harmony import */ var _image_adjust_filters_vibrance__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./image-adjust-filters/vibrance */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vibrance", function() { return _image_adjust_filters_vibrance__WEBPACK_IMPORTED_MODULE_17__["vibrance"]; });

/* harmony import */ var _image_adjust_filters_vignette__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./image-adjust-filters/vignette */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vignette", function() { return _image_adjust_filters_vignette__WEBPACK_IMPORTED_MODULE_18__["vignette"]; });

/* harmony import */ var _image_fun_filters_colorhalftone__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./image-fun-filters/colorhalftone */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colorHalftone", function() { return _image_fun_filters_colorhalftone__WEBPACK_IMPORTED_MODULE_19__["colorHalftone"]; });

/* harmony import */ var _image_fun_filters_dotscreen__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./image-fun-filters/dotscreen */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dotScreen", function() { return _image_fun_filters_dotscreen__WEBPACK_IMPORTED_MODULE_20__["dotScreen"]; });

/* harmony import */ var _image_fun_filters_edgework__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./image-fun-filters/edgework */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "edgeWork", function() { return _image_fun_filters_edgework__WEBPACK_IMPORTED_MODULE_21__["edgeWork"]; });

/* harmony import */ var _image_fun_filters_hexagonalpixelate__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./image-fun-filters/hexagonalpixelate */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexagonalPixelate", function() { return _image_fun_filters_hexagonalpixelate__WEBPACK_IMPORTED_MODULE_22__["hexagonalPixelate"]; });

/* harmony import */ var _image_fun_filters_ink__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./image-fun-filters/ink */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ink", function() { return _image_fun_filters_ink__WEBPACK_IMPORTED_MODULE_23__["ink"]; });

/* harmony import */ var _image_fun_filters_magnify__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./image-fun-filters/magnify */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "magnify", function() { return _image_fun_filters_magnify__WEBPACK_IMPORTED_MODULE_24__["magnify"]; });

/* harmony import */ var _image_warp_filters_bulgepinch__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./image-warp-filters/bulgepinch */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bulgePinch", function() { return _image_warp_filters_bulgepinch__WEBPACK_IMPORTED_MODULE_25__["bulgePinch"]; });

/* harmony import */ var _image_warp_filters_swirl__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./image-warp-filters/swirl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "swirl", function() { return _image_warp_filters_swirl__WEBPACK_IMPORTED_MODULE_26__["swirl"]; });

/* harmony import */ var _image_warp_filters_warp__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./image-warp-filters/warp */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_warp", function() { return _image_warp_filters_warp__WEBPACK_IMPORTED_MODULE_27__["warp"]; });

/* harmony import */ var _fxaa_fxaa__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./fxaa/fxaa */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fxaa", function() { return _fxaa_fxaa__WEBPACK_IMPORTED_MODULE_28__["fxaa"]; });

/* harmony import */ var _transform_transform__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./transform/transform */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_transform", function() { return _transform_transform__WEBPACK_IMPORTED_MODULE_29__["transform"]; });































//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":
/*!************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n");
//# sourceMappingURL=lights.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js ***!
  \*******************************************************************************************************/
/*! exports provided: lights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return lights; });
/* harmony import */ var _lights_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lights.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js");

const INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};

function convertColor({
  color = [0, 0, 0],
  intensity = 1.0
} = {}) {
  return color.map(component => component * intensity / 255.0);
}

function getLightSourceUniforms({
  ambientLight,
  pointLights = [],
  directionalLights = []
}) {
  const lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ('lightSources' in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;

    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }

    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }

  if ('lights' in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };

    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          lightSources.ambientLight = light;
          break;

        case 'directional':
          lightSources.directionalLights.push(light);
          break;

        case 'point':
          lightSources.pointLights.push(light);
          break;

        default:
      }
    }

    return getUniforms({
      lightSources
    });
  }

  return {};
}

const lights = {
  name: 'lights',
  vs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  fs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
//# sourceMappingURL=lights.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js ***!
  \**********************************************************************************************************/
/*! exports provided: MODULE_INJECTORS_VS, MODULE_INJECTORS_FS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODULE_INJECTORS_VS", function() { return MODULE_INJECTORS_VS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODULE_INJECTORS_FS", function() { return MODULE_INJECTORS_FS; });
const MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
const MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
//# sourceMappingURL=module-injectors.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n");
//# sourceMappingURL=pbr-fragment.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n");
//# sourceMappingURL=pbr-vertex.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js ***!
  \*************************************************************************************************/
/*! exports provided: pbr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return pbr; });
/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lights/lights */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js");
/* harmony import */ var _pbr_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pbr-vertex.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js");
/* harmony import */ var _pbr_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pbr-fragment.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js");



const pbr = {
  name: 'pbr',
  vs: _pbr_vertex_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  fs: _pbr_fragment_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__["lights"]]
};
//# sourceMappingURL=pbr.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js ***!
  \****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n");
//# sourceMappingURL=phong-lighting.glsl.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js ***!
  \***********************************************************************************************************************/
/*! exports provided: gouraudLighting, phongLighting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gouraudLighting", function() { return gouraudLighting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "phongLighting", function() { return phongLighting; });
/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lights/lights */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js");
/* harmony import */ var _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./phong-lighting.glsl */ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js");


const INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map(x => x / 255)
  };
}

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if (!('material' in opts)) {
    return {};
  }

  const {
    material
  } = opts;

  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }

  return getMaterialUniforms(material);
}

const gouraudLighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__["lights"]],
  vs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};
const phongLighting = {
  name: 'phong-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__["lights"]],
  fs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};
//# sourceMappingURL=phong-lighting.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js ***!
  \*********************************************************************************************************/
/*! exports provided: picking */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return picking; });
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};

  if (opts.pickingSelectedColor !== undefined) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }

  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, x => x / 255);

    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }

    uniforms.picking_uHighlightColor = color;
  }

  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }

  return uniforms;
}

const vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const picking = {
  name: 'picking',
  vs,
  fs,
  getUniforms
};
//# sourceMappingURL=picking.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js ***!
  \*********************************************************************************************************/
/*! exports provided: project */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "project", function() { return project; });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "../../node_modules/@math.gl/core/dist/esm/index.js");

const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {
  const uniforms = {};

  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }

  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }

  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }

  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }

  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }

  return uniforms;
}

const common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
const vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
const fs = "\n".concat(common);
const project = {
  name: 'project',
  getUniforms,
  vs,
  fs
};
//# sourceMappingURL=project.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js ***!
  \*************************************************************************************************************/
/*! exports provided: transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
const vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const transform = {
  name: 'transform',
  vs,
  fs: null
};
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js ***!
  \******************************************************************************************************/
/*! exports provided: random */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
const fs = "float random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n";
const random = {
  name: 'random',
  fs
};
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/utils/index.js ***!
  \*********************************************************************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
function isOldIE(opts = {}) {
  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
//# sourceMappingURL=is-old-ie.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js ***!
  \****************************************************************************************************/
/*! exports provided: getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQualifierDetails", function() { return getQualifierDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPassthroughFS", function() { return getPassthroughFS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeToChannelSuffix", function() { return typeToChannelSuffix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeToChannelCount", function() { return typeToChannelCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToVec4", function() { return convertToVec4; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js");

const FS100 = "void main() {gl_FragColor = vec4(0);}";
const FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const FS300 = "#version 300 es\n".concat(FS_GLES);
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  const [qualifier, type, definition] = words;

  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }

  const name = definition.split(';')[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS(options = {}) {
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;

  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }

    return FS100;
  }

  const outputValue = convertToVec4(input, inputType);

  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? 'es' : '', "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }

  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';

    case 'vec2':
      return 'xy';

    case 'vec3':
      return 'xyz';

    case 'vec4':
      return 'xyzw';

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;

    case 'vec2':
      return 2;

    case 'vec3':
      return 3;

    case 'vec4':
      return 4;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");

    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");

    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");

    case 'vec4':
      return variable;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}
//# sourceMappingURL=shader-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js ***!
  \**************************************************************************************************/
/*! exports provided: FEATURES, getContextInfo, canCompileGLGSExtension, hasFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return FEATURES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return getContextInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return canCompileGLGSExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return hasFeatures; });
/* harmony import */ var _is_old_ie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-old-ie */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js");


const GL_VENDOR = 0x1f00;
const GL_RENDERER = 0x1f01;
const GL_VERSION = 0x1f02;
const GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
const FEATURES = {};
Object.keys(WEBGL_FEATURES).forEach(key => {
  FEATURES[key] = key;
});


function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && gl._version === 2);
}

function getContextInfo(gl) {
  const info = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}

function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }

  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }

  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }

  return 'UNKNOWN GPU';
}

const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap, opts = {}) {
  const feature = WEBGL_FEATURES[cap];
  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(feature, cap);

  if (!Object(_is_old_ie__WEBPACK_IMPORTED_MODULE_0__["default"])(opts)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const behavior = opts.behavior || 'enable';
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(feature, cap);
  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(value === false || value === true);
  return value;
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => getFeature(gl, feature));
}
//# sourceMappingURL=webgl-info.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js ***!
  \********************************************************************************************/
/*! exports provided: default, DEFAULT_ACCESSOR_VALUES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Accessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ACCESSOR_VALUES", function() { return DEFAULT_ACCESSOR_VALUES; });
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");


const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};
class Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_0__["getTypedArrayFromGLType"])(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }

  static getBytesPerVertex(accessor) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(accessor.size);
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_0__["getTypedArrayFromGLType"])(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }

  static resolve(...accessors) {
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }

  constructor(...accessors) {
    accessors.forEach(accessor => this._assign(accessor));
    Object.freeze(this);
  }

  toString() {
    return JSON.stringify(this);
  }

  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }

  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }

  _assign(props = {}) {
    props = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkProps"])('Accessor', props, PROP_CHECKS);

    if (props.type !== undefined) {
      this.type = props.type;

      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }

    if (props.size !== undefined) {
      this.size = props.size;
    }

    if (props.offset !== undefined) {
      this.offset = props.offset;
    }

    if (props.stride !== undefined) {
      this.stride = props.stride;
    }

    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }

    if (props.integer !== undefined) {
      this.integer = props.integer;
    }

    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }

    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }

    if (props.index !== undefined) {
      if (typeof props.index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }

    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }

    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }

    return this;
  }

}

//# sourceMappingURL=accessor.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessor */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");





const DEBUG_DATA_LENGTH = 10;
const DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
const PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
const PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};
class Buffer extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    super(gl, props);
    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);
    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
    this.initialize(props);
    Object.seal(this);
  }

  getElementCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor__WEBPACK_IMPORTED_MODULE_1__["default"].getBytesPerElement(accessor));
  }

  getVertexCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor__WEBPACK_IMPORTED_MODULE_1__["default"].getBytesPerVertex(accessor));
  }

  initialize(props = {}) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }

    if (Number.isFinite(props)) {
      props = {
        byteLength: props
      };
    }

    props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["checkProps"])('Buffer', props, PROP_CHECKS_INITIALIZE);
    this.usage = props.usage || 35044;
    this.debugData = null;
    this.setAccessor(Object.assign({}, props, props.accessor));

    if (props.data) {
      this._setData(props.data, props.offset, props.byteLength);
    } else {
      this._setByteLength(props.byteLength || 0);
    }

    return this;
  }

  setProps(props) {
    props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["checkProps"])('Buffer', props, PROP_CHECKS_SET_PROPS);

    if ('accessor' in props) {
      this.setAccessor(props.accessor);
    }

    return this;
  }

  setAccessor(accessor) {
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;
    this.accessor = new _accessor__WEBPACK_IMPORTED_MODULE_1__["default"](accessor);
    return this;
  }

  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);

      return true;
    }

    this.bytesUsed = byteLength;
    return false;
  }

  setData(props) {
    return this.initialize(props);
  }

  subData(props) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }

    const {
      data,
      offset = 0,
      srcOffset = 0
    } = props;
    const byteLength = props.byteLength || props.length;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(data);
    const target = this.gl.webgl2 ? 36663 : this.target;
    this.gl.bindBuffer(target, this.handle);

    if (srcOffset !== 0 || byteLength !== undefined) {
      Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(this.gl);
      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data);
    }

    this.gl.bindBuffer(target, null);
    this.debugData = null;

    this._inferType(data);

    return this;
  }

  copyData({
    sourceBuffer,
    readOffset = 0,
    writeOffset = 0,
    size
  }) {
    const {
      gl
    } = this;
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(gl);
    gl.bindBuffer(36662, sourceBuffer.handle);
    gl.bindBuffer(36663, this.handle);
    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
    gl.bindBuffer(36662, null);
    gl.bindBuffer(36663, null);
    this.debugData = null;
    return this;
  }

  getData({
    dstData = null,
    srcByteOffset = 0,
    dstOffset = 0,
    length = 0
  } = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(this.gl);
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getTypedArrayFromGLType"])(this.accessor.type || 5126, {
      clamped: false
    });

    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

    const dstElementOffset = dstOffset;
    let dstAvailableElementCount;
    let dstElementCount;

    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }

    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(36662, null);
    return dstData;
  }

  bind({
    target = this.target,
    index = this.accessor && this.accessor.index,
    offset = 0,
    size
  } = {}) {
    if (target === 35345 || target === 35982) {
      if (size !== undefined) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size);
      } else {
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(offset === 0);
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }

    return this;
  }

  unbind({
    target = this.target,
    index = this.accessor && this.accessor.index
  } = {}) {
    const isIndexedBuffer = target === 35345 || target === 35982;

    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }

    return this;
  }

  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({
        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
      });
      return {
        data: this.debugData,
        changed: true
      };
    }

    return {
      data: this.debugData,
      changed: false
    };
  }

  invalidateDebugData() {
    this.debugData = null;
  }

  _setData(data, offset = 0, byteLength = data.byteLength + offset) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(ArrayBuffer.isView(data));

    this._trackDeallocatedMemory();

    const target = this._getTarget();

    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, byteLength, this.usage);
    this.gl.bufferSubData(target, offset, data);
    this.gl.bindBuffer(target, null);
    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = byteLength;

    this._trackAllocatedMemory(byteLength);

    const type = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTypeFromTypedArray"])(data);
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(type);
    this.setAccessor(new _accessor__WEBPACK_IMPORTED_MODULE_1__["default"](this.accessor, {
      type
    }));
    return this;
  }

  _setByteLength(byteLength, usage = this.usage) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(byteLength >= 0);

    this._trackDeallocatedMemory();

    let data = byteLength;

    if (byteLength === 0) {
      data = new Float32Array(0);
    }

    const target = this._getTarget();

    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);
    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;

    this._trackAllocatedMemory(byteLength);

    return this;
  }

  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }

  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getTypedArrayFromGLType"])(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }

  _inferType(data) {
    if (!this.accessor.type) {
      this.setAccessor(new _accessor__WEBPACK_IMPORTED_MODULE_1__["default"](this.accessor, {
        type: Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getGLTypeFromTypedArray"])(data)
      }));
    }
  }

  _createHandle() {
    return this.gl.createBuffer();
  }

  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);

    this._trackDeallocatedMemory();
  }

  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }

  get type() {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["log"].deprecated('Buffer.type', 'Buffer.accessor.type')();
    return this.accessor.type;
  }

  get bytes() {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["log"].deprecated('Buffer.bytes', 'Buffer.byteLength')();
    return this.byteLength;
  }

  setByteLength(byteLength) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["log"].deprecated('setByteLength', 'reallocate')();
    return this.reallocate(byteLength);
  }

  updateAccessor(opts) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["log"].deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();
    this.accessor = new _accessor__WEBPACK_IMPORTED_MODULE_1__["default"](this.accessor, opts);
    return this;
  }

}
//# sourceMappingURL=buffer.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/clear.js ***!
  \*****************************************************************************************/
/*! exports provided: clear, clearBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearBuffer", function() { return clearBuffer; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");


const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR = 0x1800;
const GL_DEPTH = 0x1801;
const GL_STENCIL = 0x1802;
const GL_DEPTH_STENCIL = 0x84f9;
const ERR_ARGUMENTS = 'clear: bad arguments';
function clear(gl, {
  framebuffer = null,
  color = null,
  depth = null,
  stencil = null
} = {}) {
  const parameters = {};

  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }

  let clearFlags = 0;

  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;

    if (color !== true) {
      parameters.clearColor = color;
    }
  }

  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }

  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(clearFlags !== 0, ERR_ARGUMENTS);
  Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl, {
  framebuffer = null,
  buffer = GL_COLOR,
  drawBuffer = 0,
  value = [0, 0, 0, 0]
} = {}) {
  Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);
  Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;

          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;

          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }

        break;

      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;

      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;

      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, ERR_ARGUMENTS);
    }
  });
}
//# sourceMappingURL=clear.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js ***!
  \*************************************************************************************************/
/*! exports provided: readPixelsToArray, readPixelsToBuffer, copyToDataUrl, copyToImage, copyToTexture, blit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readPixelsToArray", function() { return readPixelsToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readPixelsToBuffer", function() { return readPixelsToBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToDataUrl", function() { return copyToDataUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToImage", function() { return copyToImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToTexture", function() { return copyToTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blit", function() { return blit; });
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl-utils/typed-array-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js");
/* harmony import */ var _webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl-utils/format-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js");
/* harmony import */ var _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl-utils/texture-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");









function readPixelsToArray(source, options = {}) {
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || Object(_webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_5__["getGLTypeFromTypedArray"])(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return target;
}
function readPixelsToBuffer(source, {
  sourceX = 0,
  sourceY = 0,
  sourceFormat = 6408,
  target = null,
  targetByteOffset = 0,
  sourceWidth,
  sourceHeight,
  sourceType
}) {
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);

  if (!target) {
    const components = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_6__["glFormatToComponents"])(sourceFormat);
    const byteCount = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_6__["glTypeToBytes"])(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer__WEBPACK_IMPORTED_MODULE_0__["default"](gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }

  target.bind({
    target: 35051
  });
  Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["withParameters"])(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return target;
}
function copyToDataUrl(source, {
  sourceAttachment = 36064,
  targetMaxHeight = Number.MAX_SAFE_INTEGER
} = {}) {
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;

  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_4__["scalePixels"])({
      data,
      width,
      height
    }));
  }

  Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_4__["flipRows"])({
    data,
    width,
    height
  });
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d');
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToImage(source, {
  sourceAttachment = 36064,
  targetImage = null
} = {}) {
  const dataUrl = copyToDataUrl(source, {
    sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}
function copyToTexture(source, target, options = {}) {
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(target);
  let texture = null;

  if (target instanceof _texture__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }

  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;

      case 35866:
      case 32879:
        const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;

      default:
    }
  }

  if (texture) {
    texture.unbind();
  }

  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return texture;
}
function blit(source, target, options = {}) {
  const {
    sourceX0 = 0,
    sourceY0 = 0,
    targetX0 = 0,
    targetY0 = 0,
    color = true,
    depth = false,
    stencil = false,
    filter = 9728
  } = options;
  let {
    sourceX1,
    sourceY1,
    targetX1,
    targetY1,
    sourceAttachment = 36064,
    mask = 0
  } = options;
  const {
    framebuffer: srcFramebuffer,
    deleteFramebuffer: deleteSrcFramebuffer
  } = getFramebuffer(source);
  const {
    framebuffer: dstFramebuffer,
    deleteFramebuffer: deleteDstFramebuffer
  } = getFramebuffer(target);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(srcFramebuffer);
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(dstFramebuffer);
  const {
    gl,
    handle,
    width,
    height,
    readBuffer
  } = dstFramebuffer;
  const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(gl);

  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }

  if (color) {
    mask |= 16384;
  }

  if (depth) {
    mask |= 256;
  }

  if (stencil) {
    mask |= 1024;
  }

  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_3__["log"].warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  const prevDrawHandle = gl.bindFramebuffer(36009, handle);
  const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl2.readBuffer(sourceAttachment);
  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl2.readBuffer(readBuffer);
  gl2.bindFramebuffer(36008, prevReadHandle || null);
  gl2.bindFramebuffer(36009, prevDrawHandle || null);

  if (deleteSrcFramebuffer) {
    srcFramebuffer.delete();
  }

  if (deleteDstFramebuffer) {
    dstFramebuffer.delete();
  }

  return dstFramebuffer;
}

function getFramebuffer(source) {
  if (!(source instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_1__["default"])) {
    return {
      framebuffer: Object(_webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_7__["toFramebuffer"])(source),
      deleteFramebuffer: true
    };
  }

  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}

function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }

  type = type || 5121;
  const ArrayType = Object(_webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_5__["getTypedArrayFromGLType"])(type, {
    clamped: false
  });
  const components = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_6__["glFormatToComponents"])(format);
  return new ArrayType(width * height * components);
}
//# sourceMappingURL=copy-and-blit.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js ***!
  \***********************************************************************************************/
/*! exports provided: default, FRAMEBUFFER_ATTACHMENT_PARAMETERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Framebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER_ATTACHMENT_PARAMETERS", function() { return FRAMEBUFFER_ATTACHMENT_PARAMETERS; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _texture_2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-2d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _renderbuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderbuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js");
/* harmony import */ var _clear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clear */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js");
/* harmony import */ var _copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./copy-and-blit.js */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../features */ "../../node_modules/@luma.gl/webgl/dist/esm/features/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");









const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';
class Framebuffer extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, options = {}) {
    const {
      colorBufferFloat,
      colorBufferHalfFloat
    } = options;
    let supported = true;

    if (colorBufferFloat) {
      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));
    }

    if (colorBufferHalfFloat) {
      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));
    }

    return supported;
  }

  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
      id: 'default-framebuffer',
      handle: null,
      attachments: {}
    });
    return gl.luma.defaultFramebuffer;
  }

  get MAX_COLOR_ATTACHMENTS() {
    const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(this.gl);
    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
  }

  get MAX_DRAW_BUFFERS() {
    const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(this.gl);
    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.ownResources = [];
    this.initialize(opts);
    Object.seal(this);
  }

  get color() {
    return this.attachments[36064] || null;
  }

  get texture() {
    return this.attachments[36064] || null;
  }

  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }

  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }

  initialize({
    width = 1,
    height = 1,
    attachments = null,
    color = true,
    depth = true,
    stencil = false,
    check = true,
    readBuffer = undefined,
    drawBuffers = undefined
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(width >= 0 && height >= 0, 'Width and height need to be integers');
    this.width = width;
    this.height = height;

    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }

    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    });

    if (attachments && check) {
      this.checkStatus();
    }
  }

  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }

    super.delete();
    return this;
  }

  update({
    attachments = {},
    readBuffer,
    drawBuffers,
    clearAttachments = false,
    resizeAttachments = true
  }) {
    this.attach(attachments, {
      clearAttachments,
      resizeAttachments
    });
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);

    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }

    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }

    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }

  resize(options = {}) {
    let {
      width,
      height
    } = options;

    if (this.handle === null) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }

    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }

    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }

    if (width !== this.width && height !== this.height) {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
    }

    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }

    this.width = width;
    this.height = height;
    return this;
  }

  attach(attachments, {
    clearAttachments = false,
    resizeAttachments = true
  } = {}) {
    const newAttachments = {};

    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    }

    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);

    for (const key in newAttachments) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(key !== undefined, 'Misspelled framebuffer binding point?');
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;

      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;

        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      }

      if (resizeAttachments && object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }

    this.gl.bindFramebuffer(36160, prevHandle || null);
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {
      delete this.attachments[key];
    });
  }

  checkStatus() {
    const {
      gl
    } = this;
    const status = this.getStatus();

    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }

    return this;
  }

  getStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    return status;
  }

  clear(options = {}) {
    const {
      color,
      depth,
      stencil,
      drawBuffers = []
    } = options;
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);

    if (color || depth || stencil) {
      Object(_clear__WEBPACK_IMPORTED_MODULE_4__["clear"])(this.gl, {
        color,
        depth,
        stencil
      });
    }

    drawBuffers.forEach((value, drawBuffer) => {
      Object(_clear__WEBPACK_IMPORTED_MODULE_4__["clearBuffer"])(this.gl, {
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }

  readPixels(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();
    return null;
  }

  readPixelsToBuffer(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();
    return null;
  }

  copyToDataUrl(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();
    return null;
  }

  copyToImage(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();
    return null;
  }

  copyToTexture(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }

  blit(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();
    return null;
  }

  invalidate({
    attachments = [],
    x = 0,
    y = 0,
    width,
    height
  }) {
    const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(this.gl);
    const prevHandle = gl2.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

    if (invalidateAll) {
      gl2.invalidateFramebuffer(36008, attachments);
    } else {
      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }

    gl2.bindFramebuffer(36008, prevHandle);
    return this;
  }

  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);

    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }

    if (keys && value > 1000) {
      value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, value);
    }

    return value;
  }

  getAttachmentParameters(attachment = 36064, keys, parameters = this.constructor.ATTACHMENT_PARAMETERS || []) {
    const values = {};

    for (const pname of parameters) {
      const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }

    return values;
  }

  getParameters(keys = true) {
    const attachments = Object.keys(this.attachments);
    const parameters = {};

    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }

    return parameters;
  }

  show() {
    if (typeof window !== 'undefined') {
      window.open(Object(_copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__["copyToDataUrl"])(this), 'luma-debug-texture');
    }

    return this;
  }

  log(logLevel = 0, message = '') {
    if (logLevel > _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].level || typeof window === 'undefined') {
      return this;
    }

    message = message || "Framebuffer ".concat(this.id);
    const image = Object(_copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__["copyToDataUrl"])(this, {
      targetMaxHeight: 100
    });
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].image({
      logLevel,
      message,
      image
    }, message)();
    return this;
  }

  bind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }

  unbind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, null);
    return this;
  }

  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;

    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new _texture_2d__WEBPACK_IMPORTED_MODULE_2__["default"](this.gl, {
        id: "".concat(this.id, "-color0"),
        pixels: null,
        format: 6408,
        type: 5121,
        width,
        height,
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.ownResources.push(defaultAttachments[36064]);
    }

    if (depth && stencil) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl, {
        id: "".concat(this.id, "-depth-stencil"),
        format: 35056,
        width,
        height: 111
      });
      this.ownResources.push(defaultAttachments[33306]);
    } else if (depth) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl, {
        id: "".concat(this.id, "-depth"),
        format: 33189,
        width,
        height
      });
      this.ownResources.push(defaultAttachments[36096]);
    } else if (stencil) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(false);
    }

    return defaultAttachments;
  }

  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];

    if (!oldAttachment) {
      return;
    }

    if (oldAttachment instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    } else {
      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
    }

    delete this.attachments[attachment];
  }

  _attachRenderbuffer({
    attachment = 36064,
    renderbuffer
  }) {
    const {
      gl
    } = this;
    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    this.attachments[attachment] = renderbuffer;
  }

  _attachTexture({
    attachment = 36064,
    texture,
    layer,
    level
  }) {
    const {
      gl
    } = this;
    gl.bindTexture(texture.target, texture.handle);

    switch (texture.target) {
      case 35866:
      case 32879:
        const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);
        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;

      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;

      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(false, 'Illegal texture type');
    }

    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }

  _setReadBuffer(readBuffer) {
    const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["getWebGL2Context"])(this.gl);

    if (gl2) {
      gl2.readBuffer(readBuffer);
    } else {
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }

    this.readBuffer = readBuffer;
  }

  _setDrawBuffers(drawBuffers) {
    const {
      gl
    } = this;
    const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);

    if (gl2) {
      gl2.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL_draw_buffers');

      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }

    this.drawBuffers = drawBuffers;
  }

  _getAttachmentParameterFallback(pname) {
    const caps = Object(_features__WEBPACK_IMPORTED_MODULE_6__["getFeatures"])(this.gl);

    switch (pname) {
      case 36052:
        return !caps.WEBGL2 ? 0 : null;

      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return !caps.WEBGL2 ? 8 : null;

      case 33297:
        return !caps.WEBGL2 ? 5125 : null;

      case 33296:
        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;

      default:
        return null;
    }
  }

  _createHandle() {
    return this.gl.createFramebuffer();
  }

  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }

  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }

}

function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}

function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}

const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
//# sourceMappingURL=framebuffer.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProgramConfiguration; });
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accessor */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js");



class ProgramConfiguration {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);

    this._readAttributesFromProgram(program);

    this._readVaryingsFromProgram(program);
  }

  getAttributeInfo(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return this.attributeInfosByLocation[location];
    }

    return this.attributeInfosByName[locationOrName] || null;
  }

  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }

  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }

  getVaryingInfo(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return this.varyingInfos[location];
    }

    return this.varyingInfosByName[locationOrName] || null;
  }

  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }

  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }

  _readAttributesFromProgram(program) {
    const {
      gl
    } = program;
    const count = gl.getProgramParameter(program.handle, 35721);

    for (let index = 0; index < count; index++) {
      const {
        name,
        type,
        size
      } = gl.getActiveAttrib(program.handle, index);
      const location = gl.getAttribLocation(program.handle, name);

      if (location >= 0) {
        this._addAttribute(location, name, type, size);
      }
    }

    this.attributeInfos.sort((a, b) => a.location - b.location);
  }

  _readVaryingsFromProgram(program) {
    const {
      gl
    } = program;

    if (!Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      return;
    }

    const count = gl.getProgramParameter(program.handle, 35971);

    for (let location = 0; location < count; location++) {
      const {
        name,
        type,
        size
      } = gl.getTransformFeedbackVarying(program.handle, location);

      this._addVarying(location, name, type, size);
    }

    this.varyingInfos.sort((a, b) => a.location - b.location);
  }

  _addAttribute(location, name, compositeType, size) {
    const {
      type,
      components
    } = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["decomposeCompositeGLType"])(compositeType);
    const accessor = {
      type,
      size: size * components
    };

    this._inferProperties(location, name, accessor);

    const attributeInfo = {
      location,
      name,
      accessor: new _accessor__WEBPACK_IMPORTED_MODULE_0__["default"](accessor)
    };
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location] = attributeInfo;
    this.attributeInfosByName[attributeInfo.name] = attributeInfo;
  }

  _inferProperties(location, name, accessor) {
    if (/instance/i.test(name)) {
      accessor.divisor = 1;
    }
  }

  _addVarying(location, name, compositeType, size) {
    const {
      type,
      components
    } = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["decomposeCompositeGLType"])(compositeType);
    const accessor = new _accessor__WEBPACK_IMPORTED_MODULE_0__["default"]({
      type,
      size: size * components
    });
    const varying = {
      location,
      name,
      accessor
    };
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying;
  }

}
//# sourceMappingURL=program-configuration.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/program.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Program; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uniforms */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shader */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js");
/* harmony import */ var _program_configuration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./program-configuration */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");











const LOG_PROGRAM_PERF_PRIORITY = 4;
const GL_SEPARATE_ATTRIBS = 0x8c8d;
const V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];
class Program extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    super(gl, props);
    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);
    this._isCached = false;
    this.initialize(props);
    Object.seal(this);

    this._setId(props.id);
  }

  initialize(props = {}) {
    const {
      hash,
      vs,
      fs,
      varyings,
      bufferMode = GL_SEPARATE_ATTRIBS
    } = props;
    this.hash = hash || '';
    this.vs = typeof vs === 'string' ? new _shader__WEBPACK_IMPORTED_MODULE_4__["VertexShader"](this.gl, {
      id: "".concat(props.id, "-vs"),
      source: vs
    }) : vs;
    this.fs = typeof fs === 'string' ? new _shader__WEBPACK_IMPORTED_MODULE_4__["FragmentShader"](this.gl, {
      id: "".concat(props.id, "-fs"),
      source: fs
    }) : fs;
    Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(this.vs instanceof _shader__WEBPACK_IMPORTED_MODULE_4__["VertexShader"]);
    Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(this.fs instanceof _shader__WEBPACK_IMPORTED_MODULE_4__["FragmentShader"]);
    this.uniforms = {};
    this._textureUniforms = {};

    if (varyings && varyings.length > 0) {
      Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["assertWebGL2Context"])(this.gl);
      this.varyings = varyings;
      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }

    this._compileAndLink();

    this._readUniformLocationsFromLinkedProgram();

    this.configuration = new _program_configuration__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    return this.setProps(props);
  }

  delete(options = {}) {
    if (this._isCached) {
      return this;
    }

    return super.delete(options);
  }

  setProps(props) {
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }

    return this;
  }

  draw({
    logPriority,
    drawMode = 4,
    vertexCount,
    offset = 0,
    start,
    end,
    isIndexed = false,
    indexType = 5123,
    instanceCount = 0,
    isInstanced = instanceCount > 0,
    vertexArray = null,
    transformFeedback,
    framebuffer,
    parameters = {},
    uniforms,
    samplers
  }) {
    if (uniforms || samplers) {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();
      this.setUniforms(uniforms || {});
    }

    if (_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].priority >= logPriority) {
      const fb = framebuffer ? framebuffer.id : 'default';
      const message = "mode=".concat(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].log(logPriority, message)();
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(vertexArray);
    this.gl.useProgram(this.handle);

    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
      return false;
    }

    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== undefined) {
        parameters = Object.assign({}, parameters, {
          framebuffer
        });
      }

      if (transformFeedback) {
        const primitiveMode = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_8__["getPrimitiveDrawMode"])(drawMode);
        transformFeedback.begin(primitiveMode);
      }

      this._bindTextures();

      Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["withParameters"])(this.gl, parameters, () => {
        if (isIndexed && isInstanced) {
          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["isWebGL2"])(this.gl) && !isNaN(start) && !isNaN(end)) {
          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });

      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    return true;
  }

  setUniforms(uniforms = {}) {
    if (_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].priority >= 2) {
      Object(_uniforms__WEBPACK_IMPORTED_MODULE_3__["checkUniformValues"])(uniforms, this.id, this._uniformSetters);
    }

    this.gl.useProgram(this.handle);

    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];

      if (uniformSetter) {
        let value = uniform;
        let textureUpdate = false;

        if (value instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          value = value.texture;
        }

        if (value instanceof _texture__WEBPACK_IMPORTED_MODULE_1__["default"]) {
          textureUpdate = this.uniforms[uniformName] !== uniform;

          if (textureUpdate) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }

            const texture = value;
            const {
              textureIndex
            } = uniformSetter;
            texture.bind(textureIndex);
            value = textureIndex;
            this._textureUniforms[uniformName] = texture;
          } else {
            value = uniformSetter.textureIndex;
          }
        } else if (this._textureUniforms[uniformName]) {
          delete this._textureUniforms[uniformName];
        }

        if (uniformSetter(value) || textureUpdate) {
          Object(_uniforms__WEBPACK_IMPORTED_MODULE_3__["copyUniform"])(this.uniforms, uniformName, uniform);
        }
      }
    }

    return this;
  }

  _areTexturesRenderable() {
    let texturesRenderable = true;

    for (const uniformName in this._textureUniforms) {
      const texture = this._textureUniforms[uniformName];
      texture.update();
      texturesRenderable = texturesRenderable && texture.loaded;
    }

    return texturesRenderable;
  }

  _bindTextures() {
    for (const uniformName in this._textureUniforms) {
      const textureIndex = this._uniformSetters[uniformName].textureIndex;

      this._textureUniforms[uniformName].bind(textureIndex);
    }
  }

  _createHandle() {
    return this.gl.createProgram();
  }

  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }

  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};

    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, 35663);

      switch (type) {
        case 35633:
          opts.vs = new _shader__WEBPACK_IMPORTED_MODULE_4__["VertexShader"]({
            handle: shaderHandle
          });
          break;

        case 35632:
          opts.fs = new _shader__WEBPACK_IMPORTED_MODULE_4__["FragmentShader"]({
            handle: shaderHandle
          });
          break;

        default:
      }
    }

    return opts;
  }

  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }

  _setId(id) {
    if (!id) {
      const programName = this._getName();

      this.id = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["uid"])(programName);
    }
  }

  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, '');
    programName = programName ? "".concat(programName, "-program") : 'program';
    return programName;
  }

  _compileAndLink() {
    const {
      gl
    } = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    gl.linkProgram(this.handle);
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

    if (gl.debug || _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_6__["log"].level > 0) {
      const linked = gl.getProgramParameter(this.handle, 35714);

      if (!linked) {
        throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
      }

      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);

      if (!validated) {
        throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
      }
    }
  }

  _readUniformLocationsFromLinkedProgram() {
    const {
      gl
    } = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(35718);

    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {
        name
      } = Object(_uniforms__WEBPACK_IMPORTED_MODULE_3__["parseUniformName"])(info.name);
      let location = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = Object(_uniforms__WEBPACK_IMPORTED_MODULE_3__["getUniformSetter"])(gl, location, info);

      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
          this._uniformSetters["".concat(name, "[").concat(l, "]")] = Object(_uniforms__WEBPACK_IMPORTED_MODULE_3__["getUniformSetter"])(gl, location, info);
        }
      }
    }

    this._textureIndexCounter = 0;
  }

  getActiveUniforms(uniformIndices, pname) {
    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
  }

  getUniformBlockIndex(blockName) {
    return this.gl2.getUniformBlockIndex(this.handle, blockName);
  }

  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }

  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }

}
//# sourceMappingURL=program.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/query.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/query.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Query; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features */ "../../node_modules/@luma.gl/webgl/dist/esm/features/index.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");




const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_TIME_ELAPSED_EXT = 0x88bf;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const GL_ANY_SAMPLES_PASSED = 0x8c2f;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class Query extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static isSupported(gl, opts = []) {
    const webgl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl);
    const hasTimerQuery = Object(_features__WEBPACK_IMPORTED_MODULE_1__["hasFeatures"])(gl, _features__WEBPACK_IMPORTED_MODULE_1__["FEATURES"].TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;

    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;

        case 'timers':
          supported = supported && hasTimerQuery;
          break;

        default:
          Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(false);
      }
    }

    return supported;
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }

  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }

  beginOcclusionQuery({
    conservative = false
  } = {}) {
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }

  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }

  begin(target) {
    if (this._queryPending) {
      return this;
    }

    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }

  end() {
    if (this._queryPending) {
      return this;
    }

    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }

    return this;
  }

  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }

    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);

    if (resultAvailable) {
      this._queryPending = false;
    }

    return resultAvailable;
  }

  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);
  }

  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }

  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }

  createPoll(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }

    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };

      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }

  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }

  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }

}
//# sourceMappingURL=query.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';
/* harmony default export */ __webpack_exports__["default"] = ({
  [33189]: {
    bpp: 2
  },
  [33190]: {
    gl2: true,
    bpp: 3
  },
  [36012]: {
    gl2: true,
    bpp: 4
  },
  [36168]: {
    bpp: 1
  },
  [34041]: {
    bpp: 4
  },
  [35056]: {
    gl2: true,
    bpp: 4
  },
  [36013]: {
    gl2: true,
    bpp: 5
  },
  [32854]: {
    bpp: 2
  },
  [36194]: {
    bpp: 2
  },
  [32855]: {
    bpp: 2
  },
  [33321]: {
    gl2: true,
    bpp: 1
  },
  [33330]: {
    gl2: true,
    bpp: 1
  },
  [33329]: {
    gl2: true,
    bpp: 1
  },
  [33332]: {
    gl2: true,
    bpp: 2
  },
  [33331]: {
    gl2: true,
    bpp: 2
  },
  [33334]: {
    gl2: true,
    bpp: 4
  },
  [33333]: {
    gl2: true,
    bpp: 4
  },
  [33323]: {
    gl2: true,
    bpp: 2
  },
  [33336]: {
    gl2: true,
    bpp: 2
  },
  [33335]: {
    gl2: true,
    bpp: 2
  },
  [33338]: {
    gl2: true,
    bpp: 4
  },
  [33337]: {
    gl2: true,
    bpp: 4
  },
  [33340]: {
    gl2: true,
    bpp: 8
  },
  [33339]: {
    gl2: true,
    bpp: 8
  },
  [32849]: {
    gl2: true,
    bpp: 3
  },
  [32856]: {
    gl2: true,
    bpp: 4
  },
  [32857]: {
    gl2: true,
    bpp: 4
  },
  [36220]: {
    gl2: true,
    bpp: 4
  },
  [36238]: {
    gl2: true,
    bpp: 4
  },
  [36975]: {
    gl2: true,
    bpp: 4
  },
  [36214]: {
    gl2: true,
    bpp: 8
  },
  [36232]: {
    gl2: true,
    bpp: 8
  },
  [36226]: {
    gl2: true,
    bpp: 16
  },
  [36208]: {
    gl2: true,
    bpp: 16
  },
  [33325]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  },
  [33327]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [34842]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [33326]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [33328]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [34836]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  },
  [35898]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }
});
//# sourceMappingURL=renderbuffer-formats.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderbuffer; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderbuffer-formats */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");





function isFormatSupported(gl, format, formats) {
  const info = formats[format];

  if (!info) {
    return false;
  }

  const value = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl) ? info.gl2 || info.gl1 : info.gl1;

  if (typeof value === 'string') {
    return gl.getExtension(value);
  }

  return value;
}

class Renderbuffer extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static isSupported(gl, {
    format
  } = {
    format: null
  }) {
    return !format || isFormatSupported(gl, format, _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_1__["default"]);
  }

  static getSamplesForFormat(gl, {
    format
  }) {
    return gl.getInternalformatParameter(36161, format, 32937);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.initialize(opts);
    Object.seal(this);
  }

  initialize({
    format,
    width = 1,
    height = 1,
    samples = 0
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(format, 'Needs format');

    this._trackDeallocatedMemory();

    this.gl.bindRenderbuffer(36161, this.handle);

    if (samples !== 0 && Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(this.gl)) {
      this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(36161, format, width, height);
    }

    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;

    this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_1__["default"][this.format].bpp);

    return this;
  }

  resize({
    width,
    height
  }) {
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        samples: this.samples
      });
    }

    return this;
  }

  _createHandle() {
    return this.gl.createRenderbuffer();
  }

  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);

    this._trackDeallocatedMemory();
  }

  _bindHandle(handle) {
    this.gl.bindRenderbuffer(36161, handle);
  }

  _syncHandle(handle) {
    this.format = this.getParameter(36164);
    this.width = this.getParameter(36162);
    this.height = this.getParameter(36163);
    this.samples = this.getParameter(36011);
  }

  _getParameter(pname) {
    this.gl.bindRenderbuffer(36161, this.handle);
    const value = this.gl.getRenderbufferParameter(36161, pname);
    return value;
  }

}
//# sourceMappingURL=renderbuffer.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/resource.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../init */ "../../node_modules/@luma.gl/webgl/dist/esm/init.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");




const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';
class Resource {
  constructor(gl, opts = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGLContext"])(gl);
    const {
      id,
      userData = {}
    } = opts;
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || Object(_utils__WEBPACK_IMPORTED_MODULE_3__["uid"])(this.constructor.name);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;

    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }

    this.byteLength = 0;

    this._addStats();
  }

  toString() {
    return "".concat(this.constructor.name, "(").concat(this.id, ")");
  }

  get handle() {
    return this._handle;
  }

  delete({
    deleteChildren = false
  } = {}) {
    const children = this._handle && this._deleteHandle(this._handle);

    if (this._handle) {
      this._removeStats();
    }

    this._handle = null;

    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => child.delete());
    }

    return this;
  }

  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);

      return this;
    }

    let value;

    if (!this._bound) {
      this._bindHandle(this.handle);

      this._bound = true;
      value = funcOrHandle();
      this._bound = false;

      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }

    return value;
  }

  unbind() {
    this.bind(null);
  }

  getParameter(pname, opts = {}) {
    pname = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getKeyValue"])(this.gl, pname);
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];

    if (parameter) {
      const isWebgl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }

    return this._getParameter(pname, opts);
  }

  getParameters(options = {}) {
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);

    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (parameterAvailable) {
        const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getKey"])(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, options);

        if (keys && parameter.type === 'GLenum') {
          values[key] = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getKey"])(this.gl, values[key]);
        }
      }
    }

    return values;
  }

  setParameter(pname, value) {
    pname = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getKeyValue"])(this.gl, pname);
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];

    if (parameter) {
      const isWebgl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }

      if (parameter.type === 'GLenum') {
        value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["getKeyValue"])(value);
      }
    }

    this._setParameter(pname, value);

    return this;
  }

  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }

    return this;
  }

  stubRemovedMethods(className, version, methodNames) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_3__["stubRemovedMethods"])(this, className, version, methodNames);
  }

  initialize(opts) {}

  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }

  _addStats() {
    const name = this.constructor.name;
    const stats = _init__WEBPACK_IMPORTED_MODULE_1__["lumaStats"].get('Resource Counts');
    stats.get('Resources Created').incrementCount();
    stats.get("".concat(name, "s Created")).incrementCount();
    stats.get("".concat(name, "s Active")).incrementCount();
  }

  _removeStats() {
    const name = this.constructor.name;
    const stats = _init__WEBPACK_IMPORTED_MODULE_1__["lumaStats"].get('Resource Counts');
    stats.get("".concat(name, "s Active")).decrementCount();
  }

  _trackAllocatedMemory(bytes, name = this.constructor.name) {
    const stats = _init__WEBPACK_IMPORTED_MODULE_1__["lumaStats"].get('Memory Usage');
    stats.get('GPU Memory').addCount(bytes);
    stats.get("".concat(name, " Memory")).addCount(bytes);
    this.byteLength = bytes;
  }

  _trackDeallocatedMemory(name = this.constructor.name) {
    const stats = _init__WEBPACK_IMPORTED_MODULE_1__["lumaStats"].get('Memory Usage');
    stats.get('GPU Memory').subtractCount(this.byteLength);
    stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
    this.byteLength = 0;
  }

}
//# sourceMappingURL=resource.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/shader.js ***!
  \******************************************************************************************/
/*! exports provided: Shader, VertexShader, FragmentShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return Shader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return VertexShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return FragmentShader; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _glsl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glsl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");




const ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';
class Shader extends _resource__WEBPACK_IMPORTED_MODULE_3__["default"] {
  static getTypeName(shaderType) {
    switch (shaderType) {
      case 35633:
        return 'vertex-shader';

      case 35632:
        return 'fragment-shader';

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(false);
        return 'unknown';
    }
  }

  constructor(gl, props) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGLContext"])(gl);
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(typeof props.source === 'string', ERR_SOURCE);
    const id = Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(props.source, null) || props.id || Object(_utils__WEBPACK_IMPORTED_MODULE_2__["uid"])("unnamed ".concat(Shader.getTypeName(props.shaderType)));
    super(gl, {
      id
    });
    this.shaderType = props.shaderType;
    this.source = props.source;
    this.initialize(props);
  }

  initialize({
    source
  }) {
    const shaderName = Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(source, null);

    if (shaderName) {
      this.id = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["uid"])(shaderName);
    }

    this._compile(source);
  }

  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }

  toString() {
    return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
  }

  getName() {
    return Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(this.source) || 'unnamed-shader';
  }

  getSource() {
    return this.gl.getShaderSource(this.handle);
  }

  getTranslatedSource() {
    const extension = this.gl.getExtension('WEBGL_debug_shaders');
    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
  }

  _compile(source = this.source) {
    if (!source.startsWith('#version ')) {
      source = "#version 100\n".concat(source);
    }

    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);
    const compileStatus = this.getParameter(35713);

    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {
        shaderName,
        errors,
        warnings
      } = Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["parseGLSLCompilerError"])(infoLog, this.source, this.shaderType, this.id);
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
      throw new Error("GLSL compilation errors in ".concat(shaderName));
    }
  }

  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }

  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }

}
class VertexShader extends Shader {
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    super(gl, Object.assign({}, props, {
      shaderType: 35633
    }));
  }

  _createHandle() {
    return this.gl.createShader(35633);
  }

}
class FragmentShader extends Shader {
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    super(gl, Object.assign({}, props, {
      shaderType: 35632
    }));
  }

  _createHandle() {
    return this.gl.createShader(35632);
  }

}
//# sourceMappingURL=shader.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture2D; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");
/* harmony import */ var _utils_load_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/load-file */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js");



class Texture2D extends _texture__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, opts) {
    return _texture__WEBPACK_IMPORTED_MODULE_1__["default"].isSupported(gl, opts);
  }

  constructor(gl, props = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGLContext"])(gl);

    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }

    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: Object(_utils_load_file__WEBPACK_IMPORTED_MODULE_2__["loadImage"])(props.data)
      });
    }

    super(gl, Object.assign({}, props, {
      target: 3553
    }));
    this.initialize(props);
    Object.seal(this);
  }

}
//# sourceMappingURL=texture-2d.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture3D; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");
/* harmony import */ var _texture_formats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-formats */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");




class Texture3D extends _texture__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl) {
    return Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    super(gl, props);
    this.initialize(props);
    Object.seal(this);
  }

  setImageData({
    level = 0,
    dataFormat = 6408,
    width,
    height,
    depth = 1,
    border = 0,
    format,
    type = 5121,
    offset = 0,
    data,
    parameters = {}
  }) {
    this._trackDeallocatedMemory('Texture');

    this.gl.bindTexture(this.target, this.handle);
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
      }

      if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.gl.bindBuffer(35052, data.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
      }
    });

    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _texture_formats__WEBPACK_IMPORTED_MODULE_2__["DATA_FORMAT_CHANNELS"][this.dataFormat] || 4;
      const channelSize = _texture_formats__WEBPACK_IMPORTED_MODULE_2__["TYPE_SIZES"][this.type] || 1;

      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
    }

    this.loaded = true;
    return this;
  }

}
//# sourceMappingURL=texture-3d.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureCube; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");


const FACES = [34069, 34070, 34071, 34072, 34073, 34074];
class TextureCube extends _texture__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGLContext"])(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }

  initialize(props = {}) {
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;

      if (mipmaps) {
        this.generateMipmap(props);
      }

      this.setParameters(parameters);
    });
    return this;
  }

  subImage({
    face,
    data,
    x = 0,
    y = 0,
    mipmapLevel = 0
  }) {
    return this._subImage({
      target: face,
      data,
      x,
      y,
      mipmapLevel
    });
  }

  async setCubeMapImageData({
    width,
    height,
    pixels,
    data,
    border = 0,
    format = 6408,
    type = 5121
  }) {
    const {
      gl
    } = this;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(FACES.map(face => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn("".concat(this.id, " has mipmap and multiple LODs."))();
      }

      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }

  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data;
    this.bind();

    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }

    return this;
  }

}
TextureCube.FACES = FACES;
//# sourceMappingURL=texture-cube.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js ***!
  \***************************************************************************************************/
/*! exports provided: TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_FORMATS", function() { return TEXTURE_FORMATS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_FORMAT_CHANNELS", function() { return DATA_FORMAT_CHANNELS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TYPE_SIZES", function() { return TYPE_SIZES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFormatSupported", function() { return isFormatSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLinearFilteringSupported", function() { return isLinearFilteringSupported; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");

const TEXTURE_FORMATS = {
  [6407]: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  [6408]: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  [6406]: {
    dataFormat: 6406,
    types: [5121]
  },
  [6409]: {
    dataFormat: 6409,
    types: [5121]
  },
  [6410]: {
    dataFormat: 6410,
    types: [5121]
  },
  [33326]: {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  },
  [33328]: {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  },
  [34837]: {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  },
  [34836]: {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }
};
const DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
const TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];

  if (!info) {
    return false;
  }

  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }

  const value = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];

  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');

    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');

    default:
      return true;
  }
}
//# sourceMappingURL=texture-formats.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/texture.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _texture_formats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./texture-formats */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");






const NPOT_MIN_FILTERS = [9729, 9728];

const WebGLBuffer = probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["global"].WebGLBuffer || function WebGLBuffer() {};

class Texture extends _resource__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static isSupported(gl, opts = {}) {
    const {
      format,
      linearFiltering
    } = opts;
    let supported = true;

    if (format) {
      supported = supported && Object(_texture_formats__WEBPACK_IMPORTED_MODULE_4__["isFormatSupported"])(gl, format);
      supported = supported && (!linearFiltering || Object(_texture_formats__WEBPACK_IMPORTED_MODULE_4__["isLinearFilteringSupported"])(gl, format));
    }

    return supported;
  }

  constructor(gl, props) {
    const {
      id = Object(_utils__WEBPACK_IMPORTED_MODULE_5__["uid"])('texture'),
      handle,
      target
    } = props;
    super(gl, {
      id,
      handle
    });
    this.target = target;
    this.textureUnit = undefined;
    this.loaded = false;
    this.width = undefined;
    this.height = undefined;
    this.depth = undefined;
    this.format = undefined;
    this.type = undefined;
    this.dataFormat = undefined;
    this.border = undefined;
    this.textureUnit = undefined;
    this.mipmaps = undefined;
  }

  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }

  initialize(props = {}) {
    let data = props.data;

    if (data instanceof Promise) {
      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }

    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;

    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener('loadeddata', () => this.initialize(props));
      return this;
    }

    const {
      pixels = null,
      format = 6408,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = undefined
    } = props;

    if (!data) {
      data = pixels;
    }

    let {
      width,
      height,
      dataFormat,
      type,
      compressed = false,
      mipmaps = true
    } = props;
    const {
      depth = 0
    } = props;
    ({
      width,
      height,
      compressed,
      dataFormat,
      type
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;

    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }

    if (mipmaps && this._isNPOT()) {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      mipmaps = false;

      this._updateForNPOT(parameters);
    }

    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: pixelStore,
      compressed
    });

    if (mipmaps) {
      this.generateMipmap();
    }

    this.setParameters(parameters);

    if (recreate) {
      this.data = data;
    }

    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }

    return this;
  }

  update() {
    if (this._video) {
      const {
        video,
        parameters,
        lastTime
      } = this._video;

      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }

      this.setSubImageData({
        data: video,
        parameters
      });

      if (this.mipmaps) {
        this.generateMipmap();
      }

      this._video.lastTime = video.currentTime;
    }
  }

  resize({
    height,
    width,
    mipmaps = false
  }) {
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }

    return this;
  }

  generateMipmap(params = {}) {
    if (this._isNPOT()) {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      return this;
    }

    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }

  setImageData(options) {
    this._trackDeallocatedMemory('Texture');

    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;

    if (!data) {
      data = pixels;
    }

    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const {
      gl
    } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({
      data,
      dataType
    } = this._getDataType({
      data,
      compressed
    }));
    let gl2;
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(this.gl, parameters, () => {
      switch (dataType) {
        case 'null':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;

        case 'typed-array':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
          break;

        case 'buffer':
          gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);
          gl2.bindBuffer(35052, data.handle || data);
          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
          break;

        case 'browser-object':
          if (Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data);
          }

          break;

        case 'compressed':
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
          }

          break;

        default:
          Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false, 'Unknown image data type');
      }
    });

    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _texture_formats__WEBPACK_IMPORTED_MODULE_4__["DATA_FORMAT_CHANNELS"][this.dataFormat] || 4;
      const channelSize = _texture_formats__WEBPACK_IMPORTED_MODULE_4__["TYPE_SIZES"][this.type] || 1;

      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
    }

    this.loaded = true;
    return this;
  }

  setSubImageData({
    target = this.target,
    pixels = null,
    data = null,
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    level = 0,
    format = this.format,
    type = this.type,
    dataFormat = this.dataFormat,
    compressed = false,
    offset = 0,
    border = this.border,
    parameters = {}
  }) {
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(this.depth === 0, 'texSubImage not supported for 3D textures');

    if (!data) {
      data = pixels;
    }

    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }

    if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      data = data.handle;
    }

    this.gl.bindTexture(this.target, this.handle);
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (data instanceof WebGLBuffer) {
        const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(this.gl);
        gl2.bindBuffer(35052, data);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(35052, null);
      } else if (Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl)) {
        const gl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(this.gl);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }

  copyFramebuffer(opts = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }

  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }

  bind(textureUnit = this.textureUnit) {
    const {
      gl
    } = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }

    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }

  unbind(textureUnit = this.textureUnit) {
    const {
      gl
    } = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }

    gl.bindTexture(this.target, null);
    return textureUnit;
  }

  _getDataType({
    data,
    compressed = false
  }) {
    if (compressed) {
      return {
        data,
        dataType: 'compressed'
      };
    }

    if (data === null) {
      return {
        data,
        dataType: 'null'
      };
    }

    if (ArrayBuffer.isView(data)) {
      return {
        data,
        dataType: 'typed-array'
      };
    }

    if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      return {
        data: data.handle,
        dataType: 'buffer'
      };
    }

    if (data instanceof WebGLBuffer) {
      return {
        data,
        dataType: 'buffer'
      };
    }

    return {
      data,
      dataType: 'browser-object'
    };
  }

  _deduceParameters(opts) {
    const {
      format,
      data
    } = opts;
    let {
      width,
      height,
      dataFormat,
      type,
      compressed
    } = opts;
    const textureFormat = _texture_formats__WEBPACK_IMPORTED_MODULE_4__["TEXTURE_FORMATS"][format];
    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
    type = type || textureFormat && textureFormat.types[0];
    compressed = compressed || textureFormat && textureFormat.compressed;
    ({
      width,
      height
    } = this._deduceImageSize(data, width, height));
    return {
      dataFormat,
      type,
      compressed,
      width,
      height,
      format,
      data
    };
  }

  _deduceImageSize(data, width, height) {
    let size;

    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
      size = {
        width: data.naturalWidth,
        height: data.naturalHeight
      };
    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
      size = {
        width: data.videoWidth,
        height: data.videoHeight
      };
    } else if (!data) {
      size = {
        width: width >= 0 ? width : 1,
        height: height >= 0 ? height : 1
      };
    } else {
      size = {
        width,
        height
      };
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(size, 'Could not deduced texture size');
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
    return size;
  }

  _createHandle() {
    return this.gl.createTexture();
  }

  _deleteHandle() {
    this.gl.deleteTexture(this.handle);

    this._trackDeallocatedMemory('Texture');
  }

  _getParameter(pname) {
    switch (pname) {
      case 4096:
        return this.width;

      case 4097:
        return this.height;

      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }

  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);
    param = this._getNPOTParam(pname, param);

    switch (pname) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, pname, param);
        break;

      case 4096:
      case 4097:
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false);
        break;

      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }

    this.gl.bindTexture(this.target, null);
    return this;
  }

  _isNPOT() {
    if (Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl)) {
      return false;
    }

    if (!this.width || !this.height) {
      return false;
    }

    return !Object(_utils__WEBPACK_IMPORTED_MODULE_5__["isPowerOfTwo"])(this.width) || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__["isPowerOfTwo"])(this.height);
  }

  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }

    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }

    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }

  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case 10241:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            param = 9729;
          }

          break;

        case 10242:
        case 10243:
          if (param !== 33071) {
            param = 33071;
          }

          break;

        default:
          break;
      }
    }

    return param;
  }

}
//# sourceMappingURL=texture.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformFeedback; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");




class TransformFeedback extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl) {
    return Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["assertWebGL2Context"])(gl);
    super(gl, props);
    this.initialize(props);
    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);
    Object.seal(this);
  }

  initialize(props = {}) {
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;

    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isObjectEmpty"])(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }

    this.setProps(props);
    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }

    if ('configuration' in props) {
      this.configuration = props.configuration;
    }

    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }

    if ('buffers' in props) {
      this.setBuffers(props.buffers);
    }
  }

  setBuffers(buffers = {}) {
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }

  setBuffer(locationOrName, bufferOrParams) {
    const location = this._getVaryingIndex(locationOrName);

    const {
      buffer,
      byteSize,
      byteOffset
    } = this._getBufferParams(bufferOrParams);

    if (location < 0) {
      this.unused[locationOrName] = buffer;
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn(() => "".concat(this.id, " unused varying buffer ").concat(locationOrName))();
      return this;
    }

    this.buffers[location] = bufferOrParams;

    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteSize);
    }

    return this;
  }

  begin(primitiveMode = 0) {
    this.gl.bindTransformFeedback(36386, this.handle);

    this._bindBuffers();

    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }

  end() {
    this.gl.endTransformFeedback();

    this._unbindBuffers();

    this.gl.bindTransformFeedback(36386, null);
    return this;
  }

  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;

    if (bufferOrParams instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"] === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }

    if (byteOffset !== undefined || byteSize !== undefined) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }

    return {
      buffer,
      byteOffset,
      byteSize
    };
  }

  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }

  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }

    const location = Number(locationOrName);
    return Number.isFinite(location) ? location : -1;
  }

  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(this.buffers[bufferIndex]);

        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }

  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }

  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {
    const handle = buffer && buffer.handle;

    if (!handle || byteSize === undefined) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
    }

    return this;
  }

  _createHandle() {
    return this.gl.createTransformFeedback();
  }

  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }

  _bindHandle(handle) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }

}
//# sourceMappingURL=transform-feedback.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UniformBufferLayout; });
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");


const ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
const GL_FLOAT = 0x1406;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;
class UniformBufferLayout {
  constructor(layout) {
    this.layout = {};
    this.size = 0;

    for (const key in layout) {
      this._addUniform(key, layout[key]);
    }

    this.size += (4 - this.size % 4) % 4;
    const data = new Float32Array(this.size);
    this.typedArray = {
      [GL_FLOAT]: data,
      [GL_INT]: new Int32Array(data.buffer),
      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)
    };
  }

  getBytes() {
    return this.size * 4;
  }

  getData() {
    return this.typedArray[GL_FLOAT];
  }

  getSubData(index) {
    let data;
    let offset;

    if (index === undefined) {
      data = this.data;
      offset = 0;
    } else {
      const begin = this.offsets[index];
      const end = begin + this.sizes[index];
      data = this.data.subarray(begin, end);
      offset = begin * 4;
    }

    return {
      data,
      offset
    };
  }

  setUniforms(values) {
    for (const key in values) {
      this._setValue(key, values[key]);
    }

    return this;
  }

  _setValue(key, value) {
    const layout = this.layout[key];
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(layout, 'UniformLayoutStd140 illegal argument');
    const typedArray = this.typedArray[layout.type];

    if (layout.size === 1) {
      typedArray[layout.offset] = value;
    } else {
      typedArray.set(value, layout.offset);
    }
  }

  _addUniform(key, uniformType) {
    const typeAndComponents = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__["decomposeCompositeGLType"])(uniformType);
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeAndComponents, ERR_ARGUMENT);
    const {
      type,
      components: count
    } = typeAndComponents;
    this.size = this._alignTo(this.size, count);
    const offset = this.size;
    this.size += count;
    this.layout[key] = {
      type,
      size: count,
      offset
    };
  }

  _alignTo(size, count) {
    switch (count) {
      case 1:
        return size;

      case 2:
        return size + size % 2;

      default:
        return size + (4 - size % 4) % 4;
    }
  }

}
//# sourceMappingURL=uniform-buffer-layout.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js ***!
  \********************************************************************************************/
/*! exports provided: getUniformSetter, parseUniformName, checkUniformValues, copyUniform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniformSetter", function() { return getUniformSetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseUniformName", function() { return parseUniformName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkUniformValues", function() { return checkUniformValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyUniform", function() { return copyUniform; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _renderbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderbuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");





const UNIFORM_SETTERS = {
  [5126]: getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),
  [35664]: getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),
  [35665]: getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),
  [35666]: getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),
  [5124]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35667]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35668]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35669]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35670]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35671]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35672]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35673]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35674]: getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),
  [35675]: getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),
  [35676]: getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [5125]: getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),
  [36294]: getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),
  [36295]: getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),
  [36296]: getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),
  [35685]: getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),
  [35686]: getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),
  [35687]: getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),
  [35688]: getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),
  [35689]: getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),
  [35690]: getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [35679]: getSamplerSetter,
  [35682]: getSamplerSetter,
  [36289]: getSamplerSetter,
  [36292]: getSamplerSetter,
  [36293]: getSamplerSetter,
  [36298]: getSamplerSetter,
  [36299]: getSamplerSetter,
  [36300]: getSamplerSetter,
  [36303]: getSamplerSetter,
  [36306]: getSamplerSetter,
  [36307]: getSamplerSetter,
  [36308]: getSamplerSetter,
  [36311]: getSamplerSetter
};
const FLOAT_ARRAY = {};
const INT_ARRAY = {};
const UINT_ARRAY = {};
const array1 = [0];

function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }

  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }

  const length = value.length;

  if (length % uniformLength) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }

  if (value instanceof Type) {
    return value;
  }

  let result = cache[length];

  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }

  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }

  return result;
}

function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}

function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}

function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}

function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];

  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }

  return setter().bind(null, gl, location);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }

  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = name.match(UNIFORM_NAME_REGEXP);

  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}
function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);

    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : '';
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }

  return true;
}

function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }

  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    return true;
  } else if (value instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    return true;
  } else if (value instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    return Boolean(value.texture);
  }

  return false;
}

function copyUniform(uniforms, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms[key]) {
      const dest = uniforms[key];

      for (let i = 0, len = value.length; i < len; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms[key] = value.slice();
    }
  } else {
    uniforms[key] = value;
  }
}

function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }

  const checkLength = Math.min(value.length, 16);

  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }

  return true;
}

function getSamplerSetter() {
  let cache = null;
  return (gl, location, value) => {
    const update = cache !== value;

    if (update) {
      gl.uniform1i(location, value);
      cache = value;
    }

    return update;
  };
}

function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache = null;
  let cacheLength = null;
  return (gl, location, value) => {
    const arrayValue = toArray(value, size);
    const length = arrayValue.length;
    let update = false;

    if (cache === null) {
      cache = new Float32Array(length);
      cacheLength = length;
      update = true;
    } else {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(cacheLength === length, 'Uniform length cannot change.');

      for (let i = 0; i < length; ++i) {
        if (arrayValue[i] !== cache[i]) {
          update = true;
          break;
        }
      }
    }

    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache.set(arrayValue);
    }

    return update;
  };
}

function setVectorUniform(gl, functionName, location, value) {
  gl[functionName](location, value);
}

function setMatrixUniform(gl, functionName, location, value) {
  gl[functionName](location, false, value);
}
//# sourceMappingURL=uniforms.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArrayObject; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/array-utils-flat */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");






const ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';
class VertexArrayObject extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static isSupported(gl, options = {}) {
    if (options.constantAttributeZero) {
      return Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl) || Object(probe_gl__WEBPACK_IMPORTED_MODULE_5__["getBrowser"])() === 'Chrome';
    }

    return true;
  }

  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};

    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
        handle: null,
        isDefaultArray: true
      });
    }

    return gl.luma.defaultVertexArray;
  }

  static getMaxAttributes(gl) {
    VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
    return VertexArrayObject.MAX_ATTRIBUTES;
  }

  static setConstant(gl, location, array) {
    switch (array.constructor) {
      case Float32Array:
        VertexArrayObject._setConstantFloatArray(gl, location, array);

        break;

      case Int32Array:
        VertexArrayObject._setConstantIntArray(gl, location, array);

        break;

      case Uint32Array:
        VertexArrayObject._setConstantUintArray(gl, location, array);

        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(false);
    }
  }

  constructor(gl, opts = {}) {
    const id = opts.id || opts.program && opts.program.id;
    super(gl, Object.assign({}, opts, {
      id
    }));
    this.buffer = null;
    this.bufferValue = null;
    this.isDefaultArray = opts.isDefaultArray || false;
    this.gl2 = gl;
    this.initialize(opts);
    Object.seal(this);
  }

  delete() {
    super.delete();

    if (this.buffer) {
      this.buffer.delete();
    }

    return this;
  }

  get MAX_ATTRIBUTES() {
    return VertexArrayObject.getMaxAttributes(this.gl);
  }

  initialize(props = {}) {
    return this.setProps(props);
  }

  setProps(props) {
    return this;
  }

  setElementBuffer(elementBuffer = null, opts = {}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
    this.bind(() => {
      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
    });
    return this;
  }

  setBuffer(location, buffer, accessor) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, accessor);
    }

    const {
      size,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = accessor;
    const {
      gl,
      gl2
    } = this;
    location = Number(location);
    this.bind(() => {
      gl.bindBuffer(34962, buffer.handle);

      if (integer) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl));
        gl2.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }

      gl.enableVertexAttribArray(location);
      gl2.vertexAttribDivisor(location, divisor || 0);
    });
    return this;
  }

  enable(location, enable = true) {
    const disablingAttributeZero = !enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    });

    if (!disablingAttributeZero) {
      location = Number(location);
      this.bind(() => enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
    }

    return this;
  }

  getConstantBuffer(elementCount, value) {
    const constantValue = this._normalizeConstantArrayValue(value);

    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || new _buffer__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);

    if (updateNeeded) {
      const typedArray = Object(_utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_3__["getScratchArray"])(value.constructor, length);
      Object(_utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_3__["fillArray"])({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }

    return this.buffer;
  }

  _normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }

    return arrayValue;
  }

  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }

    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }

    return true;
  }

  static _setConstantFloatArray(gl, location, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location, array);
        break;

      case 2:
        gl.vertexAttrib2fv(location, array);
        break;

      case 3:
        gl.vertexAttrib3fv(location, array);
        break;

      case 4:
        gl.vertexAttrib4fv(location, array);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(false);
    }
  }

  static _setConstantIntArray(gl, location, array) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl));

    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location, array);
        break;

      case 2:
        gl.vertexAttribI2iv(location, array);
        break;

      case 3:
        gl.vertexAttribI3iv(location, array);
        break;

      case 4:
        gl.vertexAttribI4iv(location, array);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(false);
    }
  }

  static _setConstantUintArray(gl, location, array) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl));

    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location, array);
        break;

      case 2:
        gl.vertexAttribI2uiv(location, array);
        break;

      case 3:
        gl.vertexAttribI3uiv(location, array);
        break;

      case 4:
        gl.vertexAttribI4uiv(location, array);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(false);
    }
  }

  _createHandle() {
    const gl2 = this.gl;
    return gl2.createVertexArray();
  }

  _deleteHandle(handle) {
    this.gl2.deleteVertexArray(handle);
    return [this.elements];
  }

  _bindHandle(handle) {
    this.gl2.bindVertexArray(handle);
  }

  _getParameter(pname, {
    location
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Number.isFinite(location));
    return this.bind(() => {
      switch (pname) {
        case 34373:
          return this.gl.getVertexAttribOffset(location, pname);

        default:
          return this.gl.getVertexAttrib(location, pname);
      }
    });
  }

}
//# sourceMappingURL=vertex-array-object.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArray; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessor */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex-array-object */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");





const ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
const MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];
class VertexArray {
  constructor(gl, opts = {}) {
    const id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.attributes = {};
    this.vertexArrayObject = new _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"](gl);
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["stubRemovedMethods"])(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }

  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }

    this.vertexArrayObject.delete();
  }

  initialize(props = {}) {
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }

  reset() {
    this.elements = null;
    this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES
    } = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};
    this.drawParams = null;
    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }

    if ('configuration' in props) {
      this.configuration = props.configuration;
    }

    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }

    if ('elements' in props) {
      this.setElementBuffer(props.elements);
    }

    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }

    return this;
  }

  clearDrawParams() {
    this.drawParams = null;
  }

  getDrawParams() {
    this.drawParams = this.drawParams || this._updateDrawParams();
    return this.drawParams;
  }

  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];

        this._setAttribute(locationOrName, value);
      }

      this.gl.bindBuffer(34962, null);
    });
    return this;
  }

  setElementBuffer(elementBuffer = null, accessor = {}) {
    this.elements = elementBuffer;
    this.elementsAccessor = accessor;
    this.clearDrawParams();
    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    return this;
  }

  setBuffer(locationOrName, buffer, appAccessor = {}) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, appAccessor);
    }

    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);

    if (location >= 0) {
      this.values[location] = buffer;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setBuffer(location, buffer, accessor);
    }

    return this;
  }

  setConstant(locationOrName, arrayValue, appAccessor = {}) {
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
      size: arrayValue.length
    }, appAccessor));

    if (location >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
      this.values[location] = arrayValue;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.enable(location, false);
    }

    return this;
  }

  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.vertexArrayObject.setElementBuffer(null);
      }

      this.buffer = this.buffer || new _buffer__WEBPACK_IMPORTED_MODULE_2__["default"](this.gl, {
        accessor: {
          size: 4
        }
      });

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        if (this.values[location] instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.gl.disableVertexAttribArray(location);
          this.gl.bindBuffer(34962, this.buffer.handle);
          this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
        }
      }
    });
    return this;
  }

  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        const buffer = this.values[location];

        if (buffer instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.setBuffer(location, buffer);
        }
      }
    });
    return this;
  }

  bindForDraw(vertexCount, instanceCount, func) {
    let value;
    this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(vertexCount, instanceCount);

      value = func();
    });
    return value;
  }

  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const INVALID_RESULT = {
      location: -1,
      accessor: null
    };

    const {
      location,
      name
    } = this._getAttributeIndex(locationOrName);

    if (!Number.isFinite(location) || location < 0) {
      this.unused[locationOrName] = value;
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
      return INVALID_RESULT;
    }

    const accessInfo = this._getAttributeInfo(name || location);

    if (!accessInfo) {
      return INVALID_RESULT;
    }

    const currentAccessor = this.accessors[location] || {};
    const accessor = _accessor__WEBPACK_IMPORTED_MODULE_1__["default"].resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
    const {
      size,
      type
    } = accessor;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Number.isFinite(size) && Number.isFinite(type));
    return {
      location,
      accessor
    };
  }

  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }

  _getAttributeIndex(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return {
        location
      };
    }

    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;

    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }

    return {
      location: -1
    };
  }

  _setAttribute(locationOrName, value) {
    if (value instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }

  _setConstantAttributes(vertexCount, instanceCount) {
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];

    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }

    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      constant = this.values[location];

      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location, constant);
      }
    }
  }

  _setConstantAttributeZero(constant, elementCount) {
    if (_vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].isSupported(this.gl, {
      constantAttributeZero: true
    })) {
      this._setConstantAttribute(0, constant);

      return;
    }

    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }

  _setConstantAttribute(location, constant) {
    _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].setConstant(this.gl, location, constant);
  }

  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };

    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      this._updateDrawParamsForLocation(drawParams, location);
    }

    if (this.elements) {
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }

    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }

    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }

    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }

    return drawParams;
  }

  _updateDrawParamsForLocation(drawParams, location) {
    const value = this.values[location];
    const accessor = this.accessors[location];

    if (!value) {
      return;
    }

    const {
      divisor
    } = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;

    if (value instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const buffer = value;

      if (isInstanced) {
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }

  setElements(elementBuffer = null, accessor = {}) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].deprecated('setElements', 'setElementBuffer')();
    return this.setElementBuffer(elementBuffer, accessor);
  }

}
//# sourceMappingURL=vertex-array.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js ***!
  \*************************************************************************************************************/
/*! exports provided: getDebugTableForProgramConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForProgramConfiguration", function() { return getDebugTableForProgramConfiguration; });
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js");

function getDebugTableForProgramConfiguration(config) {
  const table = {};
  const header = "Accessors for ".concat(config.id);

  for (const attributeInfo of config.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }

  for (const varyingInfo of config.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }

  return table;
}

function getGLSLDeclaration(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__["getCompositeGLType"])(type, size);

  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }

  return attributeInfo.name;
}
//# sourceMappingURL=debug-program-configuration.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js ***!
  \************************************************************************************************/
/*! exports provided: getDebugTableForUniforms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForUniforms", function() { return getDebugTableForUniforms; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");

function getDebugTableForUniforms({
  header = 'Uniforms',
  program,
  uniforms,
  undefinedOnly = false
}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(program);
  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count = 0;

  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  let unusedCount = 0;
  const unusedTable = {};

  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];

      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: Object(_utils__WEBPACK_IMPORTED_MODULE_0__["formatValue"])(uniform)
        };
      }
    }
  }

  return {
    table,
    count,
    unusedTable,
    unusedCount
  };
}

function addUniformToTable({
  table,
  header,
  uniforms,
  uniformName,
  undefinedOnly
}) {
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);

  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__["formatValue"])(value) : 'N/A',
      'Uniform Type': isDefined ? value : 'NOT PROVIDED'
    };
    return true;
  }

  return false;
}

function isUniformDefined(value) {
  return value !== undefined && value !== null;
}
//# sourceMappingURL=debug-uniforms.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js ***!
  \****************************************************************************************************/
/*! exports provided: getDebugTableForVertexArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForVertexArray", function() { return getDebugTableForVertexArray; });
/* harmony import */ var _classes_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");




function getDebugTableForVertexArray({
  vertexArray,
  header = 'Attributes'
}) {
  if (!vertexArray.configuration) {
    return {};
  }

  const table = {};

  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }

  const attributes = vertexArray.values;

  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);

    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];

      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }

      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }

  return table;
}

function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;

  if (!attribute) {
    return {
      [header]: 'null',
      'Format ': 'N/A'
    };
  }

  let type = 'NOT PROVIDED';
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;

  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }

  if (attribute instanceof _classes_buffer__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;

    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKey"])(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }

    return {
      [header]: "".concat(marker).concat(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["formatValue"])(value, {
        size,
        isInteger
      })),
      'Format ': format
    };
  }

  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return {
    [header]: "".concat(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["formatValue"])(value, {
      size,
      isInteger
    }), " (constant)"),
    'Format ': "".concat(size, "x").concat(type, " (constant)")
  };
}

function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getCompositeGLType"])(type, size);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}
//# sourceMappingURL=debug-vertex-array.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return canCompileGLGSExtension; });
/* harmony import */ var _check_old_ie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./check-old-ie */ "../../node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js");
/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-features-table */ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");



const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap, options = {}) {
  const feature = _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__["default"][cap];
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(feature, cap);

  if (!Object(_check_old_ie__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
//# sourceMappingURL=check-glsl-extension.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
function isOldIE(opts = {}) {
  const navigator = typeof window !== 'undefined' && window.navigator || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
//# sourceMappingURL=check-old-ie.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/features.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/features.js ***!
  \*********************************************************************************************/
/*! exports provided: hasFeature, hasFeatures, getFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return hasFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return hasFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return getFeatures; });
/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-features-table */ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");



const LOG_UNSUPPORTED_FEATURE = 2;
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};

  for (const cap in _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    if (gl.luma.caps[cap] === undefined) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }

  return gl.luma.caps;
}

function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};

  if (gl.luma.caps[cap] === undefined) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }

  if (!gl.luma.caps[cap]) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["log"].log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }

  return gl.luma.caps[cap];
}

function queryFeature(gl, cap) {
  const feature = _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__["default"][cap];
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(feature, cap);
  let isSupported;
  const featureDefinition = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? feature[1] || feature[0] : feature[0];

  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;

    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(false);
  }

  return isSupported;
}
//# sourceMappingURL=features.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/index.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/index.js ***!
  \******************************************************************************************/
/*! exports provided: getContextInfo, getGLContextInfo, getContextLimits, FEATURES, hasFeature, hasFeatures, getFeatures, canCompileGLGSExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _limits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limits */ "../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getGLContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getContextLimits"]; });

/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-features-table */ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__["FEATURES"]; });

/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./features */ "../../node_modules/@luma.gl/webgl/dist/esm/features/features.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["hasFeature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["hasFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["getFeatures"]; });

/* harmony import */ var _check_glsl_extension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./check-glsl-extension */ "../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return _check_glsl_extension__WEBPACK_IMPORTED_MODULE_3__["default"]; });





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/limits.js ***!
  \*******************************************************************************************/
/*! exports provided: getContextLimits, getGLContextInfo, getContextInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return getContextLimits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return getGLContextInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return getContextInfo; });
/* harmony import */ var _webgl_limits_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-limits-table */ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");


function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    const isWebgl2 = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl);

    for (const parameter in _webgl_limits_table__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      const limit = _webgl_limits_table__WEBPACK_IMPORTED_MODULE_0__["default"][parameter];
      const webgl1MinLimit = limit.gl1;
      const webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      const minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      const limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      const value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}
function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  const info = Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["getContextDebugInfo"])(gl);

  if (!gl.luma.info) {
    gl.luma.info = {
      [37445]: info.vendor,
      [37446]: info.renderer,
      [7936]: info.vendorMasked,
      [7937]: info.rendererMasked,
      [7938]: info.version,
      [35724]: info.shadingLanguageVersion
    };
  }

  return gl.luma.info;
}
function getContextInfo(gl) {
  return Object.assign(Object(_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_1__["getContextDebugInfo"])(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}
//# sourceMappingURL=limits.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js ***!
  \*********************************************************************************************************/
/*! exports provided: FEATURES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return FEATURES; });
/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/texture-2d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");


const FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  FLOAT_BLEND: 'FLOAT_BLEND',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};

function checkFloat32ColorAttachment(gl) {
  const testTexture = new _classes_texture_2d__WEBPACK_IMPORTED_MODULE_1__["default"](gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new _classes_framebuffer__WEBPACK_IMPORTED_MODULE_0__["default"](gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  [FEATURES.WEBGL2]: [false, true],
  [FEATURES.VERTEX_ARRAY_OBJECT]: ['OES_vertex_array_object', true],
  [FEATURES.TIMER_QUERY]: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
  [FEATURES.INSTANCED_RENDERING]: ['ANGLE_instanced_arrays', true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ['WEBGL_draw_buffers', true],
  [FEATURES.ELEMENT_INDEX_UINT32]: ['OES_element_index_uint', true],
  [FEATURES.BLEND_EQUATION_MINMAX]: ['EXT_blend_minmax', true],
  [FEATURES.FLOAT_BLEND]: ['EXT_float_blend'],
  [FEATURES.COLOR_ENCODING_SRGB]: ['EXT_sRGB', true],
  [FEATURES.TEXTURE_DEPTH]: ['WEBGL_depth_texture', true],
  [FEATURES.TEXTURE_FLOAT]: ['OES_texture_float', true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ['OES_texture_half_float', true],
  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ['OES_texture_float_linear'],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ['OES_texture_half_float_linear'],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ['EXT_texture_filter_anisotropic'],
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ['EXT_color_buffer_half_float'],
  [FEATURES.GLSL_FRAG_DATA]: ['WEBGL_draw_buffers', true],
  [FEATURES.GLSL_FRAG_DEPTH]: ['EXT_frag_depth', true],
  [FEATURES.GLSL_DERIVATIVES]: ['OES_standard_derivatives', true],
  [FEATURES.GLSL_TEXTURE_LOD]: ['EXT_shader_texture_lod', true]
});
//# sourceMappingURL=webgl-features-table.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  [33902]: {
    gl1: new Float32Array([1, 1])
  },
  [33901]: {
    gl1: new Float32Array([1, 1])
  },
  [3379]: {
    gl1: 64,
    gl2: 2048
  },
  [34076]: {
    gl1: 16
  },
  [34930]: {
    gl1: 8
  },
  [35661]: {
    gl1: 8
  },
  [35660]: {
    gl1: 0
  },
  [34024]: {
    gl1: 1
  },
  [36348]: {
    gl1: 8
  },
  [34921]: {
    gl1: 8
  },
  [36347]: {
    gl1: 128
  },
  [36349]: {
    gl1: 16
  },
  [3386]: {
    gl1: new Int32Array([0, 0])
  },
  [32883]: {
    gl1: 0,
    gl2: 256
  },
  [35071]: {
    gl1: 0,
    gl2: 256
  },
  [37447]: {
    gl1: 0,
    gl2: 0
  },
  [36063]: {
    gl1: 0,
    gl2: 4
  },
  [35379]: {
    gl1: 0,
    gl2: 0
  },
  [35374]: {
    gl1: 0,
    gl2: 0
  },
  [35377]: {
    gl1: 0,
    gl2: 0
  },
  [34852]: {
    gl1: 0,
    gl2: 4
  },
  [36203]: {
    gl1: 0,
    gl2: 0
  },
  [33001]: {
    gl1: 0,
    gl2: 0
  },
  [33000]: {
    gl1: 0,
    gl2: 0
  },
  [37157]: {
    gl1: 0,
    gl2: 0
  },
  [35373]: {
    gl1: 0,
    gl2: 0
  },
  [35657]: {
    gl1: 0,
    gl2: 0
  },
  [36183]: {
    gl1: 0,
    gl2: 0
  },
  [37137]: {
    gl1: 0,
    gl2: 0
  },
  [34045]: {
    gl1: 0,
    gl2: 0
  },
  [35978]: {
    gl1: 0,
    gl2: 0
  },
  [35979]: {
    gl1: 0,
    gl2: 0
  },
  [35968]: {
    gl1: 0,
    gl2: 0
  },
  [35376]: {
    gl1: 0,
    gl2: 0
  },
  [35375]: {
    gl1: 0,
    gl2: 0
  },
  [35659]: {
    gl1: 0,
    gl2: 0
  },
  [37154]: {
    gl1: 0,
    gl2: 0
  },
  [35371]: {
    gl1: 0,
    gl2: 0
  },
  [35658]: {
    gl1: 0,
    gl2: 0
  },
  [35076]: {
    gl1: 0,
    gl2: -8,
    negative: true
  },
  [35077]: {
    gl1: 0,
    gl2: 7
  },
  [35380]: {
    gl1: 0,
    gl2: 0
  }
});
//# sourceMappingURL=webgl-limits-table.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js ***!
  \********************************************************************************************************/
/*! exports provided: default, parseGLSLCompilerError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatGLSLCompilerError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLSLCompilerError", function() { return parseGLSLCompilerError; });
/* harmony import */ var _get_shader_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-shader-name */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js");
/* harmony import */ var _get_shader_type_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-shader-type-name */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js");


function formatGLSLCompilerError(errLog, src, shaderType) {
  const {
    shaderName,
    errors,
    warnings
  } = parseGLSLCompilerError(errLog, src, shaderType);
  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || Object(_get_shader_name__WEBPACK_IMPORTED_MODULE_0__["default"])(src) || '(unnamed)';
  const shaderDescription = "".concat(Object(_get_shader_type_name__WEBPACK_IMPORTED_MODULE_1__["default"])(shaderType), " shader ").concat(name);

  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];

    if (errorString.length <= 1) {
      continue;
    }

    const segments = errorString.split(':');
    const type = segments[0];
    const line = parseInt(segments[2], 10);

    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }

    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }

  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}

function formatErrors(errors, lines) {
  let message = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }

    message += "".concat(line, "\n");

    if (errors[i + 1]) {
      const error = errors[i + 1];
      const segments = error.split(':', 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }

  return message;
}

function addLineNumbers(string, start = 1, delim = ': ') {
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}

function padLeft(string, digits) {
  let result = '';

  for (let i = 0; i < digits; ++i) {
    result += ' ';
  }

  return "".concat(result).concat(string);
}
//# sourceMappingURL=format-glsl-error.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderName; });
function getShaderName(shader, defaultName = 'unnamed') {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
//# sourceMappingURL=get-shader-name.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderTypeName; });
const GL_FRAGMENT_SHADER = 0x8b30;
const GL_VERTEX_SHADER = 0x8b31;
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';

    case GL_VERTEX_SHADER:
      return 'vertex';

    default:
      return 'unknown type';
  }
}
//# sourceMappingURL=get-shader-type-name.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderVersion; });
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);

  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);

    if (Number.isFinite(v)) {
      version = v;
    }
  }

  return version;
}
//# sourceMappingURL=get-shader-version.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js ***!
  \********************************************************************************************/
/*! exports provided: formatGLSLCompilerError, parseGLSLCompilerError, getShaderName, getShaderVersion, getShaderTypeName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format-glsl-error */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatGLSLCompilerError", function() { return _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseGLSLCompilerError", function() { return _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__["parseGLSLCompilerError"]; });

/* harmony import */ var _get_shader_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-shader-name */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderName", function() { return _get_shader_name__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _get_shader_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-shader-version */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderVersion", function() { return _get_shader_version__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _get_shader_type_name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-shader-type-name */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderTypeName", function() { return _get_shader_type_name__WEBPACK_IMPORTED_MODULE_3__["default"]; });





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/index.js":
/*!*********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/index.js ***!
  \*********************************************************************************/
/*! exports provided: lumaStats, requestAnimationFrame, cancelAnimationFrame, cloneTextureFrom, getKeyValue, getKey, getContextInfo, getGLContextInfo, getContextLimits, FEATURES, hasFeature, hasFeatures, getFeatures, canCompileGLGSExtension, Accessor, Buffer, Shader, VertexShader, FragmentShader, Program, Framebuffer, Renderbuffer, Texture2D, TextureCube, clear, clearBuffer, readPixelsToArray, readPixelsToBuffer, copyToDataUrl, copyToImage, copyToTexture, blit, Query, Texture3D, TransformFeedback, VertexArrayObject, VertexArray, UniformBufferLayout, setPathPrefix, loadFile, loadImage, getShaderName, getShaderVersion, log, assert, uid, isObjectEmpty, parseUniformName, getUniformSetter, getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../../node_modules/@luma.gl/webgl/dist/esm/init.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lumaStats", function() { return _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"]; });

/* harmony import */ var _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-utils/request-animation-frame */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_1__["requestAnimationFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_1__["cancelAnimationFrame"]; });

/* harmony import */ var _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-utils/texture-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_2__["cloneTextureFrom"]; });

/* harmony import */ var _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl-utils/constants-to-keys */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_3__["getKeyValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_3__["getKey"]; });

/* harmony import */ var _features_limits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./features/limits */ "../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_4__["getContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_4__["getGLContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_4__["getContextLimits"]; });

/* harmony import */ var _features_webgl_features_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./features/webgl-features-table */ "../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return _features_webgl_features_table__WEBPACK_IMPORTED_MODULE_5__["FEATURES"]; });

/* harmony import */ var _features_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./features/features */ "../../node_modules/@luma.gl/webgl/dist/esm/features/features.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return _features_features__WEBPACK_IMPORTED_MODULE_6__["hasFeature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return _features_features__WEBPACK_IMPORTED_MODULE_6__["hasFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return _features_features__WEBPACK_IMPORTED_MODULE_6__["getFeatures"]; });

/* harmony import */ var _features_check_glsl_extension__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./features/check-glsl-extension */ "../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return _features_check_glsl_extension__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _classes_accessor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./classes/accessor */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Accessor", function() { return _classes_accessor__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _classes_buffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./classes/buffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return _classes_buffer__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _classes_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./classes/shader */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_10__["Shader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_10__["VertexShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_10__["FragmentShader"]; });

/* harmony import */ var _classes_program__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./classes/program */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Program", function() { return _classes_program__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./classes/framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return _classes_framebuffer__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _classes_renderbuffer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./classes/renderbuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Renderbuffer", function() { return _classes_renderbuffer__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./classes/texture-2d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture2D", function() { return _classes_texture_2d__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _classes_texture_cube__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./classes/texture-cube */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextureCube", function() { return _classes_texture_cube__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _classes_clear__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./classes/clear */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return _classes_clear__WEBPACK_IMPORTED_MODULE_16__["clear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearBuffer", function() { return _classes_clear__WEBPACK_IMPORTED_MODULE_16__["clearBuffer"]; });

/* harmony import */ var _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./classes/copy-and-blit */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToArray", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["readPixelsToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToBuffer", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["readPixelsToBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToDataUrl", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["copyToDataUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToImage", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["copyToImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToTexture", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["copyToTexture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blit", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_17__["blit"]; });

/* harmony import */ var _classes_query__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./classes/query */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/query.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return _classes_query__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _classes_texture_3d__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classes/texture-3d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture3D", function() { return _classes_texture_3d__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _classes_transform_feedback__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./classes/transform-feedback */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformFeedback", function() { return _classes_transform_feedback__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _classes_vertex_array_object__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classes/vertex-array-object */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArrayObject", function() { return _classes_vertex_array_object__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _classes_vertex_array__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./classes/vertex-array */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArray", function() { return _classes_vertex_array__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _classes_uniform_buffer_layout__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./classes/uniform-buffer-layout */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniformBufferLayout", function() { return _classes_uniform_buffer_layout__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _utils_load_file__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./utils/load-file */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_24__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_24__["loadFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_24__["loadImage"]; });

/* harmony import */ var _glsl_utils_get_shader_name__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./glsl-utils/get-shader-name */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderName", function() { return _glsl_utils_get_shader_name__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _glsl_utils_get_shader_version__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./glsl-utils/get-shader-version */ "../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderVersion", function() { return _glsl_utils_get_shader_version__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_27__["log"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./utils/utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _utils_utils__WEBPACK_IMPORTED_MODULE_29__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _utils_utils__WEBPACK_IMPORTED_MODULE_29__["isObjectEmpty"]; });

/* harmony import */ var _classes_uniforms__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./classes/uniforms */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseUniformName", function() { return _classes_uniforms__WEBPACK_IMPORTED_MODULE_30__["parseUniformName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUniformSetter", function() { return _classes_uniforms__WEBPACK_IMPORTED_MODULE_30__["getUniformSetter"]; });

/* harmony import */ var _debug_debug_uniforms__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./debug/debug-uniforms */ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForUniforms", function() { return _debug_debug_uniforms__WEBPACK_IMPORTED_MODULE_31__["getDebugTableForUniforms"]; });

/* harmony import */ var _debug_debug_vertex_array__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./debug/debug-vertex-array */ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForVertexArray", function() { return _debug_debug_vertex_array__WEBPACK_IMPORTED_MODULE_32__["getDebugTableForVertexArray"]; });

/* harmony import */ var _debug_debug_program_configuration__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./debug/debug-program-configuration */ "../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForProgramConfiguration", function() { return _debug_debug_program_configuration__WEBPACK_IMPORTED_MODULE_33__["getDebugTableForProgramConfiguration"]; });



































//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/init.js":
/*!********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/init.js ***!
  \********************************************************************************/
/*! exports provided: lumaStats, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lumaStats", function() { return lumaStats; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_2__);



const VERSION =  true ? "8.5.4" : undefined;
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';

class StatsManager {
  constructor() {
    this.stats = new Map();
  }

  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new probe_gl__WEBPACK_IMPORTED_MODULE_1__["Stats"]({
        id: name
      }));
    }

    return this.stats.get(name);
  }

}

const lumaStats = new StatsManager();

if (probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma && probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma.VERSION !== VERSION) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma.VERSION, " vs ").concat(VERSION));
}

if (!probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma) {
  if (Object(probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["isBrowser"])()) {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].log(1, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
  }

  probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma = probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma || {
    VERSION,
    version: VERSION,
    log: _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"],
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}


/* harmony default export */ __webpack_exports__["default"] = (probe_gl_env__WEBPACK_IMPORTED_MODULE_2__["global"].luma);
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js ***!
  \**************************************************************************************************/
/*! exports provided: getScratchArrayBuffer, getScratchArray, fillArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScratchArrayBuffer", function() { return getScratchArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScratchArray", function() { return getScratchArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillArray", function() { return fillArray; });
let arrayBuffer = null;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }

  return arrayBuffer;
}
function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}
function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;

  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}
//# sourceMappingURL=array-utils-flat.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/assert.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js ***!
  \*********************************************************************************************/
/*! exports provided: checkProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkProps", function() { return checkProps; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");

function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;

  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : 'N/A';
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].removed("".concat(className, ".").concat(propName), replacement)();
    }
  }

  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }

  let newProps = null;

  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }

  return newProps || props;
}
//# sourceMappingURL=check-props.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js ***!
  \**********************************************************************************************/
/*! exports provided: formatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';

  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatValue(v, opts = {}) {
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
//# sourceMappingURL=format-value.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/index.js ***!
  \***************************************************************************************/
/*! exports provided: assert, isOldIE, uid, isPowerOfTwo, isObjectEmpty, formatValue, stubRemovedMethods, checkProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _is_old_ie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-old-ie */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/is-old-ie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isOldIE", function() { return _is_old_ie__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__["isPowerOfTwo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__["isObjectEmpty"]; });

/* harmony import */ var _format_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./format-value */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return _format_value__WEBPACK_IMPORTED_MODULE_3__["formatValue"]; });

/* harmony import */ var _stub_methods__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stub-methods */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stubRemovedMethods", function() { return _stub_methods__WEBPACK_IMPORTED_MODULE_4__["stubRemovedMethods"]; });

/* harmony import */ var _check_props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./check-props */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkProps", function() { return _check_props__WEBPACK_IMPORTED_MODULE_5__["checkProps"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/is-old-ie.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/is-old-ie.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl/env */ "../../node_modules/probe.gl/env.js");
/* harmony import */ var probe_gl_env__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(probe_gl_env__WEBPACK_IMPORTED_MODULE_0__);

function isOldIE(opts = {}) {
  return Object(probe_gl_env__WEBPACK_IMPORTED_MODULE_0__["getBrowser"])(opts.userAgent) === 'IE';
}
//# sourceMappingURL=is-old-ie.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js ***!
  \*******************************************************************************************/
/*! exports provided: setPathPrefix, loadFile, loadImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");

let pathPrefix = '';
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function loadFile(url, options = {}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof url === 'string');
  url = pathPrefix + url;
  const dataType = options.dataType || 'text';
  return fetch(url, options).then(res => res[dataType]());
}
function loadImage(url, opts) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();

      image.onload = () => resolve(image);

      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));

      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
//# sourceMappingURL=load-file.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js ***!
  \**********************************************************************************************/
/*! exports provided: stubRemovedMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stubRemovedMethods", function() { return stubRemovedMethods; });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "../../node_modules/@luma.gl/gltools/dist/esm/index.js");

function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(methodName => {
    if (prototype.methodName) {
      return;
    }

    prototype[methodName] = () => {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__["log"].removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}
//# sourceMappingURL=stub-methods.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/utils/utils.js ***!
  \***************************************************************************************/
/*! exports provided: uid, isPowerOfTwo, isObjectEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return uid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return isPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return isObjectEmpty; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");

const uidCounters = {};
function uid(id = 'id') {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return "".concat(id, "-").concat(count);
}
function isPowerOfTwo(n) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}
function isObjectEmpty(obj) {
  let isEmpty = true;

  for (const key in obj) {
    isEmpty = false;
    break;
  }

  return isEmpty;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js ***!
  \*******************************************************************************************************/
/*! exports provided: getPrimitiveDrawMode, getPrimitiveCount, getVertexCount, decomposeCompositeGLType, getCompositeGLType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveDrawMode", function() { return getPrimitiveDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveCount", function() { return getPrimitiveCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertexCount", function() { return getVertexCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decomposeCompositeGLType", function() { return decomposeCompositeGLType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCompositeGLType", function() { return getCompositeGLType; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");

const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_POINTS = 0x0;
const GL_LINES = 0x1;
const GL_LINE_LOOP = 0x2;
const GL_LINE_STRIP = 0x3;
const GL_TRIANGLES = 0x4;
const GL_TRIANGLE_STRIP = 0x5;
const GL_TRIANGLE_FAN = 0x6;
const GL_FLOAT = 0x1406;
const GL_FLOAT_VEC2 = 0x8b50;
const GL_FLOAT_VEC3 = 0x8b51;
const GL_FLOAT_VEC4 = 0x8b52;
const GL_INT = 0x1404;
const GL_INT_VEC2 = 0x8b53;
const GL_INT_VEC3 = 0x8b54;
const GL_INT_VEC4 = 0x8b55;
const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const GL_BOOL = 0x8b56;
const GL_BOOL_VEC2 = 0x8b57;
const GL_BOOL_VEC3 = 0x8b58;
const GL_BOOL_VEC4 = 0x8b59;
const GL_FLOAT_MAT2 = 0x8b5a;
const GL_FLOAT_MAT3 = 0x8b5b;
const GL_FLOAT_MAT4 = 0x8b5c;
const GL_FLOAT_MAT2x3 = 0x8b65;
const GL_FLOAT_MAT2x4 = 0x8b66;
const GL_FLOAT_MAT3x2 = 0x8b67;
const GL_FLOAT_MAT3x4 = 0x8b68;
const GL_FLOAT_MAT4x2 = 0x8b69;
const GL_FLOAT_MAT4x3 = 0x8b6a;
const COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, 'float'],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, 'vec2'],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, 'vec3'],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, 'vec4'],
  [GL_INT]: [GL_INT, 1, 'int'],
  [GL_INT_VEC2]: [GL_INT, 2, 'ivec2'],
  [GL_INT_VEC3]: [GL_INT, 3, 'ivec3'],
  [GL_INT_VEC4]: [GL_INT, 4, 'ivec4'],
  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, 'uint'],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, 'uvec2'],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, 'uvec3'],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, 'uvec4'],
  [GL_BOOL]: [GL_FLOAT, 1, 'bool'],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, 'bvec2'],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, 'bvec3'],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, 'bvec4'],
  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, 'mat2'],
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, 'mat2x3'],
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, 'mat2x4'],
  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, 'mat3'],
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, 'mat3x2'],
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, 'mat3x4'],
  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, 'mat4'],
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, 'mat4x2'],
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, 'mat4x3']
};
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;

    case GL_LINES:
      return GL_LINES;

    case GL_LINE_STRIP:
      return GL_LINES;

    case GL_LINE_LOOP:
      return GL_LINES;

    case GL_TRIANGLES:
      return GL_TRIANGLES;

    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;

    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}
function getPrimitiveCount({
  drawMode,
  vertexCount
}) {
  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;

    case GL_LINES:
      return vertexCount / 2;

    case GL_LINE_STRIP:
      return vertexCount - 1;

    case GL_TRIANGLES:
      return vertexCount / 3;

    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}
function getVertexCount({
  drawMode,
  vertexCount
}) {
  const primitiveCount = getPrimitiveCount({
    drawMode,
    vertexCount
  });

  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;

    case GL_LINES:
      return primitiveCount * 2;

    case GL_TRIANGLES:
      return primitiveCount * 3;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];

  if (!typeAndSize) {
    return null;
  }

  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;

    default:
  }

  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];

    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }

  return null;
}
//# sourceMappingURL=attribute-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js ***!
  \*********************************************************************************************************/
/*! exports provided: getKeyValue, getKey, getKeyType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return getKeyValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyType", function() { return getKeyType; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");

function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }

  const number = Number(name);

  if (!isNaN(number)) {
    return number;
  }

  name = name.replace(/^.*\./, '');
  const value = gl[name];
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(value !== undefined, "Accessing undefined constant GL.".concat(name));
  return value;
}
function getKey(gl, value) {
  value = Number(value);

  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}
function getKeyType(gl, value) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(value !== undefined, 'undefined key');
  value = Number(value);

  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}
//# sourceMappingURL=constants-to-keys.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js":
/*!****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js ***!
  \****************************************************************************************************/
/*! exports provided: glFormatToComponents, glTypeToBytes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glFormatToComponents", function() { return glFormatToComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glTypeToBytes", function() { return glTypeToBytes; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");

function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;

    case 33328:
    case 33319:
      return 2;

    case 6407:
    case 34837:
      return 3;

    case 6408:
    case 34836:
      return 4;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;

    case 33635:
    case 32819:
    case 32820:
      return 2;

    case 5126:
      return 4;

    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}
//# sourceMappingURL=format-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js ***!
  \*********************************************************************************************/
/*! exports provided: requestAnimationFrame, cancelAnimationFrame, getGLTypeFromTypedArray, getTypedArrayFromGLType, flipRows, scalePixels, getKeyValue, getKey, getKeyType, cloneTextureFrom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _request_animation_frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request-animation-frame */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return _request_animation_frame__WEBPACK_IMPORTED_MODULE_0__["requestAnimationFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return _request_animation_frame__WEBPACK_IMPORTED_MODULE_0__["cancelAnimationFrame"]; });

/* harmony import */ var _typed_array_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typed-array-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLTypeFromTypedArray", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_1__["getGLTypeFromTypedArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayFromGLType", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_1__["getTypedArrayFromGLType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flipRows", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_1__["flipRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePixels", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_1__["scalePixels"]; });

/* harmony import */ var _constants_to_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants-to-keys */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_2__["getKeyValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_2__["getKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyType", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_2__["getKeyType"]; });

/* harmony import */ var _texture_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture-utils */ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return _texture_utils__WEBPACK_IMPORTED_MODULE_3__["cloneTextureFrom"]; });





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js ***!
  \***************************************************************************************************************/
/*! exports provided: requestAnimationFrame, cancelAnimationFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return requestAnimationFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return cancelAnimationFrame; });
function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
//# sourceMappingURL=request-animation-frame.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js ***!
  \*****************************************************************************************************/
/*! exports provided: cloneTextureFrom, toFramebuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return cloneTextureFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFramebuffer", function() { return toFramebuffer; });
/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/texture-2d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _classes_texture_cube__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/texture-cube */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js");
/* harmony import */ var _classes_texture_3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/texture-3d */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js");
/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/framebuffer */ "../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js");





function cloneTextureFrom(refTexture, overrides) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(refTexture instanceof _classes_texture_2d__WEBPACK_IMPORTED_MODULE_0__["default"] || refTexture instanceof _classes_texture_cube__WEBPACK_IMPORTED_MODULE_1__["default"] || refTexture instanceof _classes_texture_3d__WEBPACK_IMPORTED_MODULE_2__["default"]);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new _classes_framebuffer__WEBPACK_IMPORTED_MODULE_3__["default"](gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
//# sourceMappingURL=texture-utils.js.map

/***/ }),

/***/ "../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js ***!
  \*********************************************************************************************************/
/*! exports provided: getGLTypeFromTypedArray, getTypedArrayFromGLType, flipRows, scalePixels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTypeFromTypedArray", function() { return getGLTypeFromTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayFromGLType", function() { return getTypedArrayFromGLType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipRows", function() { return flipRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalePixels", function() { return scalePixels; });
const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

  switch (type) {
    case Float32Array:
      return 5126;

    case Uint16Array:
      return 5123;

    case Uint32Array:
      return 5125;

    case Uint8Array:
      return 5121;

    case Uint8ClampedArray:
      return 5121;

    case Int8Array:
      return 5120;

    case Int16Array:
      return 5122;

    case Int32Array:
      return 5124;

    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType, {
  clamped = true
} = {}) {
  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
function flipRows({
  data,
  width,
  height,
  bytesPerPixel = 4,
  temp
}) {
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);

  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}
function scalePixels({
  data,
  width,
  height
}) {
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);

  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }

  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
//# sourceMappingURL=typed-array-utils.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/base/math-array.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MathArray; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}



class MathArray extends _extendableBuiltin(Array) {
  get ELEMENTS() {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
    return 0;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }

    return this.check();
  }

  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }

    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }

  toTarget(target) {
    return target ? this.to(target) : this;
  }

  toArray(array = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      array[offset + i] = this[i];
    }

    return array;
  }

  toFloat32Array() {
    return new Float32Array(this);
  }

  toString() {
    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_0__["config"]);
  }

  formatString(opts) {
    let string = '';

    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ', ' : '') + Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["formatValue"])(this[i], opts);
    }

    return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
  }

  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["equals"])(this[i], array[i])) {
        return false;
      }
    }

    return true;
  }

  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }

    return this.check();
  }

  lerp(a, b, t) {
    if (t === undefined) {
      t = b;
      b = a;
      a = this;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }

    return this.check();
  }

  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }

    return this.check();
  }

  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }

    return this.check();
  }

  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }

    return this.check();
  }

  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }

    return this.check();
  }

  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }

    return this.check();
  }

  scale(scale) {
    if (Array.isArray(scale)) {
      return this.multiply(scale);
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scale;
    }

    return this.check();
  }

  sub(a) {
    return this.subtract(a);
  }

  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }

    return this.check();
  }

  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }

    return this.check();
  }

  subScalar(a) {
    return this.addScalar(-a);
  }

  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }

    return this.check();
  }

  divideScalar(a) {
    return this.scale(1 / a);
  }

  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }

    return this.check();
  }

  multiplyByScalar(scalar) {
    return this.scale(scalar);
  }

  get elements() {
    return this;
  }

  check() {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_0__["config"].debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }

    return this;
  }

  validate() {
    let valid = this.length === this.ELEMENTS;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }

    return valid;
  }

}
//# sourceMappingURL=math-array.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/base/matrix.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math-array */ "../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");




class Matrix extends _math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  get ELEMENTS() {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(false);
    return 0;
  }

  get RANK() {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(false);
    return 0;
  }

  toString() {
    let string = '[';

    if (_lib_common__WEBPACK_IMPORTED_MODULE_2__["config"].printRowMajor) {
      string += 'row-major:';

      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += 'column-major:';

      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }

    string += ']';
    return string;
  }

  getElementIndex(row, col) {
    return col * this.RANK + row;
  }

  getElement(row, col) {
    return this[col * this.RANK + row];
  }

  setElement(row, col, value) {
    this[col * this.RANK + row] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
    return this;
  }

  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }

    return result;
  }

  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }

    return this;
  }

}
//# sourceMappingURL=matrix.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/base/vector.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector; });
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math-array */ "../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");



class Vector extends _math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  get ELEMENTS() {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
    return 0;
  }

  copy(vector) {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
    return this;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  len() {
    return Math.sqrt(this.lengthSquared());
  }

  magnitude() {
    return this.len();
  }

  lengthSquared() {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }

    return length;
  }

  magnitudeSquared() {
    return this.lengthSquared();
  }

  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }

  distanceSquared(mathArray) {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }

    return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(length);
  }

  dot(mathArray) {
    let product = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }

    return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(product);
  }

  normalize() {
    const length = this.magnitude();

    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }

    return this.check();
  }

  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }

    return this.check();
  }

  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }

    return this.check();
  }

  lengthSq() {
    return this.lengthSquared();
  }

  distanceTo(vector) {
    return this.distance(vector);
  }

  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }

  getComponent(i) {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(this[i]);
  }

  setComponent(i, value) {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    this[i] = value;
    return this.check();
  }

  addVectors(a, b) {
    return this.copy(a).add(b);
  }

  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }

  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }

  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }

}
//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/euler.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/euler.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Euler; });
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _quaternion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quaternion */ "../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js");




const ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
const ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

class Euler extends _base_math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get ZYX() {
    return 0;
  }

  static get YXZ() {
    return 1;
  }

  static get XZY() {
    return 2;
  }

  static get ZXY() {
    return 3;
  }

  static get YZX() {
    return 4;
  }

  static get XYZ() {
    return 5;
  }

  static get RollPitchYaw() {
    return 0;
  }

  static get DefaultOrder() {
    return Euler.ZYX;
  }

  static get RotationOrders() {
    return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
  }

  static rotationOrder(order) {
    return Euler.RotationOrders[order];
  }

  get ELEMENTS() {
    return 4;
  }

  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    super(-0, -0, -0, -0);

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      this.fromVector3(...arguments);
    } else {
      this.set(x, y, z, order);
    }
  }

  fromQuaternion(quaternion) {
    const [x, y, z, w] = quaternion;
    const ysqr = y * y;
    const t0 = -2.0 * (ysqr + z * z) + 1.0;
    const t1 = +2.0 * (x * y + w * z);
    let t2 = -2.0 * (x * z - w * y);
    const t3 = +2.0 * (y * z + w * x);
    const t4 = -2.0 * (x * x + ysqr) + 1.0;
    t2 = t2 > 1.0 ? 1.0 : t2;
    t2 = t2 < -1.0 ? -1.0 : t2;
    const roll = Math.atan2(t3, t4);
    const pitch = Math.asin(t2);
    const yaw = Math.atan2(t1, t0);
    return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = Number.isFinite(array[3]) || this.order;
    return this.check();
  }

  set(x = 0, y = 0, z = 0, order) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = Number.isFinite(order) ? order : this[3];
    return this.check();
  }

  validate() {
    return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
  }

  toArray(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    return array;
  }

  toArray4(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    array[offset + 3] = this[3];
    return array;
  }

  toVector3(result = [-0, -0, -0]) {
    result[0] = this[0];
    result[1] = this[1];
    result[2] = this[2];
    return result;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get alpha() {
    return this[0];
  }

  set alpha(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get beta() {
    return this[1];
  }

  set beta(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get gamma() {
    return this[2];
  }

  set gamma(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get phi() {
    return this[0];
  }

  set phi(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get theta() {
    return this[1];
  }

  set theta(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get psi() {
    return this[2];
  }

  set psi(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get roll() {
    return this[0];
  }

  set roll(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get pitch() {
    return this[1];
  }

  set pitch(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get yaw() {
    return this[2];
  }

  set yaw(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get order() {
    return this[3];
  }

  set order(value) {
    this[3] = checkOrder(value);
  }

  fromVector3(v, order) {
    return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
  }

  fromArray(array, offset = 0) {
    this[0] = array[0 + offset];
    this[1] = array[1 + offset];
    this[2] = array[2 + offset];

    if (array[3] !== undefined) {
      this[3] = array[3];
    }

    return this.check();
  }

  fromRollPitchYaw(roll, pitch, yaw) {
    return this.set(roll, pitch, yaw, Euler.ZYX);
  }

  fromRotationMatrix(m, order = Euler.DefaultOrder) {
    this._fromRotationMatrix(m, order);

    return this.check();
  }

  getRotationMatrix(m) {
    return this._getRotationMatrix(m);
  }

  getQuaternion() {
    const q = new _quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]();

    switch (this[4]) {
      case Euler.XYZ:
        return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

      case Euler.YXZ:
        return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

      case Euler.ZXY:
        return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

      case Euler.ZYX:
        return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

      case Euler.YZX:
        return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

      case Euler.XZY:
        return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
  }

  _fromRotationMatrix(m, order = Euler.DefaultOrder) {
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    order = order || this[3];

    switch (order) {
      case Euler.XYZ:
        this[1] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m13, -1, 1));

        if (Math.abs(m13) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m33);
          this[2] = Math.atan2(-m12, m11);
        } else {
          this[0] = Math.atan2(m32, m22);
          this[2] = 0;
        }

        break;

      case Euler.YXZ:
        this[0] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m23, -1, 1));

        if (Math.abs(m23) < ALMOST_ONE) {
          this[1] = Math.atan2(m13, m33);
          this[2] = Math.atan2(m21, m22);
        } else {
          this[1] = Math.atan2(-m31, m11);
          this[2] = 0;
        }

        break;

      case Euler.ZXY:
        this[0] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m32, -1, 1));

        if (Math.abs(m32) < ALMOST_ONE) {
          this[1] = Math.atan2(-m31, m33);
          this[2] = Math.atan2(-m12, m22);
        } else {
          this[1] = 0;
          this[2] = Math.atan2(m21, m11);
        }

        break;

      case Euler.ZYX:
        this[1] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m31, -1, 1));

        if (Math.abs(m31) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m33);
          this[2] = Math.atan2(m21, m11);
        } else {
          this[0] = 0;
          this[2] = Math.atan2(-m12, m22);
        }

        break;

      case Euler.YZX:
        this[2] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m21, -1, 1));

        if (Math.abs(m21) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m22);
          this[1] = Math.atan2(-m31, m11);
        } else {
          this[0] = 0;
          this[1] = Math.atan2(m13, m33);
        }

        break;

      case Euler.XZY:
        this[2] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["clamp"])(m12, -1, 1));

        if (Math.abs(m12) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m22);
          this[1] = Math.atan2(m13, m11);
        } else {
          this[0] = Math.atan2(-m23, m33);
          this[1] = 0;
        }

        break;

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }

    this[3] = order;
    return this;
  }

  _getRotationMatrix(result) {
    const te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    const x = this.x,
          y = this.y,
          z = this.z;
    const a = Math.cos(x);
    const c = Math.cos(y);
    const e = Math.cos(z);
    const b = Math.sin(x);
    const d = Math.sin(y);
    const f = Math.sin(z);

    switch (this[3]) {
      case Euler.XYZ:
        {
          const ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
          break;
        }

      case Euler.YXZ:
        {
          const ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
          break;
        }

      case Euler.ZXY:
        {
          const ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
          break;
        }

      case Euler.ZYX:
        {
          const ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
          break;
        }

      case Euler.YZX:
        {
          const ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
          break;
        }

      case Euler.XZY:
        {
          const ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
          break;
        }

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }

    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return te;
  }

  toQuaternion() {
    const cy = Math.cos(this.yaw * 0.5);
    const sy = Math.sin(this.yaw * 0.5);
    const cr = Math.cos(this.roll * 0.5);
    const sr = Math.sin(this.roll * 0.5);
    const cp = Math.cos(this.pitch * 0.5);
    const sp = Math.sin(this.pitch * 0.5);
    const w = cy * cr * cp + sy * sr * sp;
    const x = cy * sr * cp - sy * cr * sp;
    const y = cy * cr * sp + sy * sr * cp;
    const z = sy * cr * cp - cy * sr * sp;
    return new _quaternion__WEBPACK_IMPORTED_MODULE_3__["default"](x, y, z, w);
  }

}
//# sourceMappingURL=euler.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/matrix3.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/matrix3.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix3; });
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/mat3 */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");






const IDENTITY = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
const ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
const INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL1ROW0: 3,
  COL1ROW1: 4,
  COL1ROW2: 5,
  COL2ROW0: 6,
  COL2ROW1: 7,
  COL2ROW2: 8
});
const constants = {};
class Matrix3 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get IDENTITY() {
    constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix3(IDENTITY));
    return constants.IDENTITY;
  }

  static get ZERO() {
    constants.ZERO = constants.ZERO || Object.freeze(new Matrix3(ZERO));
    return constants.ZERO;
  }

  get ELEMENTS() {
    return 9;
  }

  get RANK() {
    return 3;
  }

  get INDICES() {
    return INDICES;
  }

  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);

    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }

  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }

  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }

  determinant() {
    return gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["determinant"](this);
  }

  identity() {
    return this.copy(IDENTITY);
  }

  fromQuaternion(q) {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["fromQuat"](this, q);
    return this.check();
  }

  transpose() {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["transpose"](this, this);
    return this.check();
  }

  invert() {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["invert"](this, this);
    return this.check();
  }

  multiplyLeft(a) {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, a, this);
    return this.check();
  }

  multiplyRight(a) {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, this, a);
    return this.check();
  }

  rotate(radians) {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["rotate"](this, this, radians);
    return this.check();
  }

  scale(factor) {
    if (Array.isArray(factor)) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["scale"](this, this, factor);
    } else {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["scale"](this, this, [factor, factor, factor]);
    }

    return this.check();
  }

  translate(vec) {
    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_3__["translate"](this, this, vec);
    return this.check();
  }

  transform(vector, result) {
    switch (vector.length) {
      case 2:
        result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__["transformMat3"](result || [-0, -0], vector, this);
        break;

      case 3:
        result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__["transformMat3"](result || [-0, -0, -0], vector, this);
        break;

      case 4:
        result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_2__["vec4_transformMat3"])(result || [-0, -0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkVector"])(result, vector.length);
    return result;
  }

  transformVector(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["deprecated"])('Matrix3.transformVector');
    return this.transform(vector, result);
  }

  transformVector2(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["deprecated"])('Matrix3.transformVector');
    return this.transform(vector, result);
  }

  transformVector3(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["deprecated"])('Matrix3.transformVector');
    return this.transform(vector, result);
  }

}
//# sourceMappingURL=matrix3.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/matrix4.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix4; });
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/mat4 */ "../../node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");







const IDENTITY = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
const ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
const INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL0ROW3: 3,
  COL1ROW0: 4,
  COL1ROW1: 5,
  COL1ROW2: 6,
  COL1ROW3: 7,
  COL2ROW0: 8,
  COL2ROW1: 9,
  COL2ROW2: 10,
  COL2ROW3: 11,
  COL3ROW0: 12,
  COL3ROW1: 13,
  COL3ROW2: 14,
  COL3ROW3: 15
});
const constants = {};
class Matrix4 extends _base_matrix__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get IDENTITY() {
    constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix4(IDENTITY));
    return constants.IDENTITY;
  }

  static get ZERO() {
    constants.ZERO = constants.ZERO || Object.freeze(new Matrix4(ZERO));
    return constants.ZERO;
  }

  get INDICES() {
    return INDICES;
  }

  get ELEMENTS() {
    return 16;
  }

  get RANK() {
    return 4;
  }

  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);

    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }

  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }

  identity() {
    return this.copy(IDENTITY);
  }

  fromQuaternion(q) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["fromQuat"](this, q);
    return this.check();
  }

  frustum({
    left,
    right,
    bottom,
    top,
    near,
    far
  }) {
    if (far === Infinity) {
      Matrix4._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["frustum"](this, left, right, bottom, top, near, far);
    }

    return this.check();
  }

  static _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2.0 * near / (right - left);
    const column1Row1 = 2.0 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1.0;
    const column2Row3 = -1.0;
    const column3Row2 = -2.0 * near;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  }

  lookAt(eye, center, up) {
    if (arguments.length === 1) {
      ({
        eye,
        center,
        up
      } = eye);
    }

    center = center || [0, 0, 0];
    up = up || [0, 1, 0];
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["lookAt"](this, eye, center, up);
    return this.check();
  }

  ortho({
    left,
    right,
    bottom,
    top,
    near = 0.1,
    far = 500
  }) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["ortho"](this, left, right, bottom, top, near, far);
    return this.check();
  }

  orthographic({
    fovy = 45 * Math.PI / 180,
    aspect = 1,
    focalDistance = 1,
    near = 0.1,
    far = 500
  }) {
    if (fovy > Math.PI * 2) {
      throw Error('radians');
    }

    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return new Matrix4().ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }

  perspective({
    fovy = undefined,
    fov = 45 * Math.PI / 180,
    aspect = 1,
    near = 0.1,
    far = 500
  } = {}) {
    fovy = fovy || fov;

    if (fovy > Math.PI * 2) {
      throw Error('radians');
    }

    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["perspective"](this, fovy, aspect, near, far);
    return this.check();
  }

  determinant() {
    return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["determinant"](this);
  }

  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }

  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }

  getRotation(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {
    const scale = this.getScale(scaleResult || [-0, -0, -0]);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }

  getRotationMatrix3(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {
    const scale = this.getScale(scaleResult || [-0, -0, -0]);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }

  transpose() {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["transpose"](this, this);
    return this.check();
  }

  invert() {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["invert"](this, this);
    return this.check();
  }

  multiplyLeft(a) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, a, this);
    return this.check();
  }

  multiplyRight(a) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, this, a);
    return this.check();
  }

  rotateX(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["rotateX"](this, this, radians);
    return this.check();
  }

  rotateY(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["rotateY"](this, this, radians);
    return this.check();
  }

  rotateZ(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["rotateZ"](this, this, radians);
    return this.check();
  }

  rotateXYZ([rx, ry, rz]) {
    return this.rotateX(rx).rotateY(ry).rotateZ(rz);
  }

  rotateAxis(radians, axis) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["rotate"](this, this, radians, axis);
    return this.check();
  }

  scale(factor) {
    if (Array.isArray(factor)) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["scale"](this, this, factor);
    } else {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["scale"](this, this, [factor, factor, factor]);
    }

    return this.check();
  }

  translate(vec) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__["translate"](this, this, vec);
    return this.check();
  }

  transform(vector, result) {
    if (vector.length === 4) {
      result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_6__["transformMat4"](result || [-0, -0, -0, -0], vector, this);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["checkVector"])(result, 4);
      return result;
    }

    return this.transformAsPoint(vector, result);
  }

  transformAsPoint(vector, result) {
    const {
      length
    } = vector;

    switch (length) {
      case 2:
        result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__["transformMat4"](result || [-0, -0], vector, this);
        break;

      case 3:
        result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__["transformMat4"](result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["checkVector"])(result, vector.length);
    return result;
  }

  transformAsVector(vector, result) {
    switch (vector.length) {
      case 2:
        result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_2__["vec2_transformMat4AsVector"])(result || [-0, -0], vector, this);
        break;

      case 3:
        result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_2__["vec3_transformMat4AsVector"])(result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["checkVector"])(result, vector.length);
    return result;
  }

  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }

  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }

  transformPoint(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["deprecated"])('Matrix4.transformPoint', '3.0');
    return this.transformAsPoint(vector, result);
  }

  transformVector(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["deprecated"])('Matrix4.transformVector', '3.0');
    return this.transformAsPoint(vector, result);
  }

  transformDirection(vector, result) {
    Object(_lib_validators__WEBPACK_IMPORTED_MODULE_0__["deprecated"])('Matrix4.transformDirection', '3.0');
    return this.transformAsVector(vector, result);
  }

}
//# sourceMappingURL=matrix4.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/pose.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/pose.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pose; });
/* harmony import */ var _matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix4 */ "../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var _euler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./euler */ "../../node_modules/@math.gl/core/dist/esm/classes/euler.js");



class Pose {
  constructor({
    x = 0,
    y = 0,
    z = 0,
    roll = 0,
    pitch = 0,
    yaw = 0,
    position = undefined,
    orientation = undefined
  } = {}) {
    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_1__["default"](position);
    } else {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_1__["default"](x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_2__["default"](orientation, orientation[3]);
    } else {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_2__["default"](roll, pitch, yaw, _euler__WEBPACK_IMPORTED_MODULE_2__["default"].RollPitchYaw);
    }
  }

  get x() {
    return this.position.x;
  }

  set x(value) {
    this.position.x = value;
  }

  get y() {
    return this.position.y;
  }

  set y(value) {
    this.position.y = value;
  }

  get z() {
    return this.position.z;
  }

  set z(value) {
    this.position.z = value;
  }

  get roll() {
    return this.orientation.roll;
  }

  set roll(value) {
    this.orientation.roll = value;
  }

  get pitch() {
    return this.orientation.pitch;
  }

  set pitch(value) {
    this.orientation.pitch = value;
  }

  get yaw() {
    return this.orientation.yaw;
  }

  set yaw(value) {
    this.orientation.yaw = value;
  }

  getPosition() {
    return this.position;
  }

  getOrientation() {
    return this.orientation;
  }

  equals(pose) {
    if (!pose) {
      return false;
    }

    return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
  }

  exactEquals(pose) {
    if (!pose) {
      return false;
    }

    return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
  }

  getTransformationMatrix() {
    const sr = Math.sin(this.roll);
    const sp = Math.sin(this.pitch);
    const sw = Math.sin(this.yaw);
    const cr = Math.cos(this.roll);
    const cp = Math.cos(this.pitch);
    const cw = Math.cos(this.yaw);
    const matrix = new _matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
    return matrix;
  }

  getTransformationMatrixFromPose(pose) {
    return new _matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
  }

  getTransformationMatrixToPose(pose) {
    return new _matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
  }

}
//# sourceMappingURL=pose.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/quaternion.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Quaternion; });
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");
/* harmony import */ var gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/quat */ "../../node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");





const IDENTITY_QUATERNION = [0, 0, 0, 1];
class Quaternion extends _base_math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super(-0, -0, -0, -0);

    if (Array.isArray(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      this.set(x, y, z, w);
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }

  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }

  fromMatrix3(m) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["fromMat3"](this, m);
    return this.check();
  }

  identity() {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["identity"](this);
    return this.check();
  }

  fromAxisRotation(axis, rad) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["setAxisAngle"](this, axis, rad);
    return this.check();
  }

  setAxisAngle(axis, rad) {
    return this.fromAxisRotation(axis, rad);
  }

  get ELEMENTS() {
    return 4;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  get w() {
    return this[3];
  }

  set w(value) {
    this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(value);
  }

  len() {
    return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["length"](this);
  }

  lengthSquared() {
    return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["squaredLength"](this);
  }

  dot(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.dot only takes one argument');
    }

    return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["dot"](this, a);
  }

  rotationTo(vectorA, vectorB) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["rotationTo"](this, vectorA, vectorB);
    return this.check();
  }

  add(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.add only takes one argument');
    }

    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["add"](this, this, a);
    return this.check();
  }

  calculateW() {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["calculateW"](this, this);
    return this.check();
  }

  conjugate() {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["conjugate"](this, this);
    return this.check();
  }

  invert() {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["invert"](this, this);
    return this.check();
  }

  lerp(a, b, t) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["lerp"](this, a, b, t);
    return this.check();
  }

  multiplyRight(a, b) {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(!b);
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, this, a);
    return this.check();
  }

  multiplyLeft(a, b) {
    Object(_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(!b);
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["multiply"](this, a, this);
    return this.check();
  }

  normalize() {
    const length = this.len();
    const l = length > 0 ? 1 / length : 0;
    this[0] = this[0] * l;
    this[1] = this[1] * l;
    this[2] = this[2] * l;
    this[3] = this[3] * l;

    if (length === 0) {
      this[3] = 1;
    }

    return this.check();
  }

  rotateX(rad) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["rotateX"](this, this, rad);
    return this.check();
  }

  rotateY(rad) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["rotateY"](this, this, rad);
    return this.check();
  }

  rotateZ(rad) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["rotateZ"](this, this, rad);
    return this.check();
  }

  scale(b) {
    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["scale"](this, this, b);
    return this.check();
  }

  slerp(start, target, ratio) {
    switch (arguments.length) {
      case 1:
        ({
          start = IDENTITY_QUATERNION,
          target,
          ratio
        } = arguments[0]);
        break;

      case 2:
        [target, ratio] = arguments;
        start = this;
        break;

      default:
    }

    gl_matrix_quat__WEBPACK_IMPORTED_MODULE_3__["slerp"](this, start, target, ratio);
    return this.check();
  }

  transformVector4(vector, result = vector) {
    gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_4__["transformQuat"](result, vector, this);
    return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_1__["checkVector"])(result, 4);
  }

  lengthSq() {
    return this.lengthSquared();
  }

  setFromAxisAngle(axis, rad) {
    return this.setAxisAngle(axis, rad);
  }

  premultiply(a, b) {
    return this.multiplyLeft(a, b);
  }

  multiply(a, b) {
    return this.multiplyRight(a, b);
  }

}
//# sourceMappingURL=quaternion.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphericalCoordinates; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");




const EPSILON = 0.000001;
const EARTH_RADIUS_METERS = 6.371e6;
class SphericalCoordinates {
  constructor({
    phi = 0,
    theta = 0,
    radius = 1,
    bearing = undefined,
    pitch = undefined,
    altitude = undefined,
    radiusScale = EARTH_RADIUS_METERS
  } = {}) {
    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;

    if (bearing !== undefined) {
      this.bearing = bearing;
    }

    if (pitch !== undefined) {
      this.pitch = pitch;
    }

    this.check();
  }

  toString() {
    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_0__["config"]);
  }

  formatString({
    printTypes = false
  }) {
    const f = _lib_common__WEBPACK_IMPORTED_MODULE_0__["formatValue"];
    return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
  }

  equals(other) {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["equals"])(this.radius, other.radius) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["equals"])(this.theta, other.theta) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["equals"])(this.phi, other.phi);
  }

  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }

  get bearing() {
    return 180 - Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.phi);
  }

  set bearing(v) {
    this.phi = Math.PI - Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["radians"])(v);
  }

  get pitch() {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.theta);
  }

  set pitch(v) {
    this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["radians"])(v);
  }

  get longitude() {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.phi);
  }

  get latitude() {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.theta);
  }

  get lng() {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.phi);
  }

  get lat() {
    return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"])(this.theta);
  }

  get z() {
    return (this.radius - 1) * this.radiusScale;
  }

  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }

  clone() {
    return new SphericalCoordinates().copy(this);
  }

  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }

  fromLngLatZ([lng, lat, z]) {
    this.radius = 1 + z / this.radiusScale;
    this.phi = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["radians"])(lat);
    this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["radians"])(lng);
  }

  fromVector3(v) {
    this.radius = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_2__["length"](v);

    if (this.radius > 0) {
      this.theta = Math.atan2(v[0], v[1]);
      this.phi = Math.acos(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["clamp"])(v[2] / this.radius, -1, 1));
    }

    return this.check();
  }

  toVector3() {
    return new _vector3__WEBPACK_IMPORTED_MODULE_1__["default"](0, 0, this.radius).rotateX({
      radians: this.theta
    }).rotateZ({
      radians: this.phi
    });
  }

  makeSafe() {
    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    return this;
  }

  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error('SphericalCoordinates: some fields set to invalid numbers');
    }

    return this;
  }

}
//# sourceMappingURL=spherical-coordinates.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/vector2.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/vector2.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector2; });
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");





class Vector2 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(x = 0, y = 0) {
    super(2);

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isArray"])(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(y);
      }

      this[0] = x;
      this[1] = y;
    }
  }

  set(x, y) {
    this[0] = x;
    this[1] = y;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    return this.check();
  }

  fromObject(object) {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.x);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.y);
    }

    this[0] = object.x;
    this[1] = object.y;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    return object;
  }

  get ELEMENTS() {
    return 2;
  }

  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }

  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_3__["transformMat4"](this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__["vec2_transformMat4AsVector"])(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_3__["transformMat3"](this, this, matrix3);
    return this.check();
  }

  transformByMatrix2x3(matrix2x3) {
    gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_3__["transformMat2d"](this, this, matrix2x3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_3__["transformMat2"](this, this, matrix2);
    return this.check();
  }

}
//# sourceMappingURL=vector2.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/vector3.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/vector3.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3; });
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");





const ORIGIN = [0, 0, 0];
const constants = {};
class Vector3 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get ZERO() {
    return constants.ZERO = constants.ZERO || Object.freeze(new Vector3(0, 0, 0, 0));
  }

  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);

    if (arguments.length === 1 && Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isArray"])(x)) {
      this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(z);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }

  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }

  fromObject(object) {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.x);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.y);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.z);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }

  get ELEMENTS() {
    return 3;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  angle(vector) {
    return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["angle"](this, vector);
  }

  cross(vector) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["cross"](this, this, vector);
    return this.check();
  }

  rotateX({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["rotateX"](this, this, origin, radians);
    return this.check();
  }

  rotateY({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["rotateY"](this, this, origin, radians);
    return this.check();
  }

  rotateZ({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["rotateZ"](this, this, origin, radians);
    return this.check();
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["transformMat4"](this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__["vec3_transformMat4AsVector"])(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["transformMat3"](this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__["vec3_transformMat2"])(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["transformQuat"](this, this, quaternion);
    return this.check();
  }

}
//# sourceMappingURL=vector3.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/classes/vector4.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/classes/vector4.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector4; });
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");





const constants = {};
class Vector4 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get ZERO() {
    return constants.ZERO = constants.ZERO || Object.freeze(new Vector4(0, 0, 0, 0));
  }

  constructor(x = 0, y = 0, z = 0, w = 0) {
    super(-0, -0, -0, -0);

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isArray"])(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(z);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(w);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
    }
  }

  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }

  fromObject(object) {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__["config"].debug) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.x);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.y);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.z);
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(object.w);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this;
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    object.w = this[3];
    return object;
  }

  get ELEMENTS() {
    return 4;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  get w() {
    return this[3];
  }

  set w(value) {
    this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(value);
  }

  transform(matrix4) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["transformMat4"](this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__["vec4_transformMat3"])(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__["vec4_transformMat2"])(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__["transformQuat"](this, this, quaternion);
    return this.check();
  }

  applyMatrix4(m) {
    m.transform(this, this);
    return this;
  }

}
//# sourceMappingURL=vector4.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/index.js":
/*!********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/index.js ***!
  \********************************************************************************/
/*! exports provided: Vector2, Vector3, Vector4, Matrix3, Matrix4, Quaternion, config, configure, formatValue, isArray, clone, equals, exactEquals, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, withEpsilon, checkNumber, _MathUtils, SphericalCoordinates, Pose, Euler, assert, _SphericalCoordinates, _Pose, _Euler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _classes_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/vector2 */ "../../node_modules/@math.gl/core/dist/esm/classes/vector2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return _classes_vector2__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _classes_vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/vector3 */ "../../node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return _classes_vector3__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _classes_vector4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/vector4 */ "../../node_modules/@math.gl/core/dist/esm/classes/vector4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return _classes_vector4__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/matrix3 */ "../../node_modules/@math.gl/core/dist/esm/classes/matrix3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./classes/matrix4 */ "../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/quaternion */ "../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["config"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["configure"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["formatValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["equals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["exactEquals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["toRadians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["toDegrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["radians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["degrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["clamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["lerp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withEpsilon", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_0__["withEpsilon"]; });

/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/validators */ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return _lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"]; });

/* harmony import */ var _lib_math_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/math-utils */ "../../node_modules/@math.gl/core/dist/esm/lib/math-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MathUtils", function() { return _lib_math_utils__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./classes/spherical-coordinates */ "../../node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphericalCoordinates", function() { return _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _classes_pose__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./classes/pose */ "../../node_modules/@math.gl/core/dist/esm/classes/pose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pose", function() { return _classes_pose__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _classes_euler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./classes/euler */ "../../node_modules/@math.gl/core/dist/esm/classes/euler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return _classes_euler__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_assert__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_SphericalCoordinates", function() { return _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Pose", function() { return _classes_pose__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Euler", function() { return _classes_euler__WEBPACK_IMPORTED_MODULE_11__["default"]; });















const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
const global_ = globals.global || globals.self || globals.window;
global_.mathgl = {
  config: _lib_common__WEBPACK_IMPORTED_MODULE_0__["config"]
};



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/lib/assert.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/lib/common.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/lib/common.js ***!
  \*************************************************************************************/
/*! exports provided: config, configure, formatValue, isArray, clone, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, equals, exactEquals, withEpsilon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return configure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withEpsilon", function() { return withEpsilon; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../../node_modules/@math.gl/core/dist/esm/lib/assert.js");

const RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const config = {};
config.EPSILON = 1e-12;
config.debug = false;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure(options = {}) {
  for (const key in options) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(key in config);
    config[key] = options[key];
  }

  return config;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value, {
  precision = config.precision || 4
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}

function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}

function clone(array) {
  return array.clone ? array.clone() : new Array(...array);
}

function map(value, func, result) {
  if (isArray(value)) {
    result = result || duplicateArray(value);

    for (let i = 0; i < result.length && i < value.length; ++i) {
      result[i] = func(value[i], i, result);
    }

    return result;
  }

  return func(value);
}

function toRadians(degrees) {
  return radians(degrees);
}
function toDegrees(radians) {
  return degrees(radians);
}
function radians(degrees, result) {
  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);
}
function degrees(radians, result) {
  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);
}
function sin(radians) {
  return map(radians, angle => Math.sin(angle));
}
function cos(radians) {
  return map(radians, angle => Math.cos(angle));
}
function tan(radians) {
  return map(radians, angle => Math.tan(angle));
}
function asin(radians) {
  return map(radians, angle => Math.asin(angle));
}
function acos(radians) {
  return map(radians, angle => Math.acos(angle));
}
function atan(radians) {
  return map(radians, angle => Math.atan(angle));
}
function clamp(value, min, max) {
  return map(value, value => Math.max(min, Math.min(max, value)));
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }

  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;

  if (epsilon) {
    config.EPSILON = epsilon;
  }

  try {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a && a.equals) {
      return a.equals(b);
    }

    if (b && b.equals) {
      return b.equals(a);
    }

    if (Number.isFinite(a) && Number.isFinite(b)) {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
    }

    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (a && typeof a === 'object' && b && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }

  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (let i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return false;
}
function withEpsilon(EPSILON, func) {
  const oldPrecision = config.EPSILON;
  config.EPSILON = EPSILON;
  let value;

  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }

  return value;
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js ***!
  \***********************************************************************************************/
/*! exports provided: vec2_transformMat4AsVector, vec3_transformMat4AsVector, vec3_transformMat2, vec4_transformMat2, vec4_transformMat3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2_transformMat4AsVector", function() { return vec2_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat4AsVector", function() { return vec3_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat2", function() { return vec3_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat2", function() { return vec4_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat3", function() { return vec4_transformMat3; });
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
//# sourceMappingURL=gl-matrix-extras.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/lib/math-utils.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/lib/math-utils.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
});
//# sourceMappingURL=math-utils.js.map

/***/ }),

/***/ "../../node_modules/@math.gl/core/dist/esm/lib/validators.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@math.gl/core/dist/esm/lib/validators.js ***!
  \*****************************************************************************************/
/*! exports provided: validateVector, checkNumber, checkVector, deprecated */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateVector", function() { return validateVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return checkNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkVector", function() { return checkVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecated", function() { return deprecated; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "../../node_modules/@math.gl/core/dist/esm/lib/common.js");

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }

  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}
function checkVector(v, length, callerName = '') {
  if (_common__WEBPACK_IMPORTED_MODULE_0__["config"].debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }

  return v;
}
const map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
//# sourceMappingURL=validators.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/index.js":
/*!**********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@probe.gl/stats/dist/esm/index.js ***!
  \**********************************************************************************/
/*! exports provided: Stats, Stat, _getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_stats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stats */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _lib_stats__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_stat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _lib_stat__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@probe.gl/stats/dist/esm/lib/stat.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stat; });
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");

class Stat {
  constructor(name, type) {
    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }

  incrementCount() {
    this.addCount(1);
    return this;
  }

  decrementCount() {
    this.subtractCount(1);
    return this;
  }

  addCount(value) {
    this._count += value;
    this._samples++;

    this._checkSampling();

    return this;
  }

  subtractCount(value) {
    this._count -= value;
    this._samples++;

    this._checkSampling();

    return this;
  }

  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;

    this._checkSampling();

    return this;
  }

  timeStart() {
    this._startTime = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_0__["default"])();
    this._timerPending = true;
    return this;
  }

  timeEnd() {
    if (!this._timerPending) {
      return this;
    }

    this.addTime(Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_0__["default"])() - this._startTime);
    this._timerPending = false;

    this._checkSampling();

    return this;
  }

  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }

  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }

  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }

  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }

  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }

  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }

  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }

  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }

}
//# sourceMappingURL=stat.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@probe.gl/stats/dist/esm/lib/stats.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stats; });
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");

class Stats {
  constructor({
    id,
    stats
  }) {
    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  get(name, type = 'count') {
    return this._getOrCreate({
      name,
      type
    });
  }

  get size() {
    return Object.keys(this.stats).length;
  }

  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }

    return this;
  }

  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }

  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }

  _initializeStats(stats = []) {
    stats.forEach(stat => this._getOrCreate(stat));
  }

  _getOrCreate(stat) {
    if (!stat || !stat.name) {
      return null;
    }

    const {
      name,
      type
    } = stat;

    if (!this.stats[name]) {
      if (stat instanceof _stat__WEBPACK_IMPORTED_MODULE_0__["default"]) {
        this.stats[name] = stat;
      } else {
        this.stats[name] = new _stat__WEBPACK_IMPORTED_MODULE_0__["default"](name, type);
      }
    }

    return this.stats[name];
  }

}
//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
function getHiResTimestamp() {
  let timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map

/***/ }),

/***/ "../../node_modules/earcut/src/earcut.js":
/*!*********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/earcut/src/earcut.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "../../node_modules/gl-matrix/esm/common.js":
/*!************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/common.js ***!
  \************************************************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat3.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/mat3.js ***!
  \**********************************************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat4.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/mat4.js ***!
  \**********************************************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/quat.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/quat.js ***!
  \**********************************************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "../../node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec2.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/vec2.js ***!
  \**********************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec3.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/vec3.js ***!
  \**********************************************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec4.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/gl-matrix/esm/vec4.js ***!
  \**********************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/probe.gl/dist/es5/env/get-browser.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/es5/env/get-browser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.default = getBrowser;

var _globals = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/es5/env/globals.js");

var _isBrowser = _interopRequireDefault(__webpack_require__(/*! ./is-browser */ "../../node_modules/probe.gl/dist/es5/env/is-browser.js"));

var _isElectron = _interopRequireDefault(__webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/es5/env/is-electron.js"));

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
//# sourceMappingURL=get-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/es5/env/globals.js":
/*!*********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/es5/env/globals.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/es5/env/index.js":
/*!*******************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/es5/env/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function get() {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function get() {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function get() {
    return _isElectron.default;
  }
});

var _globals = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/es5/env/globals.js");

var _isBrowser = _interopRequireWildcard(__webpack_require__(/*! ./is-browser */ "../../node_modules/probe.gl/dist/es5/env/is-browser.js"));

var _getBrowser = _interopRequireWildcard(__webpack_require__(/*! ./get-browser */ "../../node_modules/probe.gl/dist/es5/env/get-browser.js"));

var _isElectron = _interopRequireDefault(__webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/es5/env/is-electron.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/es5/env/is-browser.js":
/*!************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/es5/env/is-browser.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js"));

var _isElectron = _interopRequireDefault(__webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/es5/env/is-electron.js"));

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
//# sourceMappingURL=is-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/es5/env/is-electron.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/es5/env/is-electron.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js"));

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=is-electron.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/get-browser.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/env/get-browser.js ***!
  \*************************************************************************************/
/*! exports provided: isMobile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBrowser; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony import */ var _is_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");



function isMobile() {
  return typeof _globals__WEBPACK_IMPORTED_MODULE_0__["window"].orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !Object(_is_browser__WEBPACK_IMPORTED_MODULE_1__["default"])()) {
    return 'Node';
  }

  if (Object(_is_electron__WEBPACK_IMPORTED_MODULE_2__["default"])(mockUserAgent)) {
    return 'Electron';
  }

  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].chrome) {
    return 'Chrome';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].safari) {
    return 'Safari';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
//# sourceMappingURL=get-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/globals.js":
/*!*********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/env/globals.js ***!
  \*********************************************************************************/
/*! exports provided: self, window, global, document, process, console */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "process", function() { return process_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "console", function() { return console_; });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: typeof process === 'object' && process
};
const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};
const process_ = globals.process || {};
const console_ = console;

//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-browser.js":
/*!************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/env/is-browser.js ***!
  \************************************************************************************/
/*! exports provided: default, isBrowserMainThread */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return isBrowserMainThread; });
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");

function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || Object(_is_electron__WEBPACK_IMPORTED_MODULE_0__["default"])();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
//# sourceMappingURL=is-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-electron.js":
/*!*************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/env/is-electron.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElectron; });
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=is-electron.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/index.js":
/*!***************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/index.js ***!
  \***************************************************************************/
/*! exports provided: VERSION, self, window, global, document, process, console, isBrowser, isBrowserMainThread, getBrowser, isMobile, isElectron, assert, Log, COLOR, default, addColor, leftPad, rightPad, autobind, LocalStorage, getHiResTimestamp, Stats, Stat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../../node_modules/probe.gl/dist/esm/init.js");
/* harmony import */ var _lib_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/log */ "../../node_modules/probe.gl/dist/esm/lib/log.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_2__["VERSION"]; });

/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["console"]; });

/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["isBrowserMainThread"]; });

/* harmony import */ var _env_get_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./env/get-browser */ "../../node_modules/probe.gl/dist/esm/env/get-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBrowser", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["isMobile"]; });

/* harmony import */ var _env_is_electron__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env/is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElectron", function() { return _env_is_electron__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Log", function() { return _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_8__["COLOR"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_8__["addColor"]; });

/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_9__["leftPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_9__["rightPad"]; });

/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return _utils_autobind__WEBPACK_IMPORTED_MODULE_10__["autobind"]; });

/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalStorage", function() { return _utils_local_storage__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @probe.gl/stats */ "../../node_modules/@probe.gl/stats/dist/esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _probe_gl_stats__WEBPACK_IMPORTED_MODULE_13__["Stats"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _probe_gl_stats__WEBPACK_IMPORTED_MODULE_13__["Stat"]; });











/* harmony default export */ __webpack_exports__["default"] = (new _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]({
  id: 'probe.gl'
}));






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/init.js":
/*!**************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/init.js ***!
  \**************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"].probe = {};
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/log.js":
/*!*****************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/lib/log.js ***!
  \*****************************************************************************/
/*! exports provided: default, normalizeArguments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeArguments", function() { return normalizeArguments; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");







const originalConsole = {
  debug: _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

const cache = {};
const ONCE = {
  once: true
};

function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

class Log {
  constructor({
    id
  } = {
    id: ''
  }) {
    this.id = id;
    this.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["VERSION"];
    this._startTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])();
    this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _utils_local_storage__WEBPACK_IMPORTED_MODULE_1__["default"]("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    Object(_utils_autobind__WEBPACK_IMPORTED_MODULE_4__["autobind"])(this);
    Object.seal(this);
  }

  set level(newLevel) {
    this.setLevel(newLevel);
  }

  get level() {
    return this.getLevel();
  }

  isEnabled() {
    return this._storage.config.enabled;
  }

  getLevel() {
    return this._storage.config.level;
  }

  getTotal() {
    return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])() - this._startTs).toPrecision(10));
  }

  getDelta() {
    return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])() - this._deltaTs).toPrecision(10));
  }

  set priority(newPriority) {
    this.level = newPriority;
  }

  get priority() {
    return this.level;
  }

  getPriority() {
    return this.level;
  }

  enable(enabled = true) {
    this._storage.updateConfiguration({
      enabled
    });

    return this;
  }

  setLevel(level) {
    this._storage.updateConfiguration({
      level
    });

    return this;
  }

  assert(condition, message) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"])(condition, message);
  }

  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }

  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }

  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }

  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }

  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }

  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }

  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }

  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }

  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }

    return noop;
  }

  image({
    logLevel,
    priority,
    image,
    message = '',
    scale = 1
  }) {
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }

    return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }

  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }

  get(setting) {
    return this._storage.config[setting];
  }

  set(setting, value) {
    this._storage.updateConfiguration({
      [setting]: value
    });
  }

  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }

  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }

  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }

  group(logLevel, message, opts = {
    collapsed: false
  }) {
    opts = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    opts.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(opts);
  }

  groupCollapsed(logLevel, message, opts = {}) {
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }

  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }

  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();

    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }

  trace() {
    if (console.trace) {
      console.trace();
    }
  }

  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }

  _getLogFunction(logLevel, message, method, args = [], opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"])(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])();
      const tag = opts.tag || opts.message;

      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_6__["default"])();
        } else {
          return noop;
        }
      }

      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }

    return noop;
  }

}
Log.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["VERSION"];

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  let resolvedLevel;

  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  opts.args = args;

  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  const messageType = typeof opts.message;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_5__["default"])(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_2__["leftPad"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_2__["formatTime"])(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = Object(_utils_color__WEBPACK_IMPORTED_MODULE_3__["addColor"])(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode({
  image,
  message = '',
  scale = 1
}) {
  let asciify = null;

  try {
    asciify = __webpack_require__(/*! asciify-image */ 0);
  } catch (error) {}

  if (asciify) {
    return () => asciify(image, {
      fit: 'box',
      width: "".concat(Math.round(80 * scale), "%")
    }).then(data => console.log(data));
  }

  return noop;
}

function logImageInBrowser({
  image,
  message = '',
  scale = 1
}) {
  if (typeof image === 'string') {
    const img = new Image();

    img.onload = () => {
      const args = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_2__["formatImage"])(img, message, scale);
      console.log(...args);
    };

    img.src = image;
    return noop;
  }

  const element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    console.log(...Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_2__["formatImage"])(image, message, scale));
    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    const img = new Image();

    img.onload = () => console.log(...Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_2__["formatImage"])(img, message, scale));

    img.src = image.toDataURL();
    return noop;
  }

  return noop;
}
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/assert.js":
/*!**********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/assert.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/autobind.js":
/*!************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/autobind.js ***!
  \************************************************************************************/
/*! exports provided: autobind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return autobind; });
function autobind(obj, predefined = ['constructor']) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);

  for (const key of propNames) {
    if (typeof obj[key] === 'function') {
      if (!predefined.find(name => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
//# sourceMappingURL=autobind.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/color.js":
/*!*********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/color.js ***!
  \*********************************************************************************/
/*! exports provided: COLOR, addColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return addColor; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

const COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/formatters.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/formatters.js ***!
  \**************************************************************************************/
/*! exports provided: formatTime, leftPad, rightPad, formatValue, formatImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTime", function() { return formatTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return leftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return rightPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatImage", function() { return formatImage; });
function formatTime(ms) {
  let formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}
function leftPad(string, length = 8) {
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string, length = 8) {
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v, opts = {}) {
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';

  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale, maxWidth = 600) {
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
//# sourceMappingURL=formatters.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/globals.js":
/*!***********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/globals.js ***!
  \***********************************************************************************/
/*! exports provided: self, window, global, document, process, console, VERSION, isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["console"]; });



const VERSION =  true ? "8.5.2" : undefined;
const isBrowser = Object(_env_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"])();
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js":
/*!********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

function getHiResTimestamp() {
  let timestamp;

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance) {
    timestamp = _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance.now();
  } else if (_globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime) {
    const timeParts = _globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/dist/esm/utils/local-storage.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LocalStorage; });
function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

class LocalStorage {
  constructor(id, defaultSettings, type = 'sessionStorage') {
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  getConfiguration() {
    return this.config;
  }

  setConfiguration(configuration) {
    this.config = {};
    return this.updateConfiguration(configuration);
  }

  updateConfiguration(configuration) {
    Object.assign(this.config, configuration);

    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }

    return this;
  }

  _loadConfiguration() {
    let configuration = {};

    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }

    Object.assign(this.config, configuration);
    return this;
  }

}
//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/env.js":
/*!****************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/probe.gl/env.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// This file enables: import 'probe.gl/bench'.
// Note: Must be published using package.json "files" field
module.exports = __webpack_require__(/*! ./dist/es5/env */ "../../node_modules/probe.gl/dist/es5/env/index.js");


/***/ }),

/***/ "../../node_modules/util/node_modules/inherits/inherits_browser.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../../node_modules/util/support/isBufferBrowser.js":
/*!********************************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/util/support/isBufferBrowser.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../../node_modules/util/util.js":
/*!*************************************************************!*\
  !*** /Users/missx/Source/deck.gl/node_modules/util/util.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "../../node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "../../node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./bundle.js":
/*!*******************!*\
  !*** ./bundle.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const deckGLLayers = __webpack_require__(/*! ./src */ "./src/index.js");

/* global window, global */
const _global = typeof window === 'undefined' ? global : window;
const deck = _global.deck || {};

// Check if peer dependencies are included
if (!deck.Layer) {
  throw new Error('@deck.gl/core is not found');
}

module.exports = Object.assign(deck, deckGLLayers);


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: SimpleMeshLayer, ScenegraphLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _simple_mesh_layer_simple_mesh_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-mesh-layer/simple-mesh-layer */ "./src/simple-mesh-layer/simple-mesh-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleMeshLayer", function() { return _simple_mesh_layer_simple_mesh_layer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _scenegraph_layer_scenegraph_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scenegraph-layer/scenegraph-layer */ "./src/scenegraph-layer/scenegraph-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScenegraphLayer", function() { return _scenegraph_layer_scenegraph_layer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/* eslint-disable max-len */





/***/ }),

/***/ "./src/scenegraph-layer/gltf-utils.js":
/*!********************************************!*\
  !*** ./src/scenegraph-layer/gltf-utils.js ***!
  \********************************************/
/*! exports provided: waitForGLTFAssets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForGLTFAssets", function() { return waitForGLTFAssets; });
/* global requestAnimationFrame */

async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];

  gltfObjects.scenes.forEach(scene => {
    scene.traverse(model => {
      Object.values(model.model.getUniforms()).forEach(uniform => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });

  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));
}

async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise(resolve => requestAnimationFrame(resolve));
  }
}


/***/ }),

/***/ "./src/scenegraph-layer/scenegraph-layer-fragment.glsl.js":
/*!****************************************************************!*\
  !*** ./src/scenegraph-layer/scenegraph-layer-fragment.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es

// Uniforms
uniform float opacity;

// Varying
in vec4 vColor;

out vec4 fragmentColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`);


/***/ }),

/***/ "./src/scenegraph-layer/scenegraph-layer-vertex.glsl.js":
/*!**************************************************************!*\
  !*** ./src/scenegraph-layer/scenegraph-layer-vertex.glsl.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
#version 300 es

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Uniforms
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;

// Attributes
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif

// Varying
out vec4 vColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif

// Main
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  #ifdef MODULE_PBR
    // set PBR data
    #ifdef HAS_NORMALS
      pbr_vNormal = project_normal(instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz);
      geometry.normal = pbr_vNormal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`);


/***/ }),

/***/ "./src/scenegraph-layer/scenegraph-layer.js":
/*!**************************************************!*\
  !*** ./src/scenegraph-layer/scenegraph-layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScenegraphLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/core");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "../../node_modules/@luma.gl/shadertools/dist/esm/index.js");
/* harmony import */ var _luma_gl_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/experimental */ "../../node_modules/@luma.gl/experimental/dist/esm/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/constants */ "../../node_modules/@luma.gl/constants/dist/esm/index.js");
/* harmony import */ var _loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @loaders.gl/gltf */ "../../node_modules/@loaders.gl/gltf/dist/esm/index.js");
/* harmony import */ var _gltf_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gltf-utils */ "./src/scenegraph-layer/gltf-utils.js");
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/matrix */ "./src/utils/matrix.js");
/* harmony import */ var _scenegraph_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scenegraph-layer-vertex.glsl */ "./src/scenegraph-layer/scenegraph-layer-vertex.glsl.js");
/* harmony import */ var _scenegraph_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./scenegraph-layer-fragment.glsl */ "./src/scenegraph-layer/scenegraph-layer-fragment.glsl.js");
// Copyright (c) 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.














const DEFAULT_COLOR = [255, 255, 255, 255];

const defaultProps = {
  scenegraph: {type: 'object', value: null, async: true},
  getScene: gltf => {
    if (gltf && gltf.scenes) {
      // gltf post processor replaces `gltf.scene` number with the scene `object`
      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: scenegraph => scenegraph && scenegraph.animator,
  _animations: null,

  sizeScale: {type: 'number', value: 1, min: 0},
  sizeMinPixels: {type: 'number', min: 0, value: 0},
  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},

  getPosition: {type: 'accessor', value: x => x.position},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},

  // flat or pbr
  _lighting: 'flat',
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: null,

  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {type: 'accessor', value: [0, 0, 0]},
  getScale: {type: 'accessor', value: [1, 1, 1]},
  getTranslation: {type: 'accessor', value: [0, 0, 0]},
  // 4x4 matrix
  getTransformMatrix: {type: 'accessor', value: []},

  loaders: [_loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_5__["GLTFLoader"]]
};

class ScenegraphLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    const modules = [_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["project32"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["picking"]];

    if (this.props._lighting === 'pbr') {
      modules.push(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["pbr"]);
    }

    return {vs: _scenegraph_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_8__["default"], fs: _scenegraph_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_9__["default"], modules};
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_4__["default"].DOUBLE,
        fp64: this.use64bitPositions(),
        accessor: 'getPosition',
        transition: true
      },
      instanceColors: {
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_4__["default"].UNSIGNED_BYTE,
        size: this.props.colorFormat.length,
        accessor: 'getColor',
        normalized: true,
        defaultValue: DEFAULT_COLOR,
        transition: true
      },
      instanceModelMatrix: _utils_matrix__WEBPACK_IMPORTED_MODULE_7__["MATRIX_ATTRIBUTES"]
    });
  }

  updateState(params) {
    super.updateState(params);
    const {props, oldProps} = params;

    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph(props);
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
    }
  }

  finalizeState() {
    super.finalizeState();
    this._deleteScenegraph();
  }

  _updateScenegraph(props) {
    const {gl} = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof _luma_gl_experimental__WEBPACK_IMPORTED_MODULE_3__["ScenegraphNode"]) {
      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph
      scenegraphData = {scenes: [props.scenegraph]};
    } else if (props.scenegraph && !props.scenegraph.gltf) {
      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function
      const gltf = props.scenegraph;
      const gltfObjects = Object(_luma_gl_experimental__WEBPACK_IMPORTED_MODULE_3__["createGLTFObjects"])(gl, gltf, this._getModelOptions());
      scenegraphData = {gltf, ...gltfObjects};

      Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_6__["waitForGLTFAssets"])(gltfObjects).then(() => this.setNeedsRedraw());
    } else if (props.scenegraph) {
      // DEPRECATED PATH: Assumes this data was loaded through GLTFScenegraphLoader
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].deprecated(
        'ScenegraphLayer.props.scenegraph',
        'Use GLTFLoader instead of GLTFScenegraphLoader'
      )();
      scenegraphData = props.scenegraph;
    }

    const options = {layer: this, gl};
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);

    if (scenegraph instanceof _luma_gl_experimental__WEBPACK_IMPORTED_MODULE_3__["ScenegraphNode"]) {
      this._deleteScenegraph();
      this._applyAllAttributes(scenegraph);
      this._applyAnimationsProp(scenegraph, animator, props._animations);
      this.setState({scenegraph, animator});
    } else if (scenegraph !== null) {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn('invalid scenegraph:', scenegraph)();
    }
  }

  _applyAllAttributes(scenegraph) {
    if (this.state.attributesAvailable) {
      const allAttributes = this.getAttributeManager().getAttributes();
      scenegraph.traverse(model => {
        this._setModelAttributes(model.model, allAttributes);
      });
    }
  }

  _applyAnimationsProp(scenegraph, animator, animationsProp) {
    if (!scenegraph || !animator || !animationsProp) {
      return;
    }

    const animations = animator.getAnimations();

    // sort() to ensure '*' comes first so that other values can override
    Object.keys(animationsProp)
      .sort()
      .forEach(key => {
        // Key can be:
        //  - number for index number
        //  - name for animation name
        //  - * to affect all animations
        const value = animationsProp[key];

        if (key === '*') {
          animations.forEach(animation => {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          const number = Number(key);
          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn(`animation ${key} not found`)();
          }
        } else {
          const findResult = animations.find(({name}) => name === key);
          if (findResult) {
            Object.assign(findResult, value);
          } else {
            _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn(`animation ${key} not found`)();
          }
        }
      });
  }

  _deleteScenegraph() {
    const {scenegraph} = this.state;
    if (scenegraph instanceof _luma_gl_experimental__WEBPACK_IMPORTED_MODULE_3__["ScenegraphNode"]) {
      scenegraph.delete();
    }
  }

  _getModelOptions() {
    const {_imageBasedLightingEnvironment} = this.props;

    let env = null;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === 'function') {
        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }

    return {
      gl: this.context.gl,
      waitForFullLoad: true,
      imageBasedLightingEnvironment: env,
      modelOptions: {
        isInstanced: true,
        transpileToGLSL100: !Object(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(this.context.gl),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: false
    };
  }

  updateAttributes(changedAttributes) {
    this.setState({attributesAvailable: true});
    if (!this.state.scenegraph) return;

    this.state.scenegraph.traverse(model => {
      this._setModelAttributes(model.model, changedAttributes);
    });
  }

  draw({moduleParameters = null, parameters = {}, context}) {
    if (!this.state.scenegraph) return;

    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }

    const {viewport} = this.context;
    const {sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem} = this.props;
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((model, {worldMatrix}) => {
      model.model.setInstanceCount(numInstances);
      model.updateModuleSettings(moduleParameters);
      model.draw({
        parameters,
        uniforms: {
          sizeScale,
          opacity,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: Object(_utils_matrix__WEBPACK_IMPORTED_MODULE_7__["shouldComposeModelMatrix"])(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix,
          // Needed for PBR (TODO: find better way to get it)
          u_Camera: model.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
}

ScenegraphLayer.layerName = 'ScenegraphLayer';
ScenegraphLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js":
/*!******************************************************************!*\
  !*** ./src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

// NOTE(Tarek): This is necessary because
// headless.gl reports the extension as
// available but does not support it in
// the shader.
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`);


/***/ }),

/***/ "./src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js":
/*!****************************************************************!*\
  !*** ./src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
  geometry.normal = normals_commonspace;

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
  }

  geometry.position = position_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`);


/***/ }),

/***/ "./src/simple-mesh-layer/simple-mesh-layer.js":
/*!****************************************************!*\
  !*** ./src/simple-mesh-layer/simple-mesh-layer.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SimpleMeshLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "../../node_modules/@luma.gl/constants/dist/esm/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/core");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/webgl */ "../../node_modules/@luma.gl/webgl/dist/esm/index.js");
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/matrix */ "./src/utils/matrix.js");
/* harmony import */ var _simple_mesh_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simple-mesh-layer-vertex.glsl */ "./src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js");
/* harmony import */ var _simple_mesh_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./simple-mesh-layer-fragment.glsl */ "./src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js");
// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards
// Disabling lint temporarily to facilitate copying code in and out of this repo
/* eslint-disable */

// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











function validateGeometryAttributes(attributes, useMeshColors) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  const useColorAttribute = hasColorAttribute && useMeshColors;
  if (!useColorAttribute) {
    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};
  }
  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(
    attributes.positions || attributes.POSITION,
    'no "postions" or "POSITION" attribute in mesh'
  );
}

/*
 * Convert mesh data into geometry
 * @returns {Geometry} geometry
 */
function getGeometry(data, useMeshColors) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes, useMeshColors);
    if (data instanceof _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Geometry"]) {
      return data;
    } else {
      return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Geometry"](data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data, useMeshColors);
    return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Geometry"]({
      attributes: data
    });
  }
  throw Error('Invalid mesh');
}

const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  mesh: {value: null, type: 'object', async: true},
  texture: {type: 'image', value: null, async: true},
  sizeScale: {type: 'number', value: 1, min: 0},
  // Whether the color attribute in a mesh will be used
  // This prop will be removed and set to true in next major release
  _useMeshColors: {type: 'boolean', value: false},

  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: true,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: false,
  // Optional material for 'lighting' shader module
  material: true,
  getPosition: {type: 'accessor', value: x => x.position},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},

  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {type: 'accessor', value: [0, 0, 0]},
  getScale: {type: 'accessor', value: [1, 1, 1]},
  getTranslation: {type: 'accessor', value: [0, 0, 0]},
  // 4x4 matrix
  getTransformMatrix: {type: 'accessor', value: []}
};

class SimpleMeshLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    const transpileToGLSL100 = !Object(_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(this.context.gl);

    const defines = {};

    if (Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__["hasFeature"])(this.context.gl, _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__["FEATURES"].GLSL_DERIVATIVES)) {
      defines.DERIVATIVES_AVAILABLE = 1;
    }

    return super.getShaders({
      vs: _simple_mesh_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_5__["default"],
      fs: _simple_mesh_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_6__["default"],
      modules: [_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["project32"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["phongLighting"], _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["picking"]],
      transpileToGLSL100,
      defines
    });
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();

    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["default"].DOUBLE,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: 'getPosition'
      },
      instanceColors: {
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["default"].UNSIGNED_BYTE,
        transition: true,
        size: this.props.colorFormat.length,
        normalized: true,
        accessor: 'getColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: _utils_matrix__WEBPACK_IMPORTED_MODULE_4__["MATRIX_ATTRIBUTES"]
    });

    this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Texture2D"](this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});

    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      this.state.model?.delete();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);

        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }

    if (props.texture !== oldProps.texture) {
      this.setTexture(props.texture);
    }

    if (this.state.model) {
      this.state.model.setDrawMode(this.props.wireframe ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRIP : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["default"].TRIANGLES);
    }
  }

  finalizeState() {
    super.finalizeState();

    this.state.emptyTexture.delete();
  }

  draw({uniforms}) {
    if (!this.state.model) {
      return;
    }

    const {viewport} = this.context;
    const {sizeScale, coordinateSystem, _instanced} = this.props;

    this.state.model
      .setUniforms(uniforms)
      .setUniforms({
        sizeScale,
        composeModelMatrix: !_instanced || Object(_utils_matrix__WEBPACK_IMPORTED_MODULE_4__["shouldComposeModelMatrix"])(viewport, coordinateSystem),
        flatShading: !this.state.hasNormals
      })
      .draw();
  }

  getModel(mesh) {
    const model = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["Model"](this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: getGeometry(mesh, this.props._useMeshColors),
      isInstanced: true
    });

    const {texture} = this.props;
    const {emptyTexture} = this.state;
    model.setUniforms({
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    });

    return model;
  }

  setTexture(texture) {
    const {emptyTexture, model} = this.state;

    // props.mesh may not be ready at this time.
    // The sampler will be set when `getModel` is called
    model?.setUniforms({
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    });
  }
}

SimpleMeshLayer.layerName = 'SimpleMeshLayer';
SimpleMeshLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/utils/matrix.js":
/*!*****************************!*\
  !*** ./src/utils/matrix.js ***!
  \*****************************/
/*! exports provided: MATRIX_ATTRIBUTES, shouldComposeModelMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MATRIX_ATTRIBUTES", function() { return MATRIX_ATTRIBUTES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shouldComposeModelMatrix", function() { return shouldComposeModelMatrix; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);


/* eslint-disable max-statements, complexity */
const RADIAN_PER_DEGREE = Math.PI / 180;
const modelMatrix = new Float32Array(16);
const valueArray = new Float32Array(12);

function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;

  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);

  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);

  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];

  targetMatrix[0] = scx * cw * cp; // 0,0
  targetMatrix[1] = scx * sw * cp; // 1,0
  targetMatrix[2] = scx * -sp; // 2,0
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1
  targetMatrix[5] = scy * cp * sr; // 2,1
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2
  targetMatrix[8] = scz * cp * cr; // 2,2
}

function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];

  return mat4.subarray(0, 12);
}

const MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },

  update(attribute, {startRow, endRow}) {
    // NOTE(Tarek): "this" will be bound to a layer!
    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;

    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);

    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));

    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }

    const instanceModelMatrixData = attribute.value;

    if (attribute.constant) {
      let matrix;

      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;

        const orientation = getOrientation;
        const scale = getScale;

        calculateTransformMatrix(matrix, orientation, scale);
        matrix.set(getTranslation, 9);
      }

      attribute.value = new Float32Array(matrix);
    } else {
      let i = startRow * attribute.size;
      const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;

        if (hasMatrix) {
          modelMatrix.set(
            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)
          );
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;

          const orientation = constantOrientation
            ? getOrientation
            : getOrientation(object, objectInfo);
          const scale = constantScale ? getScale : getScale(object, objectInfo);

          calculateTransformMatrix(matrix, orientation, scale);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }

        instanceModelMatrixData[i++] = matrix[0];
        instanceModelMatrixData[i++] = matrix[1];
        instanceModelMatrixData[i++] = matrix[2];
        instanceModelMatrixData[i++] = matrix[3];
        instanceModelMatrixData[i++] = matrix[4];
        instanceModelMatrixData[i++] = matrix[5];
        instanceModelMatrixData[i++] = matrix[6];
        instanceModelMatrixData[i++] = matrix[7];
        instanceModelMatrixData[i++] = matrix[8];
        instanceModelMatrixData[i++] = matrix[9];
        instanceModelMatrixData[i++] = matrix[10];
        instanceModelMatrixData[i++] = matrix[11];
      }
    }
  }
};

// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system
// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations
// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled
// when in LNGLAT and LNGLAT_OFFSET coordinates.
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return (
    coordinateSystem === _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].CARTESIAN ||
    coordinateSystem === _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].METER_OFFSETS ||
    (coordinateSystem === _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["COORDINATE_SYSTEM"].DEFAULT && !viewport.isGeospatial)
  );
}


/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** asciify-image (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!********************************************!*\
  !*** ../node/require-utils.node (ignored) ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!*******************************************!*\
  !*** ../node/buffer-utils.node (ignored) ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!*************************************!*\
  !*** ./buffer-utils.node (ignored) ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "@deck.gl/core":
/*!***********************!*\
  !*** external "deck" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__deck_gl_core__;

/***/ }),

/***/ "@luma.gl/core":
/*!***********************!*\
  !*** external "luma" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__luma_gl_core__;

/***/ })

/******/ });
});