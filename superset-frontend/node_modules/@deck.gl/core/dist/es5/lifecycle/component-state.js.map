{"version":3,"sources":["../../../src/lifecycle/component-state.js"],"names":["ASYNC_ORIGINAL","PROP_SYMBOLS","ASYNC_RESOLVED","ASYNC_DEFAULTS","EMPTY_PROPS","Object","freeze","ComponentState","component","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","propName","asyncProp","type","release","resolvedValue","props","create","defineProperty","enumerable","value","Boolean","pendingLoadCount","resolvedLoadCount","key","isAsyncPropLoading","_watchPromise","Promise","resolve","resolvedValues","originalValues","defaultValues","_createAsyncPropData","_updateAsyncProp","getAsyncProp","_didAsyncInputValueChange","fetch","layer","url","_resolveAsyncIterable","_setPropValue","lastValue","_postProcessValue","loadCount","undefined","freezeAsyncOldProps","promise","then","data","_setAsyncPropValue","onDataLoad","catch","error","raiseError","iterable","count","chunk","dataTransform","concat","startRow","endRow","length","propType","transform","defaultValue","propTypes","constructor","_propTypes"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {PROP_SYMBOLS} from './constants';\nconst {ASYNC_ORIGINAL, ASYNC_RESOLVED, ASYNC_DEFAULTS} = PROP_SYMBOLS;\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport default class ComponentState {\n  constructor(component = null) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = EMPTY_PROPS; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  freezeAsyncOldProps() {\n    if (!this.oldAsyncProps) {\n      // Make sure oldProps is set\n      this.oldProps = this.oldProps || this.component.props;\n\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // ASYNC PROP HANDLING\n  //\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED] || {};\n    const originalValues = props[ASYNC_ORIGINAL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      const fetch = this.layer?.props.fetch;\n      const url = value;\n      if (fetch) {\n        value = fetch(url, {propName, layer: this.layer});\n      }\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    value = this._postProcessValue(asyncProp, value);\n    asyncProp.resolvedValue = value;\n    asyncProp.pendingLoadCount++;\n    asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // A chance to copy old props before updating\n      this.freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    promise\n      .then(data => {\n        data = this._postProcessValue(asyncProp, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        const onDataLoad = this.layer?.props.onDataLoad;\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {propName, layer: this.layer});\n        }\n      })\n      .catch(error => {\n        this.layer?.raiseError(error, `loading ${propName} of ${this.layer}`);\n      });\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      const {dataTransform} = this.component ? this.component.props : {};\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    const onDataLoad = this.layer?.props.onDataLoad;\n    if (onDataLoad) {\n      onDataLoad(data, {propName, layer: this.layer});\n    }\n  }\n\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.constructor._propTypes;\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"],"file":"component-state.js"}