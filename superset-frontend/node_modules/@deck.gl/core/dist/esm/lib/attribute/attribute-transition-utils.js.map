{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-utils.js"],"names":["padArray","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","getSourceBufferAttribute","gl","attribute","buffer","getBuffer","divisor","size","normalized","settings","value","getAttributeTypeFromSize","Error","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","Float64Array","noAlloc","length","padBuffer","fromLength","fromStartIndices","getData","x","precisionMultiplier","byteOffset","toStartIndices","startIndices","hasStartIndices","toLength","isConstant","state","constant","toData","srcByteOffset","getter","chunk","_normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceStartIndices","targetStartIndices","byteLength","reallocate","subData","offset"],"mappings":"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","sourcesContent":["import {padArray} from '../../utils/array-utils';\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {duration: userSettings};\n  }\n  userSettings.type = userSettings.type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[userSettings.type],\n    ...layerSettings,\n    ...userSettings\n  };\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(gl, attribute) {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      attribute.getBuffer(),\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      }\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value;\n}\n\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\n\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}) {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.state.constant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : attribute.getBuffer().getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute._normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"],"file":"attribute-transition-utils.js"}