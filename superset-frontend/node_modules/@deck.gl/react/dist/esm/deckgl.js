import { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle, forwardRef } from 'react';
import PropTypes from 'prop-types';
import { Deck } from '@deck.gl/core';
import useIsomorphicLayoutEffect from './utils/use-isomorphic-layout-effect';
import extractJSXLayers from './utils/extract-jsx-layers';
import positionChildrenUnderViews from './utils/position-children-under-views';
import extractStyles from './utils/extract-styles';

function getRefHandles(thisRef) {
  const handles = {
    pickObject: opts => thisRef.deck.pickObject(opts),
    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),
    pickObjects: opts => thisRef.deck.pickObjects(opts)
  };
  Object.defineProperty(handles, 'deck', {
    get: () => thisRef.deck
  });
  return handles;
}

function redrawDeck(thisRef) {
  if (thisRef.redrawReason) {
    thisRef.deck._drawLayers(thisRef.redrawReason);

    thisRef.redrawReason = null;
  }
}

function createDeckInstance(thisRef, props) {
  const DeckClass = props.Deck || Deck;
  const deck = new DeckClass({ ...props,
    style: null,
    width: '100%',
    height: '100%',
    _customRender: redrawReason => {
      thisRef.redrawReason = redrawReason;
      const viewports = deck.viewManager.getViewports();

      if (thisRef.lastRenderedViewports !== viewports) {
        thisRef.forceUpdate(v => v + 1);
      } else {
        redrawDeck(thisRef);
      }
    }
  });
  return deck;
}

const DeckGL = forwardRef((props, ref) => {
  const _thisRef = useRef({});

  const thisRef = _thisRef.current;
  const [version, setVersion] = useState(0);
  thisRef.forceUpdate = setVersion;
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);
  let inRender = true;

  const handleViewStateChange = params => {
    if (inRender && props.viewState) {
      thisRef.viewStateUpdateRequested = params;
      return null;
    }

    thisRef.viewStateUpdateRequested = null;
    return props.onViewStateChange(params);
  };

  const handleInteractionStateChange = params => {
    if (inRender) {
      thisRef.interactionStateUpdateRequested = params;
    } else {
      thisRef.interactionStateUpdateRequested = null;
      props.onInteractionStateChange(params);
    }
  };

  const deckProps = useMemo(() => {
    const forwardProps = { ...props,
      style: null,
      width: '100%',
      height: '100%',
      layers: jsxProps.layers,
      views: jsxProps.views,
      onViewStateChange: handleViewStateChange,
      onInteractionStateChange: handleInteractionStateChange
    };

    if (thisRef.deck) {
      thisRef.deck.setProps(forwardProps);
    }

    return forwardProps;
  }, [props]);
  useEffect(() => {
    thisRef.deck = createDeckInstance(thisRef, { ...deckProps,
      parent: containerRef.current,
      canvas: canvasRef.current
    });
    return () => thisRef.deck.finalize();
  }, []);
  useIsomorphicLayoutEffect(() => {
    redrawDeck(thisRef);
    const {
      viewStateUpdateRequested,
      interactionStateUpdateRequested
    } = thisRef;

    if (viewStateUpdateRequested) {
      handleViewStateChange(viewStateUpdateRequested);
    }

    if (interactionStateUpdateRequested) {
      handleInteractionStateChange(interactionStateUpdateRequested);
    }
  });
  useImperativeHandle(ref, () => getRefHandles(thisRef), []);
  const {
    viewManager
  } = thisRef.deck || {};
  const currentViewports = viewManager && viewManager.getViewports();
  const {
    ContextProvider,
    width,
    height,
    id,
    style
  } = props;
  const {
    containerStyle,
    canvasStyle
  } = useMemo(() => extractStyles({
    width,
    height,
    style
  }), [width, height, style]);

  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {
      thisRef.lastRenderedViewports = currentViewports;
      thisRef.version = version;
      const childrenUnderViews = positionChildrenUnderViews({
        children: jsxProps.children,
        deck: thisRef.deck,
        ContextProvider
      });
      const canvas = createElement('canvas', {
        key: 'canvas',
        id: id || 'deckgl-overlay',
        ref: canvasRef,
        style: canvasStyle
      });
      thisRef.control = createElement('div', {
        id: "".concat(id || 'deckgl', "-wrapper"),
        ref: containerRef,
        style: containerStyle
      }, [canvas, childrenUnderViews]);
    }

  inRender = false;
  return thisRef.control;
});
DeckGL.propTypes = Deck.getPropTypes(PropTypes);
DeckGL.defaultProps = Deck.defaultProps;
export default DeckGL;
//# sourceMappingURL=deckgl.js.map