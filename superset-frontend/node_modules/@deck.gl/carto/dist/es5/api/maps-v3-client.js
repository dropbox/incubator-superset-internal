"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapInstantiation = mapInstantiation;
exports.getData = getData;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _config = require("../config");

var _mapsApiCommon = require("./maps-api-common");

var _core = require("@deck.gl/core");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MAX_GET_LENGTH = 2048;

function request(_x) {
  return _request.apply(this, arguments);
}

function _request() {
  _request = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref) {
    var method, url, format, accessToken, body, response, headers, json;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            method = _ref.method, url = _ref.url, format = _ref.format, accessToken = _ref.accessToken, body = _ref.body;
            headers = {
              Accept: 'application/json'
            };

            if (accessToken) {
              headers.Authorization = "Bearer ".concat(accessToken);
            }

            if (method === 'POST') {
              headers['Content-Type'] = 'application/json';
            }

            _context.prev = 4;
            _context.next = 7;
            return fetch(url, {
              method: method,
              headers: headers,
              body: body
            });

          case 7:
            response = _context.sent;
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](4);
            throw new Error("Failed to connect to Maps API: ".concat(_context.t0));

          case 13:
            if (!(format === _mapsApiCommon.FORMATS.NDJSON)) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("return", response);

          case 15:
            _context.next = 17;
            return response.json();

          case 17:
            json = _context.sent;

            if (!response.ok) {
              dealWithError({
                response: response,
                error: json.error
              });
            }

            return _context.abrupt("return", json.rows ? json.rows : json);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 10]]);
  }));
  return _request.apply(this, arguments);
}

function dealWithError(_ref2) {
  var response = _ref2.response,
      error = _ref2.error;

  switch (response.status) {
    case 401:
    case 403:
      throw new Error("Unauthorized access to Maps API");

    default:
      throw new Error(error);
  }
}

function getParameters(_ref3) {
  var type = _ref3.type,
      source = _ref3.source;
  var encodedClient = (0, _mapsApiCommon.encodeParameter)('client', 'deck-gl-carto');
  var parameters = [encodedClient];
  var sourceName = type === _mapsApiCommon.MAP_TYPES.QUERY ? 'q' : 'name';
  parameters.push((0, _mapsApiCommon.encodeParameter)(sourceName, source));
  return parameters.join('&');
}

function mapInstantiation(_x2) {
  return _mapInstantiation.apply(this, arguments);
}

function _mapInstantiation() {
  _mapInstantiation = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(_ref4) {
    var type, source, connection, credentials, baseUrl, url, accessToken, format, body;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            type = _ref4.type, source = _ref4.source, connection = _ref4.connection, credentials = _ref4.credentials;
            baseUrl = "".concat(credentials.mapsUrl, "/").concat(connection, "/").concat(type);
            url = "".concat(baseUrl, "?").concat(getParameters({
              type: type,
              source: source
            }));
            accessToken = credentials.accessToken;
            format = 'json';

            if (!(url.length > MAX_GET_LENGTH && type === _mapsApiCommon.MAP_TYPES.QUERY)) {
              _context2.next = 10;
              break;
            }

            body = JSON.stringify({
              q: source,
              client: 'deck-gl-carto'
            });
            _context2.next = 9;
            return request({
              method: 'POST',
              url: baseUrl,
              format: format,
              accessToken: accessToken,
              body: body
            });

          case 9:
            return _context2.abrupt("return", _context2.sent);

          case 10:
            _context2.next = 12;
            return request({
              url: url,
              format: format,
              accessToken: accessToken
            });

          case 12:
            return _context2.abrupt("return", _context2.sent);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _mapInstantiation.apply(this, arguments);
}

function getUrlFromMetadata(metadata, format) {
  var m = metadata[format];

  if (m && !m.error && m.url) {
    return m.url[0];
  }

  return null;
}

function getData(_x3) {
  return _getData.apply(this, arguments);
}

function _getData() {
  _getData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(_ref5) {
    var type, source, connection, credentials, format, localCreds, metadata, url, mapFormat, prioritizedFormats, _i, _prioritizedFormats, f, accessToken;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            type = _ref5.type, source = _ref5.source, connection = _ref5.connection, credentials = _ref5.credentials, format = _ref5.format;
            localCreds = _objectSpread(_objectSpread({}, (0, _config.getDefaultCredentials)()), credentials);

            _core.log.assert(connection, 'Must define connection');

            _core.log.assert(type, 'Must define a type');

            _core.log.assert(source, 'Must define a source');

            _core.log.assert(localCreds.apiVersion === _mapsApiCommon.API_VERSIONS.V3, 'Method only available for v3');

            _core.log.assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');

            _core.log.assert(localCreds.accessToken, 'Must define an accessToken');

            _core.log.assert(localCreds.mapsUrl, 'mapsUrl cannot be undefined');

            if (!localCreds.mapsUrl) {
              localCreds.mapsUrl = (0, _config.buildMapsUrlFromBase)(localCreds.apiBaseUrl);
            }

            _context3.next = 12;
            return mapInstantiation({
              type: type,
              source: source,
              connection: connection,
              credentials: localCreds
            });

          case 12:
            metadata = _context3.sent;

            if (!format) {
              _context3.next = 19;
              break;
            }

            mapFormat = format;
            url = getUrlFromMetadata(metadata, format);

            _core.log.assert(url, "Format ".concat(format, " not available"));

            _context3.next = 30;
            break;

          case 19:
            prioritizedFormats = [_mapsApiCommon.FORMATS.GEOJSON, _mapsApiCommon.FORMATS.NDJSON, _mapsApiCommon.FORMATS.TILEJSON];
            _i = 0, _prioritizedFormats = prioritizedFormats;

          case 21:
            if (!(_i < _prioritizedFormats.length)) {
              _context3.next = 30;
              break;
            }

            f = _prioritizedFormats[_i];
            url = getUrlFromMetadata(metadata, f);

            if (!url) {
              _context3.next = 27;
              break;
            }

            mapFormat = f;
            return _context3.abrupt("break", 30);

          case 27:
            _i++;
            _context3.next = 21;
            break;

          case 30:
            accessToken = localCreds.accessToken;
            _context3.next = 33;
            return request({
              url: url,
              format: mapFormat,
              accessToken: accessToken
            });

          case 33:
            return _context3.abrupt("return", _context3.sent);

          case 34:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getData.apply(this, arguments);
}
//# sourceMappingURL=maps-v3-client.js.map