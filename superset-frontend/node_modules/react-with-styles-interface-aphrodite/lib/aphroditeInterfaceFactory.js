Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inject = require('aphrodite/lib/inject');

var _arrayFlatten = require('array-flatten');

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// This function takes the array of styles and separates them into styles that
// are handled by Aphrodite and inline styles.
function separateStyles(stylesArray) {
  var aphroditeStyles = [];

  // Since determining if an Object is empty requires collecting all of its
  // keys, and we want the best performance in this code because we are in the
  // render path, we are going to do a little bookkeeping ourselves.
  var hasInlineStyles = false;
  var inlineStyles = {};

  // This is run on potentially every node in the tree when rendering, where
  // performance is critical. Normally we would prefer using `forEach`, but
  // old-fashioned for loops are faster so that's what we have chosen here.
  for (var i = 0; i < stylesArray.length; i++) {
    // eslint-disable-line no-plusplus
    var style = stylesArray[i];

    // If this  style is falsey, we just want to disregard it. This allows for
    // syntax like:
    //
    //   css(isFoo && styles.foo)
    if (style) {
      if ((0, _has2['default'])(style, '_name') && (0, _has2['default'])(style, '_definition')) {
        // This looks like a reference to an Aphrodite style object, so that's
        // where it goes.
        aphroditeStyles.push(style);
      } else {
        Object.assign(inlineStyles, style);
        hasInlineStyles = true;
      }
    }
  }

  return {
    aphroditeStyles: aphroditeStyles,
    hasInlineStyles: hasInlineStyles,
    inlineStyles: inlineStyles
  };
}

exports['default'] = function (_ref /* aphrodite */) {
  var StyleSheet = _ref.StyleSheet,
      css = _ref.css;
  return {
    create: function () {
      function create(styleHash) {
        return StyleSheet.create(styleHash);
      }

      return create;
    }(),


    // Styles is an array of properties returned by `create()`, a POJO, or an
    // array thereof. POJOs are treated as inline styles.
    // This function returns an object to be spread onto an element.
    resolve: function () {
      function resolve(styles) {
        var flattenedStyles = (0, _arrayFlatten.from)(styles);

        var _separateStyles = separateStyles(flattenedStyles),
            aphroditeStyles = _separateStyles.aphroditeStyles,
            hasInlineStyles = _separateStyles.hasInlineStyles,
            inlineStyles = _separateStyles.inlineStyles;

        var result = {};
        if (aphroditeStyles.length > 0) {
          result.className = css.apply(undefined, _toConsumableArray(aphroditeStyles));
        }
        if (hasInlineStyles) {
          result.style = inlineStyles;
        }
        return result;
      }

      return resolve;
    }(),


    // Flushes all buffered styles to a style tag. Required for components
    // that depend upon previous styles in the component tree (i.e.
    // for calculating container width, including padding/margin).
    flush: function () {
      function flush() {
        (0, _inject.flushToStyleTag)();
      }

      return flush;
    }()
  };
};