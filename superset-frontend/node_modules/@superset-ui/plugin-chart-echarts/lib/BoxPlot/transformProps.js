"use strict";

exports.__esModule = true;
exports.default = transformProps;

var _core = require("@superset-ui/core");

var _series = require("../utils/series");

var _defaults = require("../defaults");

var _transformers = require("../Timeseries/transformers");

var _constants = require("../constants");

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function transformProps(chartProps) {
  const {
    width,
    height,
    formData,
    hooks,
    filterState,
    queriesData
  } = chartProps;
  const {
    data = []
  } = queriesData[0];
  const {
    setDataMask = () => {}
  } = hooks;
  const coltypeMapping = (0, _series.getColtypesMapping)(queriesData[0]);
  const {
    colorScheme,
    groupby = [],
    metrics: formdataMetrics = [],
    numberFormat,
    dateFormat,
    xTicksLayout,
    emitFilter,
    legendOrientation = 'top',
    xAxisTitle,
    yAxisTitle,
    xAxisTitleMargin,
    yAxisTitleMargin,
    yAxisTitlePosition
  } = formData;

  const colorFn = _core.CategoricalColorNamespace.getScale(colorScheme);

  const numberFormatter = (0, _core.getNumberFormatter)(numberFormat);
  const metricLabels = formdataMetrics.map(_core.getMetricLabel);
  const transformedData = data.map(datum => {
    const groupbyLabel = (0, _series.extractGroupbyLabel)({
      datum,
      groupby,
      coltypeMapping,
      timeFormatter: (0, _core.getTimeFormatter)(dateFormat)
    });
    return metricLabels.map(metric => {
      const name = metricLabels.length === 1 ? groupbyLabel : `${groupbyLabel}, ${metric}`;
      const isFiltered = filterState.selectedValues && !filterState.selectedValues.includes(name);
      return {
        name,
        value: [datum[`${metric}__min`], datum[`${metric}__q1`], datum[`${metric}__median`], datum[`${metric}__q3`], datum[`${metric}__max`], datum[`${metric}__mean`], datum[`${metric}__count`], datum[`${metric}__outliers`]],
        itemStyle: {
          color: colorFn(groupbyLabel),
          opacity: isFiltered ? _constants.OpacityEnum.SemiTransparent : 0.6,
          borderColor: colorFn(groupbyLabel)
        }
      };
    });
  }).flatMap(row => row);
  const outlierData = data.map(datum => metricLabels.map(metric => {
    const groupbyLabel = (0, _series.extractGroupbyLabel)({
      datum,
      groupby,
      coltypeMapping,
      timeFormatter: (0, _core.getTimeFormatter)(dateFormat)
    });
    const name = metricLabels.length === 1 ? groupbyLabel : `${groupbyLabel}, ${metric}`; // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)

    const outlierDatum = datum[`${metric}__outliers`] || [];
    const isFiltered = filterState.selectedValues && !filterState.selectedValues.includes(name);
    return {
      name: 'outlier',
      type: 'scatter',
      data: outlierDatum.map(val => [name, val]),
      tooltip: {
        formatter: param => {
          const [outlierName, stats] = param.data;
          const headline = groupby ? `<p><strong>${(0, _series.sanitizeHtml)(outlierName)}</strong></p>` : '';
          return `${headline}${numberFormatter(stats)}`;
        }
      },
      itemStyle: {
        color: colorFn(groupbyLabel),
        opacity: isFiltered ? _constants.OpacityEnum.SemiTransparent : _constants.OpacityEnum.NonTransparent
      }
    };
  })).flat(2);
  const labelMap = data.reduce((acc, datum) => {
    const label = (0, _series.extractGroupbyLabel)({
      datum,
      groupby,
      coltypeMapping,
      timeFormatter: (0, _core.getTimeFormatter)(dateFormat)
    });
    return { ...acc,
      [label]: groupby.map(col => datum[col])
    };
  }, {});
  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {
    const index = transformedData.findIndex(({
      name
    }) => name === selectedValue);
    return { ...acc,
      [index]: selectedValue
    };
  }, {});
  let axisLabel;
  if (xTicksLayout === '45°') axisLabel = {
    rotate: -45
  };else if (xTicksLayout === '90°') axisLabel = {
    rotate: -90
  };else if (xTicksLayout === 'flat') axisLabel = {
    rotate: 0
  };else if (xTicksLayout === 'staggered') axisLabel = {
    rotate: -45
  };else axisLabel = {
    show: true
  };
  const series = [{
    name: 'boxplot',
    type: 'boxplot',
    data: transformedData,
    tooltip: {
      formatter: param => {
        // @ts-ignore
        const {
          value,
          name
        } = param;
        const headline = name ? `<p><strong>${(0, _series.sanitizeHtml)(name)}</strong></p>` : '';
        const stats = [`Max: ${numberFormatter(value[5])}`, `3rd Quartile: ${numberFormatter(value[4])}`, `Mean: ${numberFormatter(value[6])}`, `Median: ${numberFormatter(value[3])}`, `1st Quartile: ${numberFormatter(value[2])}`, `Min: ${numberFormatter(value[1])}`, `# Observations: ${numberFormatter(value[7])}`];

        if (value[8].length > 0) {
          stats.push(`# Outliers: ${numberFormatter(value[8].length)}`);
        }

        return headline + stats.join('<br/>');
      }
    }
  }, // @ts-ignore
  ...outlierData];
  const addYAxisTitleOffset = !!yAxisTitle;
  const addXAxisTitleOffset = !!xAxisTitle;
  const chartPadding = (0, _transformers.getPadding)(true, legendOrientation, addYAxisTitleOffset, false, null, addXAxisTitleOffset, yAxisTitlePosition, yAxisTitleMargin, xAxisTitleMargin);
  const echartOptions = {
    grid: { ..._defaults.defaultGrid,
      ...chartPadding
    },
    xAxis: {
      type: 'category',
      data: transformedData.map(row => row.name),
      axisLabel,
      name: xAxisTitle,
      nameGap: xAxisTitleMargin,
      nameLocation: 'middle'
    },
    yAxis: { ..._defaults.defaultYAxis,
      type: 'value',
      axisLabel: {
        formatter: numberFormatter
      },
      name: yAxisTitle,
      nameGap: yAxisTitleMargin,
      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'
    },
    tooltip: { ..._defaults.defaultTooltip,
      trigger: 'item',
      axisPointer: {
        type: 'shadow'
      }
    },
    series
  };
  return {
    formData,
    width,
    height,
    echartOptions,
    setDataMask,
    emitFilter,
    labelMap,
    groupby,
    selectedValues
  };
}