'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Utilities = require('./Utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable react/prop-types */
// eslint can't see inherited propTypes!

function redColorScaleGenerator(values) {
  var min = Math.min.apply(Math, values);
  var max = Math.max.apply(Math, values);
  return function (x) {
    // eslint-disable-next-line no-magic-numbers
    var nonRed = 255 - Math.round(255 * (x - min) / (max - min));
    return { backgroundColor: 'rgb(255,' + nonRed + ',' + nonRed + ')' };
  };
}

var parseLabel = function parseLabel(value) {
  if (typeof value === 'number' || typeof value === 'string') {
    return value;
  }
  return String(value);
};

function defaultBarchartScaleGenerator(values) {
  var min = Math.min.apply(Math, values);
  var max = Math.max.apply(Math, values);
  var range = min < 0 ? max - min : Math.max(max, 0);
  // eslint-disable-next-line no-magic-numbers
  var maxScale = 100 / 1.4;
  var scaler = function scaler(val) {
    return Math.min(maxScale, maxScale * (val / range));
  };

  return function (val, text) {
    var bgColor = 'gray';
    var bBase = 0;
    if (min < 0) {
      bBase = scaler(-min);
    }
    if (val < 0) {
      bBase += scaler(val);
      bgColor = 'darkred';
    }

    return _react2.default.createElement(
      'div',
      { style: { position: 'relative', height: '100%' } },
      _react2.default.createElement('div', {
        style: {
          position: 'absolute',
          bottom: bBase + '%',
          left: 0,
          right: 0,
          height: scaler(Math.abs(val)) + '%',
          backgroundColor: bgColor
        }
      }),
      _react2.default.createElement(
        'div',
        { style: { position: 'relative', padding: '0 5px' } },
        text
      )
    );
  };
}

function displayHeaderCell(needToggle, ArrowIcon, onArrowClick, value, namesMapping) {
  var name = namesMapping[value] || value;
  return needToggle ? _react2.default.createElement(
    'span',
    { className: 'toggle-wrapper' },
    _react2.default.createElement(
      'span',
      { className: 'toggle', onClick: onArrowClick },
      ArrowIcon
    ),
    _react2.default.createElement(
      'span',
      { className: 'toggle-val' },
      parseLabel(name)
    )
  ) : parseLabel(name);
}

function makeRenderer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var TableRenderer = function (_React$Component) {
    _inherits(TableRenderer, _React$Component);

    function TableRenderer(props) {
      _classCallCheck(this, TableRenderer);

      // We need state to record which entries are collapsed and which aren't.
      // This is an object with flat-keys indicating if the corresponding rows
      // should be collapsed.
      var _this = _possibleConstructorReturn(this, (TableRenderer.__proto__ || Object.getPrototypeOf(TableRenderer)).call(this, props));

      _this.state = { collapsedRows: {}, collapsedCols: {} };

      _this.clickHeaderHandler = _this.clickHeaderHandler.bind(_this);
      _this.clickHandler = _this.clickHandler.bind(_this);
      return _this;
    }

    _createClass(TableRenderer, [{
      key: 'getBasePivotSettings',
      value: function getBasePivotSettings() {
        // One-time extraction of pivot settings that we'll use throughout the render.

        var props = this.props;
        var colAttrs = props.cols;
        var rowAttrs = props.rows;

        var tableOptions = Object.assign({
          rowTotals: true,
          colTotals: true
        }, props.tableOptions);
        var rowTotals = tableOptions.rowTotals || colAttrs.length === 0;
        var colTotals = tableOptions.colTotals || rowAttrs.length === 0;

        var namesMapping = props.namesMapping || {};
        var subtotalOptions = Object.assign({
          arrowCollapsed: '\u25B2',
          arrowExpanded: '\u25BC'
        }, props.subtotalOptions);

        var colSubtotalDisplay = Object.assign({
          displayOnTop: false,
          enabled: rowTotals,
          hideOnExpand: false
        }, subtotalOptions.colSubtotalDisplay);

        var rowSubtotalDisplay = Object.assign({
          displayOnTop: false,
          enabled: colTotals,
          hideOnExpand: false
        }, subtotalOptions.rowSubtotalDisplay);

        var pivotData = new _Utilities.PivotData(props, !opts.subtotals ? {} : {
          rowEnabled: rowSubtotalDisplay.enabled,
          colEnabled: colSubtotalDisplay.enabled,
          rowPartialOnTop: rowSubtotalDisplay.displayOnTop,
          colPartialOnTop: colSubtotalDisplay.displayOnTop
        });
        var rowKeys = pivotData.getRowKeys();
        var colKeys = pivotData.getColKeys();

        // Also pre-calculate all the callbacks for cells, etc... This is nice to have to
        // avoid re-calculations of the call-backs on cell expansions, etc...
        var cellCallbacks = {};
        var rowTotalCallbacks = {};
        var colTotalCallbacks = {};
        var grandTotalCallback = null;
        if (tableOptions.clickCallback) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = rowKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var rowKey = _step.value;

              var flatRowKey = (0, _Utilities.flatKey)(rowKey);
              if (!(flatRowKey in cellCallbacks)) {
                cellCallbacks[flatRowKey] = {};
              }
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = colKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _colKey = _step4.value;

                  cellCallbacks[flatRowKey][(0, _Utilities.flatKey)(_colKey)] = this.clickHandler(pivotData, rowKey, _colKey);
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            }

            // Add in totals as well.
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (rowTotals) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = rowKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _rowKey = _step2.value;

                rowTotalCallbacks[(0, _Utilities.flatKey)(_rowKey)] = this.clickHandler(pivotData, _rowKey, []);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
          if (colTotals) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = colKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var colKey = _step3.value;

                colTotalCallbacks[(0, _Utilities.flatKey)(colKey)] = this.clickHandler(pivotData, [], colKey);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
          if (rowTotals && colTotals) {
            grandTotalCallback = this.clickHandler(pivotData, [], []);
          }
        }

        return Object.assign({
          pivotData: pivotData,
          colAttrs: colAttrs,
          rowAttrs: rowAttrs,
          colKeys: colKeys,
          rowKeys: rowKeys,
          rowTotals: rowTotals,
          colTotals: colTotals,
          arrowCollapsed: subtotalOptions.arrowCollapsed,
          arrowExpanded: subtotalOptions.arrowExpanded,
          colSubtotalDisplay: colSubtotalDisplay,
          rowSubtotalDisplay: rowSubtotalDisplay,
          cellCallbacks: cellCallbacks,
          rowTotalCallbacks: rowTotalCallbacks,
          colTotalCallbacks: colTotalCallbacks,
          grandTotalCallback: grandTotalCallback,
          namesMapping: namesMapping
        }, TableRenderer.heatmapMappers(pivotData, props.tableColorScaleGenerator, colTotals, rowTotals), TableRenderer.barchartMapper(pivotData, props.barScaleGenerator, colTotals, rowTotals));
      }
    }, {
      key: 'clickHandler',
      value: function clickHandler(pivotData, rowValues, colValues) {
        var _this2 = this;

        var colAttrs = this.props.cols;
        var rowAttrs = this.props.rows;
        var value = pivotData.getAggregator(rowValues, colValues).value();
        var filters = {};
        var colLimit = Math.min(colAttrs.length, colValues.length);
        for (var i = 0; i < colLimit; i++) {
          var attr = colAttrs[i];
          if (colValues[i] !== null) {
            filters[attr] = colValues[i];
          }
        }
        var rowLimit = Math.min(rowAttrs.length, rowValues.length);
        for (var _i = 0; _i < rowLimit; _i++) {
          var _attr = rowAttrs[_i];
          if (rowValues[_i] !== null) {
            filters[_attr] = rowValues[_i];
          }
        }
        return function (e) {
          return _this2.props.tableOptions.clickCallback(e, value, filters, pivotData);
        };
      }
    }, {
      key: 'clickHeaderHandler',
      value: function clickHeaderHandler(pivotData, values, attrs, attrIdx, callback) {
        var isSubtotal = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        var isGrandTotal = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

        var filters = {};
        for (var i = 0; i <= attrIdx; i++) {
          var attr = attrs[i];
          filters[attr] = values[i];
        }
        return function (e) {
          return callback(e, values[attrIdx], filters, pivotData, isSubtotal, isGrandTotal);
        };
      }
    }, {
      key: 'collapseAttr',
      value: function collapseAttr(rowOrCol, attrIdx, allKeys) {
        var _this3 = this;

        return function (e) {
          // Collapse an entire attribute.
          e.stopPropagation();
          var keyLen = attrIdx + 1;
          var collapsed = allKeys.filter(function (k) {
            return k.length === keyLen;
          }).map(_Utilities.flatKey);

          var updates = {};
          collapsed.forEach(function (k) {
            updates[k] = true;
          });

          if (rowOrCol) {
            _this3.setState(function (state) {
              return {
                collapsedRows: Object.assign({}, state.collapsedRows, updates)
              };
            });
          } else {
            _this3.setState(function (state) {
              return {
                collapsedCols: Object.assign({}, state.collapsedCols, updates)
              };
            });
          }
        };
      }
    }, {
      key: 'expandAttr',
      value: function expandAttr(rowOrCol, attrIdx, allKeys) {
        var _this4 = this;

        return function (e) {
          // Expand an entire attribute. This implicitly implies expanding all of the
          // parents as well. It's a bit inefficient but ah well...
          e.stopPropagation();
          var updates = {};
          allKeys.forEach(function (k) {
            for (var i = 0; i <= attrIdx; i++) {
              updates[(0, _Utilities.flatKey)(k.slice(0, i + 1))] = false;
            }
          });

          if (rowOrCol) {
            _this4.setState(function (state) {
              return {
                collapsedRows: Object.assign({}, state.collapsedRows, updates)
              };
            });
          } else {
            _this4.setState(function (state) {
              return {
                collapsedCols: Object.assign({}, state.collapsedCols, updates)
              };
            });
          }
        };
      }
    }, {
      key: 'toggleRowKey',
      value: function toggleRowKey(flatRowKey) {
        var _this5 = this;

        return function (e) {
          e.stopPropagation();
          _this5.setState(function (state) {
            return {
              collapsedRows: Object.assign({}, state.collapsedRows, _defineProperty({}, flatRowKey, !state.collapsedRows[flatRowKey]))
            };
          });
        };
      }
    }, {
      key: 'toggleColKey',
      value: function toggleColKey(flatColKey) {
        var _this6 = this;

        return function (e) {
          e.stopPropagation();
          _this6.setState(function (state) {
            return {
              collapsedCols: Object.assign({}, state.collapsedCols, _defineProperty({}, flatColKey, !state.collapsedCols[flatColKey]))
            };
          });
        };
      }
    }, {
      key: 'calcAttrSpans',
      value: function calcAttrSpans(attrArr, numAttrs) {
        // Given an array of attribute values (i.e. each element is another array with
        // the value at every level), compute the spans for every attribute value at
        // every level. The return value is a nested array of the same shape. It has
        // -1's for repeated values and the span number otherwise.

        var spans = [];
        // Index of the last new value
        var li = Array(numAttrs).map(function () {
          return 0;
        });
        var lv = Array(numAttrs).map(function () {
          return null;
        });
        for (var i = 0; i < attrArr.length; i++) {
          // Keep increasing span values as long as the last keys are the same. For
          // the rest, record spans of 1. Update the indices too.
          var cv = attrArr[i];
          var ent = [];
          var depth = 0;
          var limit = Math.min(lv.length, cv.length);
          while (depth < limit && lv[depth] === cv[depth]) {
            ent.push(-1);
            spans[li[depth]][depth]++;
            depth++;
          }
          while (depth < cv.length) {
            li[depth] = i;
            ent.push(1);
            depth++;
          }
          spans.push(ent);
          lv = cv;
        }
        return spans;
      }
    }, {
      key: 'renderColHeaderRow',
      value: function renderColHeaderRow(attrName, attrIdx, pivotSettings) {
        // Render a single row in the column header at the top of the pivot table.

        var rowAttrs = pivotSettings.rowAttrs,
            colAttrs = pivotSettings.colAttrs,
            colKeys = pivotSettings.colKeys,
            visibleColKeys = pivotSettings.visibleColKeys,
            colAttrSpans = pivotSettings.colAttrSpans,
            rowTotals = pivotSettings.rowTotals,
            arrowExpanded = pivotSettings.arrowExpanded,
            arrowCollapsed = pivotSettings.arrowCollapsed,
            colSubtotalDisplay = pivotSettings.colSubtotalDisplay,
            maxColVisible = pivotSettings.maxColVisible,
            pivotData = pivotSettings.pivotData,
            namesMapping = pivotSettings.namesMapping;
        var _props$tableOptions = this.props.tableOptions,
            highlightHeaderCellsOnHover = _props$tableOptions.highlightHeaderCellsOnHover,
            _props$tableOptions$o = _props$tableOptions.omittedHighlightHeaderGroups,
            omittedHighlightHeaderGroups = _props$tableOptions$o === undefined ? [] : _props$tableOptions$o,
            highlightedHeaderCells = _props$tableOptions.highlightedHeaderCells,
            dateFormatters = _props$tableOptions.dateFormatters;


        var spaceCell = attrIdx === 0 && rowAttrs.length !== 0 ? _react2.default.createElement('th', {
          key: 'padding',
          colSpan: rowAttrs.length,
          rowSpan: colAttrs.length
        }) : null;

        var needToggle = opts.subtotals && colSubtotalDisplay.enabled && attrIdx !== colAttrs.length - 1;
        var arrowClickHandle = null;
        var subArrow = null;
        if (needToggle) {
          arrowClickHandle = attrIdx + 1 < maxColVisible ? this.collapseAttr(false, attrIdx, colKeys) : this.expandAttr(false, attrIdx, colKeys);
          subArrow = attrIdx + 1 < maxColVisible ? arrowExpanded : arrowCollapsed;
        }
        var attrNameCell = _react2.default.createElement(
          'th',
          { key: 'label', className: 'pvtAxisLabel' },
          displayHeaderCell(needToggle, subArrow, arrowClickHandle, attrName, namesMapping)
        );

        var attrValueCells = [];
        var rowIncrSpan = rowAttrs.length !== 0 ? 1 : 0;
        // Iterate through columns. Jump over duplicate values.
        var i = 0;
        while (i < visibleColKeys.length) {
          var colKey = visibleColKeys[i];
          var colSpan = attrIdx < colKey.length ? colAttrSpans[i][attrIdx] : 1;
          var colLabelClass = 'pvtColLabel';
          if (attrIdx < colKey.length) {
            if (highlightHeaderCellsOnHover && !omittedHighlightHeaderGroups.includes(colAttrs[attrIdx])) {
              colLabelClass += ' hoverable';
            }
            if (highlightedHeaderCells && Array.isArray(highlightedHeaderCells[colAttrs[attrIdx]]) && highlightedHeaderCells[colAttrs[attrIdx]].includes(colKey[attrIdx])) {
              colLabelClass += ' active';
            }

            var rowSpan = 1 + (attrIdx === colAttrs.length - 1 ? rowIncrSpan : 0);
            var flatColKey = (0, _Utilities.flatKey)(colKey.slice(0, attrIdx + 1));
            var onArrowClick = needToggle ? this.toggleColKey(flatColKey) : null;

            var headerCellFormattedValue = dateFormatters && dateFormatters[attrName] && typeof dateFormatters[attrName] === 'function' ? dateFormatters[attrName](colKey[attrIdx]) : colKey[attrIdx];
            attrValueCells.push(_react2.default.createElement(
              'th',
              {
                className: colLabelClass,
                key: 'colKey-' + flatColKey,
                colSpan: colSpan,
                rowSpan: rowSpan,
                onClick: this.clickHeaderHandler(pivotData, colKey, this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback)
              },
              displayHeaderCell(needToggle, this.state.collapsedCols[flatColKey] ? arrowCollapsed : arrowExpanded, onArrowClick, headerCellFormattedValue, namesMapping)
            ));
          } else if (attrIdx === colKey.length) {
            var _rowSpan = colAttrs.length - colKey.length + rowIncrSpan;
            attrValueCells.push(_react2.default.createElement(
              'th',
              {
                className: colLabelClass + ' pvtSubtotalLabel',
                key: 'colKeyBuffer-' + (0, _Utilities.flatKey)(colKey),
                colSpan: colSpan,
                rowSpan: _rowSpan,
                onClick: this.clickHeaderHandler(pivotData, colKey, this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback, true)
              },
              'Subtotal'
            ));
          }
          // The next colSpan columns will have the same value anyway...
          i = i + colSpan;
        }

        var totalCell = attrIdx === 0 && rowTotals ? _react2.default.createElement(
          'th',
          {
            key: 'total',
            className: 'pvtTotalLabel',
            rowSpan: colAttrs.length + Math.min(rowAttrs.length, 1),
            onClick: this.clickHeaderHandler(pivotData, [], this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback, false, true)
          },
          'Total (' + this.props.aggregatorName + ')'
        ) : null;

        var cells = [spaceCell, attrNameCell].concat(attrValueCells, [totalCell]);
        return _react2.default.createElement(
          'tr',
          { key: 'colAttr-' + attrIdx },
          cells
        );
      }
    }, {
      key: 'renderRowHeaderRow',
      value: function renderRowHeaderRow(pivotSettings) {
        var _this7 = this;

        // Render just the attribute names of the rows (the actual attribute values
        // will show up in the individual rows).

        var rowAttrs = pivotSettings.rowAttrs,
            colAttrs = pivotSettings.colAttrs,
            rowKeys = pivotSettings.rowKeys,
            arrowCollapsed = pivotSettings.arrowCollapsed,
            arrowExpanded = pivotSettings.arrowExpanded,
            rowSubtotalDisplay = pivotSettings.rowSubtotalDisplay,
            maxRowVisible = pivotSettings.maxRowVisible,
            pivotData = pivotSettings.pivotData,
            namesMapping = pivotSettings.namesMapping;

        return _react2.default.createElement(
          'tr',
          { key: 'rowHdr' },
          rowAttrs.map(function (r, i) {
            var needLabelToggle = opts.subtotals && rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;
            var arrowClickHandle = null;
            var subArrow = null;
            if (needLabelToggle) {
              arrowClickHandle = i + 1 < maxRowVisible ? _this7.collapseAttr(true, i, rowKeys) : _this7.expandAttr(true, i, rowKeys);
              subArrow = i + 1 < maxRowVisible ? arrowExpanded : arrowCollapsed;
            }
            return _react2.default.createElement(
              'th',
              { className: 'pvtAxisLabel', key: 'rowAttr-' + i },
              displayHeaderCell(needLabelToggle, subArrow, arrowClickHandle, r, namesMapping)
            );
          }),
          _react2.default.createElement(
            'th',
            {
              className: 'pvtTotalLabel',
              key: 'padding',
              onClick: this.clickHeaderHandler(pivotData, [], this.props.rows, 0, this.props.tableOptions.clickRowHeaderCallback, false, true)
            },
            colAttrs.length === 0 ? 'Total (' + this.props.aggregatorName + ')' : null
          )
        );
      }
    }, {
      key: 'renderTableRow',
      value: function renderTableRow(rowKey, rowIdx, pivotSettings) {
        var _this8 = this;

        // Render a single row in the pivot table.

        var rowAttrs = pivotSettings.rowAttrs,
            colAttrs = pivotSettings.colAttrs,
            rowAttrSpans = pivotSettings.rowAttrSpans,
            visibleColKeys = pivotSettings.visibleColKeys,
            pivotData = pivotSettings.pivotData,
            rowTotals = pivotSettings.rowTotals,
            rowSubtotalDisplay = pivotSettings.rowSubtotalDisplay,
            valueCellColors = pivotSettings.valueCellColors,
            cellStyle = pivotSettings.cellStyle,
            valueCellBar = pivotSettings.valueCellBar,
            arrowExpanded = pivotSettings.arrowExpanded,
            arrowCollapsed = pivotSettings.arrowCollapsed,
            cellCallbacks = pivotSettings.cellCallbacks,
            rowTotalCallbacks = pivotSettings.rowTotalCallbacks,
            namesMapping = pivotSettings.namesMapping;
        var _props$tableOptions2 = this.props.tableOptions,
            highlightHeaderCellsOnHover = _props$tableOptions2.highlightHeaderCellsOnHover,
            _props$tableOptions2$ = _props$tableOptions2.omittedHighlightHeaderGroups,
            omittedHighlightHeaderGroups = _props$tableOptions2$ === undefined ? [] : _props$tableOptions2$,
            highlightedHeaderCells = _props$tableOptions2.highlightedHeaderCells,
            cellColorFormatters = _props$tableOptions2.cellColorFormatters,
            dateFormatters = _props$tableOptions2.dateFormatters;

        var flatRowKey = (0, _Utilities.flatKey)(rowKey);

        var colIncrSpan = colAttrs.length !== 0 ? 1 : 0;
        var attrValueCells = rowKey.map(function (r, i) {
          var valueCellClassName = 'pvtRowLabel';
          if (highlightHeaderCellsOnHover && !omittedHighlightHeaderGroups.includes(rowAttrs[i])) {
            valueCellClassName += ' hoverable';
          }
          if (highlightedHeaderCells && Array.isArray(highlightedHeaderCells[rowAttrs[i]]) && highlightedHeaderCells[rowAttrs[i]].includes(r)) {
            valueCellClassName += ' active';
          }
          var rowSpan = rowAttrSpans[rowIdx][i];
          if (rowSpan > 0) {
            var _flatRowKey = (0, _Utilities.flatKey)(rowKey.slice(0, i + 1));
            var colSpan = 1 + (i === rowAttrs.length - 1 ? colIncrSpan : 0);
            var needRowToggle = opts.subtotals && rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;
            var onArrowClick = needRowToggle ? _this8.toggleRowKey(_flatRowKey) : null;

            var headerCellFormattedValue = dateFormatters && dateFormatters[rowAttrs[i]] ? dateFormatters[rowAttrs[i]](r) : r;
            return _react2.default.createElement(
              'th',
              {
                key: 'rowKeyLabel-' + i,
                className: valueCellClassName,
                rowSpan: rowSpan,
                colSpan: colSpan,
                onClick: _this8.clickHeaderHandler(pivotData, rowKey, _this8.props.rows, i, _this8.props.tableOptions.clickRowHeaderCallback)
              },
              displayHeaderCell(needRowToggle, _this8.state.collapsedRows[_flatRowKey] ? arrowCollapsed : arrowExpanded, onArrowClick, headerCellFormattedValue, namesMapping)
            );
          }
          return null;
        });

        var attrValuePaddingCell = rowKey.length < rowAttrs.length ? _react2.default.createElement(
          'th',
          {
            className: 'pvtRowLabel pvtSubtotalLabel',
            key: 'rowKeyBuffer',
            colSpan: rowAttrs.length - rowKey.length + colIncrSpan,
            rowSpan: 1,
            onClick: this.clickHeaderHandler(pivotData, rowKey, this.props.rows, rowKey.length, this.props.tableOptions.clickRowHeaderCallback, true)
          },
          'Subtotal'
        ) : null;

        var rowClickHandlers = cellCallbacks[flatRowKey] || {};
        var valueCells = visibleColKeys.map(function (colKey) {
          var flatColKey = (0, _Utilities.flatKey)(colKey);
          var agg = pivotData.getAggregator(rowKey, colKey);
          var aggValue = agg.value();
          var backgroundColor = void 0;
          var keys = [].concat(_toConsumableArray(rowKey), _toConsumableArray(colKey));
          if (cellColorFormatters) {
            Object.values(cellColorFormatters).forEach(function (cellColorFormatter) {
              if (Array.isArray(cellColorFormatter)) {
                var _loop = function _loop(key) {
                  cellColorFormatter.filter(function (formatter) {
                    return formatter.column === key;
                  }).forEach(function (formatter) {
                    var formatterResult = formatter.getColorFromValue(aggValue);
                    if (formatterResult) {
                      backgroundColor = formatterResult;
                    }
                  });
                  if (backgroundColor) {
                    return 'break';
                  }
                };

                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                  for (var _iterator5 = keys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var key = _step5.value;

                    var _ret = _loop(key);

                    if (_ret === 'break') break;
                  }
                } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                      _iterator5.return();
                    }
                  } finally {
                    if (_didIteratorError5) {
                      throw _iteratorError5;
                    }
                  }
                }
              }
            });
          }

          var style = Object.assign({}, agg.isSubtotal ? { fontWeight: 'bold' } : valueCellColors(rowKey, colKey, aggValue), !agg.isSubtotal ? { backgroundColor: backgroundColor } : {}, cellStyle);

          return _react2.default.createElement(
            'td',
            {
              className: 'pvtVal',
              key: 'pvtVal-' + flatColKey,
              onClick: rowClickHandlers[flatColKey],
              style: style
            },
            agg.isSubtotal ? agg.format(aggValue) : valueCellBar(rowKey, colKey, aggValue, agg.format(aggValue))
          );
        });

        var totalCell = null;
        if (rowTotals) {
          var agg = pivotData.getAggregator(rowKey, []);
          var aggValue = agg.value();
          totalCell = _react2.default.createElement(
            'td',
            {
              key: 'total',
              className: 'pvtTotal',
              onClick: rowTotalCallbacks[flatRowKey],
              style: cellStyle
            },
            agg.format(aggValue)
          );
        }

        var rowCells = [].concat(_toConsumableArray(attrValueCells), [attrValuePaddingCell], _toConsumableArray(valueCells), [totalCell]);

        return _react2.default.createElement(
          'tr',
          { key: 'keyRow-' + flatRowKey },
          rowCells
        );
      }
    }, {
      key: 'renderTotalsRow',
      value: function renderTotalsRow(pivotSettings) {
        // Render the final totals rows that has the totals for all the columns.

        var rowAttrs = pivotSettings.rowAttrs,
            colAttrs = pivotSettings.colAttrs,
            visibleColKeys = pivotSettings.visibleColKeys,
            rowTotals = pivotSettings.rowTotals,
            pivotData = pivotSettings.pivotData,
            cellStyle = pivotSettings.cellStyle,
            colTotalCallbacks = pivotSettings.colTotalCallbacks,
            grandTotalCallback = pivotSettings.grandTotalCallback;


        var totalLabelCell = _react2.default.createElement(
          'th',
          {
            key: 'label',
            className: 'pvtTotalLabel pvtRowTotalLabel',
            colSpan: rowAttrs.length + Math.min(colAttrs.length, 1),
            onClick: this.clickHeaderHandler(pivotData, [], this.props.rows, 0, this.props.tableOptions.clickRowHeaderCallback, false, true)
          },
          'Total (' + this.props.aggregatorName + ')'
        );

        var totalValueStyle = Object.assign({}, cellStyle, {
          padding: '5px'
        });
        var totalValueCells = visibleColKeys.map(function (colKey) {
          var flatColKey = (0, _Utilities.flatKey)(colKey);
          var agg = pivotData.getAggregator([], colKey);
          var aggValue = agg.value();

          return _react2.default.createElement(
            'td',
            {
              className: 'pvtTotal pvtRowTotal',
              key: 'total-' + flatColKey,
              onClick: colTotalCallbacks[flatColKey],
              style: totalValueStyle
            },
            agg.format(aggValue)
          );
        });

        var grandTotalCell = null;
        if (rowTotals) {
          var agg = pivotData.getAggregator([], []);
          var aggValue = agg.value();
          grandTotalCell = _react2.default.createElement(
            'td',
            {
              key: 'total',
              className: 'pvtGrandTotal pvtRowTotal',
              onClick: grandTotalCallback
            },
            agg.format(aggValue)
          );
        }

        var totalCells = [totalLabelCell].concat(_toConsumableArray(totalValueCells), [grandTotalCell]);

        return _react2.default.createElement(
          'tr',
          { key: 'total', className: 'pvtRowTotals' },
          totalCells
        );
      }
    }, {
      key: 'visibleKeys',
      value: function visibleKeys(keys, collapsed, numAttrs, subtotalDisplay) {
        return keys.filter(function (key) {
          return (
            // Is the key hidden by one of its parents?
            !key.some(function (k, j) {
              return collapsed[(0, _Utilities.flatKey)(key.slice(0, j))];
            }) && (
            // Leaf key.
            key.length === numAttrs ||
            // Children hidden. Must show total.
            (0, _Utilities.flatKey)(key) in collapsed ||
            // Don't hide totals.
            !subtotalDisplay.hideOnExpand)
          );
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _this9 = this;

        if (this.cachedProps !== this.props) {
          this.cachedProps = this.props;
          this.cachedBasePivotSettings = this.getBasePivotSettings();
        }
        var _cachedBasePivotSetti = this.cachedBasePivotSettings,
            colAttrs = _cachedBasePivotSetti.colAttrs,
            rowAttrs = _cachedBasePivotSetti.rowAttrs,
            rowKeys = _cachedBasePivotSetti.rowKeys,
            colKeys = _cachedBasePivotSetti.colKeys,
            colTotals = _cachedBasePivotSetti.colTotals,
            rowSubtotalDisplay = _cachedBasePivotSetti.rowSubtotalDisplay,
            colSubtotalDisplay = _cachedBasePivotSetti.colSubtotalDisplay;

        // Need to account for exclusions to compute the effective row
        // and column keys.

        var visibleRowKeys = opts.subtotals ? this.visibleKeys(rowKeys, this.state.collapsedRows, rowAttrs.length, rowSubtotalDisplay) : rowKeys;
        var visibleColKeys = opts.subtotals ? this.visibleKeys(colKeys, this.state.collapsedCols, colAttrs.length, colSubtotalDisplay) : colKeys;

        var pivotSettings = Object.assign({
          visibleRowKeys: visibleRowKeys,
          maxRowVisible: Math.max.apply(Math, _toConsumableArray(visibleRowKeys.map(function (k) {
            return k.length;
          }))),
          visibleColKeys: visibleColKeys,
          maxColVisible: Math.max.apply(Math, _toConsumableArray(visibleColKeys.map(function (k) {
            return k.length;
          }))),
          rowAttrSpans: this.calcAttrSpans(visibleRowKeys, rowAttrs.length),
          colAttrSpans: this.calcAttrSpans(visibleColKeys, colAttrs.length)
        }, this.cachedBasePivotSettings);

        return _react2.default.createElement(
          'table',
          { className: 'pvtTable' },
          _react2.default.createElement(
            'thead',
            null,
            colAttrs.map(function (c, j) {
              return _this9.renderColHeaderRow(c, j, pivotSettings);
            }),
            rowAttrs.length !== 0 && this.renderRowHeaderRow(pivotSettings)
          ),
          _react2.default.createElement(
            'tbody',
            null,
            visibleRowKeys.map(function (r, i) {
              return _this9.renderTableRow(r, i, pivotSettings);
            }),
            colTotals && this.renderTotalsRow(pivotSettings)
          )
        );
      }
    }], [{
      key: 'heatmapMappers',
      value: function heatmapMappers(pivotData, colorScaleGenerator, colTotals, rowTotals) {
        var valueCellColors = function valueCellColors() {
          return {};
        };
        var rowTotalColors = function rowTotalColors() {
          return {};
        };
        var colTotalColors = function colTotalColors() {
          return {};
        };
        if (opts.heatmapMode) {
          if (colTotals) {
            var colTotalValues = Object.values(pivotData.colTotals).map(function (a) {
              return a.value();
            });
            colTotalColors = colorScaleGenerator(colTotalValues);
          }
          if (rowTotals) {
            var rowTotalValues = Object.values(pivotData.rowTotals).map(function (a) {
              return a.value();
            });
            rowTotalColors = colorScaleGenerator(rowTotalValues);
          }
          if (opts.heatmapMode === 'full') {
            var allValues = [];
            Object.values(pivotData.tree).map(function (cd) {
              return Object.values(cd).map(function (a) {
                return !a.isSubtotal && allValues.push(a.value());
              });
            });
            var colorScale = colorScaleGenerator(allValues);
            valueCellColors = function valueCellColors(r, c, v) {
              return colorScale(v);
            };
          } else if (opts.heatmapMode === 'row') {
            var rowColorScales = {};
            Object.entries(pivotData.tree).map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  rk = _ref2[0],
                  cd = _ref2[1];

              var rowValues = Object.values(cd).map(function (a) {
                return !a.isSubtotal && a.value();
              });
              rowColorScales[rk] = colorScaleGenerator(rowValues);
            });
            valueCellColors = function valueCellColors(r, c, v) {
              return rowColorScales[(0, _Utilities.flatKey)(r)](v);
            };
          } else if (opts.heatmapMode === 'col') {
            var colColorScales = {};
            var colValues = {};
            Object.values(pivotData.tree).map(function (cd) {
              return Object.entries(cd).map(function (_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2),
                    ck = _ref4[0],
                    a = _ref4[1];

                if (!(ck in colValues)) {
                  colValues[ck] = [];
                }
                if (!a.isSubtotal) {
                  colValues[ck].push(a.value());
                }
              });
            });
            for (var k in colValues) {
              colColorScales[k] = colorScaleGenerator(colValues[k]);
            }
            valueCellColors = function valueCellColors(r, c, v) {
              return colColorScales[(0, _Utilities.flatKey)(c)](v);
            };
          }
        }
        return { valueCellColors: valueCellColors, rowTotalColors: rowTotalColors, colTotalColors: colTotalColors };
      }
    }, {
      key: 'barchartMapper',
      value: function barchartMapper(pivotData, barScaleGenerator, colTotals, rowTotals) {
        var cellStyle = {};
        var valueCellBar = function valueCellBar(r, c, v, t) {
          return t;
        };
        var rowTotalBar = function rowTotalBar(v, t) {
          return t;
        };
        var colTotalBar = function colTotalBar(v, t) {
          return t;
        };

        if (opts.barchartMode) {
          cellStyle = {
            textAlign: 'center',
            padding: 0,
            paddingTop: '5px',
            height: '60px'
          };
          if (colTotals) {
            var colTotalValues = Object.values(pivotData.colTotals).filter(function (a) {
              return !a.isSubtotal;
            }).map(function (a) {
              return a.value();
            });
            colTotalBar = barScaleGenerator(colTotalValues);
          }
          if (rowTotals) {
            var rowTotalValues = Object.values(pivotData.rowTotals).filter(function (a) {
              return !a.isSubtotal;
            }).map(function (a) {
              return a.value();
            });
            rowTotalBar = barScaleGenerator(rowTotalValues);
          }
          if (opts.barchartMode === 'full') {
            var allValues = [];
            Object.values(pivotData.tree).map(function (cd) {
              return Object.values(cd).map(function (a) {
                return !a.isSubtotal && allValues.push(a.value());
              });
            });
            var barScales = barScaleGenerator(allValues);
            valueCellBar = function valueCellBar(r, c, v, t) {
              return barScales(v, t);
            };
          } else if (opts.barchartMode === 'row') {
            var rowBarScales = {};
            Object.entries(pivotData.tree).map(function (_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2),
                  rk = _ref6[0],
                  cd = _ref6[1];

              var rowValues = Object.values(cd).map(function (a) {
                return !a.isSubtotal && a.value();
              });
              rowBarScales[rk] = barScaleGenerator(rowValues);
            });
            valueCellBar = function valueCellBar(r, c, v, t) {
              return rowBarScales[(0, _Utilities.flatKey)(r)](v, t);
            };
          } else if (opts.barchartMode === 'col') {
            var colBarScales = {};
            var colValues = {};
            Object.values(pivotData.tree).map(function (cd) {
              return Object.entries(cd).map(function (_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2),
                    ck = _ref8[0],
                    a = _ref8[1];

                if (!(ck in colValues)) {
                  colValues[ck] = [];
                }
                if (!a.isSubtotal) {
                  colValues[ck].push(a.value());
                }
              });
            });
            for (var k in colValues) {
              colBarScales[k] = barScaleGenerator(colValues[k]);
            }
            valueCellBar = function valueCellBar(r, c, v, t) {
              return colBarScales[(0, _Utilities.flatKey)(c)](v, t);
            };
          }
        }
        return { cellStyle: cellStyle, valueCellBar: valueCellBar, rowTotalBar: rowTotalBar, colTotalBar: colTotalBar };
      }
    }]);

    return TableRenderer;
  }(_react2.default.Component);

  TableRenderer.defaultProps = _Utilities.PivotData.defaultProps;
  TableRenderer.propTypes = _Utilities.PivotData.propTypes;
  TableRenderer.defaultProps.tableColorScaleGenerator = redColorScaleGenerator;
  TableRenderer.defaultProps.barScaleGenerator = defaultBarchartScaleGenerator;
  TableRenderer.defaultProps.tableOptions = {};
  TableRenderer.propTypes.tableColorScaleGenerator = _propTypes2.default.func;
  TableRenderer.propTypes.tableOptions = _propTypes2.default.object;
  return TableRenderer;
}

var TSVExportRenderer = function (_React$PureComponent) {
  _inherits(TSVExportRenderer, _React$PureComponent);

  function TSVExportRenderer() {
    _classCallCheck(this, TSVExportRenderer);

    return _possibleConstructorReturn(this, (TSVExportRenderer.__proto__ || Object.getPrototypeOf(TSVExportRenderer)).apply(this, arguments));
  }

  _createClass(TSVExportRenderer, [{
    key: 'render',
    value: function render() {
      var pivotData = new _Utilities.PivotData(this.props);
      var rowKeys = pivotData.getRowKeys();
      var colKeys = pivotData.getColKeys();
      if (rowKeys.length === 0) {
        rowKeys.push([]);
      }
      if (colKeys.length === 0) {
        colKeys.push([]);
      }

      var headerRow = pivotData.props.rows.map(function (r) {
        return r;
      });
      if (colKeys.length === 1 && colKeys[0].length === 0) {
        headerRow.push(this.props.aggregatorName);
      } else {
        colKeys.map(function (c) {
          return headerRow.push(c.join('-'));
        });
      }

      var result = rowKeys.map(function (r) {
        var row = r.map(function (x) {
          return x;
        });
        colKeys.map(function (c) {
          var v = pivotData.getAggregator(r, c).value();
          row.push(v ? v : '');
        });
        return row;
      });

      result.unshift(headerRow);

      return _react2.default.createElement('textarea', {
        value: result.map(function (r) {
          return r.join('\t');
        }).join('\n'),
        style: { width: window.innerWidth / 2, height: window.innerHeight / 2 },
        readOnly: true
      });
    }
  }]);

  return TSVExportRenderer;
}(_react2.default.PureComponent);

TSVExportRenderer.defaultProps = _Utilities.PivotData.defaultProps;
TSVExportRenderer.propTypes = _Utilities.PivotData.propTypes;

exports.default = {
  Table: makeRenderer(),
  'Table Heatmap': makeRenderer({ heatmapMode: 'full' }),
  'Table Col Heatmap': makeRenderer({ heatmapMode: 'col' }),
  'Table Row Heatmap': makeRenderer({ heatmapMode: 'row' }),
  'Table Barchart': makeRenderer({ barchartMode: 'full' }),
  'Table Col Barchart': makeRenderer({ barchartMode: 'col' }),
  'Table Row Barchart': makeRenderer({ barchartMode: 'row' }),
  'Table With Subtotal': makeRenderer({ subtotals: true }),
  'Table With Subtotal Heatmap': makeRenderer({
    heatmapMode: 'full',
    subtotals: true
  }),
  'Table With Subtotal Col Heatmap': makeRenderer({
    heatmapMode: 'col',
    subtotals: true
  }),
  'Table With Subtotal Row Heatmap': makeRenderer({
    heatmapMode: 'row',
    subtotals: true
  }),
  'Table With Subtotal Barchart': makeRenderer({
    barchartMode: 'full',
    subtotals: true
  }),
  'Table With Subtotal Col Barchart': makeRenderer({
    barchartMode: 'col',
    subtotals: true
  }),
  'Table With Subtotal Row Barchart': makeRenderer({
    barchartMode: 'row',
    subtotals: true
  }),
  'Exportable TSV': TSVExportRenderer
};
module.exports = exports.default;
//# sourceMappingURL=TableRenderers.js.map