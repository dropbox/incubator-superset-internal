{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Popover from 'src/components/Popover';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst sectionContainerId = 'controlSections';\nexport const getSectionContainerElement = () => {var _document$getElementB;return (_document$getElementB = document.getElementById(sectionContainerId)) == null ? void 0 : _document$getElementB.lastElementChild;};\nconst getElementYVisibilityRatioOnContainer = (node) => {var _window, _node$getBoundingClie;\n  const containerHeight = (_window = window) == null ? void 0 : _window.innerHeight;\n  const nodePositionInViewport = node == null ? void 0 : (_node$getBoundingClie = node.getBoundingClientRect()) == null ? void 0 : _node$getBoundingClie.top;\n  if (!containerHeight || !nodePositionInViewport) {\n    return 0;\n  }\n  return nodePositionInViewport / containerHeight;\n};\nconst ControlPopover = (_ref) => {let { getPopupContainer, getVisibilityRatio = getElementYVisibilityRatioOnContainer, visible: visibleProp, destroyTooltipOnHide = false, ...props } = _ref;\n  const triggerElementRef = useRef();\n  const [visible, setVisible] = useState(visibleProp === undefined ? props.defaultVisible : visibleProp);\n  const [placement, setPlacement] = React.useState('right');\n  const calculatePlacement = useCallback(() => {\n    const visibilityRatio = getVisibilityRatio(triggerElementRef.current);\n    if (visibilityRatio < 0.35 && placement !== 'rightTop') {\n      setPlacement('rightTop');\n    } else\n    if (visibilityRatio > 0.65 && placement !== 'rightBottom') {\n      setPlacement('rightBottom');\n    } else\n    {\n      setPlacement('right');\n    }\n  }, [getVisibilityRatio]);\n  const changeContainerScrollStatus = useCallback((visible) => {\n    const element = getSectionContainerElement();\n    if (element) {\n      element.style.setProperty('overflow-y', visible ? 'hidden' : 'auto', 'important');\n    }\n  }, [calculatePlacement]);\n  const handleGetPopupContainer = useCallback((triggerNode) => {\n    triggerElementRef.current = triggerNode;\n    return (getPopupContainer == null ? void 0 : getPopupContainer(triggerNode)) || document.body;\n  }, [calculatePlacement, getPopupContainer]);\n  const handleOnVisibleChange = useCallback((visible) => {\n    if (visible === undefined) {\n      changeContainerScrollStatus(visible);\n    }\n    setVisible(!!visible);\n    props.onVisibleChange == null ? void 0 : props.onVisibleChange(!!visible);\n  }, [props, changeContainerScrollStatus]);\n  const handleDocumentKeyDownListener = useCallback((event) => {\n    if (event.key === 'Escape') {\n      setVisible(false);\n      props.onVisibleChange == null ? void 0 : props.onVisibleChange(false);\n    }\n  }, [props]);\n  useEffect(() => {\n    if (visibleProp !== undefined) {\n      setVisible(!!visibleProp);\n    }\n  }, [visibleProp]);\n  useEffect(() => {\n    if (visible !== undefined) {\n      changeContainerScrollStatus(visible);\n    }\n  }, [visible, changeContainerScrollStatus]);\n  useEffect(() => {\n    if (visible) {\n      document.addEventListener('keydown', handleDocumentKeyDownListener);\n    }\n    return () => {\n      document.removeEventListener('keydown', handleDocumentKeyDownListener);\n    };\n  }, [handleDocumentKeyDownListener, visible]);\n  useEffect(() => {\n    if (visible) {\n      calculatePlacement();\n    }\n  }, [visible, calculatePlacement]);\n  return ___EmotionJSX(Popover, _extends({}, props, { visible: visible, arrowPointAtCenter: true, placement: placement, onVisibleChange: handleOnVisibleChange, getPopupContainer: handleGetPopupContainer, destroyTooltipOnHide: destroyTooltipOnHide }));\n};\nexport default ControlPopover;","map":{"version":3,"mappings":"+DAAA;;;;;;;;;;;;;;;;;;AAkBA,OAAOA,KAAP,IAAgBC,WAAhB,EAA6BC,MAA7B,EAAqCC,SAArC,EAAgDC,QAAhD,QAAgE,OAAhE;AAEA,OAAOC,OAAP,MAGO,wBAHP,C;AAKA,MAAMC,kBAAkB,GAAG,iBAA3B;AACA,OAAO,MAAMC,0BAA0B,GAAG,iEACxCC,QAAQ,CAACC,cAAT,CAAwBH,kBAAxB,CADwC,qBACxC,sBAA6CI,gBADL,EAAnC;AAGP,MAAMC,qCAAqC,GAAG,CAACC,IAAD,KAAsB;EAClE,MAAMC,eAAe,cAAGC,MAAH,qBAAG,QAAQC,WAAhC;EACA,MAAMC,sBAAsB,GAAGJ,IAAH,6CAAGA,IAAI,CAAEK,qBAAN,EAAH,qBAAG,sBAA+BC,GAA9D;EACA,IAAI,CAACL,eAAD,IAAoB,CAACG,sBAAzB,EAAiD;IAC/C,OAAO,CAAP;EACD;EAED,OAAOA,sBAAsB,GAAGH,eAAhC;AACD,CARD;AAcA,MAAMM,cAAc,GAA2B,UAM1C,KAN2C,EAC9CC,iBAD8C,EAE9CC,kBAAkB,GAAGV,qCAFyB,EAG9CW,OAAO,EAAEC,WAHqC,EAI9CC,oBAAoB,GAAG,KAJuB,EAK9C,GAAGC,KAL2C,EAM3C;EACH,MAAMC,iBAAiB,GAAGxB,MAAM,EAAhC;EAEA,MAAM,CAACoB,OAAD,EAAUK,UAAV,IAAwBvB,QAAQ,CACpCmB,WAAW,KAAKK,SAAhB,GAA4BH,KAAK,CAACI,cAAlC,GAAmDN,WADf,CAAtC;EAGA,MAAM,CAACO,SAAD,EAAYC,YAAZ,IAA4B/B,KAAK,CAACI,QAAN,CAAiC,OAAjC,CAAlC;EAEA,MAAM4B,kBAAkB,GAAG/B,WAAW,CAAC,MAAK;IAC1C,MAAMgC,eAAe,GAAGZ,kBAAkB,CAACK,iBAAiB,CAACQ,OAAnB,CAA1C;IACA,IAAID,eAAe,GAAG,IAAlB,IAA0BH,SAAS,KAAK,UAA5C,EAAwD;MACtDC,YAAY,CAAC,UAAD,CAAZ;IACD,CAFD;IAEO,IAAIE,eAAe,GAAG,IAAlB,IAA0BH,SAAS,KAAK,aAA5C,EAA2D;MAChEC,YAAY,CAAC,aAAD,CAAZ;IACD,CAFM;IAEA;MACLA,YAAY,CAAC,OAAD,CAAZ;IACD;EACF,CATqC,EASnC,CAACV,kBAAD,CATmC,CAAtC;EAWA,MAAMc,2BAA2B,GAAGlC,WAAW,CAC7C,QAAO,KAAG;IACR,MAAMmC,OAAO,GAAG7B,0BAA0B,EAA1C;IACA,IAAI6B,OAAJ,EAAa;MACXA,OAAO,CAACC,KAAR,CAAcC,WAAd,CACE,YADF,EAEEhB,OAAO,GAAG,QAAH,GAAc,MAFvB,EAGE,WAHF;IAKD;EACF,CAV4C,EAW7C,CAACU,kBAAD,CAX6C,CAA/C;EAcA,MAAMO,uBAAuB,GAAGtC,WAAW,CACzC,CAACuC,WAAD,KAA6B;IAC3Bd,iBAAiB,CAACQ,OAAlB,GAA4BM,WAA5B;IAEA,OAAO,kBAAiB,QAAjB,6BAAiB,CAAGA,WAAH,CAAjB,KAAoChC,QAAQ,CAACiC,IAApD;EACD,CALwC,EAMzC,CAACT,kBAAD,EAAqBZ,iBAArB,CANyC,CAA3C;EASA,MAAMsB,qBAAqB,GAAGzC,WAAW,CACvC,CAACqB,OAAD,KAAiC;IAC/B,IAAIA,OAAO,KAAKM,SAAhB,EAA2B;MACzBO,2BAA2B,CAACb,OAAD,CAA3B;IACD;IAEDK,UAAU,CAAC,CAAC,CAACL,OAAH,CAAV;IACAG,KAAK,CAACkB,eAAN,yBAAK,CAACA,eAAN,CAAwB,CAAC,CAACrB,OAA1B;EACD,CARsC,EASvC,CAACG,KAAD,EAAQU,2BAAR,CATuC,CAAzC;EAYA,MAAMS,6BAA6B,GAAG3C,WAAW,CAC/C,CAAC4C,KAAD,KAAyB;IACvB,IAAIA,KAAK,CAACC,GAAN,KAAc,QAAlB,EAA4B;MAC1BnB,UAAU,CAAC,KAAD,CAAV;MACAF,KAAK,CAACkB,eAAN,yBAAK,CAACA,eAAN,CAAwB,KAAxB;IACD;EACF,CAN8C,EAO/C,CAAClB,KAAD,CAP+C,CAAjD;EAUAtB,SAAS,CAAC,MAAK;IACb,IAAIoB,WAAW,KAAKK,SAApB,EAA+B;MAC7BD,UAAU,CAAC,CAAC,CAACJ,WAAH,CAAV;IACD;EACF,CAJQ,EAIN,CAACA,WAAD,CAJM,CAAT;EAMApB,SAAS,CAAC,MAAK;IACb,IAAImB,OAAO,KAAKM,SAAhB,EAA2B;MACzBO,2BAA2B,CAACb,OAAD,CAA3B;IACD;EACF,CAJQ,EAIN,CAACA,OAAD,EAAUa,2BAAV,CAJM,CAAT;EAMAhC,SAAS,CAAC,MAAK;IACb,IAAImB,OAAJ,EAAa;MACXd,QAAQ,CAACuC,gBAAT,CAA0B,SAA1B,EAAqCH,6BAArC;IACD;IAED,OAAO,MAAK;MACVpC,QAAQ,CAACwC,mBAAT,CAA6B,SAA7B,EAAwCJ,6BAAxC;IACD,CAFD;EAGD,CARQ,EAQN,CAACA,6BAAD,EAAgCtB,OAAhC,CARM,CAAT;EAUAnB,SAAS,CAAC,MAAK;IACb,IAAImB,OAAJ,EAAa;MACXU,kBAAkB;IACnB;EACF,CAJQ,EAIN,CAACV,OAAD,EAAUU,kBAAV,CAJM,CAAT;EAMA,OACE,cAAC,OAAD,eACMP,KADN,IAEE,OAAO,EAAEH,OAFX,EAGE,kBAAkB,MAHpB,EAIE,SAAS,EAAEQ,SAJb,EAKE,eAAe,EAAEY,qBALnB,EAME,iBAAiB,EAAEH,uBANrB,EAOE,oBAAoB,EAAEf,oBAPxB,IADF;AAWD,CA7GD;AA+GA,eAAeL,cAAf","names":["React","useCallback","useRef","useEffect","useState","Popover","sectionContainerId","getSectionContainerElement","document","getElementById","lastElementChild","getElementYVisibilityRatioOnContainer","node","containerHeight","window","innerHeight","nodePositionInViewport","getBoundingClientRect","top","ControlPopover","getPopupContainer","getVisibilityRatio","visible","visibleProp","destroyTooltipOnHide","props","triggerElementRef","setVisible","undefined","defaultVisible","placement","setPlacement","calculatePlacement","visibilityRatio","current","changeContainerScrollStatus","element","style","setProperty","handleGetPopupContainer","triggerNode","body","handleOnVisibleChange","onVisibleChange","handleDocumentKeyDownListener","event","key","addEventListener","removeEventListener"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/explore/components/controls/ControlPopover/ControlPopover.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useRef, useEffect, useState } from 'react';\n\nimport Popover, {\n  PopoverProps as BasePopoverProps,\n  TooltipPlacement,\n} from 'src/components/Popover';\n\nconst sectionContainerId = 'controlSections';\nexport const getSectionContainerElement = () =>\n  document.getElementById(sectionContainerId)?.lastElementChild as HTMLElement;\n\nconst getElementYVisibilityRatioOnContainer = (node: HTMLElement) => {\n  const containerHeight = window?.innerHeight;\n  const nodePositionInViewport = node?.getBoundingClientRect()?.top;\n  if (!containerHeight || !nodePositionInViewport) {\n    return 0;\n  }\n\n  return nodePositionInViewport / containerHeight;\n};\n\nexport type PopoverProps = BasePopoverProps & {\n  getVisibilityRatio?: typeof getElementYVisibilityRatioOnContainer;\n};\n\nconst ControlPopover: React.FC<PopoverProps> = ({\n  getPopupContainer,\n  getVisibilityRatio = getElementYVisibilityRatioOnContainer,\n  visible: visibleProp,\n  destroyTooltipOnHide = false,\n  ...props\n}) => {\n  const triggerElementRef = useRef<HTMLElement>();\n\n  const [visible, setVisible] = useState(\n    visibleProp === undefined ? props.defaultVisible : visibleProp,\n  );\n  const [placement, setPlacement] = React.useState<TooltipPlacement>('right');\n\n  const calculatePlacement = useCallback(() => {\n    const visibilityRatio = getVisibilityRatio(triggerElementRef.current!);\n    if (visibilityRatio < 0.35 && placement !== 'rightTop') {\n      setPlacement('rightTop');\n    } else if (visibilityRatio > 0.65 && placement !== 'rightBottom') {\n      setPlacement('rightBottom');\n    } else {\n      setPlacement('right');\n    }\n  }, [getVisibilityRatio]);\n\n  const changeContainerScrollStatus = useCallback(\n    visible => {\n      const element = getSectionContainerElement();\n      if (element) {\n        element.style.setProperty(\n          'overflow-y',\n          visible ? 'hidden' : 'auto',\n          'important',\n        );\n      }\n    },\n    [calculatePlacement],\n  );\n\n  const handleGetPopupContainer = useCallback(\n    (triggerNode: HTMLElement) => {\n      triggerElementRef.current = triggerNode;\n\n      return getPopupContainer?.(triggerNode) || document.body;\n    },\n    [calculatePlacement, getPopupContainer],\n  );\n\n  const handleOnVisibleChange = useCallback(\n    (visible: boolean | undefined) => {\n      if (visible === undefined) {\n        changeContainerScrollStatus(visible);\n      }\n\n      setVisible(!!visible);\n      props.onVisibleChange?.(!!visible);\n    },\n    [props, changeContainerScrollStatus],\n  );\n\n  const handleDocumentKeyDownListener = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        setVisible(false);\n        props.onVisibleChange?.(false);\n      }\n    },\n    [props],\n  );\n\n  useEffect(() => {\n    if (visibleProp !== undefined) {\n      setVisible(!!visibleProp);\n    }\n  }, [visibleProp]);\n\n  useEffect(() => {\n    if (visible !== undefined) {\n      changeContainerScrollStatus(visible);\n    }\n  }, [visible, changeContainerScrollStatus]);\n\n  useEffect(() => {\n    if (visible) {\n      document.addEventListener('keydown', handleDocumentKeyDownListener);\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleDocumentKeyDownListener);\n    };\n  }, [handleDocumentKeyDownListener, visible]);\n\n  useEffect(() => {\n    if (visible) {\n      calculatePlacement();\n    }\n  }, [visible, calculatePlacement]);\n\n  return (\n    <Popover\n      {...props}\n      visible={visible}\n      arrowPointAtCenter\n      placement={placement}\n      onVisibleChange={handleOnVisibleChange}\n      getPopupContainer={handleGetPopupContainer}\n      destroyTooltipOnHide={destroyTooltipOnHide}\n    />\n  );\n};\n\nexport default ControlPopover;\n"]},"metadata":{},"sourceType":"module"}