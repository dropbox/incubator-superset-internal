{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\nconst schemaApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    schemas: builder.query({\n      providesTags: [{ type: 'Schemas', id: 'LIST' }],\n      query: (_ref) => {let { dbId, forceRefresh } = _ref;return {\n          endpoint: `/api/v1/database/${dbId}/schemas/`,\n          // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n          urlParams: {\n            force: forceRefresh },\n\n          transformResponse: (_ref2) => {let { json } = _ref2;return json.result.map((value) => ({\n              value,\n              label: value,\n              title: value }));} };},\n\n\n      serializeQueryArgs: (_ref3) => {let { queryArgs: { dbId } } = _ref3;return {\n          dbId };} }) }) });\n\n\n\n\nexport const { useLazySchemasQuery, useSchemasQuery } = schemaApi;\nconst EMPTY_SCHEMAS = [];\nexport function useSchemas(options) {\n  const isMountedRef = useRef(false);\n  const { dbId, onSuccess, onError } = options || {};\n  const [trigger] = useLazySchemasQuery();\n  const result = useSchemasQuery({ dbId, forceRefresh: false }, {\n    skip: !dbId });\n\n  const handleOnSuccess = useEffectEvent((data, isRefetched) => {\n    onSuccess == null ? void 0 : onSuccess(data, isRefetched);\n  });\n  const handleOnError = useEffectEvent(() => {\n    onError == null ? void 0 : onError();\n  });\n  const refetch = useCallback(() => {\n    if (dbId) {\n      trigger({ dbId, forceRefresh: true }).then((_ref4) => {let { isSuccess, isError, data } = _ref4;\n        if (isSuccess) {\n          handleOnSuccess(data || EMPTY_SCHEMAS, true);\n        }\n        if (isError) {\n          handleOnError();\n        }\n      });\n    }\n  }, [dbId, handleOnError, handleOnSuccess, trigger]);\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, data, originalArgs } = result;\n      if (!(originalArgs != null && originalArgs.forceRefresh) && requestId && !isFetching) {\n        if (isSuccess) {\n          handleOnSuccess(data || EMPTY_SCHEMAS, false);\n        }\n        if (isError) {\n          handleOnError();\n        }\n      }\n    } else\n    {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n  return {\n    ...result,\n    refetch };\n\n}__signature__(useSchemas, \"useRef{isMountedRef}\\nuseLazySchemasQuery{[trigger]}\\nuseSchemasQuery{result}\\nuseEffectEvent{handleOnSuccess}\\nuseEffectEvent{handleOnError}\\nuseCallback{refetch}\\nuseEffect{}\", () => [useLazySchemasQuery, useSchemasQuery, useEffectEvent, useEffectEvent]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(schemaApi, \"schemaApi\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts\");reactHotLoader.register(useLazySchemasQuery, \"useLazySchemasQuery\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts\");reactHotLoader.register(useSchemasQuery, \"useSchemasQuery\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts\");reactHotLoader.register(EMPTY_SCHEMAS, \"EMPTY_SCHEMAS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts\");reactHotLoader.register(useSchemas, \"useSchemas\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useEffectEvent","api","schemaApi","injectEndpoints","endpoints","schemas","builder","query","providesTags","type","id","dbId","forceRefresh","endpoint","urlParams","force","transformResponse","json","result","map","value","label","title","serializeQueryArgs","queryArgs","useLazySchemasQuery","useSchemasQuery","EMPTY_SCHEMAS","useSchemas","options","isMountedRef","onSuccess","onError","trigger","skip","handleOnSuccess","data","isRefetched","handleOnError","refetch","then","isSuccess","isError","current","requestId","isFetching","originalArgs"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/schemas.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api, JsonResponse } from './queryApi';\n\nexport type SchemaOption = {\n  value: string;\n  label: string;\n  title: string;\n};\n\nexport type FetchSchemasQueryParams = {\n  dbId?: string | number;\n  forceRefresh: boolean;\n  onSuccess?: (data: SchemaOption[], isRefetched: boolean) => void;\n  onError?: () => void;\n};\n\ntype Params = Omit<FetchSchemasQueryParams, 'forceRefresh'>;\n\nconst schemaApi = api.injectEndpoints({\n  endpoints: builder => ({\n    schemas: builder.query<SchemaOption[], FetchSchemasQueryParams>({\n      providesTags: [{ type: 'Schemas', id: 'LIST' }],\n      query: ({ dbId, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId}/schemas/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n        },\n        transformResponse: ({ json }: JsonResponse) =>\n          json.result.map((value: string) => ({\n            value,\n            label: value,\n            title: value,\n          })),\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId } }) => ({\n        dbId,\n      }),\n    }),\n  }),\n});\n\nexport const { useLazySchemasQuery, useSchemasQuery } = schemaApi;\n\nconst EMPTY_SCHEMAS = [] as SchemaOption[];\n\nexport function useSchemas(options: Params) {\n  const isMountedRef = useRef(false);\n  const { dbId, onSuccess, onError } = options || {};\n  const [trigger] = useLazySchemasQuery();\n  const result = useSchemasQuery(\n    { dbId, forceRefresh: false },\n    {\n      skip: !dbId,\n    },\n  );\n\n  const handleOnSuccess = useEffectEvent(\n    (data: SchemaOption[], isRefetched: boolean) => {\n      onSuccess?.(data, isRefetched);\n    },\n  );\n\n  const handleOnError = useEffectEvent(() => {\n    onError?.();\n  });\n\n  const refetch = useCallback(() => {\n    if (dbId) {\n      trigger({ dbId, forceRefresh: true }).then(\n        ({ isSuccess, isError, data }) => {\n          if (isSuccess) {\n            handleOnSuccess(data || EMPTY_SCHEMAS, true);\n          }\n          if (isError) {\n            handleOnError();\n          }\n        },\n      );\n    }\n  }, [dbId, handleOnError, handleOnSuccess, trigger]);\n\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, data, originalArgs } =\n        result;\n      if (!originalArgs?.forceRefresh && requestId && !isFetching) {\n        if (isSuccess) {\n          handleOnSuccess(data || EMPTY_SCHEMAS, false);\n        }\n        if (isError) {\n          handleOnError();\n        }\n      }\n    } else {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n\n  return {\n    ...result,\n    refetch,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}