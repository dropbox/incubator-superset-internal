{"ast":null,"code":"import _invert from \"lodash/invert\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CategoricalColorNamespace, GenericDataType, getNumberFormatter, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isTimeseriesAnnotationLayer, getXAxisLabel, isPhysicalColumn, isDefined, ensureIsArray, buildCustomFormatters, getCustomFormatter } from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { DEFAULT_FORM_DATA } from './types';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport { getOverMaxHiddenFormatter, dedupSeries, extractSeries, getAxisType, getColtypesMapping, getLegendProps, extractDataTotalValues, extractShowValueIndexes } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding, getTooltipTimeFormatter, getXAxisFormatter, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from '../Timeseries/transformers';\nimport { TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getYAxisFormatter } from '../utils/getYAxisFormatter';\nconst getFormatter = (customFormatters, defaultFormatter, metrics, formatterKey, forcePercentFormat) => {var _getCustomFormatter;\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (_getCustomFormatter = getCustomFormatter(customFormatters, metrics, formatterKey)) != null ? _getCustomFormatter :\n  defaultFormatter;\n};\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, formData, queriesData, hooks, filterState, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { label_map: labelMap } = queriesData[0];\n  const { label_map: labelMapB } = queriesData[1];\n  const data1 = queriesData[0].data || [];\n  const data2 = queriesData[1].data || [];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]) };\n\n  const { area, areaB, annotationLayers, colorScheme, contributionMode, legendOrientation, legendType, logAxis, logAxisSecondary, markerEnabled, markerEnabledB, markerSize, markerSizeB, opacity, opacityB, minorSplitLine, seriesType, seriesTypeB, showLegend, showValue, showValueB, stack, stackB, truncateYAxis, tooltipTimeFormat, yAxisFormat, yAxisFormatSecondary, xAxisTimeFormat, yAxisBounds, yAxisBoundsSecondary, yAxisIndex, yAxisIndexB, yAxisTitleSecondary, zoomable, richTooltip, tooltipSortByMetric, xAxisLabelRotation, groupby, groupbyB, xAxis: xAxisOrig, xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId, timeGrainSqla, percentageThreshold, metrics = [], metricsB = [] } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel });\n\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series = [];\n  const formatter = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormat);\n  const formatterSecondary = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormat);\n  const customFormattersSecondary = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormatSecondary);\n  const primarySeries = new Set();\n  const secondarySeries = new Set();\n  const mapSeriesIdToAxis = (seriesOption, index) => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id);\n    } else\n    {\n      primarySeries.add(seriesOption.id);\n    }\n  };\n  rawSeriesA.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndex));\n  rawSeriesB.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndexB));\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack });\n\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack });\n\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedDataA, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel });\n\n  const { totalStackedValues: totalStackedValuesB, thresholdValues: thresholdValuesB } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel });\n\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data1, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data1, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(parseYAxisBound);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeriesA.forEach((entry) => {var _labelMap$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const seriesFormatter = getFormatter(customFormatters, formatter, metrics, (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      showValue,\n      stack: Boolean(stack),\n      yAxisIndex,\n      filterState,\n      seriesKey: entry.name,\n      sliceId,\n      queryIndex: 0,\n      formatter: seriesType === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max,\n        formatter: seriesFormatter }) :\n\n      seriesFormatter,\n      showValueIndexes: showValueIndexesA,\n      totalStackedValues,\n      thresholdValues });\n\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  rawSeriesB.forEach((entry) => {var _labelMapB$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesName = `${inverted[entryName] || entryName} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const seriesFormatter = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, (_labelMapB$seriesName = labelMapB[seriesName]) == null ? void 0 : _labelMapB$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area: areaB,\n      markerEnabled: markerEnabledB,\n      markerSize: markerSizeB,\n      areaOpacity: opacityB,\n      seriesType: seriesTypeB,\n      showValue: showValueB,\n      stack: Boolean(stackB),\n      yAxisIndex: yAxisIndexB,\n      filterState,\n      seriesKey: primarySeries.has(entry.name) ?\n      `${entry.name} (1)` :\n      entry.name,\n      sliceId,\n      queryIndex: 1,\n      formatter: seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: maxSecondary,\n        formatter: seriesFormatter }) :\n\n      seriesFormatter,\n      showValueIndexes: showValueIndexesB,\n      totalStackedValues: totalStackedValuesB,\n      thresholdValues: thresholdValuesB });\n\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (min === undefined)\n    min = 0;\n    if (max === undefined)\n    max = 1;\n    if (minSecondary === undefined)\n    minSecondary = 0;\n    if (maxSecondary === undefined)\n    maxSecondary = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding },\n\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation },\n\n      minInterval: xAxisType === 'time' && timeGrainSqla ?\n      TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n      0 },\n\n    yAxis: [\n    {\n      ...defaultYAxis,\n      type: logAxis ? 'log' : 'value',\n      min,\n      max,\n      minorTick: { show: true },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metrics, !!contributionMode, customFormatters, yAxisFormat) },\n\n      scale: truncateYAxis,\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n      alignTicks },\n\n    {\n      ...defaultYAxis,\n      type: logAxisSecondary ? 'log' : 'value',\n      min: minSecondary,\n      max: maxSecondary,\n      minorTick: { show: true },\n      splitLine: { show: false },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metricsB, !!contributionMode, customFormattersSecondary, yAxisFormatSecondary) },\n\n      scale: truncateYAxis,\n      name: yAxisTitleSecondary,\n      alignTicks }],\n\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const xValue = richTooltip ?\n        params[0].value[0] :\n        params.value[0];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n        const rows = [`${tooltipFormatter(xValue)}`];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue);\n        Object.keys(forecastValues).forEach((key) => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {var _labelMap$key;\n            formatterKey =\n            groupby.length === 0 ? inverted[key] : (_labelMap$key = labelMap[key]) == null ? void 0 : _labelMap$key[0];\n          } else\n          {var _labelMapB$key;\n            formatterKey =\n            groupbyB.length === 0 ? inverted[key] : (_labelMapB$key = labelMapB[key]) == null ? void 0 : _labelMapB$key[0];\n          }\n          const tooltipFormatter = getFormatter(customFormatters, formatter, metrics, formatterKey, !!contributionMode);\n          const tooltipFormatterSecondary = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, formatterKey, !!contributionMode);\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ?\n            tooltipFormatter :\n            tooltipFormatterSecondary });\n\n          const contentStyle = key === focusedSeries ? 'font-weight: 700' : 'opacity: 0.7';\n          rows.push(`<span style=\"${contentStyle}\">${content}</span>`);\n        });\n        return rows.join('<br />');\n      } },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      // @ts-ignore\n      data: rawSeriesA.\n      concat(rawSeriesB).\n      filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n      ForecastSeriesEnum.Observation).\n      map((entry) => entry.name || '').\n      concat(extractAnnotationLabels(annotationLayers, annotationData)) },\n\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom' } } } },\n\n\n\n\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom }] :\n\n\n    [] };\n\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType },\n\n    refs,\n    coltypeMapping };\n\n}","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","GenericDataType","getNumberFormatter","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isTimeseriesAnnotationLayer","getXAxisLabel","isPhysicalColumn","isDefined","ensureIsArray","buildCustomFormatters","getCustomFormatter","getOriginalSeries","DEFAULT_FORM_DATA","EchartsTimeseriesSeriesType","ForecastSeriesEnum","parseYAxisBound","getOverMaxHiddenFormatter","dedupSeries","extractSeries","getAxisType","getColtypesMapping","getLegendProps","extractDataTotalValues","extractShowValueIndexes","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getPadding","getTooltipTimeFormatter","getXAxisFormatter","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","TIMESERIES_CONSTANTS","TIMEGRAIN_TO_TIMESTAMP","getDefaultTooltip","getYAxisFormatter","getFormatter","customFormatters","defaultFormatter","metrics","formatterKey","forcePercentFormat","transformProps","chartProps","width","height","formData","queriesData","hooks","filterState","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","currencyFormats","columnFormats","label_map","labelMap","labelMapB","data1","data","data2","annotationData","coltypeMapping","area","areaB","annotationLayers","colorScheme","contributionMode","legendOrientation","legendType","logAxis","logAxisSecondary","markerEnabled","markerEnabledB","markerSize","markerSizeB","opacity","opacityB","minorSplitLine","seriesType","seriesTypeB","showLegend","showValue","showValueB","stack","stackB","truncateYAxis","tooltipTimeFormat","yAxisFormat","yAxisFormatSecondary","xAxisTimeFormat","yAxisBounds","yAxisBoundsSecondary","yAxisIndex","yAxisIndexB","yAxisTitleSecondary","zoomable","richTooltip","tooltipSortByMetric","xAxisLabelRotation","groupby","groupbyB","xAxis","xAxisOrig","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","timeGrainSqla","percentageThreshold","metricsB","refs","colorScale","getScale","xAxisLabel","rawFormData","x_axis","rebasedDataA","rawSeriesA","fillNeighborValue","undefined","rebasedDataB","rawSeriesB","dataTypes","xAxisDataType","xAxisType","series","formatter","formatterSecondary","customFormattersSecondary","primarySeries","Set","secondarySeries","mapSeriesIdToAxis","seriesOption","index","add","id","forEach","showValueIndexesA","showValueIndexesB","totalStackedValues","thresholdValues","xAxisCol","totalStackedValuesB","thresholdValuesB","Boolean","filter","layer","show","push","min","max","map","minSecondary","maxSecondary","array","time_compare","inverted","entryName","String","entry","name","seriesName","colorScaleKey","seriesFormatter","transformedSeries","areaOpacity","seriesKey","queryIndex","Bar","showValueIndexes","has","tooltipFormatter","TEMPORAL","xAxisFormatter","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","setDataMask","onContextMenu","alignTicks","echartOptions","useUTC","grid","type","nameGap","nameLocation","axisLabel","rotate","minInterval","yAxis","minorTick","scale","splitLine","tooltip","trigger","params","xValue","value","forecastValue","sort","a","b","rows","forecastValues","Object","keys","key","length","tooltipFormatterSecondary","content","contentStyle","join","legend","concat","Observation","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","bottom","zoomBottom","onFocusedSeries","seriesBreakdown","selectedValues","xValueFormatter","label"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  CategoricalColorNamespace,\n  GenericDataType,\n  getNumberFormatter,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isTimeseriesAnnotationLayer,\n  QueryFormData,\n  TimeseriesChartDataResponseResult,\n  TimeseriesDataRecord,\n  getXAxisLabel,\n  isPhysicalColumn,\n  isDefined,\n  ensureIsArray,\n  buildCustomFormatters,\n  ValueFormatter,\n  NumberFormatter,\n  QueryFormMetric,\n  getCustomFormatter,\n} from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport {\n  DEFAULT_FORM_DATA,\n  EchartsMixedTimeseriesFormData,\n  EchartsMixedTimeseriesChartTransformedProps,\n  EchartsMixedTimeseriesProps,\n} from './types';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  Refs,\n} from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport {\n  getOverMaxHiddenFormatter,\n  dedupSeries,\n  extractSeries,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  extractDataTotalValues,\n  extractShowValueIndexes,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getPadding,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from '../Timeseries/transformers';\nimport { TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getYAxisFormatter } from '../utils/getYAxisFormatter';\n\nconst getFormatter = (\n  customFormatters: Record<string, ValueFormatter>,\n  defaultFormatter: NumberFormatter,\n  metrics: QueryFormMetric[],\n  formatterKey: string,\n  forcePercentFormat: boolean,\n) => {\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (\n    getCustomFormatter(customFormatters, metrics, formatterKey) ??\n    defaultFormatter\n  );\n};\n\nexport default function transformProps(\n  chartProps: EchartsMixedTimeseriesProps,\n): EchartsMixedTimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    currencyFormats = {},\n    columnFormats = {},\n  } = datasource;\n  const { label_map: labelMap } =\n    queriesData[0] as TimeseriesChartDataResponseResult;\n  const { label_map: labelMapB } =\n    queriesData[1] as TimeseriesChartDataResponseResult;\n  const data1 = (queriesData[0].data || []) as TimeseriesDataRecord[];\n  const data2 = (queriesData[1].data || []) as TimeseriesDataRecord[];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]),\n  };\n  const {\n    area,\n    areaB,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    legendOrientation,\n    legendType,\n    logAxis,\n    logAxisSecondary,\n    markerEnabled,\n    markerEnabledB,\n    markerSize,\n    markerSizeB,\n    opacity,\n    opacityB,\n    minorSplitLine,\n    seriesType,\n    seriesTypeB,\n    showLegend,\n    showValue,\n    showValueB,\n    stack,\n    stackB,\n    truncateYAxis,\n    tooltipTimeFormat,\n    yAxisFormat,\n    yAxisFormatSecondary,\n    xAxisTimeFormat,\n    yAxisBounds,\n    yAxisBoundsSecondary,\n    yAxisIndex,\n    yAxisIndexB,\n    yAxisTitleSecondary,\n    zoomable,\n    richTooltip,\n    tooltipSortByMetric,\n    xAxisLabelRotation,\n    groupby,\n    groupbyB,\n    xAxis: xAxisOrig,\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n    timeGrainSqla,\n    percentageThreshold,\n    metrics = [],\n    metricsB = [],\n  }: EchartsMixedTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n\n  const refs: Refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n\n  let xAxisLabel = getXAxisLabel(\n    chartProps.rawFormData as QueryFormData,\n  ) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series: SeriesOption[] = [];\n  const formatter = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormat);\n  const formatterSecondary = getNumberFormatter(\n    contributionMode ? ',.0%' : yAxisFormatSecondary,\n  );\n  const customFormatters = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n  );\n  const customFormattersSecondary = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormatSecondary,\n  );\n\n  const primarySeries = new Set<string>();\n  const secondarySeries = new Set<string>();\n  const mapSeriesIdToAxis = (\n    seriesOption: SeriesOption,\n    index?: number,\n  ): void => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id as string);\n    } else {\n      primarySeries.add(seriesOption.id as string);\n    }\n  };\n  rawSeriesA.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndex),\n  );\n  rawSeriesB.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndexB),\n  );\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack,\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack,\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedDataA,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n    },\n  );\n  const {\n    totalStackedValues: totalStackedValuesB,\n    thresholdValues: thresholdValuesB,\n  } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n  });\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data1,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data1,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(\n    parseYAxisBound,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeriesA.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const seriesFormatter = getFormatter(\n      customFormatters,\n      formatter,\n      metrics,\n      labelMap[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        showValue,\n        stack: Boolean(stack),\n        yAxisIndex,\n        filterState,\n        seriesKey: entry.name,\n        sliceId,\n        queryIndex: 0,\n        formatter:\n          seriesType === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesA,\n        totalStackedValues,\n        thresholdValues,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  rawSeriesB.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = `${inverted[entryName] || entryName} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const seriesFormatter = getFormatter(\n      customFormattersSecondary,\n      formatterSecondary,\n      metricsB,\n      labelMapB[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area: areaB,\n        markerEnabled: markerEnabledB,\n        markerSize: markerSizeB,\n        areaOpacity: opacityB,\n        seriesType: seriesTypeB,\n        showValue: showValueB,\n        stack: Boolean(stackB),\n        yAxisIndex: yAxisIndexB,\n        filterState,\n        seriesKey: primarySeries.has(entry.name as string)\n          ? `${entry.name} (1)`\n          : entry.name,\n        sliceId,\n        queryIndex: 1,\n        formatter:\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max: maxSecondary,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesB,\n        totalStackedValues: totalStackedValuesB,\n        thresholdValues: thresholdValuesB,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (min === undefined) min = 0;\n    if (max === undefined) max = 1;\n    if (minSecondary === undefined) minSecondary = 0;\n    if (maxSecondary === undefined) maxSecondary = 1;\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n\n  const chartPadding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisTitleOffset,\n    zoomable,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation,\n      },\n      minInterval:\n        xAxisType === 'time' && timeGrainSqla\n          ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n          : 0,\n    },\n    yAxis: [\n      {\n        ...defaultYAxis,\n        type: logAxis ? 'log' : 'value',\n        min,\n        max,\n        minorTick: { show: true },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metrics,\n            !!contributionMode,\n            customFormatters,\n            yAxisFormat,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitle,\n        nameGap: convertInteger(yAxisTitleMargin),\n        nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n        alignTicks,\n      },\n      {\n        ...defaultYAxis,\n        type: logAxisSecondary ? 'log' : 'value',\n        min: minSecondary,\n        max: maxSecondary,\n        minorTick: { show: true },\n        splitLine: { show: false },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metricsB,\n            !!contributionMode,\n            customFormattersSecondary,\n            yAxisFormatSecondary,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitleSecondary,\n        alignTicks,\n      },\n    ],\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const xValue: number = richTooltip\n          ? params[0].value[0]\n          : params.value[0];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n\n        const rows: Array<string> = [`${tooltipFormatter(xValue)}`];\n        const forecastValues =\n          extractForecastValuesFromTooltipParams(forecastValue);\n\n        Object.keys(forecastValues).forEach(key => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {\n            formatterKey =\n              groupby.length === 0 ? inverted[key] : labelMap[key]?.[0];\n          } else {\n            formatterKey =\n              groupbyB.length === 0 ? inverted[key] : labelMapB[key]?.[0];\n          }\n          const tooltipFormatter = getFormatter(\n            customFormatters,\n            formatter,\n            metrics,\n            formatterKey,\n            !!contributionMode,\n          );\n          const tooltipFormatterSecondary = getFormatter(\n            customFormattersSecondary,\n            formatterSecondary,\n            metricsB,\n            formatterKey,\n            !!contributionMode,\n          );\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key)\n              ? tooltipFormatter\n              : tooltipFormatterSecondary,\n          });\n          const contentStyle =\n            key === focusedSeries ? 'font-weight: 700' : 'opacity: 0.7';\n          rows.push(`<span style=\"${contentStyle}\">${content}</span>`);\n        });\n        return rows.join('<br />');\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n      ),\n      // @ts-ignore\n      data: rawSeriesA\n        .concat(rawSeriesB)\n        .filter(\n          entry =>\n            extractForecastSeriesContext((entry.name || '') as string).type ===\n            ForecastSeriesEnum.Observation,\n        )\n        .map(entry => entry.name || '')\n        .concat(extractAnnotationLabels(annotationLayers, annotationData)),\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom',\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}