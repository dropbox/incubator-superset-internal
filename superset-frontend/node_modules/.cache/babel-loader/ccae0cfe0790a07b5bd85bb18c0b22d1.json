{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isDefined, SupersetClient } from '../..';\nimport getChartBuildQueryRegistry from '../registries/ChartBuildQueryRegistrySingleton';\nimport getChartMetadataRegistry from '../registries/ChartMetadataRegistrySingleton';\nexport default class ChartClient {\n\n  constructor(config) {if (config === void 0) {config = {};}this.client = void 0;\n    const { client = SupersetClient } = config;\n    this.client = client;\n  }\n  loadFormData(input, options) {\n    /* If sliceId is provided, use it to fetch stored formData from API */\n    if ('sliceId' in input) {\n      const promise = this.client.\n      get({\n        endpoint: `/api/v1/form_data/?slice_id=${input.sliceId}`,\n        ...options }).\n\n      then((response) => response.json);\n      /*\n       * If formData is also specified, override API result\n       * with user-specified formData\n       */\n      return promise.then((dbFormData) => ({\n        ...dbFormData,\n        ...input.formData }));\n\n    }\n    /* If sliceId is not provided, returned formData wrapped in a Promise */\n    return input.formData ?\n    Promise.resolve(input.formData) :\n    Promise.reject(new Error('At least one of sliceId or formData must be specified'));\n  }\n  async loadQueryData(formData, options) {\n    const { viz_type: visType } = formData;\n    const metaDataRegistry = getChartMetadataRegistry();\n    const buildQueryRegistry = getChartBuildQueryRegistry();\n    if (metaDataRegistry.has(visType)) {var _await$buildQueryRegi;\n      const { useLegacyApi } = metaDataRegistry.get(visType);\n      const buildQuery = (_await$buildQueryRegi = await buildQueryRegistry.get(visType)) != null ? _await$buildQueryRegi : () => formData;\n      const requestConfig = useLegacyApi ?\n      {\n        endpoint: '/superset/explore_json/',\n        postPayload: {\n          form_data: buildQuery(formData) },\n\n        ...options } :\n\n      {\n        endpoint: '/api/v1/chart/data',\n        jsonPayload: {\n          query_context: buildQuery(formData) },\n\n        ...options };\n\n      return this.client.\n      post(requestConfig).\n      then((response) => Array.isArray(response.json) ? response.json : [response.json]);\n    }\n    return Promise.reject(new Error(`Unknown chart type: ${visType}`));\n  }\n  loadDatasource(datasourceKey, options) {\n    return this.client.\n    get({\n      endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}`,\n      ...options }).\n\n    then((response) => response.json);\n  }\n  // eslint-disable-next-line class-methods-use-this\n  loadAnnotation(annotationLayer) {\n    /* When annotation does not require query */\n    if (!isDefined(annotationLayer.sourceType)) {\n      return Promise.resolve({});\n    }\n    // TODO: Implement\n    return Promise.reject(new Error('This feature is not implemented yet.'));\n  }\n  loadAnnotations(annotationLayers) {\n    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {\n      return Promise.all(annotationLayers.map((layer) => this.loadAnnotation(layer))).then((results) => annotationLayers.reduce((prev, layer, i) => {\n        const output = prev;\n        output[layer.name] = results[i];\n        return output;\n      }, {}));\n    }\n    return Promise.resolve({});\n  }\n  loadChartData(input) {\n    return this.loadFormData(input).then((formData) => Promise.all([\n    this.loadAnnotations(formData.annotation_layers),\n    this.loadDatasource(formData.datasource),\n    this.loadQueryData(formData)]).\n    then((_ref) => {let [annotationData, datasource, queriesData] = _ref;return {\n        annotationData,\n        datasource,\n        formData,\n        queriesData };}));\n\n  }}","map":{"version":3,"mappings":"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","names":["isDefined","SupersetClient","getChartBuildQueryRegistry","getChartMetadataRegistry","ChartClient","constructor","config","client","loadFormData","input","options","promise","get","endpoint","sliceId","then","response","json","dbFormData","formData","Promise","resolve","reject","Error","loadQueryData","viz_type","visType","metaDataRegistry","buildQueryRegistry","has","useLegacyApi","buildQuery","requestConfig","postPayload","form_data","jsonPayload","query_context","post","Array","isArray","loadDatasource","datasourceKey","loadAnnotation","annotationLayer","sourceType","loadAnnotations","annotationLayers","length","all","map","layer","reduce","prev","i","output","name","results","loadChartData","annotation_layers","datasource","annotationData","queriesData"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/chart/clients/ChartClient.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  isDefined,\n  SupersetClient,\n  SupersetClientInterface,\n  RequestConfig,\n  SupersetClientClass,\n  QueryFormData,\n  Datasource,\n} from '../..';\nimport getChartBuildQueryRegistry from '../registries/ChartBuildQueryRegistrySingleton';\nimport getChartMetadataRegistry from '../registries/ChartMetadataRegistrySingleton';\nimport { QueryData } from '../types/QueryResponse';\nimport { AnnotationLayerMetadata } from '../types/Annotation';\nimport { PlainObject } from '../types/Base';\n\n// This expands to Partial<All> & (union of all possible single-property types)\ntype AtLeastOne<All, Each = { [K in keyof All]: Pick<All, K> }> = Partial<All> &\n  Each[keyof Each];\n\nexport type SliceIdAndOrFormData = AtLeastOne<{\n  sliceId: number;\n  formData: Partial<QueryFormData>;\n}>;\n\ninterface AnnotationData {\n  [key: string]: PlainObject;\n}\n\nexport interface ChartData {\n  annotationData: AnnotationData;\n  datasource: PlainObject;\n  formData: QueryFormData;\n  queriesData: QueryData[];\n}\n\nexport default class ChartClient {\n  readonly client: SupersetClientInterface | SupersetClientClass;\n\n  constructor(\n    config: {\n      client?: SupersetClientInterface | SupersetClientClass;\n    } = {},\n  ) {\n    const { client = SupersetClient } = config;\n    this.client = client;\n  }\n\n  loadFormData(\n    input: SliceIdAndOrFormData,\n    options?: Partial<RequestConfig>,\n  ): Promise<QueryFormData> {\n    /* If sliceId is provided, use it to fetch stored formData from API */\n    if ('sliceId' in input) {\n      const promise = this.client\n        .get({\n          endpoint: `/api/v1/form_data/?slice_id=${input.sliceId}`,\n          ...options,\n        } as RequestConfig)\n        .then(response => response.json as QueryFormData);\n\n      /*\n       * If formData is also specified, override API result\n       * with user-specified formData\n       */\n      return promise.then((dbFormData: QueryFormData) => ({\n        ...dbFormData,\n        ...input.formData,\n      }));\n    }\n\n    /* If sliceId is not provided, returned formData wrapped in a Promise */\n    return input.formData\n      ? Promise.resolve(input.formData as QueryFormData)\n      : Promise.reject(\n          new Error('At least one of sliceId or formData must be specified'),\n        );\n  }\n\n  async loadQueryData(\n    formData: QueryFormData,\n    options?: Partial<RequestConfig>,\n  ): Promise<QueryData[]> {\n    const { viz_type: visType } = formData;\n    const metaDataRegistry = getChartMetadataRegistry();\n    const buildQueryRegistry = getChartBuildQueryRegistry();\n\n    if (metaDataRegistry.has(visType)) {\n      const { useLegacyApi } = metaDataRegistry.get(visType)!;\n      const buildQuery =\n        (await buildQueryRegistry.get(visType)) ?? (() => formData);\n      const requestConfig: RequestConfig = useLegacyApi\n        ? {\n            endpoint: '/superset/explore_json/',\n            postPayload: {\n              form_data: buildQuery(formData),\n            },\n            ...options,\n          }\n        : {\n            endpoint: '/api/v1/chart/data',\n            jsonPayload: {\n              query_context: buildQuery(formData),\n            },\n            ...options,\n          };\n\n      return this.client\n        .post(requestConfig)\n        .then(response =>\n          Array.isArray(response.json) ? response.json : [response.json],\n        );\n    }\n\n    return Promise.reject(new Error(`Unknown chart type: ${visType}`));\n  }\n\n  loadDatasource(\n    datasourceKey: string,\n    options?: Partial<RequestConfig>,\n  ): Promise<Datasource> {\n    return this.client\n      .get({\n        endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}`,\n        ...options,\n      } as RequestConfig)\n      .then(response => response.json as Datasource);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  loadAnnotation(\n    annotationLayer: AnnotationLayerMetadata,\n  ): Promise<AnnotationData> {\n    /* When annotation does not require query */\n    if (!isDefined(annotationLayer.sourceType)) {\n      return Promise.resolve({} as AnnotationData);\n    }\n\n    // TODO: Implement\n    return Promise.reject(new Error('This feature is not implemented yet.'));\n  }\n\n  loadAnnotations(\n    annotationLayers?: AnnotationLayerMetadata[],\n  ): Promise<AnnotationData> {\n    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {\n      return Promise.all(\n        annotationLayers.map(layer => this.loadAnnotation(layer)),\n      ).then(results =>\n        annotationLayers.reduce((prev, layer, i) => {\n          const output: AnnotationData = prev;\n          output[layer.name] = results[i];\n\n          return output;\n        }, {}),\n      );\n    }\n\n    return Promise.resolve({});\n  }\n\n  loadChartData(input: SliceIdAndOrFormData): Promise<ChartData> {\n    return this.loadFormData(input).then(\n      (\n        formData: QueryFormData & {\n          // eslint-disable-next-line camelcase\n          annotation_layers?: AnnotationLayerMetadata[];\n        },\n      ) =>\n        Promise.all([\n          this.loadAnnotations(formData.annotation_layers),\n          this.loadDatasource(formData.datasource),\n          this.loadQueryData(formData),\n        ]).then(([annotationData, datasource, queriesData]) => ({\n          annotationData,\n          datasource,\n          formData,\n          queriesData,\n        })),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}