{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\nimport { useSchemas } from './schemas';\nconst tableApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    tables: builder.query({\n      providesTags: ['Tables'],\n      query: (_ref) => {let { dbId, schema, forceRefresh } = _ref;return {\n          endpoint: `/api/v1/database/${dbId != null ? dbId : 'undefined'}/tables/`,\n          // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n          urlParams: {\n            force: forceRefresh,\n            schema_name: schema ? encodeURIComponent(schema) : '' },\n\n          transformResponse: (_ref2) => {let { json } = _ref2;return {\n              options: json.result,\n              hasMore: json.count > json.result.length };} };},\n\n\n      serializeQueryArgs: (_ref3) => {let { queryArgs: { dbId, schema } } = _ref3;return {\n          dbId,\n          schema };} }) }) });\n\n\n\n\nexport const { useLazyTablesQuery, useTablesQuery } = tableApi;\nexport function useTables(options) {\n  const isMountedRef = useRef(false);\n  const { data: schemaOptions, isFetching } = useSchemas({\n    dbId: options.dbId });\n\n  const schemaOptionsMap = useMemo(() => new Set(schemaOptions == null ? void 0 : schemaOptions.map((_ref4) => {let { value } = _ref4;return value;})), [schemaOptions]);\n  const { dbId, schema, onSuccess, onError } = options || {};\n  const enabled = Boolean(dbId && schema && !isFetching && schemaOptionsMap.has(schema));\n  const result = useTablesQuery({ dbId, schema, forceRefresh: false }, {\n    skip: !enabled });\n\n  const [trigger] = useLazyTablesQuery();\n  const handleOnSuccess = useEffectEvent((data, isRefetched) => {\n    onSuccess == null ? void 0 : onSuccess(data, isRefetched);\n  });\n  const handleOnError = useEffectEvent((error) => {\n    onError == null ? void 0 : onError(error);\n  });\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, schema, forceRefresh: true }).then((_ref5) => {let { isSuccess, isError, data, error } = _ref5;\n        if (isSuccess && data) {\n          handleOnSuccess(data, true);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      });\n    }\n  }, [dbId, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, data, error, originalArgs } = result;\n      if (!(originalArgs != null && originalArgs.forceRefresh) && requestId && !isFetching) {\n        if (isSuccess && data) {\n          handleOnSuccess(data, false);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      }\n    } else\n    {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n  return {\n    ...result,\n    refetch };\n\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useEffect","useRef","useEffectEvent","api","useSchemas","tableApi","injectEndpoints","endpoints","tables","builder","query","providesTags","dbId","schema","forceRefresh","endpoint","urlParams","force","schema_name","encodeURIComponent","transformResponse","json","options","result","hasMore","count","length","serializeQueryArgs","queryArgs","useLazyTablesQuery","useTablesQuery","useTables","isMountedRef","data","schemaOptions","isFetching","schemaOptionsMap","Set","map","value","onSuccess","onError","enabled","Boolean","has","skip","trigger","handleOnSuccess","isRefetched","handleOnError","error","refetch","then","isSuccess","isError","current","requestId","originalArgs"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/hooks/apiResources/tables.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\n\nimport { useSchemas } from './schemas';\n\nexport interface Table {\n  label: string;\n  value: string;\n  type: string;\n  extra?: {\n    certification?: {\n      certified_by: string;\n      details: string;\n    };\n    warning_markdown?: string;\n  };\n}\n\ntype QueryResponse = {\n  json: {\n    count: number;\n    result: Table[];\n  };\n  response: Response;\n};\n\nexport type Data = {\n  options: Table[];\n  hasMore: boolean;\n};\n\nexport type FetchTablesQueryParams = {\n  dbId?: string | number;\n  schema?: string;\n  forceRefresh?: boolean;\n  onSuccess?: (data: Data, isRefetched: boolean) => void;\n  onError?: (error: Response) => void;\n};\n\ntype Params = Omit<FetchTablesQueryParams, 'forceRefresh'>;\n\nconst tableApi = api.injectEndpoints({\n  endpoints: builder => ({\n    tables: builder.query<Data, FetchTablesQueryParams>({\n      providesTags: ['Tables'],\n      query: ({ dbId, schema, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId ?? 'undefined'}/tables/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          schema_name: schema ? encodeURIComponent(schema) : '',\n        },\n        transformResponse: ({ json }: QueryResponse) => ({\n          options: json.result,\n          hasMore: json.count > json.result.length,\n        }),\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, schema } }) => ({\n        dbId,\n        schema,\n      }),\n    }),\n  }),\n});\n\nexport const { useLazyTablesQuery, useTablesQuery } = tableApi;\n\nexport function useTables(options: Params) {\n  const isMountedRef = useRef(false);\n  const { data: schemaOptions, isFetching } = useSchemas({\n    dbId: options.dbId,\n  });\n  const schemaOptionsMap = useMemo(\n    () => new Set(schemaOptions?.map(({ value }) => value)),\n    [schemaOptions],\n  );\n  const { dbId, schema, onSuccess, onError } = options || {};\n\n  const enabled = Boolean(\n    dbId && schema && !isFetching && schemaOptionsMap.has(schema),\n  );\n\n  const result = useTablesQuery(\n    { dbId, schema, forceRefresh: false },\n    {\n      skip: !enabled,\n    },\n  );\n  const [trigger] = useLazyTablesQuery();\n\n  const handleOnSuccess = useEffectEvent((data: Data, isRefetched: boolean) => {\n    onSuccess?.(data, isRefetched);\n  });\n\n  const handleOnError = useEffectEvent((error: Response) => {\n    onError?.(error);\n  });\n\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, schema, forceRefresh: true }).then(\n        ({ isSuccess, isError, data, error }) => {\n          if (isSuccess && data) {\n            handleOnSuccess(data, true);\n          }\n          if (isError) {\n            handleOnError(error as Response);\n          }\n        },\n      );\n    }\n  }, [dbId, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const {\n        requestId,\n        isSuccess,\n        isError,\n        isFetching,\n        data,\n        error,\n        originalArgs,\n      } = result;\n      if (!originalArgs?.forceRefresh && requestId && !isFetching) {\n        if (isSuccess && data) {\n          handleOnSuccess(data, false);\n        }\n        if (isError) {\n          handleOnError(error as Response);\n        }\n      }\n    } else {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n\n  return {\n    ...result,\n    refetch,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}