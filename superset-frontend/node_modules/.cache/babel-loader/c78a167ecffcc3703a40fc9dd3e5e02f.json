{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n(function (Actions) {\n  Actions[\"GET\"] = \"get\";\n  Actions[\"REPLY\"] = \"reply\";\n  Actions[\"EMIT\"] = \"emit\";\n  Actions[\"ERROR\"] = \"error\";\n})(Actions || (Actions = {}));\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n  // used to make unique ids\n\n\n\n  constructor(params) {this.port = void 0;this.name = '';this.methods = {};this.incrementor = 1;this.debugMode = void 0;this.isInitialised = void 0;\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n  init(params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n    const { port, name = 'switchboard', debug = false } = params;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else\n      if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n    this.isInitialised = true;\n  }\n  async getMethodResult(_ref) {let { messageId, method, args } = _ref;\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined` };\n\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result };\n\n    }\n    catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error` };\n\n    }\n  }\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonsense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args) {if (args === void 0) {args = undefined;}\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId)\n        return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else\n        {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args };\n\n      this.port.postMessage(message);\n    });\n  }\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args) {if (args === void 0) {args = undefined;}\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args };\n\n    this.port.postMessage(message);\n  }\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n  log() {\n    if (this.debugMode) {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n  logError() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}\n    console.error(`[${this.name}]`, ...args);\n  }\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}const _default = new Switchboard();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Actions, \"Actions\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isGet, \"isGet\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isReply, \"isReply\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isEmit, \"isEmit\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isError, \"isError\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["Actions","isGet","message","switchboardAction","GET","isReply","REPLY","isEmit","EMIT","isError","ERROR","Switchboard","constructor","params","port","name","methods","incrementor","debugMode","isInitialised","init","logError","debug","addEventListener","event","log","data","postMessage","getMethodResult","method","args","executor","messageId","error","result","err","defineMethod","methodName","get","undefined","Promise","resolve","reject","Error","getNewMessageId","listener","removeEventListener","errStr","start","emit","console"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport type Params = {\n  port: MessagePort;\n  name?: string;\n  debug?: boolean;\n};\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nenum Actions {\n  GET = 'get',\n  REPLY = 'reply',\n  EMIT = 'emit',\n  ERROR = 'error',\n}\n\ntype Method<A extends {}, R> = (args: A) => R | Promise<R>;\n\n// helper types/functions for making sure wires don't get crossed\n\ninterface Message {\n  switchboardAction: Actions;\n}\n\ninterface GetMessage<T = any> extends Message {\n  switchboardAction: Actions.GET;\n  method: string;\n  messageId: string;\n  args: T;\n}\n\nfunction isGet(message: Message): message is GetMessage {\n  return message.switchboardAction === Actions.GET;\n}\n\ninterface ReplyMessage<T = any> extends Message {\n  switchboardAction: Actions.REPLY;\n  messageId: string;\n  result: T;\n}\n\nfunction isReply(message: Message): message is ReplyMessage {\n  return message.switchboardAction === Actions.REPLY;\n}\n\ninterface EmitMessage<T = any> extends Message {\n  switchboardAction: Actions.EMIT;\n  method: string;\n  args: T;\n}\n\nfunction isEmit(message: Message): message is EmitMessage {\n  return message.switchboardAction === Actions.EMIT;\n}\n\ninterface ErrorMessage extends Message {\n  switchboardAction: Actions.ERROR;\n  messageId: string;\n  error: string;\n}\n\nfunction isError(message: Message): message is ErrorMessage {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n  port: MessagePort;\n\n  name = '';\n\n  methods: Record<string, Method<any, unknown>> = {};\n\n  // used to make unique ids\n  incrementor = 1;\n\n  debugMode: boolean;\n\n  private isInitialised: boolean;\n\n  constructor(params?: Params) {\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n\n  init(params: Params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n\n    const { port, name = 'switchboard', debug = false } = params;\n\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async event => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n\n    this.isInitialised = true;\n  }\n\n  private async getMethodResult({\n    messageId,\n    method,\n    args,\n  }: GetMessage): Promise<ReplyMessage | ErrorMessage> {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined`,\n      };\n    }\n    try {\n      const result = await executor(args);\n      return <ReplyMessage>{\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result,\n      };\n    } catch (err) {\n      this.logError(err);\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error`,\n      };\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod<A = any, R = any>(methodName: string, executor: Method<A, R>) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonsense.\n   * @returns whatever is returned from the method\n   */\n  get<T = unknown>(method: string, args: unknown = undefined): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event: MessageEvent) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message)\n            ? message.error\n            : 'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message: GetMessage = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args,\n      };\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method: string, args: unknown = undefined) {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message: EmitMessage = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args,\n    };\n    this.port.postMessage(message);\n  }\n\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n\n  private log(...args: unknown[]) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  private logError(...args: unknown[]) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  private getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  }\n}\n\nexport default new Switchboard();\n"]},"metadata":{},"sourceType":"module"}