{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getMetricLabel } from '@superset-ui/core';\nimport { extent as d3Extent } from 'd3-array';\nimport { DEFAULT_FORM_DATA as DEFAULT_GRAPH_FORM_DATA } from './types';\nimport { DEFAULT_GRAPH_SERIES_OPTION } from './constants';\nimport { getChartPadding, getColtypesMapping, getLegendProps, sanitizeHtml } from '../utils/series';\nimport { getDefaultTooltip } from '../utils/tooltip';\nfunction verifyEdgeSymbol(symbol) {\n  if (symbol === 'none' || symbol === 'circle' || symbol === 'arrow') {\n    return symbol;\n  }\n  return 'none';\n}\nfunction parseEdgeSymbol(symbols) {\n  const [start, end] = (symbols || '').split(',');\n  return [verifyEdgeSymbol(start), verifyEdgeSymbol(end)];\n}\n/**\n * Emphasized edge width with a min and max.\n */\nfunction getEmphasizedEdgeWidth(width) {\n  return Math.max(5, Math.min(width * 2, 20));\n}\n/**\n * Normalize node size, edge width, and apply label visibility thresholds.\n */\nfunction normalizeStyles(nodes, links, _ref) {let { baseNodeSize, baseEdgeWidth, showSymbolThreshold } = _ref;\n  const minNodeSize = baseNodeSize * 0.5;\n  const maxNodeSize = baseNodeSize * 2;\n  const minEdgeWidth = baseEdgeWidth * 0.5;\n  const maxEdgeWidth = baseEdgeWidth * 2;\n  const [nodeMinValue, nodeMaxValue] = d3Extent(nodes, (x) => x.value);\n  const nodeSpread = nodeMaxValue - nodeMinValue;\n  nodes.forEach((node) => {\n    // eslint-disable-next-line no-param-reassign\n    node.symbolSize =\n    ((node.value - nodeMinValue) / nodeSpread * maxNodeSize || 0) +\n    minNodeSize;\n    // eslint-disable-next-line no-param-reassign\n    node.label = {\n      ...node.label,\n      show: showSymbolThreshold ? node.value > showSymbolThreshold : true };\n\n  });\n  const [linkMinValue, linkMaxValue] = d3Extent(links, (x) => x.value);\n  const linkSpread = linkMaxValue - linkMinValue;\n  links.forEach((link) => {\n    const lineWidth = (link.value - linkMinValue) / linkSpread * maxEdgeWidth ||\n    0 + minEdgeWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.lineStyle.width = lineWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.emphasis.lineStyle = {\n      ...link.emphasis.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth) };\n\n    // eslint-disable-next-line no-param-reassign\n    link.select.lineStyle = {\n      ...link.select.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth * 0.8),\n      opacity: 1 };\n\n  });\n}\nfunction getKeyByValue(object, value) {\n  return Object.keys(object).find((key) => object[key] === value);\n}\nfunction edgeFormatter(sourceIndex, targetIndex, value, nodes) {\n  const source = Number(sourceIndex);\n  const target = Number(targetIndex);\n  return `${sanitizeHtml(getKeyByValue(nodes, source))} > ${sanitizeHtml(getKeyByValue(nodes, target))} : ${value}`;\n}\nfunction getCategoryName(columnName, name) {\n  if (name === false) {\n    return `${columnName}: false`;\n  }\n  if (name === true) {\n    return `${columnName}: true`;\n  }\n  if (name == null) {\n    return 'N/A';\n  }\n  return String(name);\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, queriesData, hooks, inContextMenu, filterState, emitCrossFilters, theme } = chartProps;\n  const data = queriesData[0].data || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { source, target, sourceCategory, targetCategory, colorScheme, metric = '', layout, roam, draggable, selectedMode, showSymbolThreshold, edgeLength, gravity, repulsion, friction, legendMargin, legendOrientation, legendType, showLegend, baseEdgeWidth, baseNodeSize, edgeSymbol, sliceId } = { ...DEFAULT_GRAPH_FORM_DATA, ...formData };\n  const refs = {};\n  const metricLabel = getMetricLabel(metric);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const nodes = {};\n  const categories = new Set();\n  const echartNodes = [];\n  const echartLinks = [];\n  /**\n   * Get the node id of an existing node,\n   * or create a new node if it doesn't exist.\n   */\n  function getOrCreateNode(name, col, category) {\n    if (!(name in nodes)) {\n      nodes[name] = echartNodes.length;\n      echartNodes.push({\n        id: String(nodes[name]),\n        name,\n        col,\n        value: 0,\n        category,\n        select: DEFAULT_GRAPH_SERIES_OPTION.select,\n        tooltip: {\n          ...getDefaultTooltip(refs),\n          ...DEFAULT_GRAPH_SERIES_OPTION.tooltip } });\n\n\n    }\n    const node = echartNodes[nodes[name]];\n    if (category) {\n      categories.add(category);\n      // category may be empty when one of `sourceCategory`\n      // or `targetCategory` is not set.\n      if (!node.category) {\n        node.category = category;\n      }\n    }\n    return node;\n  }\n  data.forEach((link) => {\n    const value = link[metricLabel];\n    if (!value) {\n      return;\n    }\n    const sourceName = link[source];\n    const targetName = link[target];\n    const sourceCategoryName = sourceCategory ?\n    getCategoryName(sourceCategory, link[sourceCategory]) :\n    undefined;\n    const targetCategoryName = targetCategory ?\n    getCategoryName(targetCategory, link[targetCategory]) :\n    undefined;\n    const sourceNode = getOrCreateNode(sourceName, source, sourceCategoryName);\n    const targetNode = getOrCreateNode(targetName, target, targetCategoryName);\n    sourceNode.value += value;\n    targetNode.value += value;\n    echartLinks.push({\n      source: sourceNode.id,\n      target: targetNode.id,\n      value,\n      lineStyle: {},\n      emphasis: {},\n      select: {} });\n\n  });\n  normalizeStyles(echartNodes, echartLinks, {\n    showSymbolThreshold,\n    baseEdgeWidth,\n    baseNodeSize });\n\n  const categoryList = [...categories];\n  const series = [\n  {\n    zoom: DEFAULT_GRAPH_SERIES_OPTION.zoom,\n    type: 'graph',\n    categories: categoryList.map((c) => ({\n      name: c,\n      itemStyle: { color: colorFn(c, sliceId) } })),\n\n    layout,\n    force: {\n      ...DEFAULT_GRAPH_SERIES_OPTION.force,\n      edgeLength,\n      gravity,\n      repulsion,\n      friction },\n\n    circular: DEFAULT_GRAPH_SERIES_OPTION.circular,\n    data: echartNodes,\n    links: echartLinks,\n    roam,\n    draggable,\n    edgeSymbol: parseEdgeSymbol(edgeSymbol),\n    edgeSymbolSize: baseEdgeWidth * 2,\n    selectedMode,\n    ...getChartPadding(showLegend, legendOrientation, legendMargin),\n    animation: DEFAULT_GRAPH_SERIES_OPTION.animation,\n    label: DEFAULT_GRAPH_SERIES_OPTION.label,\n    lineStyle: DEFAULT_GRAPH_SERIES_OPTION.lineStyle,\n    emphasis: DEFAULT_GRAPH_SERIES_OPTION.emphasis }];\n\n\n  const echartOptions = {\n    animationDuration: DEFAULT_GRAPH_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_GRAPH_SERIES_OPTION.animationEasing,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      formatter: (params) => edgeFormatter(params.data.source, params.data.target, params.value, nodes) },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: categoryList },\n\n    series };\n\n  const { onContextMenu, setDataMask } = hooks;\n  return {\n    width,\n    height,\n    formData,\n    echartOptions,\n    onContextMenu,\n    setDataMask,\n    filterState,\n    refs,\n    emitCrossFilters,\n    coltypeMapping };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(verifyEdgeSymbol, \"verifyEdgeSymbol\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(parseEdgeSymbol, \"parseEdgeSymbol\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(getEmphasizedEdgeWidth, \"getEmphasizedEdgeWidth\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(normalizeStyles, \"normalizeStyles\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(getKeyByValue, \"getKeyByValue\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(edgeFormatter, \"edgeFormatter\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(getCategoryName, \"getCategoryName\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","getMetricLabel","extent","d3Extent","DEFAULT_FORM_DATA","DEFAULT_GRAPH_FORM_DATA","DEFAULT_GRAPH_SERIES_OPTION","getChartPadding","getColtypesMapping","getLegendProps","sanitizeHtml","getDefaultTooltip","verifyEdgeSymbol","symbol","parseEdgeSymbol","symbols","start","end","split","getEmphasizedEdgeWidth","width","Math","max","min","normalizeStyles","nodes","links","baseNodeSize","baseEdgeWidth","showSymbolThreshold","minNodeSize","maxNodeSize","minEdgeWidth","maxEdgeWidth","nodeMinValue","nodeMaxValue","x","value","nodeSpread","forEach","node","symbolSize","label","show","linkMinValue","linkMaxValue","linkSpread","lineWidth","link","lineStyle","emphasis","select","opacity","getKeyByValue","object","Object","keys","find","key","edgeFormatter","sourceIndex","targetIndex","source","Number","target","getCategoryName","columnName","name","String","transformProps","chartProps","height","formData","queriesData","hooks","inContextMenu","filterState","emitCrossFilters","theme","data","coltypeMapping","sourceCategory","targetCategory","colorScheme","metric","layout","roam","draggable","selectedMode","edgeLength","gravity","repulsion","friction","legendMargin","legendOrientation","legendType","showLegend","edgeSymbol","sliceId","refs","metricLabel","colorFn","getScale","categories","Set","echartNodes","echartLinks","getOrCreateNode","col","category","length","push","id","tooltip","add","sourceName","targetName","sourceCategoryName","undefined","targetCategoryName","sourceNode","targetNode","categoryList","series","zoom","type","map","c","itemStyle","color","force","circular","edgeSymbolSize","animation","echartOptions","animationDuration","animationEasing","formatter","params","legend","onContextMenu","setDataMask"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Graph/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  getMetricLabel,\n  DataRecord,\n  DataRecordValue,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, GraphSeriesOption } from 'echarts';\nimport { extent as d3Extent } from 'd3-array';\nimport { GraphEdgeItemOption } from 'echarts/types/src/chart/graph/GraphSeries';\nimport {\n  EchartsGraphFormData,\n  EChartGraphNode,\n  DEFAULT_FORM_DATA as DEFAULT_GRAPH_FORM_DATA,\n  EdgeSymbol,\n  GraphChartTransformedProps,\n  EchartsGraphChartProps,\n} from './types';\nimport { DEFAULT_GRAPH_SERIES_OPTION } from './constants';\nimport {\n  getChartPadding,\n  getColtypesMapping,\n  getLegendProps,\n  sanitizeHtml,\n} from '../utils/series';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\n\ntype EdgeWithStyles = GraphEdgeItemOption & {\n  lineStyle: Exclude<GraphEdgeItemOption['lineStyle'], undefined>;\n  emphasis: Exclude<GraphEdgeItemOption['emphasis'], undefined>;\n  select: Exclude<GraphEdgeItemOption['select'], undefined>;\n};\n\nfunction verifyEdgeSymbol(symbol: string): EdgeSymbol {\n  if (symbol === 'none' || symbol === 'circle' || symbol === 'arrow') {\n    return symbol;\n  }\n  return 'none';\n}\n\nfunction parseEdgeSymbol(symbols?: string | null): [EdgeSymbol, EdgeSymbol] {\n  const [start, end] = (symbols || '').split(',');\n  return [verifyEdgeSymbol(start), verifyEdgeSymbol(end)];\n}\n\n/**\n * Emphasized edge width with a min and max.\n */\nfunction getEmphasizedEdgeWidth(width: number) {\n  return Math.max(5, Math.min(width * 2, 20));\n}\n\n/**\n * Normalize node size, edge width, and apply label visibility thresholds.\n */\nfunction normalizeStyles(\n  nodes: EChartGraphNode[],\n  links: EdgeWithStyles[],\n  {\n    baseNodeSize,\n    baseEdgeWidth,\n    showSymbolThreshold,\n  }: {\n    baseNodeSize: number;\n    baseEdgeWidth: number;\n    showSymbolThreshold?: number;\n  },\n) {\n  const minNodeSize = baseNodeSize * 0.5;\n  const maxNodeSize = baseNodeSize * 2;\n  const minEdgeWidth = baseEdgeWidth * 0.5;\n  const maxEdgeWidth = baseEdgeWidth * 2;\n  const [nodeMinValue, nodeMaxValue] = d3Extent(nodes, x => x.value) as [\n    number,\n    number,\n  ];\n\n  const nodeSpread = nodeMaxValue - nodeMinValue;\n  nodes.forEach(node => {\n    // eslint-disable-next-line no-param-reassign\n    node.symbolSize =\n      (((node.value - nodeMinValue) / nodeSpread) * maxNodeSize || 0) +\n      minNodeSize;\n    // eslint-disable-next-line no-param-reassign\n    node.label = {\n      ...node.label,\n      show: showSymbolThreshold ? node.value > showSymbolThreshold : true,\n    };\n  });\n\n  const [linkMinValue, linkMaxValue] = d3Extent(links, x => x.value) as [\n    number,\n    number,\n  ];\n  const linkSpread = linkMaxValue - linkMinValue;\n  links.forEach(link => {\n    const lineWidth =\n      ((link.value! - linkMinValue) / linkSpread) * maxEdgeWidth ||\n      0 + minEdgeWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.lineStyle.width = lineWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.emphasis.lineStyle = {\n      ...link.emphasis.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth),\n    };\n    // eslint-disable-next-line no-param-reassign\n    link.select.lineStyle = {\n      ...link.select.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth * 0.8),\n      opacity: 1,\n    };\n  });\n}\n\nfunction getKeyByValue(\n  object: { [name: string]: number },\n  value: number,\n): string {\n  return Object.keys(object).find(key => object[key] === value) as string;\n}\n\nfunction edgeFormatter(\n  sourceIndex: string,\n  targetIndex: string,\n  value: number,\n  nodes: { [name: string]: number },\n): string {\n  const source = Number(sourceIndex);\n  const target = Number(targetIndex);\n  return `${sanitizeHtml(getKeyByValue(nodes, source))} > ${sanitizeHtml(\n    getKeyByValue(nodes, target),\n  )} : ${value}`;\n}\n\nfunction getCategoryName(columnName: string, name?: DataRecordValue) {\n  if (name === false) {\n    return `${columnName}: false`;\n  }\n  if (name === true) {\n    return `${columnName}: true`;\n  }\n  if (name == null) {\n    return 'N/A';\n  }\n  return String(name);\n}\n\nexport default function transformProps(\n  chartProps: EchartsGraphChartProps,\n): GraphChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    inContextMenu,\n    filterState,\n    emitCrossFilters,\n    theme,\n  } = chartProps;\n  const data: DataRecord[] = queriesData[0].data || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    source,\n    target,\n    sourceCategory,\n    targetCategory,\n    colorScheme,\n    metric = '',\n    layout,\n    roam,\n    draggable,\n    selectedMode,\n    showSymbolThreshold,\n    edgeLength,\n    gravity,\n    repulsion,\n    friction,\n    legendMargin,\n    legendOrientation,\n    legendType,\n    showLegend,\n    baseEdgeWidth,\n    baseNodeSize,\n    edgeSymbol,\n    sliceId,\n  }: EchartsGraphFormData = { ...DEFAULT_GRAPH_FORM_DATA, ...formData };\n\n  const refs: Refs = {};\n  const metricLabel = getMetricLabel(metric);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const nodes: { [name: string]: number } = {};\n  const categories: Set<string> = new Set();\n  const echartNodes: EChartGraphNode[] = [];\n  const echartLinks: EdgeWithStyles[] = [];\n\n  /**\n   * Get the node id of an existing node,\n   * or create a new node if it doesn't exist.\n   */\n  function getOrCreateNode(name: string, col: string, category?: string) {\n    if (!(name in nodes)) {\n      nodes[name] = echartNodes.length;\n      echartNodes.push({\n        id: String(nodes[name]),\n        name,\n        col,\n        value: 0,\n        category,\n        select: DEFAULT_GRAPH_SERIES_OPTION.select,\n        tooltip: {\n          ...getDefaultTooltip(refs),\n          ...DEFAULT_GRAPH_SERIES_OPTION.tooltip,\n        },\n      });\n    }\n    const node = echartNodes[nodes[name]];\n    if (category) {\n      categories.add(category);\n      // category may be empty when one of `sourceCategory`\n      // or `targetCategory` is not set.\n      if (!node.category) {\n        node.category = category;\n      }\n    }\n    return node;\n  }\n\n  data.forEach(link => {\n    const value = link[metricLabel] as number;\n    if (!value) {\n      return;\n    }\n    const sourceName = link[source] as string;\n    const targetName = link[target] as string;\n    const sourceCategoryName = sourceCategory\n      ? getCategoryName(sourceCategory, link[sourceCategory])\n      : undefined;\n    const targetCategoryName = targetCategory\n      ? getCategoryName(targetCategory, link[targetCategory])\n      : undefined;\n    const sourceNode = getOrCreateNode(sourceName, source, sourceCategoryName);\n    const targetNode = getOrCreateNode(targetName, target, targetCategoryName);\n\n    sourceNode.value += value;\n    targetNode.value += value;\n\n    echartLinks.push({\n      source: sourceNode.id,\n      target: targetNode.id,\n      value,\n      lineStyle: {},\n      emphasis: {},\n      select: {},\n    });\n  });\n\n  normalizeStyles(echartNodes, echartLinks, {\n    showSymbolThreshold,\n    baseEdgeWidth,\n    baseNodeSize,\n  });\n\n  const categoryList = [...categories];\n\n  const series: GraphSeriesOption[] = [\n    {\n      zoom: DEFAULT_GRAPH_SERIES_OPTION.zoom,\n      type: 'graph',\n      categories: categoryList.map(c => ({\n        name: c,\n        itemStyle: { color: colorFn(c, sliceId) },\n      })),\n      layout,\n      force: {\n        ...DEFAULT_GRAPH_SERIES_OPTION.force,\n        edgeLength,\n        gravity,\n        repulsion,\n        friction,\n      },\n      circular: DEFAULT_GRAPH_SERIES_OPTION.circular,\n      data: echartNodes,\n      links: echartLinks,\n      roam,\n      draggable,\n      edgeSymbol: parseEdgeSymbol(edgeSymbol),\n      edgeSymbolSize: baseEdgeWidth * 2,\n      selectedMode,\n      ...getChartPadding(showLegend, legendOrientation, legendMargin),\n      animation: DEFAULT_GRAPH_SERIES_OPTION.animation,\n      label: DEFAULT_GRAPH_SERIES_OPTION.label,\n      lineStyle: DEFAULT_GRAPH_SERIES_OPTION.lineStyle,\n      emphasis: DEFAULT_GRAPH_SERIES_OPTION.emphasis,\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    animationDuration: DEFAULT_GRAPH_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_GRAPH_SERIES_OPTION.animationEasing,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      formatter: (params: any): string =>\n        edgeFormatter(\n          params.data.source,\n          params.data.target,\n          params.value,\n          nodes,\n        ),\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: categoryList,\n    },\n    series,\n  };\n\n  const { onContextMenu, setDataMask } = hooks;\n\n  return {\n    width,\n    height,\n    formData,\n    echartOptions,\n    onContextMenu,\n    setDataMask,\n    filterState,\n    refs,\n    emitCrossFilters,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}