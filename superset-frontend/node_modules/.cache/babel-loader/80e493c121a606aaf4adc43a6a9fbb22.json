{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n  PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n\n  zoom: PropTypes.number };\n\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: (location) => [location[0], location[1]],\n  renderWhileDragging: true };\n\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options) {if (options === void 0) {options = {};}\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false } =\n    options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw(_ref) {let { width, height, ctx, isDragging, project } = _ref;\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom } =\n    this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n        location.properties,\n        aggregation);\n\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter((v) => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n        roundDecimal(pixel[0], 1),\n        roundDecimal(pixel[1], 1)];\n\n\n        if (\n        pixelRounded[0] + radius >= 0 &&\n        pixelRounded[0] - radius < width &&\n        pixelRounded[1] + radius >= 0 &&\n        pixelRounded[1] - radius < height)\n        {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n            (clusterLabel / maxLabel) ** 0.5 * radius,\n            1);\n\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n            x,\n            y,\n            scaledRadius,\n            x,\n            y,\n            0);\n\n\n            gradient.addColorStop(\n            1,\n            `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`);\n\n            gradient.addColorStop(\n            0,\n            `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`);\n\n            ctx.arc(\n            pixelRounded[0],\n            pixelRounded[1],\n            scaledRadius,\n            0,\n            Math.PI * 2);\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true });\n\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n            radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                pointRadius * MILES_PER_KM,\n                pointLatitude,\n                zoom);\n\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric)) ?\n              roundDecimal(pointMetric, 2) :\n              pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n            pixelRounded[0],\n            pixelRounded[1],\n            roundDecimal(pointRadius, 1),\n            0,\n            Math.PI * 2);\n\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false });\n\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return ___EmotionJSX(CanvasOverlay, { redraw: this.redraw });\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;const _default =\n\nScatterPlotGlowOverlay;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(defaultProps, \"defaultProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(computeClusterLabel, \"computeClusterLabel\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(ScatterPlotGlowOverlay, \"ScatterPlotGlowOverlay\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["PropTypes","React","CanvasOverlay","kmToPixels","MILES_PER_KM","roundDecimal","luminanceFromRGB","propTypes","aggregation","string","compositeOperation","dotRadius","number","lngLatAccessor","func","locations","arrayOf","object","isRequired","pointRadiusUnit","renderWhileDragging","bool","rgb","oneOfType","zoom","defaultProps","location","computeClusterLabel","properties","count","point_count","sum","mean","Math","round","squaredSum","variance","sqrt","ScatterPlotGlowOverlay","PureComponent","constructor","props","redraw","bind","drawText","ctx","pixel","options","IS_DARK_THRESHOLD","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","height","isDragging","project","clusterLabelMap","forEach","i","cluster","maxLabel","max","filter","v","Number","isNaN","clearRect","_forEach","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","PI","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointRadius","pointLabel","pointLatitude","undefined","render"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}