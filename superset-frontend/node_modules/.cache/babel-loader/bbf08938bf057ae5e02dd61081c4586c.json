{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, hasGenericChartAxes, isPhysicalColumn, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.aggregate || mode === QueryMode.raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.raw : QueryMode.aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false };\n\n  }\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing = [];\n    if (queryMode === QueryMode.aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(percentMetrics.map(getMetricLabel));\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`) } }];\n\n\n\n      }\n      columns = columns.map((col) => {var _formData$temporal_co;\n        if (isPhysicalColumn(col) &&\n        formData.time_grain_sqla &&\n        hasGenericChartAxes &&\n        formData != null && (_formData$temporal_co = formData.temporal_columns_lookup) != null && _formData$temporal_co[col]) {\n          return {\n            timeGrain: formData.time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL' };\n\n        }\n        return col;\n      });\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps };\n\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters });\n\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true },\n\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges } });};\n\n\n};const _default =\ncachedBuildQuery();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getQueryMode, \"getQueryMode\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(buildQuery, \"buildQuery\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(cachedBuildQuery, \"cachedBuildQuery\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["buildQueryContext","ensureIsArray","getMetricLabel","hasGenericChartAxes","isPhysicalColumn","QueryMode","removeDuplicates","updateExternalFormData","getQueryMode","formData","query_mode","mode","aggregate","raw","rawColumns","all_columns","hasRawColumns","length","buildQuery","options","percent_metrics","percentMetrics","order_desc","orderDesc","queryMode","sortByMetric","timeseries_limit_metric","formDataCopy","include_time","metrics","orderby","columns","baseQueryObject","postProcessing","percentMetricLabels","map","concat","operation","rename_columns","x","col","time_grain_sqla","temporal_columns_lookup","timeGrain","columnType","sqlExpression","label","expressionType","moreProps","ownState","server_pagination","row_limit","pageSize","server_page_length","row_offset","currentPage","queryObject","post_processing","extras","cachedChanges","slice_id","JSON","stringify","filters","hooks","setDataMask","setCachedChanges","extraQueries","show_totals","push","undefined","interactiveGroupBy","extra_form_data","interactive_groupby","Set","is_rowcount","cachedBuildQuery","newChanges"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AdhocColumn,\n  buildQueryContext,\n  ensureIsArray,\n  getMetricLabel,\n  hasGenericChartAxes,\n  isPhysicalColumn,\n  QueryMode,\n  QueryObject,\n  removeDuplicates,\n} from '@superset-ui/core';\nimport { PostProcessingRule } from '@superset-ui/core/src/query/types/PostProcessing';\nimport { BuildQuery } from '@superset-ui/core/src/chart/registries/ChartBuildQueryRegistrySingleton';\nimport { TableChartFormData } from './types';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData: TableChartFormData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.aggregate || mode === QueryMode.raw) {\n    return mode;\n  }\n  const rawColumns = formData?.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.raw : QueryMode.aggregate;\n}\n\nconst buildQuery: BuildQuery<TableChartFormData> = (\n  formData: TableChartFormData,\n  options,\n) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false } =\n    formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false,\n    };\n  }\n\n  return buildQueryContext(formDataCopy, baseQueryObject => {\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing: PostProcessingRule[] = [];\n\n    if (queryMode === QueryMode.aggregate) {\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else if (metrics?.length > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(\n          percentMetrics.map(getMetricLabel),\n        );\n        metrics = removeDuplicates(\n          metrics.concat(percentMetrics),\n          getMetricLabel,\n        );\n        postProcessing = [\n          {\n            operation: 'contribution',\n            options: {\n              columns: percentMetricLabels,\n              rename_columns: percentMetricLabels.map(x => `%${x}`),\n            },\n          },\n        ];\n      }\n\n      columns = columns.map(col => {\n        if (\n          isPhysicalColumn(col) &&\n          formData.time_grain_sqla &&\n          hasGenericChartAxes &&\n          formData?.temporal_columns_lookup?.[col]\n        ) {\n          return {\n            timeGrain: formData.time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL',\n          } as AdhocColumn;\n        }\n        return col;\n      });\n    }\n\n    const moreProps: Partial<QueryObject> = {};\n    const ownState = options?.ownState ?? {};\n    if (formDataCopy.server_pagination) {\n      moreProps.row_limit =\n        ownState.pageSize ?? formDataCopy.server_page_length;\n      moreProps.row_offset =\n        (ownState.currentPage ?? 0) * (ownState.pageSize ?? 0);\n    }\n\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps,\n    };\n\n    if (\n      formData.server_pagination &&\n      options?.extras?.cachedChanges?.[formData.slice_id] &&\n      JSON.stringify(options?.extras?.cachedChanges?.[formData.slice_id]) !==\n        JSON.stringify(queryObject.filters)\n    ) {\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(\n        options?.hooks?.setDataMask,\n        0,\n        queryObject.row_limit ?? 0,\n      );\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options?.hooks?.setCachedChanges({\n      [formData.slice_id]: queryObject.filters,\n    });\n\n    const extraQueries: QueryObject[] = [];\n    if (\n      metrics?.length &&\n      formData.show_totals &&\n      queryMode === QueryMode.aggregate\n    ) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined, // we don't need orderby stuff here,\n        orderby: undefined, // because this query will be used for get total aggregation.\n      });\n    }\n\n    const interactiveGroupBy = formData.extra_form_data?.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n        ...new Set([...queryObject.columns, ...interactiveGroupBy]),\n      ];\n    }\n\n    if (formData.server_pagination) {\n      return [\n        { ...queryObject },\n        {\n          ...queryObject,\n          row_limit: 0,\n          row_offset: 0,\n          post_processing: [],\n          is_rowcount: true,\n        },\n        ...extraQueries,\n      ];\n    }\n\n    return [queryObject, ...extraQueries];\n  });\n};\n\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = (): BuildQuery<TableChartFormData> => {\n  let cachedChanges: any = {};\n  const setCachedChanges = (newChanges: any) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n\n  return (formData, options) =>\n    buildQuery(\n      { ...formData },\n      {\n        extras: { cachedChanges },\n        ownState: options?.ownState ?? {},\n        hooks: {\n          ...options?.hooks,\n          setDataMask: () => {},\n          setCachedChanges,\n        },\n      },\n    );\n};\n\nexport default cachedBuildQuery();\n"]},"metadata":{},"sourceType":"module"}