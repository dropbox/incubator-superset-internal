{"ast":null,"code":"function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}\n\n/* eslint no-console: 0 */\nimport { globalBox } from 'global-box';\nimport OverwritePolicy from './OverwritePolicy';\nimport createRegistryState from './createRegistryState';\n/**\n * Registry class\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type L Type of value returned from loader function when using `registerLoader()`.\n * `L` can be either `V`, `Promise<V>` or `V | Promise<V>`\n * Set `L=V` when does not support asynchronous loader.\n * By default `L` is set to `V | Promise<V>` to support\n * both synchronous and asynchronous loaders.\n */\n\nexport default class Registry {\n  constructor(config) {if (config === void 0) {config = {};}\n    _defineProperty(this, \"state\", void 0);\n\n    if (typeof config.globalId === 'undefined') {\n      this.state = createRegistryState(config);\n    } else {\n      this.state = globalBox().getOrCreate(config.globalId, () => createRegistryState(config));\n    }\n  }\n  /**\n   * Clear all item in the registry.\n   * Reset default key to initial default key (if any)\n   */\n\n\n  clear() {\n    this.state.items = {};\n    this.state.promises = {};\n    this.state.defaultKey = this.state.initialDefaultKey;\n    return this;\n  }\n  /**\n   * Check if item with the given key exists\n   * @param key the key to look for\n   */\n\n\n  has(key) {\n    const item = this.state.items[key];\n    return item !== null && item !== undefined;\n  }\n  /**\n   * Register key with a value\n   * @param key\n   * @param value\n   */\n\n\n  registerValue(key, value) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('value' in item && item.value !== value || 'loader' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        value };\n\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Register key with a loader, a function that returns a value.\n   * @param key\n   * @param loader\n   */\n\n\n  registerLoader(key, loader) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('loader' in item && item.loader !== loader || 'value' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        loader };\n\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Get value from the specified key.\n   * If the item contains a loader, invoke the loader and return its output.\n   * @param key\n   */\n\n\n  get(key) {\n    const targetKey = key != null ? key : this.state.defaultKey;\n    if (typeof targetKey === 'undefined') return undefined;\n    const item = this.state.items[targetKey];\n\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader && item.loader();\n      }\n\n      return item.value;\n    }\n\n    return undefined;\n  }\n  /**\n   * Similar to `.get()` but wrap results in a `Promise`.\n   * This is useful when some items are async loaders to provide uniform output.\n   * @param key\n   */\n\n\n  getAsPromise(key) {\n    const promise = this.state.promises[key];\n\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n\n    const item = this.get(key);\n\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item);\n      this.state.promises[key] = newPromise;\n      return newPromise;\n    }\n\n    return Promise.reject(new Error(\"Item with key \\\"\" + key + \"\\\" is not registered.\"));\n  }\n  /**\n   * Return the current default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  getDefaultKey() {\n    return this.state.defaultKey;\n  }\n  /**\n   * Set default key to the specified key\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   * @param key\n   */\n\n\n  setDefaultKey(key) {\n    this.state.defaultKey = key;\n    return this;\n  }\n  /**\n   * Remove default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  clearDefaultKey() {\n    this.state.defaultKey = undefined;\n    return this;\n  }\n  /**\n   * Return a map of all key-values in this registry.\n   */\n\n\n  getMap() {\n    return this.keys().reduce((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n      return map;\n    }, {});\n  }\n  /**\n   * Same with `.getMap()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  getMapAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map((key) => this.getAsPromise(key))).then((values) => values.reduce((prev, value, i) => {\n      const map = prev;\n      map[keys[i]] = value;\n      return map;\n    }, {}));\n  }\n  /**\n   * Return all keys in this registry.\n   */\n\n\n  keys() {\n    return Object.keys(this.state.items);\n  }\n  /**\n   * Return all values in this registry.\n   * For loaders, they are invoked and their outputs are returned.\n   */\n\n\n  values() {\n    return this.keys().map((key) => this.get(key));\n  }\n  /**\n   * Same with `.values()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  valuesAsPromise() {\n    return Promise.all(this.keys().map((key) => this.getAsPromise(key)));\n  }\n  /**\n   * Return all key-value entries in this registry.\n   */\n\n\n  entries() {\n    return this.keys().map((key) => ({\n      key,\n      value: this.get(key) }));\n\n  }\n  /**\n   * Same with `.entries()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  entriesAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map((key) => this.getAsPromise(key))).then((values) => values.map((value, i) => ({\n      key: keys[i],\n      value })));\n\n  }\n  /**\n   * Remove the item with the specified key.\n   * Do nothing if an item with the given key does not exist.\n   * @param key\n   */\n\n\n  remove(key) {\n    delete this.state.items[key];\n    delete this.state.promises[key];\n    return this;\n  }\n  /**\n   * Get number of items in the registry\n   */\n\n\n  size() {\n    return this.keys().length;\n  }\n  /**\n   * Returns true if there is no item in the registry\n   */\n\n\n  isEmpty() {\n    return this.size() === 0;\n  }}","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","globalBox","OverwritePolicy","createRegistryState","Registry","constructor","config","globalId","state","getOrCreate","clear","items","promises","defaultKey","initialDefaultKey","has","item","undefined","registerValue","willOverwrite","overwritePolicy","WARN","console","warn","PROHIBIT","Error","setFirstItemAsDefault","registerLoader","loader","get","targetKey","getAsPromise","promise","newPromise","Promise","resolve","reject","getDefaultKey","setDefaultKey","clearDefaultKey","getMap","keys","reduce","prev","map","getMapAsPromise","all","then","values","i","valuesAsPromise","entries","entriesAsPromise","remove","size","length","isEmpty"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/node_modules/@encodable/registry/esm/models/Registry.js"],"sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint no-console: 0 */\nimport { globalBox } from 'global-box';\nimport OverwritePolicy from './OverwritePolicy';\nimport createRegistryState from './createRegistryState';\n/**\n * Registry class\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type L Type of value returned from loader function when using `registerLoader()`.\n * `L` can be either `V`, `Promise<V>` or `V | Promise<V>`\n * Set `L=V` when does not support asynchronous loader.\n * By default `L` is set to `V | Promise<V>` to support\n * both synchronous and asynchronous loaders.\n */\n\nexport default class Registry {\n  constructor(config = {}) {\n    _defineProperty(this, \"state\", void 0);\n\n    if (typeof config.globalId === 'undefined') {\n      this.state = createRegistryState(config);\n    } else {\n      this.state = globalBox().getOrCreate(config.globalId, () => createRegistryState(config));\n    }\n  }\n  /**\n   * Clear all item in the registry.\n   * Reset default key to initial default key (if any)\n   */\n\n\n  clear() {\n    this.state.items = {};\n    this.state.promises = {};\n    this.state.defaultKey = this.state.initialDefaultKey;\n    return this;\n  }\n  /**\n   * Check if item with the given key exists\n   * @param key the key to look for\n   */\n\n\n  has(key) {\n    const item = this.state.items[key];\n    return item !== null && item !== undefined;\n  }\n  /**\n   * Register key with a value\n   * @param key\n   * @param value\n   */\n\n\n  registerValue(key, value) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('value' in item && item.value !== value || 'loader' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        value\n      };\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Register key with a loader, a function that returns a value.\n   * @param key\n   * @param loader\n   */\n\n\n  registerLoader(key, loader) {\n    const item = this.state.items[key];\n    const willOverwrite = this.has(key) && ('loader' in item && item.loader !== loader || 'value' in item);\n\n    if (willOverwrite) {\n      if (this.state.overwritePolicy === OverwritePolicy.WARN) {\n        console.warn(\"Item with key \\\"\" + key + \"\\\" already exists. You are assigning a new value.\");\n      } else if (this.state.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\"Item with key \\\"\" + key + \"\\\" already exists. Cannot overwrite.\");\n      }\n    }\n\n    if (!item || willOverwrite) {\n      this.state.items[key] = {\n        loader\n      };\n      delete this.state.promises[key];\n    } // If there is no default, set as default\n\n\n    if (this.state.setFirstItemAsDefault && !this.state.defaultKey) {\n      this.state.defaultKey = key;\n    }\n\n    return this;\n  }\n  /**\n   * Get value from the specified key.\n   * If the item contains a loader, invoke the loader and return its output.\n   * @param key\n   */\n\n\n  get(key) {\n    const targetKey = key != null ? key : this.state.defaultKey;\n    if (typeof targetKey === 'undefined') return undefined;\n    const item = this.state.items[targetKey];\n\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader && item.loader();\n      }\n\n      return item.value;\n    }\n\n    return undefined;\n  }\n  /**\n   * Similar to `.get()` but wrap results in a `Promise`.\n   * This is useful when some items are async loaders to provide uniform output.\n   * @param key\n   */\n\n\n  getAsPromise(key) {\n    const promise = this.state.promises[key];\n\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n\n    const item = this.get(key);\n\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item);\n      this.state.promises[key] = newPromise;\n      return newPromise;\n    }\n\n    return Promise.reject(new Error(\"Item with key \\\"\" + key + \"\\\" is not registered.\"));\n  }\n  /**\n   * Return the current default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  getDefaultKey() {\n    return this.state.defaultKey;\n  }\n  /**\n   * Set default key to the specified key\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   * @param key\n   */\n\n\n  setDefaultKey(key) {\n    this.state.defaultKey = key;\n    return this;\n  }\n  /**\n   * Remove default key.\n   * Default key is a fallback key to use if `.get()` was called without a key.\n   */\n\n\n  clearDefaultKey() {\n    this.state.defaultKey = undefined;\n    return this;\n  }\n  /**\n   * Return a map of all key-values in this registry.\n   */\n\n\n  getMap() {\n    return this.keys().reduce((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n      return map;\n    }, {});\n  }\n  /**\n   * Same with `.getMap()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  getMapAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.reduce((prev, value, i) => {\n      const map = prev;\n      map[keys[i]] = value;\n      return map;\n    }, {}));\n  }\n  /**\n   * Return all keys in this registry.\n   */\n\n\n  keys() {\n    return Object.keys(this.state.items);\n  }\n  /**\n   * Return all values in this registry.\n   * For loaders, they are invoked and their outputs are returned.\n   */\n\n\n  values() {\n    return this.keys().map(key => this.get(key));\n  }\n  /**\n   * Same with `.values()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  valuesAsPromise() {\n    return Promise.all(this.keys().map(key => this.getAsPromise(key)));\n  }\n  /**\n   * Return all key-value entries in this registry.\n   */\n\n\n  entries() {\n    return this.keys().map(key => ({\n      key,\n      value: this.get(key)\n    }));\n  }\n  /**\n   * Same with `.entries()` but return a `Promise` that resolves when all values are resolved.\n   */\n\n\n  entriesAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values => values.map((value, i) => ({\n      key: keys[i],\n      value\n    })));\n  }\n  /**\n   * Remove the item with the specified key.\n   * Do nothing if an item with the given key does not exist.\n   * @param key\n   */\n\n\n  remove(key) {\n    delete this.state.items[key];\n    delete this.state.promises[key];\n    return this;\n  }\n  /**\n   * Get number of items in the registry\n   */\n\n\n  size() {\n    return this.keys().length;\n  }\n  /**\n   * Returns true if there is no item in the registry\n   */\n\n\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}