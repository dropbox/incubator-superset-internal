{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { SupersetClient } from '@superset-ui/core';\nimport rison from 'rison';\nexport const OBJECT_TYPES_VALUES = Object.freeze([\n'dashboard',\n'chart',\n'saved_query']);\n\nexport const OBJECT_TYPES = Object.freeze({\n  DASHBOARD: 'dashboard',\n  CHART: 'chart',\n  QUERY: 'saved_query' });\n\nconst OBJECT_TYPE_ID_MAP = {\n  saved_query: 1,\n  chart: 2,\n  dashboard: 3 };\n\nconst map_object_type_to_id = (objectType) => {\n  if (!_includesInstanceProperty(OBJECT_TYPES_VALUES).call(OBJECT_TYPES_VALUES, objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  return OBJECT_TYPE_ID_MAP[objectType];\n};\nexport function fetchAllTags(callback, error) {\n  SupersetClient.get({ endpoint: `/api/v1/tag` }).\n  then((_ref) => {let { json } = _ref;return callback(json);}).\n  catch((response) => error(response));\n}\nexport function fetchTags(_ref2, callback, error) {let { objectType, objectId, includeTypes = false } = _ref2;\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!_includesInstanceProperty(OBJECT_TYPES_VALUES).call(OBJECT_TYPES_VALUES, objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.get({\n    endpoint: `/api/v1/${objectType}/${objectId}` }).\n\n  then((_ref3) => {let { json } = _ref3;return callback(json.result.tags.filter((tag) => tag.name.indexOf(':') === -1 || includeTypes));}).\n  catch((response) => error(response));\n}\nexport function deleteTaggedObjects(_ref4, tag, callback, error) {let { objectType, objectId } = _ref4;\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!_includesInstanceProperty(OBJECT_TYPES_VALUES).call(OBJECT_TYPES_VALUES, objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/${map_object_type_to_id(objectType)}/${objectId}/${tag.name}` }).\n\n  then((_ref5) => {let { json } = _ref5;return json ?\n    callback(JSON.stringify(json)) :\n    callback('Successfully Deleted Tagged Objects');}).\n  catch((response) => {\n    const err_str = response.message;\n    return err_str ? error(err_str) : error('Error Deleting Tagged Objects');\n  });\n}\nexport function deleteTags(tags, callback, error) {\n  const tag_names = tags.map((tag) => tag.name);\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/?q=${rison.encode(tag_names)}` }).\n\n  then((_ref6) => {let { json } = _ref6;return json.message ?\n    callback(json.message) :\n    callback('Successfully Deleted Tag');}).\n  catch((response) => {\n    const err_str = response.message;\n    return err_str ? error(err_str) : error('Error Deleting Tag');\n  });\n}\nexport function addTag(_ref7, tag, callback, error) {let { objectType, objectId, includeTypes = false } = _ref7;\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (tag.indexOf(':') !== -1 && !includeTypes) {\n    return;\n  }\n  const objectTypeId = map_object_type_to_id(objectType);\n  SupersetClient.post({\n    endpoint: `/api/v1/tag/${objectTypeId}/${objectId}/`,\n    body: JSON.stringify({\n      properties: {\n        tags: [tag] } }),\n\n\n    parseMethod: 'json',\n    headers: { 'Content-Type': 'application/json' } }).\n\n  then((_ref8) => {let { json } = _ref8;return callback(JSON.stringify(json));}).\n  catch((response) => error(response));\n}\nexport function fetchObjects(_ref9, callback, error) {let { tags = '', types } = _ref9;\n  let url = `/api/v1/tag/get_objects/?tags=${tags}`;\n  if (types) {\n    url += `&types=${types}`;\n  }\n  SupersetClient.get({ endpoint: url }).\n  then((_ref10) => {let { json } = _ref10;return callback(json.result);}).\n  catch((response) => error(response));\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(OBJECT_TYPES_VALUES, \"OBJECT_TYPES_VALUES\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(OBJECT_TYPES, \"OBJECT_TYPES\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(OBJECT_TYPE_ID_MAP, \"OBJECT_TYPE_ID_MAP\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(map_object_type_to_id, \"map_object_type_to_id\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(fetchAllTags, \"fetchAllTags\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(fetchTags, \"fetchTags\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(deleteTaggedObjects, \"deleteTaggedObjects\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(deleteTags, \"deleteTags\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(addTag, \"addTag\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");reactHotLoader.register(fetchObjects, \"fetchObjects\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["SupersetClient","rison","OBJECT_TYPES_VALUES","Object","freeze","OBJECT_TYPES","DASHBOARD","CHART","QUERY","OBJECT_TYPE_ID_MAP","saved_query","chart","dashboard","map_object_type_to_id","objectType","msg","Error","fetchAllTags","callback","error","get","endpoint","then","json","catch","response","fetchTags","objectId","includeTypes","undefined","result","tags","filter","tag","name","indexOf","deleteTaggedObjects","delete","JSON","stringify","err_str","message","deleteTags","tag_names","map","encode","addTag","objectTypeId","post","body","properties","parseMethod","headers","fetchObjects","types","url"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/features/tags/tags.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { JsonObject, SupersetClient } from '@superset-ui/core';\nimport rison from 'rison';\nimport Tag from 'src/types/TagType';\n\nexport const OBJECT_TYPES_VALUES = Object.freeze([\n  'dashboard',\n  'chart',\n  'saved_query',\n]);\n\nexport const OBJECT_TYPES = Object.freeze({\n  DASHBOARD: 'dashboard',\n  CHART: 'chart',\n  QUERY: 'saved_query',\n});\n\nconst OBJECT_TYPE_ID_MAP = {\n  saved_query: 1,\n  chart: 2,\n  dashboard: 3,\n};\n\nconst map_object_type_to_id = (objectType: string) => {\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  return OBJECT_TYPE_ID_MAP[objectType];\n};\n\nexport function fetchAllTags(\n  callback: (json: JsonObject) => void,\n  error: (response: Response) => void,\n) {\n  SupersetClient.get({ endpoint: `/api/v1/tag` })\n    .then(({ json }) => callback(json))\n    .catch(response => error(response));\n}\n\nexport function fetchTags(\n  {\n    objectType,\n    objectId,\n    includeTypes = false,\n  }: {\n    objectType: string;\n    objectId: number;\n    includeTypes: boolean;\n  },\n  callback: (json: JsonObject) => void,\n  error: (response: Response) => void,\n) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.get({\n    endpoint: `/api/v1/${objectType}/${objectId}`,\n  })\n    .then(({ json }) =>\n      callback(\n        json.result.tags.filter(\n          (tag: Tag) => tag.name.indexOf(':') === -1 || includeTypes,\n        ),\n      ),\n    )\n    .catch(response => error(response));\n}\nexport function deleteTaggedObjects(\n  { objectType, objectId }: { objectType: string; objectId: number },\n  tag: Tag,\n  callback: (text: string) => void,\n  error: (response: string) => void,\n) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/${map_object_type_to_id(objectType)}/${objectId}/${\n      tag.name\n    }`,\n  })\n    .then(({ json }) =>\n      json\n        ? callback(JSON.stringify(json))\n        : callback('Successfully Deleted Tagged Objects'),\n    )\n    .catch(response => {\n      const err_str = response.message;\n      return err_str ? error(err_str) : error('Error Deleting Tagged Objects');\n    });\n}\n\nexport function deleteTags(\n  tags: Tag[],\n  callback: (text: string) => void,\n  error: (response: string) => void,\n) {\n  const tag_names = tags.map(tag => tag.name) as string[];\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/?q=${rison.encode(tag_names)}`,\n  })\n    .then(({ json }) =>\n      json.message\n        ? callback(json.message)\n        : callback('Successfully Deleted Tag'),\n    )\n    .catch(response => {\n      const err_str = response.message;\n      return err_str ? error(err_str) : error('Error Deleting Tag');\n    });\n}\n\nexport function addTag(\n  {\n    objectType,\n    objectId,\n    includeTypes = false,\n  }: {\n    objectType: string;\n    objectId: number;\n    includeTypes: boolean;\n  },\n  tag: string,\n  callback: (text: string) => void,\n  error: (response: Response) => void,\n) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (tag.indexOf(':') !== -1 && !includeTypes) {\n    return;\n  }\n  const objectTypeId = map_object_type_to_id(objectType);\n  SupersetClient.post({\n    endpoint: `/api/v1/tag/${objectTypeId}/${objectId}/`,\n    body: JSON.stringify({\n      properties: {\n        tags: [tag],\n      },\n    }),\n    parseMethod: 'json',\n    headers: { 'Content-Type': 'application/json' },\n  })\n    .then(({ json }) => callback(JSON.stringify(json)))\n    .catch(response => error(response));\n}\n\nexport function fetchObjects(\n  { tags = '', types }: { tags: string; types: string | null },\n  callback: (json: JsonObject) => void,\n  error: (response: Response) => void,\n) {\n  let url = `/api/v1/tag/get_objects/?tags=${tags}`;\n  if (types) {\n    url += `&types=${types}`;\n  }\n  SupersetClient.get({ endpoint: url })\n    .then(({ json }) => callback(json.result))\n    .catch(response => error(response));\n}\n"]},"metadata":{},"sourceType":"module"}