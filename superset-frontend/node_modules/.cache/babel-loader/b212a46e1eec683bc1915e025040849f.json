{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, FeatureFlag, makeApi, SupersetClient, logging } from '@superset-ui/core';\nimport getBootstrapData from 'src/utils/getBootstrapData';\nimport { isFeatureEnabled } from '../featureFlags';\nimport { getClientErrorObject, parseErrorJson } from '../utils/getClientErrorObject';\nconst TRANSPORT_POLLING = 'polling';\nconst TRANSPORT_WS = 'ws';\nconst JOB_STATUS = {\n  PENDING: 'pending',\n  RUNNING: 'running',\n  ERROR: 'error',\n  DONE: 'done' };\n\nconst LOCALSTORAGE_KEY = 'last_async_event_id';\nconst POLLING_URL = '/api/v1/async_event/';\nconst MAX_RETRIES = 6;\nconst RETRY_DELAY = 100;\nlet config;\nlet transport;\nlet pollingDelayMs;\nlet pollingTimeoutId;\nlet listenersByJobId;\nlet retriesByJobId;\nlet lastReceivedEventId;\nconst addListener = (id, fn) => {\n  listenersByJobId[id] = fn;\n};\nconst removeListener = (id) => {\n  if (!listenersByJobId[id])\n  return;\n  delete listenersByJobId[id];\n};\nconst fetchCachedData = async (asyncEvent) => {\n  let status = 'success';\n  let data;\n  try {\n    const { json } = await SupersetClient.get({\n      endpoint: String(asyncEvent.result_url) });\n\n    data = 'result' in json ? json.result : json;\n  }\n  catch (response) {\n    status = 'error';\n    data = await getClientErrorObject(response);\n  }\n  return { status, data };\n};\nexport const waitForAsyncData = async (asyncResponse) => new Promise((resolve, reject) => {\n  const jobId = asyncResponse.job_id;\n  const listener = async (asyncEvent) => {\n    switch (asyncEvent.status) {\n      case JOB_STATUS.DONE:{\n          let { data, status } = await fetchCachedData(asyncEvent); // eslint-disable-line prefer-const\n          data = ensureIsArray(data);\n          if (status === 'success') {\n            resolve(data);\n          } else\n          {\n            reject(data);\n          }\n          break;\n        }\n      case JOB_STATUS.ERROR:{\n          const err = parseErrorJson(asyncEvent);\n          reject(err);\n          break;\n        }\n      default:{\n          logging.warn('received event with status', asyncEvent.status);\n        }}\n\n    removeListener(jobId);\n  };\n  addListener(jobId, listener);\n});\nconst fetchEvents = makeApi({\n  method: 'GET',\n  endpoint: POLLING_URL });\n\nconst setLastId = (asyncEvent) => {\n  lastReceivedEventId = asyncEvent.id;\n  try {\n    localStorage.setItem(LOCALSTORAGE_KEY, lastReceivedEventId);\n  }\n  catch (err) {\n    logging.warn('Error saving event Id to localStorage', err);\n  }\n};\nexport const processEvents = async (events) => {\n  events.forEach((asyncEvent) => {\n    const jobId = asyncEvent.job_id;\n    const listener = listenersByJobId[jobId];\n    if (listener) {\n      listener(asyncEvent);\n      delete retriesByJobId[jobId];\n    } else\n    {\n      // handle race condition where event is received\n      // before listener is registered\n      if (!retriesByJobId[jobId])\n      retriesByJobId[jobId] = 0;\n      retriesByJobId[jobId] += 1;\n      if (retriesByJobId[jobId] <= MAX_RETRIES) {\n        setTimeout(() => {\n          processEvents([asyncEvent]);\n        }, RETRY_DELAY * retriesByJobId[jobId]);\n      } else\n      {\n        delete retriesByJobId[jobId];\n        logging.warn('listener not found for job_id', asyncEvent.job_id);\n      }\n    }\n    setLastId(asyncEvent);\n  });\n};\nconst loadEventsFromApi = async () => {\n  const eventArgs = lastReceivedEventId ? { last_id: lastReceivedEventId } : {};\n  if (Object.keys(listenersByJobId).length) {\n    try {\n      const { result: events } = await fetchEvents(eventArgs);\n      if (events != null && events.length)\n      await processEvents(events);\n    }\n    catch (err) {\n      logging.warn(err);\n    }\n  }\n  if (transport === TRANSPORT_POLLING) {\n    pollingTimeoutId = window.setTimeout(loadEventsFromApi, pollingDelayMs);\n  }\n};\nconst wsConnectMaxRetries = 6;\nconst wsConnectErrorDelay = 2500;\nlet wsConnectRetries = 0;\nlet wsConnectTimeout;\nlet ws;\nconst wsConnect = () => {\n  let url = config.GLOBAL_ASYNC_QUERIES_WEBSOCKET_URL;\n  if (lastReceivedEventId)\n  url += `?last_id=${lastReceivedEventId}`;\n  ws = new WebSocket(url);\n  ws.addEventListener('open', () => {\n    logging.log('WebSocket connected');\n    clearTimeout(wsConnectTimeout);\n    wsConnectRetries = 0;\n  });\n  ws.addEventListener('close', () => {\n    wsConnectTimeout = setTimeout(() => {\n      wsConnectRetries += 1;\n      if (wsConnectRetries <= wsConnectMaxRetries) {\n        wsConnect();\n      } else\n      {\n        logging.warn('WebSocket not available, falling back to async polling');\n        loadEventsFromApi();\n      }\n    }, wsConnectErrorDelay);\n  });\n  ws.addEventListener('error', () => {\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n    if (ws.readyState < 2)\n    ws.close();\n  });\n  ws.addEventListener('message', async (event) => {\n    let events = [];\n    try {\n      events = [JSON.parse(event.data)];\n      await processEvents(events);\n    }\n    catch (err) {\n      logging.warn(err);\n    }\n  });\n};\nexport const init = (appConfig) => {\n  if (!isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES))\n  return;\n  if (pollingTimeoutId)\n  clearTimeout(pollingTimeoutId);\n  listenersByJobId = {};\n  retriesByJobId = {};\n  lastReceivedEventId = null;\n  config = appConfig || getBootstrapData().common.conf;\n  transport = config.GLOBAL_ASYNC_QUERIES_TRANSPORT || TRANSPORT_POLLING;\n  pollingDelayMs = config.GLOBAL_ASYNC_QUERIES_POLLING_DELAY || 500;\n  try {\n    lastReceivedEventId = localStorage.getItem(LOCALSTORAGE_KEY);\n  }\n  catch (err) {\n    logging.warn('Failed to fetch last event Id from localStorage');\n  }\n  if (transport === TRANSPORT_POLLING) {\n    loadEventsFromApi();\n  }\n  if (transport === TRANSPORT_WS) {\n    wsConnect();\n  }\n};\ninit();;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(TRANSPORT_POLLING, \"TRANSPORT_POLLING\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(TRANSPORT_WS, \"TRANSPORT_WS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(JOB_STATUS, \"JOB_STATUS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(LOCALSTORAGE_KEY, \"LOCALSTORAGE_KEY\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(POLLING_URL, \"POLLING_URL\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(MAX_RETRIES, \"MAX_RETRIES\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(RETRY_DELAY, \"RETRY_DELAY\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(config, \"config\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(transport, \"transport\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(pollingDelayMs, \"pollingDelayMs\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(pollingTimeoutId, \"pollingTimeoutId\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(listenersByJobId, \"listenersByJobId\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(retriesByJobId, \"retriesByJobId\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(lastReceivedEventId, \"lastReceivedEventId\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(addListener, \"addListener\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(removeListener, \"removeListener\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(fetchCachedData, \"fetchCachedData\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(waitForAsyncData, \"waitForAsyncData\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(fetchEvents, \"fetchEvents\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(setLastId, \"setLastId\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(processEvents, \"processEvents\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(loadEventsFromApi, \"loadEventsFromApi\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(wsConnectMaxRetries, \"wsConnectMaxRetries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(wsConnectErrorDelay, \"wsConnectErrorDelay\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(wsConnectRetries, \"wsConnectRetries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(wsConnectTimeout, \"wsConnectTimeout\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(ws, \"ws\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(wsConnect, \"wsConnect\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(init, \"init\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"wSAAA;;;;;;;;;;;;;;;;;;AAkBA,SACEA,aADF,EAEEC,WAFF,EAGEC,OAHF,EAIEC,cAJF,EAKEC,OALF,QAMO,mBANP;AAQA,OAAOC,gBAAP,MAA6B,4BAA7B;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,SACEC,oBADF,EAEEC,cAFF,QAGO,+BAHP;AAsBA,MAAMC,iBAAiB,GAAG,SAA1B;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,UAAU,GAAG;EACjBC,OAAO,EAAE,SADQ;EAEjBC,OAAO,EAAE,SAFQ;EAGjBC,KAAK,EAAE,OAHU;EAIjBC,IAAI,EAAE,MAJW,EAAnB;;AAMA,MAAMC,gBAAgB,GAAG,qBAAzB;AACA,MAAMC,WAAW,GAAG,sBAApB;AACA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,WAAW,GAAG,GAApB;AAEA,IAAIC,MAAJ;AACA,IAAIC,SAAJ;AACA,IAAIC,cAAJ;AACA,IAAIC,gBAAJ;AACA,IAAIC,gBAAJ;AACA,IAAIC,cAAJ;AACA,IAAIC,mBAAJ;AAEA,MAAMC,WAAW,GAAG,CAACC,EAAD,EAAaC,EAAb,KAAwB;EAC1CL,gBAAgB,CAACI,EAAD,CAAhB,GAAuBC,EAAvB;AACD,CAFD;AAIA,MAAMC,cAAc,GAAG,CAACF,EAAD,KAAe;EACpC,IAAI,CAACJ,gBAAgB,CAACI,EAAD,CAArB;EAA2B;EAC3B,OAAOJ,gBAAgB,CAACI,EAAD,CAAvB;AACD,CAHD;AAKA,MAAMG,eAAe,GAAG,OACtBC,UADsB,KAES;EAC/B,IAAIC,MAAM,GAAG,SAAb;EACA,IAAIC,IAAJ;EACA,IAAI;IACF,MAAM,EAAEC,IAAF,KAAW,MAAMhC,cAAc,CAACiC,GAAf,CAAmB;MACxCC,QAAQ,EAAEC,MAAM,CAACN,UAAU,CAACO,UAAZ,CADwB,EAAnB,CAAvB;;IAGAL,IAAI,GAAG,YAAYC,IAAZ,GAAmBA,IAAI,CAACK,MAAxB,GAAiCL,IAAxC;EACD;EAAC,OAAOM,QAAP,EAAiB;IACjBR,MAAM,GAAG,OAAT;IACAC,IAAI,GAAG,MAAM3B,oBAAoB,CAACkC,QAAD,CAAjC;EACD;EAED,OAAO,EAAER,MAAF,EAAUC,IAAV,EAAP;AACD,CAhBD;AAkBA,OAAO,MAAMQ,gBAAgB,GAAG,OAAOC,aAAP,KAC9B,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;EAC9B,MAAMC,KAAK,GAAGJ,aAAa,CAACK,MAA5B;EACA,MAAMC,QAAQ,GAAG,OAAOjB,UAAP,KAAiC;IAChD,QAAQA,UAAU,CAACC,MAAnB;MACE,KAAKtB,UAAU,CAACI,IAAhB,CAAsB;UACpB,IAAI,EAAEmB,IAAF,EAAQD,MAAR,KAAmB,MAAMF,eAAe,CAACC,UAAD,CAA5C,CADoB,CACsC;UAC1DE,IAAI,GAAGlC,aAAa,CAACkC,IAAD,CAApB;UACA,IAAID,MAAM,KAAK,SAAf,EAA0B;YACxBY,OAAO,CAACX,IAAD,CAAP;UACD,CAFD;UAEO;YACLY,MAAM,CAACZ,IAAD,CAAN;UACD;UACD;QACD;MACD,KAAKvB,UAAU,CAACG,KAAhB,CAAuB;UACrB,MAAMoC,GAAG,GAAG1C,cAAc,CAACwB,UAAD,CAA1B;UACAc,MAAM,CAACI,GAAD,CAAN;UACA;QACD;MACD,QAAS;UACP9C,OAAO,CAAC+C,IAAR,CAAa,4BAAb,EAA2CnB,UAAU,CAACC,MAAtD;QACD,CAlBH;;IAoBAH,cAAc,CAACiB,KAAD,CAAd;EACD,CAtBD;EAuBApB,WAAW,CAACoB,KAAD,EAAQE,QAAR,CAAX;AACD,CA1BD,CADK;AA6BP,MAAMG,WAAW,GAAGlD,OAAO,CAGzB;EACAmD,MAAM,EAAE,KADR;EAEAhB,QAAQ,EAAEpB,WAFV,EAHyB,CAA3B;;AAQA,MAAMqC,SAAS,GAAG,CAACtB,UAAD,KAA2B;EAC3CN,mBAAmB,GAAGM,UAAU,CAACJ,EAAjC;EACA,IAAI;IACF2B,YAAY,CAACC,OAAb,CAAqBxC,gBAArB,EAAuCU,mBAAvC;EACD;EAAC,OAAOwB,GAAP,EAAY;IACZ9C,OAAO,CAAC+C,IAAR,CAAa,uCAAb,EAAsDD,GAAtD;EACD;AACF,CAPD;AASA,OAAO,MAAMO,aAAa,GAAG,OAAOC,MAAP,KAA+B;EAC1DA,MAAM,CAACC,OAAP,CAAe,CAAC3B,UAAD,KAA2B;IACxC,MAAMe,KAAK,GAAGf,UAAU,CAACgB,MAAzB;IACA,MAAMC,QAAQ,GAAGzB,gBAAgB,CAACuB,KAAD,CAAjC;IACA,IAAIE,QAAJ,EAAc;MACZA,QAAQ,CAACjB,UAAD,CAAR;MACA,OAAOP,cAAc,CAACsB,KAAD,CAArB;IACD,CAHD;IAGO;MACL;MACA;MACA,IAAI,CAACtB,cAAc,CAACsB,KAAD,CAAnB;MAA4BtB,cAAc,CAACsB,KAAD,CAAd,GAAwB,CAAxB;MAC5BtB,cAAc,CAACsB,KAAD,CAAd,IAAyB,CAAzB;MAEA,IAAItB,cAAc,CAACsB,KAAD,CAAd,IAAyB7B,WAA7B,EAA0C;QACxC0C,UAAU,CAAC,MAAK;UACdH,aAAa,CAAC,CAACzB,UAAD,CAAD,CAAb;QACD,CAFS,EAEPb,WAAW,GAAGM,cAAc,CAACsB,KAAD,CAFrB,CAAV;MAGD,CAJD;MAIO;QACL,OAAOtB,cAAc,CAACsB,KAAD,CAArB;QACA3C,OAAO,CAAC+C,IAAR,CAAa,+BAAb,EAA8CnB,UAAU,CAACgB,MAAzD;MACD;IACF;IACDM,SAAS,CAACtB,UAAD,CAAT;EACD,CAtBD;AAuBD,CAxBM;AA0BP,MAAM6B,iBAAiB,GAAG,YAAW;EACnC,MAAMC,SAAS,GAAGpC,mBAAmB,GAAG,EAAEqC,OAAO,EAAErC,mBAAX,EAAH,GAAsC,EAA3E;EACA,IAAIsC,MAAM,CAACC,IAAP,CAAYzC,gBAAZ,EAA8B0C,MAAlC,EAA0C;IACxC,IAAI;MACF,MAAM,EAAE1B,MAAM,EAAEkB,MAAV,KAAqB,MAAMN,WAAW,CAACU,SAAD,CAA5C;MACA,IAAIJ,MAAJ,YAAIA,MAAM,CAAEQ,MAAZ;MAAoB,MAAMT,aAAa,CAACC,MAAD,CAAnB;IACrB;IAAC,OAAOR,GAAP,EAAY;MACZ9C,OAAO,CAAC+C,IAAR,CAAaD,GAAb;IACD;EACF;EAED,IAAI7B,SAAS,KAAKZ,iBAAlB,EAAqC;IACnCc,gBAAgB,GAAG4C,MAAM,CAACP,UAAP,CAAkBC,iBAAlB,EAAqCvC,cAArC,CAAnB;EACD;AACF,CAdD;AAgBA,MAAM8C,mBAAmB,GAAG,CAA5B;AACA,MAAMC,mBAAmB,GAAG,IAA5B;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,gBAAJ;AACA,IAAIC,EAAJ;AAEA,MAAMC,SAAS,GAAG,MAAW;EAC3B,IAAIC,GAAG,GAAGtD,MAAM,CAACuD,kCAAjB;EACA,IAAIjD,mBAAJ;EAAyBgD,GAAG,IAAI,YAAYhD,mBAAmB,EAAtC;EACzB8C,EAAE,GAAG,IAAII,SAAJ,CAAcF,GAAd,CAAL;EAEAF,EAAE,CAACK,gBAAH,CAAoB,MAApB,EAA4B,MAAK;IAC/BzE,OAAO,CAAC0E,GAAR,CAAY,qBAAZ;IACAC,YAAY,CAACR,gBAAD,CAAZ;IACAD,gBAAgB,GAAG,CAAnB;EACD,CAJD;EAMAE,EAAE,CAACK,gBAAH,CAAoB,OAApB,EAA6B,MAAK;IAChCN,gBAAgB,GAAGX,UAAU,CAAC,MAAK;MACjCU,gBAAgB,IAAI,CAApB;MACA,IAAIA,gBAAgB,IAAIF,mBAAxB,EAA6C;QAC3CK,SAAS;MACV,CAFD;MAEO;QACLrE,OAAO,CAAC+C,IAAR,CAAa,wDAAb;QACAU,iBAAiB;MAClB;IACF,CAR4B,EAQ1BQ,mBAR0B,CAA7B;EASD,CAVD;EAYAG,EAAE,CAACK,gBAAH,CAAoB,OAApB,EAA6B,MAAK;IAChC;IACA,IAAIL,EAAE,CAACQ,UAAH,GAAgB,CAApB;IAAuBR,EAAE,CAACS,KAAH;EACxB,CAHD;EAKAT,EAAE,CAACK,gBAAH,CAAoB,SAApB,EAA+B,OAAMK,KAAN,KAAc;IAC3C,IAAIxB,MAAM,GAAiB,EAA3B;IACA,IAAI;MACFA,MAAM,GAAG,CAACyB,IAAI,CAACC,KAAL,CAAWF,KAAK,CAAChD,IAAjB,CAAD,CAAT;MACA,MAAMuB,aAAa,CAACC,MAAD,CAAnB;IACD;IAAC,OAAOR,GAAP,EAAY;MACZ9C,OAAO,CAAC+C,IAAR,CAAaD,GAAb;IACD;EACF,CARD;AASD,CArCD;AAuCA,OAAO,MAAMmC,IAAI,GAAG,CAACC,SAAD,KAA0B;EAC5C,IAAI,CAAChF,gBAAgB,CAACL,WAAW,CAACsF,oBAAb,CAArB;EAAyD;EACzD,IAAIhE,gBAAJ;EAAsBwD,YAAY,CAACxD,gBAAD,CAAZ;EAEtBC,gBAAgB,GAAG,EAAnB;EACAC,cAAc,GAAG,EAAjB;EACAC,mBAAmB,GAAG,IAAtB;EAEAN,MAAM,GAAGkE,SAAS,IAAIjF,gBAAgB,GAAGmF,MAAnB,CAA0BC,IAAhD;EACApE,SAAS,GAAGD,MAAM,CAACsE,8BAAP,IAAyCjF,iBAArD;EACAa,cAAc,GAAGF,MAAM,CAACuE,kCAAP,IAA6C,GAA9D;EAEA,IAAI;IACFjE,mBAAmB,GAAG6B,YAAY,CAACqC,OAAb,CAAqB5E,gBAArB,CAAtB;EACD;EAAC,OAAOkC,GAAP,EAAY;IACZ9C,OAAO,CAAC+C,IAAR,CAAa,iDAAb;EACD;EAED,IAAI9B,SAAS,KAAKZ,iBAAlB,EAAqC;IACnCoD,iBAAiB;EAClB;EACD,IAAIxC,SAAS,KAAKX,YAAlB,EAAgC;IAC9B+D,SAAS;EACV;AACF,CAxBM;AA0BPY,IAAI,G,iLA/ME5E,iB,gJACAC,Y,2IACAC,U,yIAMAK,gB,+IACAC,W,0IACAC,W,0IACAC,W,0IAEFC,M,qIACAC,S,wIACAC,c,6IACAC,gB,+IACAC,gB,+IACAC,c,6IACAC,mB,kJAEEC,W,0IAIAG,c,6IAKAC,e,8IAkBOW,gB,+IA6BPU,W,0IAQAE,S,wIASOG,a,4IA0BPI,iB,gJAgBAO,mB,kJACAC,mB,kJACFC,gB,+IACAC,gB,+IACAC,E,iIAEEC,S,wIAuCOY,I","names":["ensureIsArray","FeatureFlag","makeApi","SupersetClient","logging","getBootstrapData","isFeatureEnabled","getClientErrorObject","parseErrorJson","TRANSPORT_POLLING","TRANSPORT_WS","JOB_STATUS","PENDING","RUNNING","ERROR","DONE","LOCALSTORAGE_KEY","POLLING_URL","MAX_RETRIES","RETRY_DELAY","config","transport","pollingDelayMs","pollingTimeoutId","listenersByJobId","retriesByJobId","lastReceivedEventId","addListener","id","fn","removeListener","fetchCachedData","asyncEvent","status","data","json","get","endpoint","String","result_url","result","response","waitForAsyncData","asyncResponse","Promise","resolve","reject","jobId","job_id","listener","err","warn","fetchEvents","method","setLastId","localStorage","setItem","processEvents","events","forEach","setTimeout","loadEventsFromApi","eventArgs","last_id","Object","keys","length","window","wsConnectMaxRetries","wsConnectErrorDelay","wsConnectRetries","wsConnectTimeout","ws","wsConnect","url","GLOBAL_ASYNC_QUERIES_WEBSOCKET_URL","WebSocket","addEventListener","log","clearTimeout","readyState","close","event","JSON","parse","init","appConfig","GLOBAL_ASYNC_QUERIES","common","conf","GLOBAL_ASYNC_QUERIES_TRANSPORT","GLOBAL_ASYNC_QUERIES_POLLING_DELAY","getItem"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/middleware/asyncEvent.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  ensureIsArray,\n  FeatureFlag,\n  makeApi,\n  SupersetClient,\n  logging,\n} from '@superset-ui/core';\nimport { SupersetError } from 'src/components/ErrorMessage/types';\nimport getBootstrapData from 'src/utils/getBootstrapData';\nimport { isFeatureEnabled } from '../featureFlags';\nimport {\n  getClientErrorObject,\n  parseErrorJson,\n} from '../utils/getClientErrorObject';\n\ntype AsyncEvent = {\n  id?: string | null;\n  channel_id: string;\n  job_id: string;\n  user_id?: string;\n  status: string;\n  errors?: SupersetError[];\n  result_url: string | null;\n};\n\ntype CachedDataResponse = {\n  status: string;\n  data: any;\n};\ntype AppConfig = Record<string, any>;\ntype ListenerFn = (asyncEvent: AsyncEvent) => Promise<any>;\n\nconst TRANSPORT_POLLING = 'polling';\nconst TRANSPORT_WS = 'ws';\nconst JOB_STATUS = {\n  PENDING: 'pending',\n  RUNNING: 'running',\n  ERROR: 'error',\n  DONE: 'done',\n};\nconst LOCALSTORAGE_KEY = 'last_async_event_id';\nconst POLLING_URL = '/api/v1/async_event/';\nconst MAX_RETRIES = 6;\nconst RETRY_DELAY = 100;\n\nlet config: AppConfig;\nlet transport: string;\nlet pollingDelayMs: number;\nlet pollingTimeoutId: number;\nlet listenersByJobId: Record<string, ListenerFn>;\nlet retriesByJobId: Record<string, number>;\nlet lastReceivedEventId: string | null | undefined;\n\nconst addListener = (id: string, fn: any) => {\n  listenersByJobId[id] = fn;\n};\n\nconst removeListener = (id: string) => {\n  if (!listenersByJobId[id]) return;\n  delete listenersByJobId[id];\n};\n\nconst fetchCachedData = async (\n  asyncEvent: AsyncEvent,\n): Promise<CachedDataResponse> => {\n  let status = 'success';\n  let data;\n  try {\n    const { json } = await SupersetClient.get({\n      endpoint: String(asyncEvent.result_url),\n    });\n    data = 'result' in json ? json.result : json;\n  } catch (response) {\n    status = 'error';\n    data = await getClientErrorObject(response);\n  }\n\n  return { status, data };\n};\n\nexport const waitForAsyncData = async (asyncResponse: AsyncEvent) =>\n  new Promise((resolve, reject) => {\n    const jobId = asyncResponse.job_id;\n    const listener = async (asyncEvent: AsyncEvent) => {\n      switch (asyncEvent.status) {\n        case JOB_STATUS.DONE: {\n          let { data, status } = await fetchCachedData(asyncEvent); // eslint-disable-line prefer-const\n          data = ensureIsArray(data);\n          if (status === 'success') {\n            resolve(data);\n          } else {\n            reject(data);\n          }\n          break;\n        }\n        case JOB_STATUS.ERROR: {\n          const err = parseErrorJson(asyncEvent);\n          reject(err);\n          break;\n        }\n        default: {\n          logging.warn('received event with status', asyncEvent.status);\n        }\n      }\n      removeListener(jobId);\n    };\n    addListener(jobId, listener);\n  });\n\nconst fetchEvents = makeApi<\n  { last_id?: string | null },\n  { result: AsyncEvent[] }\n>({\n  method: 'GET',\n  endpoint: POLLING_URL,\n});\n\nconst setLastId = (asyncEvent: AsyncEvent) => {\n  lastReceivedEventId = asyncEvent.id;\n  try {\n    localStorage.setItem(LOCALSTORAGE_KEY, lastReceivedEventId as string);\n  } catch (err) {\n    logging.warn('Error saving event Id to localStorage', err);\n  }\n};\n\nexport const processEvents = async (events: AsyncEvent[]) => {\n  events.forEach((asyncEvent: AsyncEvent) => {\n    const jobId = asyncEvent.job_id;\n    const listener = listenersByJobId[jobId];\n    if (listener) {\n      listener(asyncEvent);\n      delete retriesByJobId[jobId];\n    } else {\n      // handle race condition where event is received\n      // before listener is registered\n      if (!retriesByJobId[jobId]) retriesByJobId[jobId] = 0;\n      retriesByJobId[jobId] += 1;\n\n      if (retriesByJobId[jobId] <= MAX_RETRIES) {\n        setTimeout(() => {\n          processEvents([asyncEvent]);\n        }, RETRY_DELAY * retriesByJobId[jobId]);\n      } else {\n        delete retriesByJobId[jobId];\n        logging.warn('listener not found for job_id', asyncEvent.job_id);\n      }\n    }\n    setLastId(asyncEvent);\n  });\n};\n\nconst loadEventsFromApi = async () => {\n  const eventArgs = lastReceivedEventId ? { last_id: lastReceivedEventId } : {};\n  if (Object.keys(listenersByJobId).length) {\n    try {\n      const { result: events } = await fetchEvents(eventArgs);\n      if (events?.length) await processEvents(events);\n    } catch (err) {\n      logging.warn(err);\n    }\n  }\n\n  if (transport === TRANSPORT_POLLING) {\n    pollingTimeoutId = window.setTimeout(loadEventsFromApi, pollingDelayMs);\n  }\n};\n\nconst wsConnectMaxRetries = 6;\nconst wsConnectErrorDelay = 2500;\nlet wsConnectRetries = 0;\nlet wsConnectTimeout: any;\nlet ws: WebSocket;\n\nconst wsConnect = (): void => {\n  let url = config.GLOBAL_ASYNC_QUERIES_WEBSOCKET_URL;\n  if (lastReceivedEventId) url += `?last_id=${lastReceivedEventId}`;\n  ws = new WebSocket(url);\n\n  ws.addEventListener('open', () => {\n    logging.log('WebSocket connected');\n    clearTimeout(wsConnectTimeout);\n    wsConnectRetries = 0;\n  });\n\n  ws.addEventListener('close', () => {\n    wsConnectTimeout = setTimeout(() => {\n      wsConnectRetries += 1;\n      if (wsConnectRetries <= wsConnectMaxRetries) {\n        wsConnect();\n      } else {\n        logging.warn('WebSocket not available, falling back to async polling');\n        loadEventsFromApi();\n      }\n    }, wsConnectErrorDelay);\n  });\n\n  ws.addEventListener('error', () => {\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n    if (ws.readyState < 2) ws.close();\n  });\n\n  ws.addEventListener('message', async event => {\n    let events: AsyncEvent[] = [];\n    try {\n      events = [JSON.parse(event.data)];\n      await processEvents(events);\n    } catch (err) {\n      logging.warn(err);\n    }\n  });\n};\n\nexport const init = (appConfig?: AppConfig) => {\n  if (!isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES)) return;\n  if (pollingTimeoutId) clearTimeout(pollingTimeoutId);\n\n  listenersByJobId = {};\n  retriesByJobId = {};\n  lastReceivedEventId = null;\n\n  config = appConfig || getBootstrapData().common.conf;\n  transport = config.GLOBAL_ASYNC_QUERIES_TRANSPORT || TRANSPORT_POLLING;\n  pollingDelayMs = config.GLOBAL_ASYNC_QUERIES_POLLING_DELAY || 500;\n\n  try {\n    lastReceivedEventId = localStorage.getItem(LOCALSTORAGE_KEY);\n  } catch (err) {\n    logging.warn('Failed to fetch last event Id from localStorage');\n  }\n\n  if (transport === TRANSPORT_POLLING) {\n    loadEventsFromApi();\n  }\n  if (transport === TRANSPORT_WS) {\n    wsConnect();\n  }\n};\n\ninit();\n"]},"metadata":{},"sourceType":"module"}