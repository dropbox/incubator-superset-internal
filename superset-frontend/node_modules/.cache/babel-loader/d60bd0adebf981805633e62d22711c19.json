{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport 'whatwg-fetch';\nimport fetchRetry from 'fetch-retry';\nimport { CACHE_AVAILABLE, CACHE_KEY, HTTP_STATUS_NOT_MODIFIED, HTTP_STATUS_OK } from '../constants';\nfunction tryParsePayload(payload) {\n  try {\n    return typeof payload === 'string' ?\n    JSON.parse(payload) :\n    payload;\n  }\n  catch (error) {\n    throw new Error(`Invalid payload:\\n\\n${payload}`);\n  }\n}\n/**\n * Try appending search params to an URL if needed.\n */\nfunction getFullUrl(partialUrl, params) {\n  if (params) {\n    const url = new URL(partialUrl, window.location.href);\n    const search = params instanceof URLSearchParams ? params : new URLSearchParams(params);\n    // will completely override any existing search params\n    url.search = search.toString();\n    return url.href;\n  }\n  return partialUrl;\n}\n/**\n * Fetch an API response and returns the corresponding json.\n *\n * @param {Payload} postPayload payload to send as FormData in a post form\n * @param {Payload} jsonPayload json payload to post, will automatically add Content-Type header\n * @param {string} stringify whether to stringify field values when post as formData\n */\nexport default async function callApi(_ref) {var _window$location;let { body, cache = 'default', credentials = 'same-origin', fetchRetryOptions, headers, method = 'GET', mode = 'same-origin', postPayload, jsonPayload, redirect = 'follow', signal, stringify = true, url: url_, searchParams } = _ref;\n  const fetchWithRetry = fetchRetry(fetch, fetchRetryOptions);\n  const url = `${getFullUrl(url_, searchParams)}`;\n  const request = {\n    body,\n    cache,\n    credentials,\n    headers,\n    method,\n    mode,\n    redirect,\n    signal };\n\n  if (method === 'GET' &&\n  cache !== 'no-store' &&\n  cache !== 'reload' &&\n  CACHE_AVAILABLE &&\n  ((_window$location = window.location) == null ? void 0 : _window$location.protocol) === 'https:') {\n    let supersetCache = null;\n    try {\n      supersetCache = await caches.open(CACHE_KEY);\n      const cachedResponse = await supersetCache.match(url);\n      if (cachedResponse) {\n        // if we have a cached response, send its ETag in the\n        // `If-None-Match` header in a conditional request\n        const etag = cachedResponse.headers.get('Etag');\n        request.headers = { ...request.headers, 'If-None-Match': etag };\n      }\n    }\n    catch {\n      // If superset is in an iframe and third-party cookies are disabled, caches.open throws\n    }\n    const response = await fetchWithRetry(url, request);\n    if (supersetCache && response.status === HTTP_STATUS_NOT_MODIFIED) {\n      const cachedFullResponse = await supersetCache.match(url);\n      if (cachedFullResponse) {\n        return cachedFullResponse.clone();\n      }\n      throw new Error('Received 304 but no content is cached!');\n    }\n    if (supersetCache &&\n    response.status === HTTP_STATUS_OK &&\n    response.headers.get('Etag')) {\n      supersetCache.delete(url);\n      supersetCache.put(url, response.clone());\n    }\n    return response;\n  }\n  if (method === 'POST' || method === 'PATCH' || method === 'PUT') {\n    if (postPayload && jsonPayload) {\n      throw new Error('Please provide only one of jsonPayload or postPayload');\n    }\n    if (postPayload instanceof FormData) {\n      request.body = postPayload;\n    } else\n    if (postPayload) {\n      const payload = tryParsePayload(postPayload);\n      if (payload && typeof payload === 'object') {\n        // using FormData has the effect that Content-Type header is set to `multipart/form-data`,\n        // not e.g., 'application/x-www-form-urlencoded'\n        const formData = new FormData();\n        Object.keys(payload).forEach((key) => {\n          const value = payload[key];\n          if (typeof value !== 'undefined') {\n            let valueString;\n            try {\n              // We have seen instances where casting to String() throws error\n              // This check allows all valid attributes to be appended to the formData\n              // while logging error to console for any attribute that fails the cast to String\n              valueString = stringify ? JSON.stringify(value) : String(value);\n            }\n            catch (e) {\n              // eslint-disable-next-line no-console\n              console.error(`Unable to convert attribute '${key}' to a String(). '${key}' was not added to the formData in request.body for call to ${url}`, value, e);\n            }\n            if (valueString !== undefined) {\n              formData.append(key, valueString);\n            }\n          }\n        });\n        request.body = formData;\n      }\n    }\n    if (jsonPayload !== undefined) {\n      request.body = JSON.stringify(jsonPayload);\n      request.headers = {\n        ...request.headers,\n        'Content-Type': 'application/json' };\n\n    }\n  }\n  return fetchWithRetry(url, request);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAmBA,OAAO,cAAP;AACA,OAAOA,UAAP,MAAuB,aAAvB;AAEA,SACEC,eADF,EAEEC,SAFF,EAGEC,wBAHF,EAIEC,cAJF,QAKO,cALP;AAOA,SAASC,eAAT,CAAyBC,OAAzB,EAAyC;EACvC,IAAI;IACF,OAAO,OAAOA,OAAP,KAAmB,QAAnB;IACFC,IAAI,CAACC,KAAL,CAAWF,OAAX,CADE;IAEHA,OAFJ;EAGD;EAAC,OAAOG,KAAP,EAAc;IACd,MAAM,IAAIC,KAAJ,CAAU,uBAAuBJ,OAAO,EAAxC,CAAN;EACD;AACF;AAED;;;AAGA,SAASK,UAAT,CAAoBC,UAApB,EAAwCC,MAAxC,EAAuE;EACrE,IAAIA,MAAJ,EAAY;IACV,MAAMC,GAAG,GAAG,IAAIC,GAAJ,CAAQH,UAAR,EAAoBI,MAAM,CAACC,QAAP,CAAgBC,IAApC,CAAZ;IACA,MAAMC,MAAM,GACVN,MAAM,YAAYO,eAAlB,GAAoCP,MAApC,GAA6C,IAAIO,eAAJ,CAAoBP,MAApB,CAD/C;IAEA;IACAC,GAAG,CAACK,MAAJ,GAAaA,MAAM,CAACE,QAAP,EAAb;IACA,OAAOP,GAAG,CAACI,IAAX;EACD;EACD,OAAON,UAAP;AACD;AAED;;;;;;;AAOA,eAAe,eAAeU,OAAf,OAeL,0BAf4B,EACpCC,IADoC,EAEpCC,KAAK,GAAG,SAF4B,EAGpCC,WAAW,GAAG,aAHsB,EAIpCC,iBAJoC,EAKpCC,OALoC,EAMpCC,MAAM,GAAG,KAN2B,EAOpCC,IAAI,GAAG,aAP6B,EAQpCC,WARoC,EASpCC,WAToC,EAUpCC,QAAQ,GAAG,QAVyB,EAWpCC,MAXoC,EAYpCC,SAAS,GAAG,IAZwB,EAapCpB,GAAG,EAAEqB,IAb+B,EAcpCC,YAdoC,EAe5B;EACR,MAAMC,cAAc,GAAGrC,UAAU,CAACsC,KAAD,EAAQZ,iBAAR,CAAjC;EACA,MAAMZ,GAAG,GAAG,GAAGH,UAAU,CAACwB,IAAD,EAAOC,YAAP,CAAoB,EAA7C;EAEA,MAAMG,OAAO,GAAG;IACdhB,IADc;IAEdC,KAFc;IAGdC,WAHc;IAIdE,OAJc;IAKdC,MALc;IAMdC,IANc;IAOdG,QAPc;IAQdC,MARc,EAAhB;;EAWA,IACEL,MAAM,KAAK,KAAX;EACAJ,KAAK,KAAK,UADV;EAEAA,KAAK,KAAK,QAFV;EAGAvB,eAHA;EAIA,2BAAM,CAACgB,QAAP,sCAAiBuB,QAAjB,MAA8B,QALhC,EAME;IACA,IAAIC,aAAa,GAAiB,IAAlC;IACA,IAAI;MACFA,aAAa,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYzC,SAAZ,CAAtB;MACA,MAAM0C,cAAc,GAAG,MAAMH,aAAa,CAACI,KAAd,CAAoB/B,GAApB,CAA7B;MACA,IAAI8B,cAAJ,EAAoB;QAClB;QACA;QACA,MAAME,IAAI,GAAGF,cAAc,CAACjB,OAAf,CAAuBoB,GAAvB,CAA2B,MAA3B,CAAb;QACAR,OAAO,CAACZ,OAAR,GAAkB,EAAE,GAAGY,OAAO,CAACZ,OAAb,EAAsB,iBAAiBmB,IAAvC,EAAlB;MACD;IACF;IAAC,MAAM;MACN;IACD;IAED,MAAME,QAAQ,GAAG,MAAMX,cAAc,CAACvB,GAAD,EAAMyB,OAAN,CAArC;IAEA,IAAIE,aAAa,IAAIO,QAAQ,CAACC,MAAT,KAAoB9C,wBAAzC,EAAmE;MACjE,MAAM+C,kBAAkB,GAAG,MAAMT,aAAa,CAACI,KAAd,CAAoB/B,GAApB,CAAjC;MACA,IAAIoC,kBAAJ,EAAwB;QACtB,OAAOA,kBAAkB,CAACC,KAAnB,EAAP;MACD;MACD,MAAM,IAAIzC,KAAJ,CAAU,wCAAV,CAAN;IACD;IACD,IACE+B,aAAa;IACbO,QAAQ,CAACC,MAAT,KAAoB7C,cADpB;IAEA4C,QAAQ,CAACrB,OAAT,CAAiBoB,GAAjB,CAAqB,MAArB,CAHF,EAIE;MACAN,aAAa,CAACW,MAAd,CAAqBtC,GAArB;MACA2B,aAAa,CAACY,GAAd,CAAkBvC,GAAlB,EAAuBkC,QAAQ,CAACG,KAAT,EAAvB;IACD;IAED,OAAOH,QAAP;EACD;EAED,IAAIpB,MAAM,KAAK,MAAX,IAAqBA,MAAM,KAAK,OAAhC,IAA2CA,MAAM,KAAK,KAA1D,EAAiE;IAC/D,IAAIE,WAAW,IAAIC,WAAnB,EAAgC;MAC9B,MAAM,IAAIrB,KAAJ,CAAU,uDAAV,CAAN;IACD;IACD,IAAIoB,WAAW,YAAYwB,QAA3B,EAAqC;MACnCf,OAAO,CAAChB,IAAR,GAAeO,WAAf;IACD,CAFD;IAEO,IAAIA,WAAJ,EAAiB;MACtB,MAAMxB,OAAO,GAAGD,eAAe,CAACyB,WAAD,CAA/B;MACA,IAAIxB,OAAO,IAAI,OAAOA,OAAP,KAAmB,QAAlC,EAA4C;QAC1C;QACA;QACA,MAAMiD,QAAQ,GAAa,IAAID,QAAJ,EAA3B;QACAE,MAAM,CAACC,IAAP,CAAYnD,OAAZ,EAAqBoD,OAArB,CAA6B,IAAG,KAAG;UACjC,MAAMC,KAAK,GAAIrD,OAAsB,CAACsD,GAAD,CAArC;UACA,IAAI,OAAOD,KAAP,KAAiB,WAArB,EAAkC;YAChC,IAAIE,WAAJ;YACA,IAAI;cACF;cACA;cACA;cACAA,WAAW,GAAG3B,SAAS,GAAG3B,IAAI,CAAC2B,SAAL,CAAeyB,KAAf,CAAH,GAA2BG,MAAM,CAACH,KAAD,CAAxD;YACD;YAAC,OAAOI,CAAP,EAAU;cACV;cACAC,OAAO,CAACvD,KAAR,CACE,gCAAgCmD,GAAG,qBAAqBA,GAAG,+DAA+D9C,GAAG,EAD/H,EAEE6C,KAFF,EAGEI,CAHF;YAKD;YACD,IAAIF,WAAW,KAAKI,SAApB,EAA+B;cAC7BV,QAAQ,CAACW,MAAT,CAAgBN,GAAhB,EAAqBC,WAArB;YACD;UACF;QACF,CArBD;QAsBAtB,OAAO,CAAChB,IAAR,GAAegC,QAAf;MACD;IACF;IACD,IAAIxB,WAAW,KAAKkC,SAApB,EAA+B;MAC7B1B,OAAO,CAAChB,IAAR,GAAehB,IAAI,CAAC2B,SAAL,CAAeH,WAAf,CAAf;MACAQ,OAAO,CAACZ,OAAR,GAAkB;QAChB,GAAGY,OAAO,CAACZ,OADK;QAEhB,gBAAgB,kBAFA,EAAlB;;IAID;EACF;EAED,OAAOU,cAAc,CAACvB,GAAD,EAAMyB,OAAN,CAArB;AACD","names":["fetchRetry","CACHE_AVAILABLE","CACHE_KEY","HTTP_STATUS_NOT_MODIFIED","HTTP_STATUS_OK","tryParsePayload","payload","JSON","parse","error","Error","getFullUrl","partialUrl","params","url","URL","window","location","href","search","URLSearchParams","toString","callApi","body","cache","credentials","fetchRetryOptions","headers","method","mode","postPayload","jsonPayload","redirect","signal","stringify","url_","searchParams","fetchWithRetry","fetch","request","protocol","supersetCache","caches","open","cachedResponse","match","etag","get","response","status","cachedFullResponse","clone","delete","put","FormData","formData","Object","keys","forEach","value","key","valueString","String","e","console","undefined","append"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/connection/callApi/callApi.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport 'whatwg-fetch';\nimport fetchRetry from 'fetch-retry';\nimport { CallApi, Payload, JsonValue, JsonObject } from '../types';\nimport {\n  CACHE_AVAILABLE,\n  CACHE_KEY,\n  HTTP_STATUS_NOT_MODIFIED,\n  HTTP_STATUS_OK,\n} from '../constants';\n\nfunction tryParsePayload(payload: Payload) {\n  try {\n    return typeof payload === 'string'\n      ? (JSON.parse(payload) as JsonValue)\n      : payload;\n  } catch (error) {\n    throw new Error(`Invalid payload:\\n\\n${payload}`);\n  }\n}\n\n/**\n * Try appending search params to an URL if needed.\n */\nfunction getFullUrl(partialUrl: string, params: CallApi['searchParams']) {\n  if (params) {\n    const url = new URL(partialUrl, window.location.href);\n    const search =\n      params instanceof URLSearchParams ? params : new URLSearchParams(params);\n    // will completely override any existing search params\n    url.search = search.toString();\n    return url.href;\n  }\n  return partialUrl;\n}\n\n/**\n * Fetch an API response and returns the corresponding json.\n *\n * @param {Payload} postPayload payload to send as FormData in a post form\n * @param {Payload} jsonPayload json payload to post, will automatically add Content-Type header\n * @param {string} stringify whether to stringify field values when post as formData\n */\nexport default async function callApi({\n  body,\n  cache = 'default',\n  credentials = 'same-origin',\n  fetchRetryOptions,\n  headers,\n  method = 'GET',\n  mode = 'same-origin',\n  postPayload,\n  jsonPayload,\n  redirect = 'follow',\n  signal,\n  stringify = true,\n  url: url_,\n  searchParams,\n}: CallApi): Promise<Response> {\n  const fetchWithRetry = fetchRetry(fetch, fetchRetryOptions);\n  const url = `${getFullUrl(url_, searchParams)}`;\n\n  const request = {\n    body,\n    cache,\n    credentials,\n    headers,\n    method,\n    mode,\n    redirect,\n    signal,\n  };\n\n  if (\n    method === 'GET' &&\n    cache !== 'no-store' &&\n    cache !== 'reload' &&\n    CACHE_AVAILABLE &&\n    window.location?.protocol === 'https:'\n  ) {\n    let supersetCache: Cache | null = null;\n    try {\n      supersetCache = await caches.open(CACHE_KEY);\n      const cachedResponse = await supersetCache.match(url);\n      if (cachedResponse) {\n        // if we have a cached response, send its ETag in the\n        // `If-None-Match` header in a conditional request\n        const etag = cachedResponse.headers.get('Etag') as string;\n        request.headers = { ...request.headers, 'If-None-Match': etag };\n      }\n    } catch {\n      // If superset is in an iframe and third-party cookies are disabled, caches.open throws\n    }\n\n    const response = await fetchWithRetry(url, request);\n\n    if (supersetCache && response.status === HTTP_STATUS_NOT_MODIFIED) {\n      const cachedFullResponse = await supersetCache.match(url);\n      if (cachedFullResponse) {\n        return cachedFullResponse.clone();\n      }\n      throw new Error('Received 304 but no content is cached!');\n    }\n    if (\n      supersetCache &&\n      response.status === HTTP_STATUS_OK &&\n      response.headers.get('Etag')\n    ) {\n      supersetCache.delete(url);\n      supersetCache.put(url, response.clone());\n    }\n\n    return response;\n  }\n\n  if (method === 'POST' || method === 'PATCH' || method === 'PUT') {\n    if (postPayload && jsonPayload) {\n      throw new Error('Please provide only one of jsonPayload or postPayload');\n    }\n    if (postPayload instanceof FormData) {\n      request.body = postPayload;\n    } else if (postPayload) {\n      const payload = tryParsePayload(postPayload);\n      if (payload && typeof payload === 'object') {\n        // using FormData has the effect that Content-Type header is set to `multipart/form-data`,\n        // not e.g., 'application/x-www-form-urlencoded'\n        const formData: FormData = new FormData();\n        Object.keys(payload).forEach(key => {\n          const value = (payload as JsonObject)[key] as JsonValue;\n          if (typeof value !== 'undefined') {\n            let valueString;\n            try {\n              // We have seen instances where casting to String() throws error\n              // This check allows all valid attributes to be appended to the formData\n              // while logging error to console for any attribute that fails the cast to String\n              valueString = stringify ? JSON.stringify(value) : String(value);\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.error(\n                `Unable to convert attribute '${key}' to a String(). '${key}' was not added to the formData in request.body for call to ${url}`,\n                value,\n                e,\n              );\n            }\n            if (valueString !== undefined) {\n              formData.append(key, valueString);\n            }\n          }\n        });\n        request.body = formData;\n      }\n    }\n    if (jsonPayload !== undefined) {\n      request.body = JSON.stringify(jsonPayload);\n      request.headers = {\n        ...request.headers,\n        'Content-Type': 'application/json',\n      };\n    }\n  }\n\n  return fetchWithRetry(url, request);\n}\n"]},"metadata":{},"sourceType":"module"}