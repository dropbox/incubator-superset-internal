{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useSelector, useDispatch, shallowEqual, useStore } from 'react-redux';\nimport { t } from '@superset-ui/core';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport { addTable, addDangerToast } from 'src/SqlLab/actions/sqlLab';\nimport { SCHEMA_AUTOCOMPLETE_SCORE, TABLE_AUTOCOMPLETE_SCORE, COLUMN_AUTOCOMPLETE_SCORE, SQL_FUNCTIONS_AUTOCOMPLETE_SCORE } from 'src/SqlLab/constants';\nimport { schemaEndpoints, tableEndpoints, skipToken } from 'src/hooks/apiResources';\nimport { api } from 'src/hooks/apiResources/queryApi';\nimport { useDatabaseFunctionsQuery } from 'src/hooks/apiResources/databaseFunctions';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nconst EMPTY_LIST = [];\nconst { useQueryState: useSchemasQueryState } = schemaEndpoints.schemas;\nconst { useQueryState: useTablesQueryState } = tableEndpoints.tables;\nconst getHelperText = (value) => value.length > 30 && {\n  docText: value };\n\nexport function useKeywords(_ref, skip) {let { queryEditorId, dbId, schema } = _ref;if (skip === void 0) {skip = false;}\n  const dispatch = useDispatch();\n  const hasFetchedKeywords = useRef(false);\n  // skipFetch is used to prevent re-evaluating memoized keywords\n  // due to updated api results by skip flag\n  const skipFetch = hasFetchedKeywords && skip;\n  const { data: schemaOptions } = useSchemasQueryState({\n    dbId,\n    forceRefresh: false },\n  { skip: skipFetch || !dbId });\n  const { data: tableData } = useTablesQueryState({\n    dbId,\n    schema,\n    forceRefresh: false },\n  { skip: skipFetch || !dbId || !schema });\n  const { data: functionNames, isError } = useDatabaseFunctionsQuery({ dbId }, { skip: skipFetch || !dbId });\n  useEffect(() => {\n    if (isError) {\n      dispatch(addDangerToast(t('An error occurred while fetching function names.')));\n    }\n  }, [dispatch, isError]);\n  const tablesForColumnMetadata = useSelector((_ref2) => {var _sqlLab$tables;let { sqlLab } = _ref2;return skip ?\n    [] :\n    ((_sqlLab$tables = sqlLab == null ? void 0 : sqlLab.tables) != null ? _sqlLab$tables : []).\n    filter((table) => table.queryEditorId === queryEditorId).\n    map((table) => table.name);}, shallowEqual);\n  const store = useStore();\n  const apiState = store.getState()[api.reducerPath];\n  const allColumns = useMemo(() => {\n    const columns = new Set();\n    tablesForColumnMetadata.forEach((table) => {var _tableEndpoints$table, _tableEndpoints$table2;\n      (_tableEndpoints$table = tableEndpoints.tableMetadata.\n      select(dbId && schema ?\n      {\n        dbId,\n        schema,\n        table } :\n\n      skipToken)({\n        [api.reducerPath]: apiState }).\n\n      data) == null ? void 0 : (_tableEndpoints$table2 = _tableEndpoints$table.columns) == null ? void 0 : _tableEndpoints$table2.forEach((_ref3) => {let { name } = _ref3;\n        columns.add(name);\n      });\n    });\n    return [...columns];\n  }, [dbId, schema, apiState, tablesForColumnMetadata]);\n  const insertMatch = useEffectEvent((editor, data) => {var _context;\n    if (data.meta === 'table') {\n      dispatch(addTable({ id: queryEditorId, dbId }, data.value, schema));\n    }\n    let { caption } = data;\n    if (data.meta === 'table' && _includesInstanceProperty(caption).call(caption, ' ')) {\n      caption = `\"${caption}\"`;\n    }\n    // executing https://github.com/thlorenz/brace/blob/3a00c5d59777f9d826841178e1eb36694177f5e6/ext/language_tools.js#L1448\n    editor.completer.insertMatch(`${caption}${_includesInstanceProperty(_context = ['function', 'schema']).call(_context, data.meta) ? '' : ' '}`);\n  });\n  const schemaKeywords = useMemo(() => (schemaOptions != null ? schemaOptions : []).map((s) => ({\n    name: s.label,\n    value: s.value,\n    score: SCHEMA_AUTOCOMPLETE_SCORE,\n    meta: 'schema',\n    completer: {\n      insertMatch },\n\n    ...getHelperText(s.value) })),\n  [schemaOptions, insertMatch]);\n  const tableKeywords = useMemo(() => {var _tableData$options;return ((_tableData$options = tableData == null ? void 0 : tableData.options) != null ? _tableData$options : []).map((_ref4) => {let { value, label } = _ref4;return {\n        name: label,\n        value,\n        score: TABLE_AUTOCOMPLETE_SCORE,\n        meta: 'table',\n        completer: {\n          insertMatch },\n\n        ...getHelperText(value) };});},\n  [tableData == null ? void 0 : tableData.options, insertMatch]);\n  const columnKeywords = useMemo(() => allColumns.map((col) => ({\n    name: col,\n    value: col,\n    score: COLUMN_AUTOCOMPLETE_SCORE,\n    meta: 'column',\n    ...getHelperText(col) })),\n  [allColumns]);\n  const functionKeywords = useMemo(() => (functionNames != null ? functionNames : []).map((func) => ({\n    name: func,\n    value: func,\n    score: SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n    meta: 'function',\n    completer: {\n      insertMatch },\n\n    ...getHelperText(func) })),\n  [functionNames, insertMatch]);\n  const keywords = useMemo(() => columnKeywords.\n  concat(schemaKeywords).\n  concat(tableKeywords).\n  concat(functionKeywords).\n  concat(sqlKeywords), [schemaKeywords, tableKeywords, columnKeywords, functionKeywords]);\n  hasFetchedKeywords.current = !skip;\n  return skip ? EMPTY_LIST : keywords;\n}","map":{"version":3,"mappings":"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","names":["useEffect","useMemo","useRef","useSelector","useDispatch","shallowEqual","useStore","t","sqlKeywords","addTable","addDangerToast","SCHEMA_AUTOCOMPLETE_SCORE","TABLE_AUTOCOMPLETE_SCORE","COLUMN_AUTOCOMPLETE_SCORE","SQL_FUNCTIONS_AUTOCOMPLETE_SCORE","schemaEndpoints","tableEndpoints","skipToken","api","useDatabaseFunctionsQuery","useEffectEvent","EMPTY_LIST","useQueryState","useSchemasQueryState","schemas","useTablesQueryState","tables","getHelperText","value","length","docText","useKeywords","skip","queryEditorId","dbId","schema","dispatch","hasFetchedKeywords","skipFetch","data","schemaOptions","forceRefresh","tableData","functionNames","isError","tablesForColumnMetadata","sqlLab","filter","table","map","name","store","apiState","getState","reducerPath","allColumns","columns","Set","forEach","tableMetadata","select","add","insertMatch","editor","meta","id","caption","completer","schemaKeywords","s","label","score","tableKeywords","options","columnKeywords","col","functionKeywords","func","keywords","concat","current"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/SqlLab/components/AceEditorWrapper/useKeywords.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useSelector, useDispatch, shallowEqual, useStore } from 'react-redux';\nimport { t } from '@superset-ui/core';\n\nimport { Editor } from 'src/components/AsyncAceEditor';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport { addTable, addDangerToast } from 'src/SqlLab/actions/sqlLab';\nimport {\n  SCHEMA_AUTOCOMPLETE_SCORE,\n  TABLE_AUTOCOMPLETE_SCORE,\n  COLUMN_AUTOCOMPLETE_SCORE,\n  SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n} from 'src/SqlLab/constants';\nimport {\n  schemaEndpoints,\n  tableEndpoints,\n  skipToken,\n} from 'src/hooks/apiResources';\nimport { api } from 'src/hooks/apiResources/queryApi';\nimport { useDatabaseFunctionsQuery } from 'src/hooks/apiResources/databaseFunctions';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { SqlLabRootState } from 'src/SqlLab/types';\n\ntype Params = {\n  queryEditorId: string | number;\n  dbId?: string | number;\n  schema?: string;\n};\n\nconst EMPTY_LIST = [] as typeof sqlKeywords;\n\nconst { useQueryState: useSchemasQueryState } = schemaEndpoints.schemas;\nconst { useQueryState: useTablesQueryState } = tableEndpoints.tables;\n\nconst getHelperText = (value: string) =>\n  value.length > 30 && {\n    docText: value,\n  };\n\nexport function useKeywords(\n  { queryEditorId, dbId, schema }: Params,\n  skip = false,\n) {\n  const dispatch = useDispatch();\n  const hasFetchedKeywords = useRef(false);\n  // skipFetch is used to prevent re-evaluating memoized keywords\n  // due to updated api results by skip flag\n  const skipFetch = hasFetchedKeywords && skip;\n  const { data: schemaOptions } = useSchemasQueryState(\n    {\n      dbId,\n      forceRefresh: false,\n    },\n    { skip: skipFetch || !dbId },\n  );\n  const { data: tableData } = useTablesQueryState(\n    {\n      dbId,\n      schema,\n      forceRefresh: false,\n    },\n    { skip: skipFetch || !dbId || !schema },\n  );\n\n  const { data: functionNames, isError } = useDatabaseFunctionsQuery(\n    { dbId },\n    { skip: skipFetch || !dbId },\n  );\n\n  useEffect(() => {\n    if (isError) {\n      dispatch(\n        addDangerToast(t('An error occurred while fetching function names.')),\n      );\n    }\n  }, [dispatch, isError]);\n\n  const tablesForColumnMetadata = useSelector<SqlLabRootState, string[]>(\n    ({ sqlLab }) =>\n      skip\n        ? []\n        : (sqlLab?.tables ?? [])\n            .filter(table => table.queryEditorId === queryEditorId)\n            .map(table => table.name),\n    shallowEqual,\n  );\n\n  const store = useStore();\n  const apiState = store.getState()[api.reducerPath];\n\n  const allColumns = useMemo(() => {\n    const columns = new Set<string>();\n    tablesForColumnMetadata.forEach(table => {\n      tableEndpoints.tableMetadata\n        .select(\n          dbId && schema\n            ? {\n                dbId,\n                schema,\n                table,\n              }\n            : skipToken,\n        )({\n          [api.reducerPath]: apiState,\n        })\n        .data?.columns?.forEach(({ name }) => {\n          columns.add(name);\n        });\n    });\n    return [...columns];\n  }, [dbId, schema, apiState, tablesForColumnMetadata]);\n\n  const insertMatch = useEffectEvent((editor: Editor, data: any) => {\n    if (data.meta === 'table') {\n      dispatch(addTable({ id: queryEditorId, dbId }, data.value, schema));\n    }\n\n    let { caption } = data;\n    if (data.meta === 'table' && caption.includes(' ')) {\n      caption = `\"${caption}\"`;\n    }\n\n    // executing https://github.com/thlorenz/brace/blob/3a00c5d59777f9d826841178e1eb36694177f5e6/ext/language_tools.js#L1448\n    editor.completer.insertMatch(\n      `${caption}${['function', 'schema'].includes(data.meta) ? '' : ' '}`,\n    );\n  });\n\n  const schemaKeywords = useMemo(\n    () =>\n      (schemaOptions ?? []).map(s => ({\n        name: s.label,\n        value: s.value,\n        score: SCHEMA_AUTOCOMPLETE_SCORE,\n        meta: 'schema',\n        completer: {\n          insertMatch,\n        },\n        ...getHelperText(s.value),\n      })),\n    [schemaOptions, insertMatch],\n  );\n\n  const tableKeywords = useMemo(\n    () =>\n      (tableData?.options ?? []).map(({ value, label }) => ({\n        name: label,\n        value,\n        score: TABLE_AUTOCOMPLETE_SCORE,\n        meta: 'table',\n        completer: {\n          insertMatch,\n        },\n        ...getHelperText(value),\n      })),\n    [tableData?.options, insertMatch],\n  );\n\n  const columnKeywords = useMemo(\n    () =>\n      allColumns.map(col => ({\n        name: col,\n        value: col,\n        score: COLUMN_AUTOCOMPLETE_SCORE,\n        meta: 'column',\n        ...getHelperText(col),\n      })),\n    [allColumns],\n  );\n\n  const functionKeywords = useMemo(\n    () =>\n      (functionNames ?? []).map(func => ({\n        name: func,\n        value: func,\n        score: SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n        meta: 'function',\n        completer: {\n          insertMatch,\n        },\n        ...getHelperText(func),\n      })),\n    [functionNames, insertMatch],\n  );\n\n  const keywords = useMemo(\n    () =>\n      columnKeywords\n        .concat(schemaKeywords)\n        .concat(tableKeywords)\n        .concat(functionKeywords)\n        .concat(sqlKeywords),\n    [schemaKeywords, tableKeywords, columnKeywords, functionKeywords],\n  );\n\n  hasFetchedKeywords.current = !skip;\n\n  return skip ? EMPTY_LIST : keywords;\n}\n"]},"metadata":{},"sourceType":"module"}