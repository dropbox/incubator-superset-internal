{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport { ensureIsArray, formatNumber, NumberFormats, t, usePrevious } from '@superset-ui/core';\nimport AntdSelect from 'antd/lib/select';\n\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, sortSelectedFirstHelper, sortComparatorWithSearchHelper, handleFilterOptionHelper, dropDownRenderHelper, getSuffixIcon, SELECT_ALL_VALUE, selectAllOption, mapValues, mapOptions, hasCustomLabels } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Select = /*#__PURE__*/forwardRef((_ref, ref) => {let { allowClear, allowNewOptions = false, allowSelectAll = true, ariaLabel, autoClearSearchValue = false, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, labelInValue = false, loading, mode = 'single', name, notFoundContent, onBlur, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props } = _ref;\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = allowNewOptions ? true : showSearch;\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const { Option } = AntdSelect;\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValue), [selectValue]);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const initialOptions = useMemo(() => Array.isArray(options) ? options.slice() : EMPTY_OPTIONS, [options]);\n  const initialOptionsSorted = useMemo(() => initialOptions.slice().sort(sortSelectedFirst), [initialOptions, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(initialOptionsSorted);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    const result = missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n    return result.filter((opt) => opt.value !== SELECT_ALL_VALUE);\n  }, [selectOptions, selectValue]);\n  const enabledOptions = useMemo(() => fullSelectOptions.filter((option) => !option.disabled), [fullSelectOptions]);\n  const selectAllEligible = useMemo(() => fullSelectOptions.filter((option) => hasOption(option.value, selectValue) || !option.disabled), [fullSelectOptions, selectValue]);\n  const selectAllEnabled = useMemo(() => !isSingleMode &&\n  allowSelectAll &&\n  fullSelectOptions.length > 0 &&\n  enabledOptions.length > 1 &&\n  !inputValue, [\n  isSingleMode,\n  allowSelectAll,\n  fullSelectOptions.length,\n  enabledOptions.length,\n  inputValue]);\n\n  const selectAllMode = useMemo(() => ensureIsArray(selectValue).length === selectAllEligible.length + 1, [selectValue, selectAllEligible]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      setSelectValue(selectedItem);\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (value === getValue(SELECT_ALL_VALUE)) {\n          if (isLabeledValue(selectedItem)) {\n            return [\n            ...selectAllEligible,\n            selectAllOption];\n\n          }\n          return [\n          SELECT_ALL_VALUE,\n          ...selectAllEligible.map((opt) => opt.value)];\n\n        }\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          if (result.length === selectAllEligible.length &&\n          selectAllEnabled) {\n            return isLabeledValue(selectedItem) ?\n            [...result, selectAllOption] :\n            [...result, SELECT_ALL_VALUE];\n          }\n          return result;\n        }\n        return previousState;\n      });\n    }\n    fireOnChange();\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const clear = () => {\n    if (isSingleMode) {\n      setSelectValue(undefined);\n    } else\n    {\n      setSelectValue(fullSelectOptions.\n      filter((option) => option.disabled && hasOption(option.value, selectValue)).\n      map((option) => labelInValue ?\n      { label: option.label, value: option.value } :\n      option.value));\n      fireOnChange();\n    }\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n        clear();\n      } else\n      {\n        let array = selectValue;\n        array = array.filter((element) => getValue(element) !== getValue(value));\n        // if this was not a new item, deselect select all option\n        if (selectAllMode && !option.isNewOption) {\n          array = array.filter((element) => getValue(element) !== SELECT_ALL_VALUE);\n        }\n        setSelectValue(array);\n        // removes new option\n        if (option.isNewOption) {\n          setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n        }\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true };\n\n      const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    setInputValue(searchValue);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      if (!_isEqual(initialOptionsSorted, selectOptions)) {\n        setSelectOptions(initialOptionsSorted);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText);\n  const handleClear = () => {\n    clear();\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    setSelectOptions(initialOptions);\n  }, [initialOptions]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    // if all values are selected, add select all to value\n    if (selectAllEnabled &&\n    ensureIsArray(value).length === selectAllEligible.length) {\n      setSelectValue(labelInValue ?\n      [...ensureIsArray(value), selectAllOption] :\n      [...ensureIsArray(value), SELECT_ALL_VALUE]);\n    }\n  }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n  useEffect(() => {\n    const checkSelectAll = ensureIsArray(selectValue).some((v) => getValue(v) === SELECT_ALL_VALUE);\n    if (checkSelectAll && !selectAllMode) {\n      const optionsToSelect = selectAllEligible.map((option) => labelInValue ? option : option.value);\n      optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n      setSelectValue(optionsToSelect);\n      fireOnChange();\n    }\n  }, [\n  selectValue,\n  selectAllMode,\n  labelInValue,\n  selectAllEligible,\n  fireOnChange]);\n\n  const selectAllLabel = useMemo(() => () =>\n  // TODO: localize\n  `${SELECT_ALL_VALUE} (${formatNumber(NumberFormats.INTEGER, selectAllEligible.length)})`, [selectAllEligible]);\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  const handleOnChange = useCallback((values, options) => {\n    // intercept onChange call to handle the select all case\n    // if the \"select all\" option is selected, we want to send all options to the onChange,\n    // otherwise we want to remove\n    let newValues = values;\n    let newOptions = options;\n    if (!isSingleMode) {\n      if (ensureIsArray(newValues).some((val) => getValue(val) === SELECT_ALL_VALUE)) {\n        // send all options to onchange if all are not currently there\n        if (!selectAllMode) {\n          newValues = mapValues(selectAllEligible, labelInValue);\n          newOptions = mapOptions(selectAllEligible);\n        } else\n        {\n          newValues = ensureIsArray(values).filter((val) => getValue(val) !== SELECT_ALL_VALUE);\n        }\n      } else\n      if (ensureIsArray(values).length === selectAllEligible.length &&\n      selectAllMode) {\n        const array = selectAllEligible.filter((option) => hasOption(option.value, selectValue) && option.disabled);\n        newValues = mapValues(array, labelInValue);\n        newOptions = mapOptions(array);\n      }\n    }\n    onChange == null ? void 0 : onChange(newValues, newOptions);\n  }, [\n  isSingleMode,\n  labelInValue,\n  onChange,\n  selectAllEligible,\n  selectAllMode,\n  selectValue]);\n\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        handleOnChange(selectValue, selectValue ? options[0] : undefined);\n      } else\n      {\n        handleOnChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  handleOnChange,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]);\n\n  const shouldRenderChildrenOptions = useMemo(() => selectAllEnabled || hasCustomLabels(options), [selectAllEnabled, options]);\n  const omittedCount = useMemo(() => {\n    const num_selected = ensureIsArray(selectValue).length;\n    const num_shown = maxTagCount;\n    return num_selected - num_shown - (selectAllMode ? 1 : 0);\n  }, [maxTagCount, selectAllMode, selectValue]);\n  const customMaxTagPlaceholder = () => `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n  // We can't remove the + tag so when Select All\n  // is the only item omitted, we subtract one from maxTagCount\n  let actualMaxTagCount = maxTagCount;\n  if (actualMaxTagCount !== 'responsive' &&\n  omittedCount === 0 &&\n  selectAllMode) {\n    actualMaxTagCount -= 1;\n  }\n  const onPaste = (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      setSelectValue(labelInValue ? { label: pastedText, value: pastedText } : pastedText);\n    } else\n    {\n      const token = tokenSeparators.find((token) => _includesInstanceProperty(pastedText).call(pastedText, token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      if (labelInValue) {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...array.map((value) => ({\n          label: value,\n          value }))]);\n\n\n      } else\n      {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...array]);\n\n      }\n    }\n  };\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: labelInValue, maxTagCount: actualMaxTagCount, maxTagPlaceholder: customMaxTagPlaceholder, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n    // @ts-ignore\n    , onPaste: onPaste, onPopupScroll: undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, shouldShowSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  selectAllEnabled && ___EmotionJSX(Option, { id: \"select-all\", className: \"select-all\", key: SELECT_ALL_VALUE, value: SELECT_ALL_VALUE },\n  selectAllLabel()),\n\n  shouldRenderChildrenOptions &&\n  renderSelectOptions(fullSelectOptions)));\n\n\n});\nexport default Select;","map":{"version":3,"mappings":"6QAAA;;;;;;;;;;;;;;;;;;AAkBA,OAAOA,KAAP,IACEC,UADF,EAIEC,SAJF,EAKEC,OALF,EAMEC,QANF,EAOEC,WAPF,QASO,OATP;AAUA,SACEC,aADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,CAJF,EAKEC,WALF,QAMO,mBANP;AAOA,OAAOC,UAAP,MAA6D,iBAA7D;;AAEA,SAASC,aAAT,QAA8B,eAA9B;AACA,SACEC,QADF,EAEEC,SAFF,EAGEC,cAHF,EAIEC,mBAJF,EAKEC,uBALF,EAMEC,8BANF,EAOEC,wBAPF,EAQEC,oBARF,EASEC,aATF,EAUEC,gBAVF,EAWEC,eAXF,EAYEC,SAZF,EAaEC,UAbF,EAcEC,eAdF,QAeO,SAfP;AAiBA,SACEC,mBADF,EAEEC,eAFF,EAGEC,YAHF,EAIEC,YAJF,EAKEC,kBALF,QAMO,UANP;AAOA,SACEC,aADF,EAEEC,aAFF,EAGEC,gBAHF,EAIEC,uBAJF,QAKO,aALP;AAMA,SAASC,eAAT,QAAgC,aAAhC;AAEA;;;;;;;;;;;;;;AAcA,MAAMC,MAAM,gBAAGpC,UAAU,CACvB,OAoCEqC,GApCF,KAqCI,KApCF,EACEC,UADF,EAEEC,eAAe,GAAG,KAFpB,EAGEC,cAAc,GAAG,IAHnB,EAIEC,SAJF,EAKEC,oBAAoB,GAAG,KALzB,EAMEC,YAAY,GAAG,IANjB,EAOEC,MAAM,GAAG,IAPX,EAQEC,cAAc,GAAG,KARnB,EASEC,UATF,EAUEC,eAAe,GAAG,KAVpB,EAWEC,YAAY,GAAG,KAXjB,EAYEC,OAZF,EAaEC,IAAI,GAAG,QAbT,EAcEC,IAdF,EAeEC,eAfF,EAgBEC,MAhBF,EAiBEC,QAjBF,EAkBEC,OAlBF,EAmBEC,uBAnBF,EAoBEC,UApBF,EAqBEC,QArBF,EAsBEC,QAtBF,EAuBEC,iBAAiB,GAAG,CAAC,OAAD,EAAU,OAAV,CAvBtB,EAwBEC,OAxBF,EAyBEC,WAAW,GAAGtD,CAAC,CAAC,YAAD,CAzBjB,EA0BEuD,UAAU,GAAG,IA1Bf,EA2BEC,cAAc,GAAG9B,uBA3BnB,EA4BE+B,eAAe,GAAGhC,gBA5BpB,EA6BEiC,KA7BF,EA8BEC,iBA9BF,EA+BEC,OA/BF,EAgCEC,WAAW,EAAEC,gBAhCf,EAiCE,GAAGC,KAjCL,EAoCE;EACF,MAAMC,YAAY,GAAGtB,IAAI,KAAK,QAA9B;EACA,MAAMuB,gBAAgB,GAAGlC,eAAe,GAAG,IAAH,GAAUwB,UAAlD;EACA,MAAM,CAACW,WAAD,EAAcC,cAAd,IAAgCxE,QAAQ,CAAC+D,KAAD,CAA9C;EACA,MAAM,CAACU,UAAD,EAAaC,aAAb,IAA8B1E,QAAQ,CAAC,EAAD,CAA5C;EACA,MAAM,CAAC2E,SAAD,EAAYC,YAAZ,IAA4B5E,QAAQ,CAAC8C,OAAD,CAA1C;EACA,MAAM,CAAC+B,iBAAD,EAAoBC,oBAApB,IAA4C9E,QAAQ,CAAC,KAAD,CAA1D;EACA,MAAM,CAACkE,WAAD,EAAca,cAAd,IAAgC/E,QAAQ,CAC5CmE,gBAD4C,WAC5CA,gBAD4C,GACxBtC,aADwB,CAA9C;EAGA,MAAM,CAACmD,aAAD,EAAgBC,gBAAhB,IAAoCjF,QAAQ,CAAC,CAAD,CAAlD;EACA,MAAMkF,mBAAmB,GAAG5E,WAAW,CAAC0E,aAAD,EAAgB,CAAhB,CAAvC;EAEA,MAAMG,YAAY,GAAGlF,WAAW,CAC9B,MAAMgF,gBAAgB,CAACD,aAAa,GAAG,CAAjB,CADQ,EAE9B,CAACA,aAAD,CAF8B,CAAhC;EAKAlF,SAAS,CAAC,MAAK;IACb,IAAImE,OAAJ,EAAa;MACXc,cAAc,CAACF,iBAAiB,GAAG,CAAH,GAAO,CAAzB,CAAd;IACD;EACF,CAJQ,EAIN,CAACA,iBAAD,EAAoBZ,OAApB,CAJM,CAAT;EAMA,MAAMmB,UAAU,GAAGf,YAAY,GAAGgB,SAAH,GAAe,UAA9C;EAEA,MAAM,EAAEC,MAAF,KAAa/E,UAAnB;EAEA,MAAMgF,iBAAiB,GAAGtF,WAAW,CACnC,CAACuF,CAAD,EAAsBC,CAAtB,KACE5E,uBAAuB,CAAC2E,CAAD,EAAIC,CAAJ,EAAOlB,WAAP,CAFU,EAGnC,CAACA,WAAD,CAHmC,CAArC;EAKA,MAAMmB,wBAAwB,GAAGzF,WAAW,CAC1C,CAACuF,CAAD,EAAsBC,CAAtB,KACE3E,8BAA8B,CAC5B0E,CAD4B,EAE5BC,CAF4B,EAG5BhB,UAH4B,EAI5Bc,iBAJ4B,EAK5B1B,cAL4B,CAFU,EAS1C,CAACY,UAAD,EAAaZ,cAAb,EAA6B0B,iBAA7B,CAT0C,CAA5C;EAYA,MAAMI,cAAc,GAAG5F,OAAO,CAC5B,MAAO6F,KAAK,CAACC,OAAN,CAAcnC,OAAd,IAAyBA,OAAO,CAACoC,KAAR,EAAzB,GAA2ClE,aADtB,EAE5B,CAAC8B,OAAD,CAF4B,CAA9B;EAIA,MAAMqC,oBAAoB,GAAGhG,OAAO,CAClC,MAAM4F,cAAc,CAACG,KAAf,GAAuBE,IAAvB,CAA4BT,iBAA5B,CAD4B,EAElC,CAACI,cAAD,EAAiBJ,iBAAjB,CAFkC,CAApC;EAKA,MAAM,CAACU,aAAD,EAAgBC,gBAAhB,IACJlG,QAAQ,CAAoB+F,oBAApB,CADV;EAGA;EACA,MAAMI,iBAAiB,GAAGpG,OAAO,CAAC,MAAK;IACrC,MAAMqG,aAAa,GAAsBlG,aAAa,CAACqE,WAAD,CAAb;IACtC8B,MADsC,CAC/B,IAAG,KAAI,CAAC3F,SAAS,CAACD,QAAQ,CAAC6F,GAAD,CAAT,EAAgBL,aAAhB,CADc;IAEtCM,GAFsC,CAElC,IAAG,KACN5F,cAAc,CAAC2F,GAAD,CAAd,GAAsBA,GAAtB,GAA4B,EAAEvC,KAAK,EAAEuC,GAAT,EAAcE,KAAK,EAAEC,MAAM,CAACH,GAAD,CAA3B,EAHS,CAAzC;IAKA,MAAMI,MAAM,GACVN,aAAa,CAACO,MAAd,GAAuB,CAAvB;IACIP,aAAa,CAACQ,MAAd,CAAqBX,aAArB,CADJ;IAEIA,aAHN;IAIA,OAAOS,MAAM,CAACL,MAAP,CAAc,IAAG,KAAIC,GAAG,CAACvC,KAAJ,KAAc7C,gBAAnC,CAAP;EACD,CAXgC,EAW9B,CAAC+E,aAAD,EAAgB1B,WAAhB,CAX8B,CAAjC;EAaA,MAAMsC,cAAc,GAAG9G,OAAO,CAC5B,MAAMoG,iBAAiB,CAACE,MAAlB,CAAyB,OAAM,KAAI,CAACS,MAAM,CAACC,QAA3C,CADsB,EAE5B,CAACZ,iBAAD,CAF4B,CAA9B;EAKA,MAAMa,iBAAiB,GAAGjH,OAAO,CAC/B,MACEoG,iBAAiB,CAACE,MAAlB,CACE,OAAM,KAAI3F,SAAS,CAACoG,MAAM,CAAC/C,KAAR,EAAeQ,WAAf,CAAT,IAAwC,CAACuC,MAAM,CAACC,QAD5D,CAF6B,EAK/B,CAACZ,iBAAD,EAAoB5B,WAApB,CAL+B,CAAjC;EAQA,MAAM0C,gBAAgB,GAAGlH,OAAO,CAC9B,MACE,CAACsE,YAAD;EACAhC,cADA;EAEA8D,iBAAiB,CAACQ,MAAlB,GAA2B,CAF3B;EAGAE,cAAc,CAACF,MAAf,GAAwB,CAHxB;EAIA,CAAClC,UAN2B,EAO9B;EACEJ,YADF;EAEEhC,cAFF;EAGE8D,iBAAiB,CAACQ,MAHpB;EAIEE,cAAc,CAACF,MAJjB;EAKElC,UALF,CAP8B,CAAhC;;EAgBA,MAAMyC,aAAa,GAAGnH,OAAO,CAC3B,MAAMG,aAAa,CAACqE,WAAD,CAAb,CAA2BoC,MAA3B,KAAsCK,iBAAiB,CAACL,MAAlB,GAA2B,CAD5C,EAE3B,CAACpC,WAAD,EAAcyC,iBAAd,CAF2B,CAA7B;EAKA,MAAMG,cAAc,GAA4B,CAACC,YAAD,EAAeN,MAAf,KAAyB;IACvE,IAAIzC,YAAJ,EAAkB;MAChBG,cAAc,CAAC4C,YAAD,CAAd;IACD,CAFD;IAEO;MACL5C,cAAc,CAAC,cAAa,KAAG;QAC7B,MAAM6C,KAAK,GAAGnH,aAAa,CAACoH,aAAD,CAA3B;QACA,MAAMvD,KAAK,GAAGtD,QAAQ,CAAC2G,YAAD,CAAtB;QACA;QACA,IAAIrD,KAAK,KAAKtD,QAAQ,CAACS,gBAAD,CAAtB,EAA0C;UACxC,IAAIP,cAAc,CAACyG,YAAD,CAAlB,EAAkC;YAChC,OAAO;YACL,GAAGJ,iBADE;YAEL7F,eAFK,CAAP;;UAID;UACD,OAAO;UACLD,gBADK;UAEL,GAAG8F,iBAAiB,CAACT,GAAlB,CAAsB,IAAG,KAAID,GAAG,CAACvC,KAAjC,CAFE,CAAP;;QAID;QACD,IAAI,CAACrD,SAAS,CAACqD,KAAD,EAAQsD,KAAR,CAAd,EAA8B;UAC5B,MAAMX,MAAM,GAAG,CAAC,GAAGW,KAAJ,EAAWD,YAAX,CAAf;UACA,IACEV,MAAM,CAACC,MAAP,KAAkBK,iBAAiB,CAACL,MAApC;UACAM,gBAFF,EAGE;YACA,OAAOtG,cAAc,CAACyG,YAAD,CAAd;YACF,CAAC,GAAGV,MAAJ,EAAYvF,eAAZ,CADE;YAEF,CAAC,GAAGuF,MAAJ,EAAYxF,gBAAZ,CAFL;UAGD;UACD,OAAOwF,MAAP;QACD;QACD,OAAOY,aAAP;MACD,CA7Ba,CAAd;IA8BD;IACDnC,YAAY;IACZ3B,QAAQ,QAAR,oBAAQ,CAAG4D,YAAH,EAAiBN,MAAjB,CAAR;EACD,CArCD;EAuCA,MAAMS,KAAK,GAAG,MAAK;IACjB,IAAIlD,YAAJ,EAAkB;MAChBG,cAAc,CAACa,SAAD,CAAd;IACD,CAFD;IAEO;MACLb,cAAc,CACZ2B,iBAAiB;MACdE,MADH,CAEI,OAAM,KAAIS,MAAM,CAACC,QAAP,IAAmBrG,SAAS,CAACoG,MAAM,CAAC/C,KAAR,EAAeQ,WAAf,CAF1C;MAIGgC,GAJH,CAIO,OAAM,KACT1D,YAAY;MACR,EAAE2D,KAAK,EAAEM,MAAM,CAACN,KAAhB,EAAuBzC,KAAK,EAAE+C,MAAM,CAAC/C,KAArC,EADQ;MAER+C,MAAM,CAAC/C,KAPf,CADY,CAAd;MAWAoB,YAAY;IACb;EACF,CAjBD;EAmBA,MAAMqC,gBAAgB,GAA8B,CAACzD,KAAD,EAAQ+C,MAAR,KAAkB;IACpE,IAAIlB,KAAK,CAACC,OAAN,CAActB,WAAd,CAAJ,EAAgC;MAC9B,IAAI9D,QAAQ,CAACsD,KAAD,CAAR,KAAoBtD,QAAQ,CAACS,gBAAD,CAAhC,EAAoD;QAClDqG,KAAK;MACN,CAFD;MAEO;QACL,IAAIF,KAAK,GAAG9C,WAAZ;QACA8C,KAAK,GAAGA,KAAK,CAAChB,MAAN,CACN,QAAO,KAAI5F,QAAQ,CAACgH,OAAD,CAAR,KAAsBhH,QAAQ,CAACsD,KAAD,CADnC,CAAR;QAGA;QACA,IAAImD,aAAa,IAAI,CAACJ,MAAM,CAACY,WAA7B,EAA0C;UACxCL,KAAK,GAAGA,KAAK,CAAChB,MAAN,CACN,QAAO,KAAI5F,QAAQ,CAACgH,OAAD,CAAR,KAAsBvG,gBAD3B,CAAR;QAGD;QACDsD,cAAc,CAAC6C,KAAD,CAAd;QAEA;QACA,IAAIP,MAAM,CAACY,WAAX,EAAwB;UACtBxB,gBAAgB,CACdC,iBAAiB,CAACE,MAAlB,CACE,OAAM,KAAI5F,QAAQ,CAACqG,MAAM,CAAC/C,KAAR,CAAR,KAA2BtD,QAAQ,CAACsD,KAAD,CAD/C,CADc,CAAhB;QAKD;MACF;IACF;IACDoB,YAAY;IACZ7B,UAAU,QAAV,sBAAU,CAAGS,KAAH,EAAU+C,MAAV,CAAV;EACD,CA7BD;EA+BA,MAAMa,cAAc,GAAG,UAAS,CAACC,MAAD,KAAmB;IACjD,MAAMC,WAAW,GAAGD,MAAM,CAACE,IAAP,EAApB;IACA,IAAI1F,eAAJ,EAAqB;MACnB,MAAM2F,SAAS,GAAGF,WAAW;MAC3B,CAACnH,SAAS,CAACmH,WAAD,EAAc1B,iBAAd,EAAiC,IAAjC,CADM,IACoC;QAClDK,KAAK,EAAEqB,WAD2C;QAElD9D,KAAK,EAAE8D,WAF2C;QAGlDH,WAAW,EAAE,IAHqC,EADtD;;MAMA,MAAMM,kBAAkB,GAAG9H,aAAa,CAACiG,iBAAD,CAAb,CAAiCE,MAAjC,CACzB,IAAG,KAAI,CAACC,GAAG,CAACoB,WAAL,IAAoBhH,SAAS,CAAC4F,GAAG,CAACvC,KAAL,EAAYQ,WAAZ,CADX,CAA3B;MAGA,MAAM0D,UAAU,GAAGF,SAAS;MACxB,CAACA,SAAD,EAAY,GAAGC,kBAAf,CADwB;MAExBA,kBAFJ;MAGA9B,gBAAgB,CAAC+B,UAAD,CAAhB;IACD;IACDvD,aAAa,CAACmD,WAAD,CAAb;IACAtE,QAAQ,QAAR,oBAAQ,CAAGsE,WAAH,CAAR;EACD,CAnBsB,EAmBpBrH,aAnBoB,CAAvB;EAqBAV,SAAS,CAAC,MAAM,MAAM6H,cAAc,CAACO,MAAf,EAAb,EAAsC,CAACP,cAAD,CAAtC,CAAT;EAEA,MAAMQ,kBAAkB,GAAG,CAACP,MAAD,EAAiBd,MAAjB,KACzB/F,wBAAwB,CAAC6G,MAAD,EAASd,MAAT,EAAiBrD,iBAAjB,EAAoCjB,YAApC,CAD1B;EAGA,MAAM4F,6BAA6B,GAAG,CAACvD,iBAAD,KAA+B;IACnEC,oBAAoB,CAACD,iBAAD,CAApB;IAEA;IACA;IACA,IAAIA,iBAAiB,IAAI,CAACJ,UAAtB,IAAoCwB,aAAa,CAACU,MAAd,GAAuB,CAA/D,EAAkE;MAChE,IAAI,CAAC,SAAQZ,oBAAR,EAA8BE,aAA9B,CAAL,EAAmD;QACjDC,gBAAgB,CAACH,oBAAD,CAAhB;MACD;IACF;IACD,IAAI1C,uBAAJ,EAA6B;MAC3BA,uBAAuB,CAACwB,iBAAD,CAAvB;IACD;EACF,CAbD;EAeA,MAAMwD,cAAc,GAAG,CACrBC,UADqB,KAGrBtH,oBAAoB,CAClBsH,UADkB,EAElBzD,iBAFkB,EAGlBF,SAHkB,EAIlBwB,iBAAiB,CAACQ,MAJA,EAKlBhE,UALkB,CAHtB;EAWA,MAAM4F,WAAW,GAAG,MAAK;IACvBhB,KAAK;IACL,IAAInE,OAAJ,EAAa;MACXA,OAAO;IACR;EACF,CALD;EAOAtD,SAAS,CAAC,MAAK;IACb;IACAoG,gBAAgB,CAACP,cAAD,CAAhB;EACD,CAHQ,EAGN,CAACA,cAAD,CAHM,CAAT;EAKA7F,SAAS,CAAC,MAAK;IACb,IAAIgD,OAAO,KAAKuC,SAAZ,IAAyBvC,OAAO,KAAK6B,SAAzC,EAAoD;MAClDC,YAAY,CAAC9B,OAAD,CAAZ;IACD;EACF,CAJQ,EAIN,CAAC6B,SAAD,EAAY7B,OAAZ,CAJM,CAAT;EAMAhD,SAAS,CAAC,MAAK;IACb0E,cAAc,CAACT,KAAD,CAAd;EACD,CAFQ,EAEN,CAACA,KAAD,CAFM,CAAT;EAIAjE,SAAS,CAAC,MAAK;IACb;IACA,IACEmH,gBAAgB;IAChB/G,aAAa,CAAC6D,KAAD,CAAb,CAAqB4C,MAArB,KAAgCK,iBAAiB,CAACL,MAFpD,EAGE;MACAnC,cAAc,CACZ3B,YAAY;MACP,CAAC,GAAG3C,aAAa,CAAC6D,KAAD,CAAjB,EAA0B5C,eAA1B,CADO;MAEP,CAAC,GAAGjB,aAAa,CAAC6D,KAAD,CAAjB,EAA0B7C,gBAA1B,CAHO,CAAd;IAKD;EACF,CAZQ,EAYN,CAAC2B,YAAD,EAAemE,iBAAiB,CAACL,MAAjC,EAAyCM,gBAAzC,EAA2DlD,KAA3D,CAZM,CAAT;EAcAjE,SAAS,CAAC,MAAK;IACb,MAAM0I,cAAc,GAAGtI,aAAa,CAACqE,WAAD,CAAb,CAA2BkE,IAA3B,CACrB,EAAC,KAAIhI,QAAQ,CAACiI,CAAD,CAAR,KAAgBxH,gBADA,CAAvB;IAGA,IAAIsH,cAAc,IAAI,CAACtB,aAAvB,EAAsC;MACpC,MAAMyB,eAAe,GAAG3B,iBAAiB,CAACT,GAAlB,CAAsB,OAAM,KAClD1D,YAAY,GAAGiE,MAAH,GAAYA,MAAM,CAAC/C,KADT,CAAxB;MAGA4E,eAAe,CAACC,IAAhB,CAAqB/F,YAAY,GAAG1B,eAAH,GAAqBD,gBAAtD;MACAsD,cAAc,CAACmE,eAAD,CAAd;MACAxD,YAAY;IACb;EACF,CAZQ,EAYN;EACDZ,WADC;EAED2C,aAFC;EAGDrE,YAHC;EAIDmE,iBAJC;EAKD7B,YALC,CAZM,CAAT;;EAoBA,MAAM0D,cAAc,GAAG9I,OAAO,CAC5B,MAAM;EACJ;EACA,GAAGmB,gBAAgB,KAAKf,YAAY,CAClCC,aAAa,CAAC0I,OADoB,EAElC9B,iBAAiB,CAACL,MAFgB,CAGnC,GANyB,EAO5B,CAACK,iBAAD,CAP4B,CAA9B;EAUA,MAAM+B,YAAY,GAAG,CAACC,KAAD,KAAyC;IAC5DtE,aAAa,CAAC,EAAD,CAAb;IACAxB,MAAM,QAAN,kBAAM,CAAG8F,KAAH,CAAN;EACD,CAHD;EAKA,MAAMC,cAAc,GAAGhJ,WAAW,CAChC,CAACiJ,MAAD,EAAcxF,OAAd,KAA8B;IAC5B;IACA;IACA;IACA,IAAIyF,SAAS,GAAGD,MAAhB;IACA,IAAIjB,UAAU,GAAGvE,OAAjB;IACA,IAAI,CAACW,YAAL,EAAmB;MACjB,IACEnE,aAAa,CAACiJ,SAAD,CAAb,CAAyBV,IAAzB,CACE,IAAG,KAAIhI,QAAQ,CAAC2I,GAAD,CAAR,KAAkBlI,gBAD3B,CADF,EAIE;QACA;QACA,IAAI,CAACgG,aAAL,EAAoB;UAClBiC,SAAS,GAAG/H,SAAS,CAAC4F,iBAAD,EAAoBnE,YAApB,CAArB;UACAoF,UAAU,GAAG5G,UAAU,CAAC2F,iBAAD,CAAvB;QACD,CAHD;QAGO;UACLmC,SAAS,GAAGjJ,aAAa,CAACgJ,MAAD,CAAb,CAAsB7C,MAAtB,CACV,CAAC+C,GAAD,KAAc3I,QAAQ,CAAC2I,GAAD,CAAR,KAAkBlI,gBADtB,CAAZ;QAGD;MACF,CAdD;MAcO,IACLhB,aAAa,CAACgJ,MAAD,CAAb,CAAsBvC,MAAtB,KAAiCK,iBAAiB,CAACL,MAAnD;MACAO,aAFK,EAGL;QACA,MAAMG,KAAK,GAAGL,iBAAiB,CAACX,MAAlB,CACZ,OAAM,KAAI3F,SAAS,CAACoG,MAAM,CAAC/C,KAAR,EAAeQ,WAAf,CAAT,IAAwCuC,MAAM,CAACC,QAD7C,CAAd;QAGAoC,SAAS,GAAG/H,SAAS,CAACiG,KAAD,EAAQxE,YAAR,CAArB;QACAoF,UAAU,GAAG5G,UAAU,CAACgG,KAAD,CAAvB;MACD;IACF;IACDlE,QAAQ,QAAR,oBAAQ,CAAGgG,SAAH,EAAclB,UAAd,CAAR;EACD,CAlC+B,EAmChC;EACE5D,YADF;EAEExB,YAFF;EAGEM,QAHF;EAIE6D,iBAJF;EAKEE,aALF;EAME3C,WANF,CAnCgC,CAAlC;;EA6CAzE,SAAS,CAAC,MAAK;IACb,IAAIkF,aAAa,KAAKE,mBAAtB,EAA2C;MACzC,MAAMmC,KAAK,GAAGnH,aAAa,CAACqE,WAAD,CAA3B;MACA,MAAM8E,GAAG,GAAG,IAAIC,GAAJ,CAAQjC,KAAK,CAACd,GAAN,CAAU9F,QAAV,CAAR,CAAZ;MACA,MAAMiD,OAAO,GAAGrC,UAAU,CACxB8E,iBAAiB,CAACE,MAAlB,CAAyB,IAAG,KAAIgD,GAAG,CAACE,GAAJ,CAAQjD,GAAG,CAACvC,KAAZ,CAAhC,CADwB,CAA1B;MAGA,IAAIM,YAAJ,EAAkB;QAChB4E,cAAc,CAAC1E,WAAD,EAAcA,WAAW,GAAGb,OAAO,CAAC,CAAD,CAAV,GAAgB2B,SAAzC,CAAd;MACD,CAFD;MAEO;QACL4D,cAAc,CAAC5B,KAAD,EAAQ3D,OAAR,CAAd;MACD;IACF;EACF,CAbQ,EAaN;EACDyC,iBADC;EAED8C,cAFC;EAGD5E,YAHC;EAIDlB,QAJC;EAKD6B,aALC;EAMDE,mBANC;EAODX,WAPC,CAbM,CAAT;;EAuBA,MAAMiF,2BAA2B,GAAGzJ,OAAO,CACzC,MAAMkH,gBAAgB,IAAI3F,eAAe,CAACoC,OAAD,CADA,EAEzC,CAACuD,gBAAD,EAAmBvD,OAAnB,CAFyC,CAA3C;EAKA,MAAM+F,YAAY,GAAG1J,OAAO,CAAC,MAAK;IAChC,MAAM2J,YAAY,GAAGxJ,aAAa,CAACqE,WAAD,CAAb,CAA2BoC,MAAhD;IACA,MAAMgD,SAAS,GAAGzF,WAAlB;IACA,OAAOwF,YAAY,GAAGC,SAAf,IAA4BzC,aAAa,GAAG,CAAH,GAAO,CAAhD,CAAP;EACD,CAJ2B,EAIzB,CAAChD,WAAD,EAAcgD,aAAd,EAA6B3C,WAA7B,CAJyB,CAA5B;EAMA,MAAMqF,uBAAuB,GAAG,MAC9B,KAAKH,YAAY,GAAG,CAAf,GAAmBA,YAAnB,GAAkC,CAAC,MAD1C;EAGA;EACA;EACA,IAAII,iBAAiB,GAAG3F,WAAxB;EACA,IACE2F,iBAAiB,KAAK,YAAtB;EACAJ,YAAY,KAAK,CADjB;EAEAvC,aAHF,EAIE;IACA2C,iBAAiB,IAAI,CAArB;EACD;EAED,MAAMC,OAAO,GAAG,CAACC,CAAD,KAAwC;IACtD,MAAMC,UAAU,GAAGD,CAAC,CAACE,aAAF,CAAgBC,OAAhB,CAAwB,MAAxB,CAAnB;IACA,IAAI7F,YAAJ,EAAkB;MAChBG,cAAc,CACZ3B,YAAY,GAAG,EAAE2D,KAAK,EAAEwD,UAAT,EAAqBjG,KAAK,EAAEiG,UAA5B,EAAH,GAA8CA,UAD9C,CAAd;IAGD,CAJD;IAIO;MACL,MAAMG,KAAK,GAAGrG,eAAe,CAACsG,IAAhB,CAAqB,MAAK,KAAI,oCAAU,MAAV,WAAU,EAAUD,KAAV,CAAxC,CAAd;MACA,MAAM9C,KAAK,GAAG8C,KAAK,GAAG,MAAKH,UAAU,CAACK,KAAX,CAAiBF,KAAjB,CAAL,CAAH,GAAmC,CAACH,UAAD,CAAtD;MACA,IAAInH,YAAJ,EAAkB;QAChB2B,cAAc,CAAC,SAAQ,KAAI;QACzB,IAAK8F,QAAQ,IAAI,EAAjB,CADyB;QAEzB,GAAGjD,KAAK,CAACd,GAAN,CAA4B,MAAK,MAAK;UACvCC,KAAK,EAAEzC,KADgC;UAEvCA,KAFuC,EAAL,CAAjC,CAFsB,CAAb,CAAd;;;MAOD,CARD;MAQO;QACLS,cAAc,CAAC,SAAQ,KAAI;QACzB,IAAK8F,QAAQ,IAAI,EAAjB,CADyB;QAEzB,GAAGjD,KAFsB,CAAb,CAAd;;MAID;IACF;EACF,CAxBD;EA0BA,OACE,cAAC,eAAD,IAAiB,cAAc,EAAE3E,cAAjC;EACGD,MAAM,IACL,cAAC,YAAD,IAAc,cAAc,EAAEC,cAA9B,IAA+CD,MAA/C,CAFJ;EAIE,cAAC,YAAD,aACE,UAAU,EAAE,CAACkC,SAAD,IAAcxC,UAD5B,EAEE,cAAYG,SAAS,IAAIU,IAF3B,EAGE,oBAAoB,EAAET,oBAHxB,EAIE,cAAc,EAAE8F,cAJlB,EAKE,YAAY,EAAEF,kBALhB,EAME,UAAU,EAAEzC,wBANd,EAOE,iBAAiB,EACf1B,iBAAiB,KAAK,YAAW,KAAIuG,WAAW,CAACC,UAAhC,CARrB,EAUE,cAAc,EAAE9H,cAVlB,EAWE,YAAY,EAAEG,YAXhB,EAYE,WAAW,EAAEgH,iBAZf,EAaE,iBAAiB,EAAED,uBAbrB,EAcE,IAAI,EAAExE,UAdR,EAeE,eAAe,EAAET,SAAS,GAAGtE,CAAC,CAAC,YAAD,CAAJ,GAAqB4C,eAfjD,EAgBE,MAAM,EAAE8F,YAhBV,EAiBE,UAAU,EAAEvB,gBAjBd,EAkBE,uBAAuB,EAAEY;IACzB;IAnBF,EAoBE,OAAO,EAAE0B,OApBX,EAqBE,aAAa,EAAEzE,SArBjB,EAsBE,QAAQ,EAAEf,gBAAgB,GAAGqD,cAAH,GAAoBtC,SAtBhD,EAuBE,QAAQ,EAAE8B,cAvBZ,EAwBE,OAAO,EAAEoB,WAxBX,EAyBE,WAAW,EAAE5E,WAzBf,EA0BE,UAAU,EAAEW,gBA1Bd,EA2BE,SAAS,MA3BX,EA4BE,eAAe,EAAER,eA5BnB,EA6BE,KAAK,EAAES,WA7BT,EA8BE,UAAU,EAAEtD,aAAa,CACvB0D,SADuB,EAEvBL,gBAFuB,EAGvBO,iBAHuB,CA9B3B,EAmCE,oBAAoB,EAClBjC,eAAe,GACb,cAAC,kBAAD,IAAoB,QAAQ,EAAC,GAA7B,EAAiC,cAAW,MAA5C,GADa,GAGb,cAAC,mBAAD,IAAqB,QAAQ,EAAC,GAA9B,EAAkC,cAAW,OAA7C,GAvCN,EA0CE,OAAO,EAAE4G,2BAA2B,GAAGnE,SAAH,GAAec,iBA1CrD,EA2CE,OAAO,EAAElC,OA3CX,EA4CE,SAAS,EAAEjC,eA5Cb,IA6CMoC,KA7CN,IA8CE,GAAG,EAAElC,GA9CP;EAgDG+E,gBAAgB,IACf,cAAC,MAAD,IACE,EAAE,EAAC,YADL,EAEE,SAAS,EAAC,YAFZ,EAGE,GAAG,EAAE/F,gBAHP,EAIE,KAAK,EAAEA,gBAJT;EAMG2H,cAAc,EANjB,CAjDJ;;EA0DGW,2BAA2B;EAC1B5I,mBAAmB,CAACuF,iBAAD,CA3DvB,CAJF,CADF;;;AAoED,CA9hBsB,CAAzB;AAiiBA,eAAelE,MAAf","names":["React","forwardRef","useEffect","useMemo","useState","useCallback","ensureIsArray","formatNumber","NumberFormats","t","usePrevious","AntdSelect","FAST_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","sortSelectedFirstHelper","sortComparatorWithSearchHelper","handleFilterOptionHelper","dropDownRenderHelper","getSuffixIcon","SELECT_ALL_VALUE","selectAllOption","mapValues","mapOptions","hasCustomLabels","StyledCheckOutlined","StyledContainer","StyledHeader","StyledSelect","StyledStopOutlined","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","Select","ref","allowClear","allowNewOptions","allowSelectAll","ariaLabel","autoClearSearchValue","filterOption","header","headerPosition","helperText","invertSelection","labelInValue","loading","mode","name","notFoundContent","onBlur","onChange","onClear","onDropdownVisibleChange","onDeselect","onSearch","onSelect","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","value","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","isSingleMode","shouldShowSearch","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","isDropdownVisible","setIsDropdownVisible","setMaxTagCount","onChangeCount","setOnChangeCount","previousChangeCount","fireOnChange","mappedMode","undefined","Option","sortSelectedFirst","a","b","sortComparatorWithSearch","initialOptions","Array","isArray","slice","initialOptionsSorted","sort","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","result","length","concat","enabledOptions","option","disabled","selectAllEligible","selectAllEnabled","selectAllMode","handleOnSelect","selectedItem","array","previousState","clear","handleOnDeselect","element","isNewOption","handleOnSearch","search","searchValue","trim","newOption","cleanSelectOptions","newOptions","cancel","handleFilterOption","handleOnDropdownVisibleChange","dropdownRender","originNode","handleClear","checkSelectAll","some","v","optionsToSelect","push","selectAllLabel","INTEGER","handleOnBlur","event","handleOnChange","values","newValues","val","set","Set","has","shouldRenderChildrenOptions","omittedCount","num_selected","num_shown","customMaxTagPlaceholder","actualMaxTagCount","onPaste","e","pastedText","clipboardData","getData","token","find","split","previous","triggerNode","parentNode"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/components/Select/Select.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  ClipboardEvent,\n} from 'react';\nimport {\n  ensureIsArray,\n  formatNumber,\n  NumberFormats,\n  t,\n  usePrevious,\n} from '@superset-ui/core';\nimport AntdSelect, { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport { debounce, isEqual, uniq } from 'lodash';\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  handleFilterOptionHelper,\n  dropDownRenderHelper,\n  getSuffixIcon,\n  SELECT_ALL_VALUE,\n  selectAllOption,\n  mapValues,\n  mapOptions,\n  hasCustomLabels,\n} from './utils';\nimport { RawValue, SelectOptionsType, SelectProps } from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst Select = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      allowSelectAll = true,\n      ariaLabel,\n      autoClearSearchValue = false,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      labelInValue = false,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onBlur,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      onDeselect,\n      onSearch,\n      onSelect,\n      optionFilterProps = ['label', 'value'],\n      options,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators = TOKEN_SEPARATORS,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: SelectProps,\n    ref: RefObject<HTMLInputElement>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const shouldShowSearch = allowNewOptions ? true : showSearch;\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n    const [onChangeCount, setOnChangeCount] = useState(0);\n    const previousChangeCount = usePrevious(onChangeCount, 0);\n\n    const fireOnChange = useCallback(\n      () => setOnChangeCount(onChangeCount + 1),\n      [onChangeCount],\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    const mappedMode = isSingleMode ? undefined : 'multiple';\n\n    const { Option } = AntdSelect;\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValue),\n      [selectValue],\n    );\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const initialOptions = useMemo(\n      () => (Array.isArray(options) ? options.slice() : EMPTY_OPTIONS),\n      [options],\n    );\n    const initialOptionsSorted = useMemo(\n      () => initialOptions.slice().sort(sortSelectedFirst),\n      [initialOptions, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(initialOptionsSorted);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      const result =\n        missingValues.length > 0\n          ? missingValues.concat(selectOptions)\n          : selectOptions;\n      return result.filter(opt => opt.value !== SELECT_ALL_VALUE);\n    }, [selectOptions, selectValue]);\n\n    const enabledOptions = useMemo(\n      () => fullSelectOptions.filter(option => !option.disabled),\n      [fullSelectOptions],\n    );\n\n    const selectAllEligible = useMemo(\n      () =>\n        fullSelectOptions.filter(\n          option => hasOption(option.value, selectValue) || !option.disabled,\n        ),\n      [fullSelectOptions, selectValue],\n    );\n\n    const selectAllEnabled = useMemo(\n      () =>\n        !isSingleMode &&\n        allowSelectAll &&\n        fullSelectOptions.length > 0 &&\n        enabledOptions.length > 1 &&\n        !inputValue,\n      [\n        isSingleMode,\n        allowSelectAll,\n        fullSelectOptions.length,\n        enabledOptions.length,\n        inputValue,\n      ],\n    );\n\n    const selectAllMode = useMemo(\n      () => ensureIsArray(selectValue).length === selectAllEligible.length + 1,\n      [selectValue, selectAllEligible],\n    );\n\n    const handleOnSelect: SelectProps['onSelect'] = (selectedItem, option) => {\n      if (isSingleMode) {\n        setSelectValue(selectedItem);\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (value === getValue(SELECT_ALL_VALUE)) {\n            if (isLabeledValue(selectedItem)) {\n              return [\n                ...selectAllEligible,\n                selectAllOption,\n              ] as AntdLabeledValue[];\n            }\n            return [\n              SELECT_ALL_VALUE,\n              ...selectAllEligible.map(opt => opt.value),\n            ] as AntdLabeledValue[];\n          }\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            if (\n              result.length === selectAllEligible.length &&\n              selectAllEnabled\n            ) {\n              return isLabeledValue(selectedItem)\n                ? ([...result, selectAllOption] as AntdLabeledValue[])\n                : ([...result, SELECT_ALL_VALUE] as (string | number)[]);\n            }\n            return result as AntdLabeledValue[];\n          }\n          return previousState;\n        });\n      }\n      fireOnChange();\n      onSelect?.(selectedItem, option);\n    };\n\n    const clear = () => {\n      if (isSingleMode) {\n        setSelectValue(undefined);\n      } else {\n        setSelectValue(\n          fullSelectOptions\n            .filter(\n              option => option.disabled && hasOption(option.value, selectValue),\n            )\n            .map(option =>\n              labelInValue\n                ? { label: option.label, value: option.value }\n                : option.value,\n            ),\n        );\n        fireOnChange();\n      }\n    };\n\n    const handleOnDeselect: SelectProps['onDeselect'] = (value, option) => {\n      if (Array.isArray(selectValue)) {\n        if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n          clear();\n        } else {\n          let array = selectValue as AntdLabeledValue[];\n          array = array.filter(\n            element => getValue(element) !== getValue(value),\n          );\n          // if this was not a new item, deselect select all option\n          if (selectAllMode && !option.isNewOption) {\n            array = array.filter(\n              element => getValue(element) !== SELECT_ALL_VALUE,\n            );\n          }\n          setSelectValue(array);\n\n          // removes new option\n          if (option.isNewOption) {\n            setSelectOptions(\n              fullSelectOptions.filter(\n                option => getValue(option.value) !== getValue(value),\n              ),\n            );\n          }\n        }\n      }\n      fireOnChange();\n      onDeselect?.(value, option);\n    };\n\n    const handleOnSearch = debounce((search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      setInputValue(searchValue);\n      onSearch?.(searchValue);\n    }, FAST_DEBOUNCE);\n\n    useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        if (!isEqual(initialOptionsSorted, selectOptions)) {\n          setSelectOptions(initialOptionsSorted);\n        }\n      }\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n      );\n\n    const handleClear = () => {\n      clear();\n      if (onClear) {\n        onClear();\n      }\n    };\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      setSelectOptions(initialOptions);\n    }, [initialOptions]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    useEffect(() => {\n      // if all values are selected, add select all to value\n      if (\n        selectAllEnabled &&\n        ensureIsArray(value).length === selectAllEligible.length\n      ) {\n        setSelectValue(\n          labelInValue\n            ? ([...ensureIsArray(value), selectAllOption] as AntdLabeledValue[])\n            : ([...ensureIsArray(value), SELECT_ALL_VALUE] as RawValue[]),\n        );\n      }\n    }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n\n    useEffect(() => {\n      const checkSelectAll = ensureIsArray(selectValue).some(\n        v => getValue(v) === SELECT_ALL_VALUE,\n      );\n      if (checkSelectAll && !selectAllMode) {\n        const optionsToSelect = selectAllEligible.map(option =>\n          labelInValue ? option : option.value,\n        );\n        optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n        setSelectValue(optionsToSelect);\n        fireOnChange();\n      }\n    }, [\n      selectValue,\n      selectAllMode,\n      labelInValue,\n      selectAllEligible,\n      fireOnChange,\n    ]);\n\n    const selectAllLabel = useMemo(\n      () => () =>\n        // TODO: localize\n        `${SELECT_ALL_VALUE} (${formatNumber(\n          NumberFormats.INTEGER,\n          selectAllEligible.length,\n        )})`,\n      [selectAllEligible],\n    );\n\n    const handleOnBlur = (event: React.FocusEvent<HTMLElement>) => {\n      setInputValue('');\n      onBlur?.(event);\n    };\n\n    const handleOnChange = useCallback(\n      (values: any, options: any) => {\n        // intercept onChange call to handle the select all case\n        // if the \"select all\" option is selected, we want to send all options to the onChange,\n        // otherwise we want to remove\n        let newValues = values;\n        let newOptions = options;\n        if (!isSingleMode) {\n          if (\n            ensureIsArray(newValues).some(\n              val => getValue(val) === SELECT_ALL_VALUE,\n            )\n          ) {\n            // send all options to onchange if all are not currently there\n            if (!selectAllMode) {\n              newValues = mapValues(selectAllEligible, labelInValue);\n              newOptions = mapOptions(selectAllEligible);\n            } else {\n              newValues = ensureIsArray(values).filter(\n                (val: any) => getValue(val) !== SELECT_ALL_VALUE,\n              );\n            }\n          } else if (\n            ensureIsArray(values).length === selectAllEligible.length &&\n            selectAllMode\n          ) {\n            const array = selectAllEligible.filter(\n              option => hasOption(option.value, selectValue) && option.disabled,\n            );\n            newValues = mapValues(array, labelInValue);\n            newOptions = mapOptions(array);\n          }\n        }\n        onChange?.(newValues, newOptions);\n      },\n      [\n        isSingleMode,\n        labelInValue,\n        onChange,\n        selectAllEligible,\n        selectAllMode,\n        selectValue,\n      ],\n    );\n\n    useEffect(() => {\n      if (onChangeCount !== previousChangeCount) {\n        const array = ensureIsArray(selectValue);\n        const set = new Set(array.map(getValue));\n        const options = mapOptions(\n          fullSelectOptions.filter(opt => set.has(opt.value)),\n        );\n        if (isSingleMode) {\n          handleOnChange(selectValue, selectValue ? options[0] : undefined);\n        } else {\n          handleOnChange(array, options);\n        }\n      }\n    }, [\n      fullSelectOptions,\n      handleOnChange,\n      isSingleMode,\n      onChange,\n      onChangeCount,\n      previousChangeCount,\n      selectValue,\n    ]);\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => selectAllEnabled || hasCustomLabels(options),\n      [selectAllEnabled, options],\n    );\n\n    const omittedCount = useMemo(() => {\n      const num_selected = ensureIsArray(selectValue).length;\n      const num_shown = maxTagCount as number;\n      return num_selected - num_shown - (selectAllMode ? 1 : 0);\n    }, [maxTagCount, selectAllMode, selectValue]);\n\n    const customMaxTagPlaceholder = () =>\n      `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n\n    // We can't remove the + tag so when Select All\n    // is the only item omitted, we subtract one from maxTagCount\n    let actualMaxTagCount = maxTagCount;\n    if (\n      actualMaxTagCount !== 'responsive' &&\n      omittedCount === 0 &&\n      selectAllMode\n    ) {\n      actualMaxTagCount -= 1;\n    }\n\n    const onPaste = (e: ClipboardEvent<HTMLInputElement>) => {\n      const pastedText = e.clipboardData.getData('text');\n      if (isSingleMode) {\n        setSelectValue(\n          labelInValue ? { label: pastedText, value: pastedText } : pastedText,\n        );\n      } else {\n        const token = tokenSeparators.find(token => pastedText.includes(token));\n        const array = token ? uniq(pastedText.split(token)) : [pastedText];\n        if (labelInValue) {\n          setSelectValue(previous => [\n            ...((previous || []) as AntdLabeledValue[]),\n            ...array.map<AntdLabeledValue>(value => ({\n              label: value,\n              value,\n            })),\n          ]);\n        } else {\n          setSelectValue(previous => [\n            ...((previous || []) as string[]),\n            ...array,\n          ]);\n        }\n      }\n    };\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={autoClearSearchValue}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue={labelInValue}\n          maxTagCount={actualMaxTagCount}\n          maxTagPlaceholder={customMaxTagPlaceholder}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onBlur={handleOnBlur}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          // @ts-ignore\n          onPaste={onPaste}\n          onPopupScroll={undefined}\n          onSearch={shouldShowSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          placeholder={placeholder}\n          showSearch={shouldShowSearch}\n          showArrow\n          tokenSeparators={tokenSeparators}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(\n            isLoading,\n            shouldShowSearch,\n            isDropdownVisible,\n          )}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          options={shouldRenderChildrenOptions ? undefined : fullSelectOptions}\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {selectAllEnabled && (\n            <Option\n              id=\"select-all\"\n              className=\"select-all\"\n              key={SELECT_ALL_VALUE}\n              value={SELECT_ALL_VALUE}\n            >\n              {selectAllLabel()}\n            </Option>\n          )}\n          {shouldRenderChildrenOptions &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default Select;\n"]},"metadata":{},"sourceType":"module"}