{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { SupersetClient } from '../../../connection';\nimport handleError from './handleError';\nconst validRequestTypes = new Set(['form', 'json', 'search', 'rison']);\nfunction isPayloadless(method) {\n  return !method || method === 'GET' || method === 'DELETE' || method === 'HEAD';\n}\n/**\n * Generate an API caller with predefined configs/typing and consistent\n * return values.\n */\nexport default function makeApi(options) {\n  const { endpoint, method, requestType: requestType_, responseType, processResponse, ...requestOptions } = options;\n  // use `search` payload (searchParams) when it's a GET request\n  const requestType = requestType_ || (isPayloadless(method) ? 'search' : 'json');\n  if (!validRequestTypes.has(requestType)) {\n    throw new Error(`Invalid request payload type, choose from: ${[...validRequestTypes].join(' | ')}`);\n  }\n  async function request(payload, _temp)\n\n  {let { client = SupersetClient } = _temp === void 0 ? { client: SupersetClient } : _temp;\n    try {\n      const requestConfig = {\n        ...requestOptions,\n        method,\n        endpoint };\n\n      if (requestType === 'search') {\n        requestConfig.searchParams = payload;\n      } else\n      if (requestType === 'rison') {\n        requestConfig.endpoint = `${endpoint}?q=${rison.encode(payload)}`;\n      } else\n      if (requestType === 'form') {\n        requestConfig.postPayload = payload;\n      } else\n      {\n        requestConfig.jsonPayload = payload;\n      }\n      let result;\n      const response = await client.request({\n        ...requestConfig,\n        parseMethod: 'raw' });\n\n      if (responseType === 'text') {\n        result = await response.text();\n      } else\n      if (responseType === 'raw' || responseType === null) {\n        result = response;\n      } else\n      {\n        result = await response.json();\n        // if response json has an \"error\" field\n        if (result && typeof result === 'object' && 'error' in result) {\n          return handleError(result);\n        }\n      }\n      const typedResult = result;\n      return processResponse ? processResponse(typedResult) : typedResult;\n    }\n    catch (error) {\n      return handleError(error);\n    }\n  }\n  request.method = method;\n  request.endpoint = endpoint;\n  request.requestType = requestType;\n  return request;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAkBA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SACEC,cADF,QASO,qBATP;AAUA,OAAOC,WAAP,MAAwC,eAAxC;AAOA,MAAMC,iBAAiB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,MAAD,EAAS,MAAT,EAAiB,QAAjB,EAA2B,OAA3B,CAAR,CAA1B;AAoBA,SAASC,aAAT,CAAuBC,MAAvB,EAAsC;EACpC,OACE,CAACA,MAAD,IAAWA,MAAM,KAAK,KAAtB,IAA+BA,MAAM,KAAK,QAA1C,IAAsDA,MAAM,KAAK,MADnE;AAGD;AAED;;;;AAIA,eAAc,SAAUC,OAAV,CAKZC,OALY,EAcX;EAED,MAAM,EACJC,QADI,EAEJH,MAFI,EAGJI,WAAW,EAAEC,YAHT,EAIJC,YAJI,EAKJC,eALI,EAMJ,GAAGC,cANC,KAOFN,OAPJ;EAQA;EACA,MAAME,WAAW,GACfC,YAAY,KAAKN,aAAa,CAACC,MAAD,CAAb,GAAwB,QAAxB,GAAmC,MAAxC,CADd;EAEA,IAAI,CAACH,iBAAiB,CAACY,GAAlB,CAAsBL,WAAtB,CAAL,EAAyC;IACvC,MAAM,IAAIM,KAAJ,CACJ,8CAA8C,CAAC,GAAGb,iBAAJ,EAAuBc,IAAvB,CAC5C,KAD4C,CAE7C,EAHG,CAAN;EAKD;EAED,eAAeC,OAAf,CACEC,OADF;;EAIG,KAFD,EAAEC,MAAM,GAAGnB,cAAX,EAEC,sBAFwD,EACvDmB,MAAM,EAAEnB,cAD+C,EAExD;IAED,IAAI;MACF,MAAMoB,aAAa,GAAG;QACpB,GAAGP,cADiB;QAEpBR,MAFoB;QAGpBG,QAHoB,EAAtB;;MAKA,IAAIC,WAAW,KAAK,QAApB,EAA8B;QAC5BW,aAAa,CAACC,YAAd,GAA6BH,OAA7B;MACD,CAFD;MAEO,IAAIT,WAAW,KAAK,OAApB,EAA6B;QAClCW,aAAa,CAACZ,QAAd,GAAyB,GAAGA,QAAQ,MAAMT,KAAK,CAACuB,MAAN,CAAaJ,OAAb,CAAqB,EAA/D;MACD,CAFM;MAEA,IAAIT,WAAW,KAAK,MAApB,EAA4B;QACjCW,aAAa,CAACG,WAAd,GAA4BL,OAA5B;MACD,CAFM;MAEA;QACLE,aAAa,CAACI,WAAd,GAA4BN,OAA5B;MACD;MAED,IAAIO,MAAJ;MACA,MAAMC,QAAQ,GAAG,MAAMP,MAAM,CAACF,OAAP,CAAe;QACpC,GAAGG,aADiC;QAEpCO,WAAW,EAAE,KAFuB,EAAf,CAAvB;;MAKA,IAAIhB,YAAY,KAAK,MAArB,EAA6B;QAC3Bc,MAAM,GAAG,MAAMC,QAAQ,CAACE,IAAT,EAAf;MACD,CAFD;MAEO,IAAIjB,YAAY,KAAK,KAAjB,IAA0BA,YAAY,KAAK,IAA/C,EAAqD;QAC1Dc,MAAM,GAAGC,QAAT;MACD,CAFM;MAEA;QACLD,MAAM,GAAG,MAAMC,QAAQ,CAACG,IAAT,EAAf;QACA;QACA,IAAIJ,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAA5B,IAAwC,WAAWA,MAAvD,EAA+D;UAC7D,OAAOxB,WAAW,CAACwB,MAAD,CAAlB;QACD;MACF;MACD,MAAMK,WAAW,GAAGL,MAApB;MACA,OACEb,eAAe,GAAGA,eAAe,CAACkB,WAAD,CAAlB,GAAkCA,WADnD;IAGD;IAAC,OAAOC,KAAP,EAAc;MACd,OAAO9B,WAAW,CAAC8B,KAAD,CAAlB;IACD;EACF;EAEDd,OAAO,CAACZ,MAAR,GAAiBA,MAAjB;EACAY,OAAO,CAACT,QAAR,GAAmBA,QAAnB;EACAS,OAAO,CAACR,WAAR,GAAsBA,WAAtB;EAEA,OAAOQ,OAAP;AACD","names":["rison","SupersetClient","handleError","validRequestTypes","Set","isPayloadless","method","makeApi","options","endpoint","requestType","requestType_","responseType","processResponse","requestOptions","has","Error","join","request","payload","client","requestConfig","searchParams","encode","postPayload","jsonPayload","result","response","parseMethod","text","json","typedResult","error"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/packages/superset-ui-core/src/query/api/v1/makeApi.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport {\n  SupersetClient,\n  Payload as SupersetPayload,\n  JsonObject,\n  JsonValue,\n  ParseMethod,\n  Endpoint,\n  Method,\n  RequestBase,\n} from '../../../connection';\nimport handleError, { ErrorInput } from './handleError';\nimport {\n  SupersetApiRequestOptions,\n  SupersetApiErrorPayload,\n  ParsedResponseType,\n} from './types';\n\nconst validRequestTypes = new Set(['form', 'json', 'search', 'rison']);\n\ninterface SupersetApiFactoryOptions extends Omit<RequestBase, 'url'> {\n  /**\n   * API endpoint, must be relative.\n   */\n  endpoint: Endpoint;\n  /**\n   * Request method: 'GET' | 'POST' | 'DELETE' | 'PUT' | ...\n   */\n  method: Method;\n  /**\n   * How to send the payload:\n   *  - form: set request.body as FormData\n   *  - json: as JSON string with request Content-Type header set to application/json\n   *  - search: add to search params\n   */\n  requestType?: 'form' | 'json' | 'search' | 'rison';\n}\n\nfunction isPayloadless(method?: Method) {\n  return (\n    !method || method === 'GET' || method === 'DELETE' || method === 'HEAD'\n  );\n}\n\n/**\n * Generate an API caller with predefined configs/typing and consistent\n * return values.\n */\nexport default function makeApi<\n  Payload = SupersetPayload,\n  Result = JsonObject,\n  T extends ParseMethod = ParseMethod,\n>(\n  options: SupersetApiFactoryOptions & {\n    /**\n     * How to parse response, choose from: 'json' | 'text' | 'raw'.\n     */\n    responseType?: T;\n    /**\n     * Further process parsed response\n     */\n    processResponse?(result: ParsedResponseType<T>): Result;\n  },\n) {\n  const {\n    endpoint,\n    method,\n    requestType: requestType_,\n    responseType,\n    processResponse,\n    ...requestOptions\n  } = options;\n  // use `search` payload (searchParams) when it's a GET request\n  const requestType =\n    requestType_ || (isPayloadless(method) ? 'search' : 'json');\n  if (!validRequestTypes.has(requestType)) {\n    throw new Error(\n      `Invalid request payload type, choose from: ${[...validRequestTypes].join(\n        ' | ',\n      )}`,\n    );\n  }\n\n  async function request(\n    payload: Payload,\n    { client = SupersetClient }: SupersetApiRequestOptions = {\n      client: SupersetClient,\n    },\n  ): Promise<Result> {\n    try {\n      const requestConfig = {\n        ...requestOptions,\n        method,\n        endpoint,\n      };\n      if (requestType === 'search') {\n        requestConfig.searchParams = payload;\n      } else if (requestType === 'rison') {\n        requestConfig.endpoint = `${endpoint}?q=${rison.encode(payload)}`;\n      } else if (requestType === 'form') {\n        requestConfig.postPayload = payload;\n      } else {\n        requestConfig.jsonPayload = payload;\n      }\n\n      let result: JsonValue | Response;\n      const response = await client.request({\n        ...requestConfig,\n        parseMethod: 'raw',\n      });\n\n      if (responseType === 'text') {\n        result = await response.text();\n      } else if (responseType === 'raw' || responseType === null) {\n        result = response;\n      } else {\n        result = await response.json();\n        // if response json has an \"error\" field\n        if (result && typeof result === 'object' && 'error' in result) {\n          return handleError(result as SupersetApiErrorPayload);\n        }\n      }\n      const typedResult = result as ParsedResponseType<T>;\n      return (\n        processResponse ? processResponse(typedResult) : typedResult\n      ) as Result;\n    } catch (error) {\n      return handleError(error as ErrorInput);\n    }\n  }\n\n  request.method = method;\n  request.endpoint = endpoint;\n  request.requestType = requestType;\n\n  return request;\n}\n"]},"metadata":{},"sourceType":"module"}