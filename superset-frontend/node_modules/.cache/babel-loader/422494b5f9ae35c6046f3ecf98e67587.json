{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport { ensureIsArray, formatNumber, NumberFormats, t } from '@superset-ui/core';\nimport AntdSelect from 'antd/lib/select';\n\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, sortSelectedFirstHelper, sortComparatorWithSearchHelper, handleFilterOptionHelper, dropDownRenderHelper, getSuffixIcon, SELECT_ALL_VALUE, selectAllOption, mapValues, mapOptions, hasCustomLabels } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Select = /*#__PURE__*/forwardRef((_ref, ref) => {let { allowClear, allowNewOptions = false, allowSelectAll = true, ariaLabel, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, labelInValue = false, loading, mode = 'single', name, notFoundContent, onChange, onClear, onDropdownVisibleChange, optionFilterProps = ['label', 'value'], options, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props } = _ref;\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = allowNewOptions ? true : showSearch;\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  const mappedMode = isSingleMode ?\n  undefined :\n  allowNewOptions ?\n  'tags' :\n  'multiple';\n  const { Option } = AntdSelect;\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValue), [selectValue]);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const initialOptions = useMemo(() => options && Array.isArray(options) ? options.slice() : EMPTY_OPTIONS, [options]);\n  const initialOptionsSorted = useMemo(() => initialOptions.slice().sort(sortSelectedFirst), [initialOptions, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(initialOptionsSorted);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    const result = missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n    return result.filter((opt) => opt.value !== SELECT_ALL_VALUE);\n  }, [selectOptions, selectValue]);\n  const enabledOptions = useMemo(() => fullSelectOptions.filter((option) => !option.disabled), [fullSelectOptions]);\n  const selectAllEligible = useMemo(() => fullSelectOptions.filter((option) => hasOption(option.value, selectValue) || !option.disabled), [fullSelectOptions, selectValue]);\n  const selectAllEnabled = useMemo(() => !isSingleMode &&\n  allowSelectAll &&\n  selectOptions.length > 0 &&\n  enabledOptions.length > 1 &&\n  !inputValue, [\n  isSingleMode,\n  allowSelectAll,\n  selectOptions.length,\n  enabledOptions.length,\n  inputValue]);\n\n  const selectAllMode = useMemo(() => ensureIsArray(selectValue).length === selectAllEligible.length + 1, [selectValue, selectAllEligible]);\n  const handleOnSelect = (selectedItem) => {\n    if (isSingleMode) {\n      setSelectValue(selectedItem);\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (value === getValue(SELECT_ALL_VALUE)) {\n          if (isLabeledValue(selectedItem)) {\n            return [\n            ...selectAllEligible,\n            selectAllOption];\n\n          }\n          return [\n          SELECT_ALL_VALUE,\n          ...selectAllEligible.map((opt) => opt.value)];\n\n        }\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          if (result.length === selectAllEligible.length &&\n          selectAllEnabled) {\n            return isLabeledValue(selectedItem) ?\n            [...result, selectAllOption] :\n            [...result, SELECT_ALL_VALUE];\n          }\n          return result;\n        }\n        return previousState;\n      });\n    }\n    setInputValue('');\n  };\n  const clear = () => {\n    setSelectValue(fullSelectOptions.\n    filter((option) => option.disabled && hasOption(option.value, selectValue)).\n    map((option) => labelInValue ?\n    { label: option.label, value: option.value } :\n    option.value));\n  };\n  const handleOnDeselect = (value) => {\n    if (Array.isArray(selectValue)) {\n      if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n        clear();\n      } else\n      {\n        let array = selectValue;\n        array = array.filter((element) => getValue(element) !== getValue(value));\n        // if this was not a new item, deselect select all option\n        if (selectAllMode &&\n        selectOptions.some((opt) => opt.value === getValue(value))) {\n          array = array.filter((element) => getValue(element) !== SELECT_ALL_VALUE);\n        }\n        setSelectValue(array);\n      }\n    }\n    setInputValue('');\n  };\n  const handleOnSearch = (search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions && isSingleMode) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true };\n\n      const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    setInputValue(search);\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      if (!_isEqual(initialOptionsSorted, selectOptions)) {\n        setSelectOptions(initialOptionsSorted);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText);\n  const handleClear = () => {\n    clear();\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    setSelectOptions(initialOptions);\n  }, [initialOptions]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    // if all values are selected, add select all to value\n    if (selectAllEnabled &&\n    ensureIsArray(value).length === selectAllEligible.length) {\n      setSelectValue(labelInValue ?\n      [...ensureIsArray(value), selectAllOption] :\n      [\n      ...ensureIsArray(value),\n      SELECT_ALL_VALUE]);\n\n    }\n  }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n  useEffect(() => {\n    const checkSelectAll = ensureIsArray(selectValue).some((v) => getValue(v) === SELECT_ALL_VALUE);\n    if (checkSelectAll && !selectAllMode) {\n      const optionsToSelect = selectAllEligible.map((option) => labelInValue ? option : option.value);\n      optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n      setSelectValue(optionsToSelect);\n    }\n  }, [selectValue, selectAllMode, labelInValue, selectAllEligible]);\n  const selectAllLabel = useMemo(() => () =>\n  // TODO: localize\n  `${SELECT_ALL_VALUE} (${formatNumber(NumberFormats.INTEGER, selectAllEligible.length)})`, [selectAllEligible]);\n  const handleOnChange = (values, options) => {\n    // intercept onChange call to handle the select all case\n    // if the \"select all\" option is selected, we want to send all options to the onChange,\n    // otherwise we want to remove\n    let newValues = values;\n    let newOptions = options;\n    if (!isSingleMode) {\n      if (ensureIsArray(newValues).some((val) => getValue(val) === SELECT_ALL_VALUE)) {\n        // send all options to onchange if all are not currently there\n        if (!selectAllMode) {\n          newValues = mapValues(selectAllEligible, labelInValue);\n          newOptions = mapOptions(selectAllEligible);\n        } else\n        {\n          newValues = ensureIsArray(values).filter((val) => getValue(val) !== SELECT_ALL_VALUE);\n        }\n      } else\n      if (ensureIsArray(values).length === selectAllEligible.length &&\n      selectAllMode) {\n        const array = selectAllEligible.filter((option) => hasOption(option.value, selectValue) && option.disabled);\n        newValues = mapValues(array, labelInValue);\n        newOptions = mapOptions(array);\n      }\n    }\n    onChange == null ? void 0 : onChange(newValues, newOptions);\n  };\n  const shouldRenderChildrenOptions = useMemo(() => selectAllEnabled || hasCustomLabels(options), [selectAllEnabled, options]);\n  const customMaxTagPlaceholder = () => {\n    const num_selected = ensureIsArray(selectValue).length;\n    const num_shown = maxTagCount;\n    return selectAllMode ?\n    `+ ${num_selected - num_shown - 1} ...` :\n    `+ ${num_selected - num_shown} ...`;\n  };\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: false, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: labelInValue, maxTagCount: maxTagCount, maxTagPlaceholder: customMaxTagPlaceholder, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange, onPopupScroll: undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, onChange: handleOnChange, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: tokenSeparators || TOKEN_SEPARATORS, value: selectValue, suffixIcon: getSuffixIcon(isLoading, shouldShowSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }) }, !shouldRenderChildrenOptions && { options: fullSelectOptions }, { oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  selectAllEnabled && ___EmotionJSX(Option, { id: \"select-all\", className: \"select-all\", key: SELECT_ALL_VALUE, value: SELECT_ALL_VALUE },\n  selectAllLabel()),\n\n  shouldRenderChildrenOptions &&\n  renderSelectOptions(fullSelectOptions)));\n\n\n});\nexport default Select;","map":{"version":3,"mappings":"qGAAA;;;;;;;;;;;;;;;;;;AAkBA,OAAOA,KAAP,IACEC,UADF,EAIEC,SAJF,EAKEC,OALF,EAMEC,QANF,EAOEC,WAPF,QAQO,OARP;AASA,SACEC,aADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,CAJF,QAKO,mBALP;AAMA,OAAOC,UAAP,MAA6D,iBAA7D;;AAEA,SACEC,QADF,EAEEC,SAFF,EAGEC,cAHF,EAIEC,mBAJF,EAKEC,uBALF,EAMEC,8BANF,EAOEC,wBAPF,EAQEC,oBARF,EASEC,aATF,EAUEC,gBAVF,EAWEC,eAXF,EAYEC,SAZF,EAaEC,UAbF,EAcEC,eAdF,QAeO,SAfP;AAiBA,SACEC,mBADF,EAEEC,eAFF,EAGEC,YAHF,EAIEC,YAJF,EAKEC,kBALF,QAMO,UANP;AAOA,SACEC,aADF,EAEEC,aAFF,EAGEC,gBAHF,EAIEC,uBAJF,QAKO,aALP;AAMA,SAASC,eAAT,QAAgC,aAAhC;AAEA;;;;;;;;;;;;;;AAcA,MAAMC,MAAM,gBAAGlC,UAAU,CACvB,OA+BEmC,GA/BF,KAgCI,KA/BF,EACEC,UADF,EAEEC,eAAe,GAAG,KAFpB,EAGEC,cAAc,GAAG,IAHnB,EAIEC,SAJF,EAKEC,YAAY,GAAG,IALjB,EAMEC,MAAM,GAAG,IANX,EAOEC,cAAc,GAAG,KAPnB,EAQEC,UARF,EASEC,eAAe,GAAG,KATpB,EAUEC,YAAY,GAAG,KAVjB,EAWEC,OAXF,EAYEC,IAAI,GAAG,QAZT,EAaEC,IAbF,EAcEC,eAdF,EAeEC,QAfF,EAgBEC,OAhBF,EAiBEC,uBAjBF,EAkBEC,iBAAiB,GAAG,CAAC,OAAD,EAAU,OAAV,CAlBtB,EAmBEC,OAnBF,EAoBEC,WAAW,GAAG/C,CAAC,CAAC,YAAD,CApBjB,EAqBEgD,UAAU,GAAG,IArBf,EAsBEC,cAAc,GAAGzB,uBAtBnB,EAuBE0B,eAvBF,EAwBEC,KAxBF,EAyBEC,iBAzBF,EA0BEC,OA1BF,EA2BEC,WAAW,EAAEC,gBA3Bf,EA4BE,GAAGC,KA5BL,EA+BE;EACF,MAAMC,YAAY,GAAGlB,IAAI,KAAK,QAA9B;EACA,MAAMmB,gBAAgB,GAAG7B,eAAe,GAAG,IAAH,GAAUmB,UAAlD;EACA,MAAM,CAACW,WAAD,EAAcC,cAAd,IAAgCjE,QAAQ,CAACwD,KAAD,CAA9C;EACA,MAAM,CAACU,UAAD,EAAaC,aAAb,IAA8BnE,QAAQ,CAAC,EAAD,CAA5C;EACA,MAAM,CAACoE,SAAD,EAAYC,YAAZ,IAA4BrE,QAAQ,CAAC2C,OAAD,CAA1C;EACA,MAAM,CAAC2B,iBAAD,EAAoBC,oBAApB,IAA4CvE,QAAQ,CAAC,KAAD,CAA1D;EACA,MAAM,CAAC2D,WAAD,EAAca,cAAd,IAAgCxE,QAAQ,CAC5C4D,gBAD4C,WAC5CA,gBAD4C,GACxBjC,aADwB,CAA9C;EAIA7B,SAAS,CAAC,MAAK;IACb,IAAI4D,OAAJ,EAAa;MACXc,cAAc,CAACF,iBAAiB,GAAG,CAAH,GAAO,CAAzB,CAAd;IACD;EACF,CAJQ,EAIN,CAACA,iBAAD,EAAoBZ,OAApB,CAJM,CAAT;EAMA,MAAMe,UAAU,GAAGX,YAAY;EAC3BY,SAD2B;EAE3BxC,eAAe;EACf,MADe;EAEf,UAJJ;EAMA,MAAM,EAAEyC,MAAF,KAAarE,UAAnB;EAEA,MAAMsE,iBAAiB,GAAG3E,WAAW,CACnC,CAAC4E,CAAD,EAAsBC,CAAtB,KACEnE,uBAAuB,CAACkE,CAAD,EAAIC,CAAJ,EAAOd,WAAP,CAFU,EAGnC,CAACA,WAAD,CAHmC,CAArC;EAKA,MAAMe,wBAAwB,GAAG9E,WAAW,CAC1C,CAAC4E,CAAD,EAAsBC,CAAtB,KACElE,8BAA8B,CAC5BiE,CAD4B,EAE5BC,CAF4B,EAG5BZ,UAH4B,EAI5BU,iBAJ4B,EAK5BtB,cAL4B,CAFU,EAS1C,CAACY,UAAD,EAAaZ,cAAb,EAA6BsB,iBAA7B,CAT0C,CAA5C;EAYA,MAAMI,cAAc,GAAGjF,OAAO,CAC5B,MACEoD,OAAO,IAAI8B,KAAK,CAACC,OAAN,CAAc/B,OAAd,CAAX,GAAoCA,OAAO,CAACgC,KAAR,EAApC,GAAsDzD,aAF5B,EAG5B,CAACyB,OAAD,CAH4B,CAA9B;EAKA,MAAMiC,oBAAoB,GAAGrF,OAAO,CAClC,MAAMiF,cAAc,CAACG,KAAf,GAAuBE,IAAvB,CAA4BT,iBAA5B,CAD4B,EAElC,CAACI,cAAD,EAAiBJ,iBAAjB,CAFkC,CAApC;EAKA,MAAM,CAACU,aAAD,EAAgBC,gBAAhB,IACJvF,QAAQ,CAAoBoF,oBAApB,CADV;EAGA;EACA,MAAMI,iBAAiB,GAAGzF,OAAO,CAAC,MAAK;IACrC,MAAM0F,aAAa,GAAsBvF,aAAa,CAAC8D,WAAD,CAAb;IACtC0B,MADsC,CAC/B,IAAG,KAAI,CAAClF,SAAS,CAACD,QAAQ,CAACoF,GAAD,CAAT,EAAgBL,aAAhB,CADc;IAEtCM,GAFsC,CAElC,IAAG,KACNnF,cAAc,CAACkF,GAAD,CAAd,GAAsBA,GAAtB,GAA4B,EAAEnC,KAAK,EAAEmC,GAAT,EAAcE,KAAK,EAAEC,MAAM,CAACH,GAAD,CAA3B,EAHS,CAAzC;IAKA,MAAMI,MAAM,GACVN,aAAa,CAACO,MAAd,GAAuB,CAAvB;IACIP,aAAa,CAACQ,MAAd,CAAqBX,aAArB,CADJ;IAEIA,aAHN;IAIA,OAAOS,MAAM,CAACL,MAAP,CAAc,IAAG,KAAIC,GAAG,CAACnC,KAAJ,KAAcxC,gBAAnC,CAAP;EACD,CAXgC,EAW9B,CAACsE,aAAD,EAAgBtB,WAAhB,CAX8B,CAAjC;EAaA,MAAMkC,cAAc,GAAGnG,OAAO,CAC5B,MAAMyF,iBAAiB,CAACE,MAAlB,CAAyB,OAAM,KAAI,CAACS,MAAM,CAACC,QAA3C,CADsB,EAE5B,CAACZ,iBAAD,CAF4B,CAA9B;EAKA,MAAMa,iBAAiB,GAAGtG,OAAO,CAC/B,MACEyF,iBAAiB,CAACE,MAAlB,CACE,OAAM,KAAIlF,SAAS,CAAC2F,MAAM,CAAC3C,KAAR,EAAeQ,WAAf,CAAT,IAAwC,CAACmC,MAAM,CAACC,QAD5D,CAF6B,EAK/B,CAACZ,iBAAD,EAAoBxB,WAApB,CAL+B,CAAjC;EAQA,MAAMsC,gBAAgB,GAAGvG,OAAO,CAC9B,MACE,CAAC+D,YAAD;EACA3B,cADA;EAEAmD,aAAa,CAACU,MAAd,GAAuB,CAFvB;EAGAE,cAAc,CAACF,MAAf,GAAwB,CAHxB;EAIA,CAAC9B,UAN2B,EAO9B;EACEJ,YADF;EAEE3B,cAFF;EAGEmD,aAAa,CAACU,MAHhB;EAIEE,cAAc,CAACF,MAJjB;EAKE9B,UALF,CAP8B,CAAhC;;EAgBA,MAAMqC,aAAa,GAAGxG,OAAO,CAC3B,MAAMG,aAAa,CAAC8D,WAAD,CAAb,CAA2BgC,MAA3B,KAAsCK,iBAAiB,CAACL,MAAlB,GAA2B,CAD5C,EAE3B,CAAChC,WAAD,EAAcqC,iBAAd,CAF2B,CAA7B;EAKA,MAAMG,cAAc,GAAG,CACrBC,YADqB,KAEnB;IACF,IAAI3C,YAAJ,EAAkB;MAChBG,cAAc,CAACwC,YAAD,CAAd;IACD,CAFD;IAEO;MACLxC,cAAc,CAAC,cAAa,KAAG;QAC7B,MAAMyC,KAAK,GAAGxG,aAAa,CAACyG,aAAD,CAA3B;QACA,MAAMnD,KAAK,GAAGjD,QAAQ,CAACkG,YAAD,CAAtB;QACA;QACA,IAAIjD,KAAK,KAAKjD,QAAQ,CAACS,gBAAD,CAAtB,EAA0C;UACxC,IAAIP,cAAc,CAACgG,YAAD,CAAlB,EAAkC;YAChC,OAAO;YACL,GAAGJ,iBADE;YAELpF,eAFK,CAAP;;UAID;UACD,OAAO;UACLD,gBADK;UAEL,GAAGqF,iBAAiB,CAACT,GAAlB,CAAsB,IAAG,KAAID,GAAG,CAACnC,KAAjC,CAFE,CAAP;;QAID;QACD,IAAI,CAAChD,SAAS,CAACgD,KAAD,EAAQkD,KAAR,CAAd,EAA8B;UAC5B,MAAMX,MAAM,GAAG,CAAC,GAAGW,KAAJ,EAAWD,YAAX,CAAf;UACA,IACEV,MAAM,CAACC,MAAP,KAAkBK,iBAAiB,CAACL,MAApC;UACAM,gBAFF,EAGE;YACA,OAAO7F,cAAc,CAACgG,YAAD,CAAd;YACF,CAAC,GAAGV,MAAJ,EAAY9E,eAAZ,CADE;YAEF,CAAC,GAAG8E,MAAJ,EAAY/E,gBAAZ,CAFL;UAGD;UACD,OAAO+E,MAAP;QACD;QACD,OAAOY,aAAP;MACD,CA7Ba,CAAd;IA8BD;IACDxC,aAAa,CAAC,EAAD,CAAb;EACD,CAtCD;EAwCA,MAAMyC,KAAK,GAAG,MAAK;IACjB3C,cAAc,CACZuB,iBAAiB;IACdE,MADH,CAEI,OAAM,KAAIS,MAAM,CAACC,QAAP,IAAmB5F,SAAS,CAAC2F,MAAM,CAAC3C,KAAR,EAAeQ,WAAf,CAF1C;IAIG4B,GAJH,CAIO,OAAM,KACTlD,YAAY;IACR,EAAEmD,KAAK,EAAEM,MAAM,CAACN,KAAhB,EAAuBrC,KAAK,EAAE2C,MAAM,CAAC3C,KAArC,EADQ;IAER2C,MAAM,CAAC3C,KAPf,CADY,CAAd;EAWD,CAZD;EAcA,MAAMqD,gBAAgB,GAAG,CACvBrD,KADuB,KAErB;IACF,IAAIyB,KAAK,CAACC,OAAN,CAAclB,WAAd,CAAJ,EAAgC;MAC9B,IAAIzD,QAAQ,CAACiD,KAAD,CAAR,KAAoBjD,QAAQ,CAACS,gBAAD,CAAhC,EAAoD;QAClD4F,KAAK;MACN,CAFD;MAEO;QACL,IAAIF,KAAK,GAAG1C,WAAZ;QACA0C,KAAK,GAAGA,KAAK,CAAChB,MAAN,CACN,QAAO,KAAInF,QAAQ,CAACuG,OAAD,CAAR,KAAsBvG,QAAQ,CAACiD,KAAD,CADnC,CAAR;QAGA;QACA,IACE+C,aAAa;QACbjB,aAAa,CAACyB,IAAd,CAAmB,IAAG,KAAIpB,GAAG,CAACnC,KAAJ,KAAcjD,QAAQ,CAACiD,KAAD,CAAhD,CAFF,EAGE;UACAkD,KAAK,GAAGA,KAAK,CAAChB,MAAN,CACN,QAAO,KAAInF,QAAQ,CAACuG,OAAD,CAAR,KAAsB9F,gBAD3B,CAAR;QAGD;QACDiD,cAAc,CAACyC,KAAD,CAAd;MACD;IACF;IACDvC,aAAa,CAAC,EAAD,CAAb;EACD,CAxBD;EA0BA,MAAM6C,cAAc,GAAG,CAACC,MAAD,KAAmB;IACxC,MAAMC,WAAW,GAAGD,MAAM,CAACE,IAAP,EAApB;IACA,IAAIjF,eAAe,IAAI4B,YAAvB,EAAqC;MACnC,MAAMsD,SAAS,GAAGF,WAAW;MAC3B,CAAC1G,SAAS,CAAC0G,WAAD,EAAc1B,iBAAd,EAAiC,IAAjC,CADM,IACoC;QAClDK,KAAK,EAAEqB,WAD2C;QAElD1D,KAAK,EAAE0D,WAF2C;QAGlDG,WAAW,EAAE,IAHqC,EADtD;;MAMA,MAAMC,kBAAkB,GAAGpH,aAAa,CAACsF,iBAAD,CAAb,CAAiCE,MAAjC,CACzB,IAAG,KAAI,CAACC,GAAG,CAAC0B,WAAL,IAAoB7G,SAAS,CAACmF,GAAG,CAACnC,KAAL,EAAYQ,WAAZ,CADX,CAA3B;MAGA,MAAMuD,UAAU,GAAGH,SAAS;MACxB,CAACA,SAAD,EAAY,GAAGE,kBAAf,CADwB;MAExBA,kBAFJ;MAGA/B,gBAAgB,CAACgC,UAAD,CAAhB;IACD;IACDpD,aAAa,CAAC8C,MAAD,CAAb;EACD,CAlBD;EAoBA,MAAMO,kBAAkB,GAAG,CAACP,MAAD,EAAiBd,MAAjB,KACzBtF,wBAAwB,CAACoG,MAAD,EAASd,MAAT,EAAiBjD,iBAAjB,EAAoCb,YAApC,CAD1B;EAGA,MAAMoF,6BAA6B,GAAG,CAACnD,iBAAD,KAA+B;IACnEC,oBAAoB,CAACD,iBAAD,CAApB;IAEA;IACA;IACA,IAAIA,iBAAiB,IAAI,CAACJ,UAAtB,IAAoCoB,aAAa,CAACU,MAAd,GAAuB,CAA/D,EAAkE;MAChE,IAAI,CAAC,SAAQZ,oBAAR,EAA8BE,aAA9B,CAAL,EAAmD;QACjDC,gBAAgB,CAACH,oBAAD,CAAhB;MACD;IACF;IACD,IAAInC,uBAAJ,EAA6B;MAC3BA,uBAAuB,CAACqB,iBAAD,CAAvB;IACD;EACF,CAbD;EAeA,MAAMoD,cAAc,GAAG,CACrBC,UADqB,KAGrB7G,oBAAoB,CAClB6G,UADkB,EAElBrD,iBAFkB,EAGlBF,SAHkB,EAIlBoB,iBAAiB,CAACQ,MAJA,EAKlBxD,UALkB,CAHtB;EAWA,MAAMoF,WAAW,GAAG,MAAK;IACvBhB,KAAK;IACL,IAAI5D,OAAJ,EAAa;MACXA,OAAO;IACR;EACF,CALD;EAOAlD,SAAS,CAAC,MAAK;IACb;IACAyF,gBAAgB,CAACP,cAAD,CAAhB;EACD,CAHQ,EAGN,CAACA,cAAD,CAHM,CAAT;EAKAlF,SAAS,CAAC,MAAK;IACb,IAAI6C,OAAO,KAAK+B,SAAZ,IAAyB/B,OAAO,KAAKyB,SAAzC,EAAoD;MAClDC,YAAY,CAAC1B,OAAD,CAAZ;IACD;EACF,CAJQ,EAIN,CAACyB,SAAD,EAAYzB,OAAZ,CAJM,CAAT;EAMA7C,SAAS,CAAC,MAAK;IACbmE,cAAc,CAACT,KAAD,CAAd;EACD,CAFQ,EAEN,CAACA,KAAD,CAFM,CAAT;EAIA1D,SAAS,CAAC,MAAK;IACb;IACA,IACEwG,gBAAgB;IAChBpG,aAAa,CAACsD,KAAD,CAAb,CAAqBwC,MAArB,KAAgCK,iBAAiB,CAACL,MAFpD,EAGE;MACA/B,cAAc,CACZvB,YAAY;MACP,CAAC,GAAGxC,aAAa,CAACsD,KAAD,CAAjB,EAA0BvC,eAA1B,CADO;MAEP;MACC,GAAGf,aAAa,CAACsD,KAAD,CADjB;MAECxC,gBAFD,CAHO,CAAd;;IAQD;EACF,CAfQ,EAeN,CAAC0B,YAAD,EAAe2D,iBAAiB,CAACL,MAAjC,EAAyCM,gBAAzC,EAA2D9C,KAA3D,CAfM,CAAT;EAiBA1D,SAAS,CAAC,MAAK;IACb,MAAM+H,cAAc,GAAG3H,aAAa,CAAC8D,WAAD,CAAb,CAA2B+C,IAA3B,CACrB,EAAC,KAAIxG,QAAQ,CAACuH,CAAD,CAAR,KAAgB9G,gBADA,CAAvB;IAGA,IAAI6G,cAAc,IAAI,CAACtB,aAAvB,EAAsC;MACpC,MAAMwB,eAAe,GAAG1B,iBAAiB,CAACT,GAAlB,CAAsB,OAAM,KAClDlD,YAAY,GAAGyD,MAAH,GAAYA,MAAM,CAAC3C,KADT,CAAxB;MAGAuE,eAAe,CAACC,IAAhB,CAAqBtF,YAAY,GAAGzB,eAAH,GAAqBD,gBAAtD;MACAiD,cAAc,CAAC8D,eAAD,CAAd;IACD;EACF,CAXQ,EAWN,CAAC/D,WAAD,EAAcuC,aAAd,EAA6B7D,YAA7B,EAA2C2D,iBAA3C,CAXM,CAAT;EAaA,MAAM4B,cAAc,GAAGlI,OAAO,CAC5B,MAAM;EACJ;EACA,GAAGiB,gBAAgB,KAAKb,YAAY,CAClCC,aAAa,CAAC8H,OADoB,EAElC7B,iBAAiB,CAACL,MAFgB,CAGnC,GANyB,EAO5B,CAACK,iBAAD,CAP4B,CAA9B;EAUA,MAAM8B,cAAc,GAAG,CAACC,MAAD,EAAcjF,OAAd,KAA8B;IACnD;IACA;IACA;IACA,IAAIkF,SAAS,GAAGD,MAAhB;IACA,IAAIb,UAAU,GAAGpE,OAAjB;IACA,IAAI,CAACW,YAAL,EAAmB;MACjB,IACE5D,aAAa,CAACmI,SAAD,CAAb,CAAyBtB,IAAzB,CACE,IAAG,KAAIxG,QAAQ,CAAC+H,GAAD,CAAR,KAAkBtH,gBAD3B,CADF,EAIE;QACA;QACA,IAAI,CAACuF,aAAL,EAAoB;UAClB8B,SAAS,GAAGnH,SAAS,CAACmF,iBAAD,EAAoB3D,YAApB,CAArB;UACA6E,UAAU,GAAGpG,UAAU,CAACkF,iBAAD,CAAvB;QACD,CAHD;QAGO;UACLgC,SAAS,GAAGnI,aAAa,CAACkI,MAAD,CAAb,CAAsB1C,MAAtB,CACV,CAAC4C,GAAD,KAAc/H,QAAQ,CAAC+H,GAAD,CAAR,KAAkBtH,gBADtB,CAAZ;QAGD;MACF,CAdD;MAcO,IACLd,aAAa,CAACkI,MAAD,CAAb,CAAsBpC,MAAtB,KAAiCK,iBAAiB,CAACL,MAAnD;MACAO,aAFK,EAGL;QACA,MAAMG,KAAK,GAAGL,iBAAiB,CAACX,MAAlB,CACZ,OAAM,KAAIlF,SAAS,CAAC2F,MAAM,CAAC3C,KAAR,EAAeQ,WAAf,CAAT,IAAwCmC,MAAM,CAACC,QAD7C,CAAd;QAGAiC,SAAS,GAAGnH,SAAS,CAACwF,KAAD,EAAQhE,YAAR,CAArB;QACA6E,UAAU,GAAGpG,UAAU,CAACuF,KAAD,CAAvB;MACD;IACF;IACD3D,QAAQ,QAAR,oBAAQ,CAAGsF,SAAH,EAAcd,UAAd,CAAR;EACD,CAjCD;EAmCA,MAAMgB,2BAA2B,GAAGxI,OAAO,CACzC,MAAMuG,gBAAgB,IAAIlF,eAAe,CAAC+B,OAAD,CADA,EAEzC,CAACmD,gBAAD,EAAmBnD,OAAnB,CAFyC,CAA3C;EAKA,MAAMqF,uBAAuB,GAAG,MAAK;IACnC,MAAMC,YAAY,GAAGvI,aAAa,CAAC8D,WAAD,CAAb,CAA2BgC,MAAhD;IACA,MAAM0C,SAAS,GAAG/E,WAAlB;IACA,OAAO4C,aAAa;IAChB,KAAKkC,YAAY,GAAGC,SAAf,GAA2B,CAAC,MADjB;IAEhB,KAAKD,YAAY,GAAGC,SAAS,MAFjC;EAGD,CAND;EAQA,OACE,cAAC,eAAD,IAAiB,cAAc,EAAEnG,cAAjC;EACGD,MAAM,IACL,cAAC,YAAD,IAAc,cAAc,EAAEC,cAA9B,IAA+CD,MAA/C,CAFJ;EAIE,cAAC,YAAD,aACE,UAAU,EAAE,CAAC8B,SAAD,IAAcnC,UAD5B,EAEE,cAAYG,SAAS,IAAIS,IAF3B,EAGE,oBAAoB,EAAE,KAHxB,EAIE,cAAc,EAAE6E,cAJlB,EAKE,YAAY,EAAEF,kBALhB,EAME,UAAU,EAAEzC,wBANd,EAOE,iBAAiB,EACftB,iBAAiB,KAAK,YAAW,KAAIkF,WAAW,CAACC,UAAhC,CARrB,EAUE,cAAc,EAAErG,cAVlB,EAWE,YAAY,EAAEG,YAXhB,EAYE,WAAW,EAAEiB,WAZf,EAaE,iBAAiB,EAAE6E,uBAbrB,EAcE,IAAI,EAAE/D,UAdR,EAeE,eAAe,EAAEL,SAAS,GAAG/D,CAAC,CAAC,YAAD,CAAJ,GAAqByC,eAfjD,EAgBE,UAAU,EAAE+D,gBAhBd,EAiBE,uBAAuB,EAAEY,6BAjB3B,EAkBE,aAAa,EAAE/C,SAlBjB,EAmBE,QAAQ,EAAEX,gBAAgB,GAAGiD,cAAH,GAAoBtC,SAnBhD,EAoBE,QAAQ,EAAE8B,cApBZ,EAqBE,OAAO,EAAEoB,WArBX,EAsBE,QAAQ,EAAEO,cAtBZ,EAuBE,WAAW,EAAE/E,WAvBf,EAwBE,UAAU,EAAEW,gBAxBd,EAyBE,SAAS,MAzBX,EA0BE,eAAe,EAAER,eAAe,IAAI3B,gBA1BtC,EA2BE,KAAK,EAAEoC,WA3BT,EA4BE,UAAU,EAAEjD,aAAa,CACvBqD,SADuB,EAEvBL,gBAFuB,EAGvBO,iBAHuB,CA5B3B,EAiCE,oBAAoB,EAClB7B,eAAe,GACb,cAAC,kBAAD,IAAoB,QAAQ,EAAC,GAA7B,EAAiC,cAAW,MAA5C,GADa,GAGb,cAAC,mBAAD,IAAqB,QAAQ,EAAC,GAA9B,EAAkC,cAAW,OAA7C,GArCN,IAwCO,CAAC8F,2BAAD,IAAgC,EAAEpF,OAAO,EAAEqC,iBAAX,EAxCvC,IAyCE,OAAO,EAAE9B,OAzCX,EA0CE,SAAS,EAAE5B,eA1Cb,IA2CM+B,KA3CN,IA4CE,GAAG,EAAE7B,GA5CP;EA8CGsE,gBAAgB,IACf,cAAC,MAAD,IACE,EAAE,EAAC,YADL,EAEE,SAAS,EAAC,YAFZ,EAGE,GAAG,EAAEtF,gBAHP,EAIE,KAAK,EAAEA,gBAJT;EAMGiH,cAAc,EANjB,CA/CJ;;EAwDGM,2BAA2B;EAC1B7H,mBAAmB,CAAC8E,iBAAD,CAzDvB,CAJF,CADF;;;AAkED,CAzbsB,CAAzB;AA4bA,eAAezD,MAAf","names":["React","forwardRef","useEffect","useMemo","useState","useCallback","ensureIsArray","formatNumber","NumberFormats","t","AntdSelect","getValue","hasOption","isLabeledValue","renderSelectOptions","sortSelectedFirstHelper","sortComparatorWithSearchHelper","handleFilterOptionHelper","dropDownRenderHelper","getSuffixIcon","SELECT_ALL_VALUE","selectAllOption","mapValues","mapOptions","hasCustomLabels","StyledCheckOutlined","StyledContainer","StyledHeader","StyledSelect","StyledStopOutlined","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","Select","ref","allowClear","allowNewOptions","allowSelectAll","ariaLabel","filterOption","header","headerPosition","helperText","invertSelection","labelInValue","loading","mode","name","notFoundContent","onChange","onClear","onDropdownVisibleChange","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","value","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","isSingleMode","shouldShowSearch","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","isDropdownVisible","setIsDropdownVisible","setMaxTagCount","mappedMode","undefined","Option","sortSelectedFirst","a","b","sortComparatorWithSearch","initialOptions","Array","isArray","slice","initialOptionsSorted","sort","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","result","length","concat","enabledOptions","option","disabled","selectAllEligible","selectAllEnabled","selectAllMode","handleOnSelect","selectedItem","array","previousState","clear","handleOnDeselect","element","some","handleOnSearch","search","searchValue","trim","newOption","isNewOption","cleanSelectOptions","newOptions","handleFilterOption","handleOnDropdownVisibleChange","dropdownRender","originNode","handleClear","checkSelectAll","v","optionsToSelect","push","selectAllLabel","INTEGER","handleOnChange","values","newValues","val","shouldRenderChildrenOptions","customMaxTagPlaceholder","num_selected","num_shown","triggerNode","parentNode"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/Select.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n} from 'react';\nimport {\n  ensureIsArray,\n  formatNumber,\n  NumberFormats,\n  t,\n} from '@superset-ui/core';\nimport AntdSelect, { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport { isEqual } from 'lodash';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  handleFilterOptionHelper,\n  dropDownRenderHelper,\n  getSuffixIcon,\n  SELECT_ALL_VALUE,\n  selectAllOption,\n  mapValues,\n  mapOptions,\n  hasCustomLabels,\n} from './utils';\nimport { SelectOptionsType, SelectProps } from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst Select = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      allowSelectAll = true,\n      ariaLabel,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      labelInValue = false,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      optionFilterProps = ['label', 'value'],\n      options,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: SelectProps,\n    ref: RefObject<HTMLInputElement>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const shouldShowSearch = allowNewOptions ? true : showSearch;\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    const mappedMode = isSingleMode\n      ? undefined\n      : allowNewOptions\n      ? 'tags'\n      : 'multiple';\n\n    const { Option } = AntdSelect;\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValue),\n      [selectValue],\n    );\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const initialOptions = useMemo(\n      () =>\n        options && Array.isArray(options) ? options.slice() : EMPTY_OPTIONS,\n      [options],\n    );\n    const initialOptionsSorted = useMemo(\n      () => initialOptions.slice().sort(sortSelectedFirst),\n      [initialOptions, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(initialOptionsSorted);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      const result =\n        missingValues.length > 0\n          ? missingValues.concat(selectOptions)\n          : selectOptions;\n      return result.filter(opt => opt.value !== SELECT_ALL_VALUE);\n    }, [selectOptions, selectValue]);\n\n    const enabledOptions = useMemo(\n      () => fullSelectOptions.filter(option => !option.disabled),\n      [fullSelectOptions],\n    );\n\n    const selectAllEligible = useMemo(\n      () =>\n        fullSelectOptions.filter(\n          option => hasOption(option.value, selectValue) || !option.disabled,\n        ),\n      [fullSelectOptions, selectValue],\n    );\n\n    const selectAllEnabled = useMemo(\n      () =>\n        !isSingleMode &&\n        allowSelectAll &&\n        selectOptions.length > 0 &&\n        enabledOptions.length > 1 &&\n        !inputValue,\n      [\n        isSingleMode,\n        allowSelectAll,\n        selectOptions.length,\n        enabledOptions.length,\n        inputValue,\n      ],\n    );\n\n    const selectAllMode = useMemo(\n      () => ensureIsArray(selectValue).length === selectAllEligible.length + 1,\n      [selectValue, selectAllEligible],\n    );\n\n    const handleOnSelect = (\n      selectedItem: string | number | AntdLabeledValue | undefined,\n    ) => {\n      if (isSingleMode) {\n        setSelectValue(selectedItem);\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (value === getValue(SELECT_ALL_VALUE)) {\n            if (isLabeledValue(selectedItem)) {\n              return [\n                ...selectAllEligible,\n                selectAllOption,\n              ] as AntdLabeledValue[];\n            }\n            return [\n              SELECT_ALL_VALUE,\n              ...selectAllEligible.map(opt => opt.value),\n            ] as AntdLabeledValue[];\n          }\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            if (\n              result.length === selectAllEligible.length &&\n              selectAllEnabled\n            ) {\n              return isLabeledValue(selectedItem)\n                ? ([...result, selectAllOption] as AntdLabeledValue[])\n                : ([...result, SELECT_ALL_VALUE] as (string | number)[]);\n            }\n            return result as AntdLabeledValue[];\n          }\n          return previousState;\n        });\n      }\n      setInputValue('');\n    };\n\n    const clear = () => {\n      setSelectValue(\n        fullSelectOptions\n          .filter(\n            option => option.disabled && hasOption(option.value, selectValue),\n          )\n          .map(option =>\n            labelInValue\n              ? { label: option.label, value: option.value }\n              : option.value,\n          ),\n      );\n    };\n\n    const handleOnDeselect = (\n      value: string | number | AntdLabeledValue | undefined,\n    ) => {\n      if (Array.isArray(selectValue)) {\n        if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n          clear();\n        } else {\n          let array = selectValue as AntdLabeledValue[];\n          array = array.filter(\n            element => getValue(element) !== getValue(value),\n          );\n          // if this was not a new item, deselect select all option\n          if (\n            selectAllMode &&\n            selectOptions.some(opt => opt.value === getValue(value))\n          ) {\n            array = array.filter(\n              element => getValue(element) !== SELECT_ALL_VALUE,\n            );\n          }\n          setSelectValue(array);\n        }\n      }\n      setInputValue('');\n    };\n\n    const handleOnSearch = (search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions && isSingleMode) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      setInputValue(search);\n    };\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        if (!isEqual(initialOptionsSorted, selectOptions)) {\n          setSelectOptions(initialOptionsSorted);\n        }\n      }\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n      );\n\n    const handleClear = () => {\n      clear();\n      if (onClear) {\n        onClear();\n      }\n    };\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      setSelectOptions(initialOptions);\n    }, [initialOptions]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    useEffect(() => {\n      // if all values are selected, add select all to value\n      if (\n        selectAllEnabled &&\n        ensureIsArray(value).length === selectAllEligible.length\n      ) {\n        setSelectValue(\n          labelInValue\n            ? ([...ensureIsArray(value), selectAllOption] as AntdLabeledValue[])\n            : ([\n                ...ensureIsArray(value),\n                SELECT_ALL_VALUE,\n              ] as AntdLabeledValue[]),\n        );\n      }\n    }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n\n    useEffect(() => {\n      const checkSelectAll = ensureIsArray(selectValue).some(\n        v => getValue(v) === SELECT_ALL_VALUE,\n      );\n      if (checkSelectAll && !selectAllMode) {\n        const optionsToSelect = selectAllEligible.map(option =>\n          labelInValue ? option : option.value,\n        );\n        optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n        setSelectValue(optionsToSelect);\n      }\n    }, [selectValue, selectAllMode, labelInValue, selectAllEligible]);\n\n    const selectAllLabel = useMemo(\n      () => () =>\n        // TODO: localize\n        `${SELECT_ALL_VALUE} (${formatNumber(\n          NumberFormats.INTEGER,\n          selectAllEligible.length,\n        )})`,\n      [selectAllEligible],\n    );\n\n    const handleOnChange = (values: any, options: any) => {\n      // intercept onChange call to handle the select all case\n      // if the \"select all\" option is selected, we want to send all options to the onChange,\n      // otherwise we want to remove\n      let newValues = values;\n      let newOptions = options;\n      if (!isSingleMode) {\n        if (\n          ensureIsArray(newValues).some(\n            val => getValue(val) === SELECT_ALL_VALUE,\n          )\n        ) {\n          // send all options to onchange if all are not currently there\n          if (!selectAllMode) {\n            newValues = mapValues(selectAllEligible, labelInValue);\n            newOptions = mapOptions(selectAllEligible);\n          } else {\n            newValues = ensureIsArray(values).filter(\n              (val: any) => getValue(val) !== SELECT_ALL_VALUE,\n            );\n          }\n        } else if (\n          ensureIsArray(values).length === selectAllEligible.length &&\n          selectAllMode\n        ) {\n          const array = selectAllEligible.filter(\n            option => hasOption(option.value, selectValue) && option.disabled,\n          );\n          newValues = mapValues(array, labelInValue);\n          newOptions = mapOptions(array);\n        }\n      }\n      onChange?.(newValues, newOptions);\n    };\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => selectAllEnabled || hasCustomLabels(options),\n      [selectAllEnabled, options],\n    );\n\n    const customMaxTagPlaceholder = () => {\n      const num_selected = ensureIsArray(selectValue).length;\n      const num_shown = maxTagCount as number;\n      return selectAllMode\n        ? `+ ${num_selected - num_shown - 1} ...`\n        : `+ ${num_selected - num_shown} ...`;\n    };\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={false}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue={labelInValue}\n          maxTagCount={maxTagCount}\n          maxTagPlaceholder={customMaxTagPlaceholder}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          onPopupScroll={undefined}\n          onSearch={shouldShowSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          onChange={handleOnChange}\n          placeholder={placeholder}\n          showSearch={shouldShowSearch}\n          showArrow\n          tokenSeparators={tokenSeparators || TOKEN_SEPARATORS}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(\n            isLoading,\n            shouldShowSearch,\n            isDropdownVisible,\n          )}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          {...(!shouldRenderChildrenOptions && { options: fullSelectOptions })}\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {selectAllEnabled && (\n            <Option\n              id=\"select-all\"\n              className=\"select-all\"\n              key={SELECT_ALL_VALUE}\n              value={SELECT_ALL_VALUE}\n            >\n              {selectAllLabel()}\n            </Option>\n          )}\n          {shouldRenderChildrenOptions &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default Select;\n"]},"metadata":{},"sourceType":"module"}