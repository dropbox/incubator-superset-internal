{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, hasGenericChartAxes, isPhysicalColumn, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.aggregate || mode === QueryMode.raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.raw : QueryMode.aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false, extra_form_data } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla = (extra_form_data == null ? void 0 : extra_form_data.time_grain_sqla) || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false };\n\n  }\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing = [];\n    if (queryMode === QueryMode.aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(percentMetrics.map(getMetricLabel));\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`) } }];\n\n\n\n      }\n      columns = columns.map((col) => {var _formData$temporal_co;\n        if (isPhysicalColumn(col) &&\n        time_grain_sqla &&\n        hasGenericChartAxes &&\n        formData != null && (_formData$temporal_co = formData.temporal_columns_lookup) != null && _formData$temporal_co[col]) {\n          return {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL' };\n\n        }\n        return col;\n      });\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps };\n\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters });\n\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true },\n\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges } });};\n\n\n};\nexport default cachedBuildQuery();","map":{"version":3,"mappings":"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","names":["buildQueryContext","ensureIsArray","getMetricLabel","hasGenericChartAxes","isPhysicalColumn","QueryMode","removeDuplicates","updateExternalFormData","getQueryMode","formData","query_mode","mode","aggregate","raw","rawColumns","all_columns","hasRawColumns","length","buildQuery","options","percent_metrics","percentMetrics","order_desc","orderDesc","extra_form_data","queryMode","sortByMetric","timeseries_limit_metric","time_grain_sqla","formDataCopy","include_time","metrics","orderby","columns","baseQueryObject","postProcessing","percentMetricLabels","map","concat","operation","rename_columns","x","col","temporal_columns_lookup","timeGrain","columnType","sqlExpression","label","expressionType","moreProps","ownState","server_pagination","row_limit","pageSize","server_page_length","row_offset","currentPage","queryObject","post_processing","extras","cachedChanges","slice_id","JSON","stringify","filters","hooks","setDataMask","setCachedChanges","extraQueries","show_totals","push","undefined","interactiveGroupBy","interactive_groupby","Set","is_rowcount","cachedBuildQuery","newChanges"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AdhocColumn,\n  buildQueryContext,\n  ensureIsArray,\n  getMetricLabel,\n  hasGenericChartAxes,\n  isPhysicalColumn,\n  QueryMode,\n  QueryObject,\n  removeDuplicates,\n} from '@superset-ui/core';\nimport { PostProcessingRule } from '@superset-ui/core/src/query/types/PostProcessing';\nimport { BuildQuery } from '@superset-ui/core/src/chart/registries/ChartBuildQueryRegistrySingleton';\nimport { TableChartFormData } from './types';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData: TableChartFormData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.aggregate || mode === QueryMode.raw) {\n    return mode;\n  }\n  const rawColumns = formData?.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.raw : QueryMode.aggregate;\n}\n\nconst buildQuery: BuildQuery<TableChartFormData> = (\n  formData: TableChartFormData,\n  options,\n) => {\n  const {\n    percent_metrics: percentMetrics,\n    order_desc: orderDesc = false,\n    extra_form_data,\n  } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla =\n    extra_form_data?.time_grain_sqla || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false,\n    };\n  }\n\n  return buildQueryContext(formDataCopy, baseQueryObject => {\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    let postProcessing: PostProcessingRule[] = [];\n\n    if (queryMode === QueryMode.aggregate) {\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else if (metrics?.length > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricLabels = removeDuplicates(\n          percentMetrics.map(getMetricLabel),\n        );\n        metrics = removeDuplicates(\n          metrics.concat(percentMetrics),\n          getMetricLabel,\n        );\n        postProcessing = [\n          {\n            operation: 'contribution',\n            options: {\n              columns: percentMetricLabels,\n              rename_columns: percentMetricLabels.map(x => `%${x}`),\n            },\n          },\n        ];\n      }\n\n      columns = columns.map(col => {\n        if (\n          isPhysicalColumn(col) &&\n          time_grain_sqla &&\n          hasGenericChartAxes &&\n          formData?.temporal_columns_lookup?.[col]\n        ) {\n          return {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL',\n          } as AdhocColumn;\n        }\n        return col;\n      });\n    }\n\n    const moreProps: Partial<QueryObject> = {};\n    const ownState = options?.ownState ?? {};\n    if (formDataCopy.server_pagination) {\n      moreProps.row_limit =\n        ownState.pageSize ?? formDataCopy.server_page_length;\n      moreProps.row_offset =\n        (ownState.currentPage ?? 0) * (ownState.pageSize ?? 0);\n    }\n\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      ...moreProps,\n    };\n\n    if (\n      formData.server_pagination &&\n      options?.extras?.cachedChanges?.[formData.slice_id] &&\n      JSON.stringify(options?.extras?.cachedChanges?.[formData.slice_id]) !==\n        JSON.stringify(queryObject.filters)\n    ) {\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(\n        options?.hooks?.setDataMask,\n        0,\n        queryObject.row_limit ?? 0,\n      );\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options?.hooks?.setCachedChanges({\n      [formData.slice_id]: queryObject.filters,\n    });\n\n    const extraQueries: QueryObject[] = [];\n    if (\n      metrics?.length &&\n      formData.show_totals &&\n      queryMode === QueryMode.aggregate\n    ) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined, // we don't need orderby stuff here,\n        orderby: undefined, // because this query will be used for get total aggregation.\n      });\n    }\n\n    const interactiveGroupBy = formData.extra_form_data?.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n        ...new Set([...queryObject.columns, ...interactiveGroupBy]),\n      ];\n    }\n\n    if (formData.server_pagination) {\n      return [\n        { ...queryObject },\n        {\n          ...queryObject,\n          row_limit: 0,\n          row_offset: 0,\n          post_processing: [],\n          is_rowcount: true,\n        },\n        ...extraQueries,\n      ];\n    }\n\n    return [queryObject, ...extraQueries];\n  });\n};\n\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = (): BuildQuery<TableChartFormData> => {\n  let cachedChanges: any = {};\n  const setCachedChanges = (newChanges: any) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n\n  return (formData, options) =>\n    buildQuery(\n      { ...formData },\n      {\n        extras: { cachedChanges },\n        ownState: options?.ownState ?? {},\n        hooks: {\n          ...options?.hooks,\n          setDataMask: () => {},\n          setCachedChanges,\n        },\n      },\n    );\n};\n\nexport default cachedBuildQuery();\n"]},"metadata":{},"sourceType":"module"}