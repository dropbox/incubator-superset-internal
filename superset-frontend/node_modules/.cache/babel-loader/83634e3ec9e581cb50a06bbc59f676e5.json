{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isSimpleAdhocFilter } from './types/Filter';\nimport convertFilter from './convertFilter';\nfunction sanitizeClause(clause) {\n  let sanitizedClause = clause;\n  if (_includesInstanceProperty(clause).call(clause, '--')) {\n    sanitizedClause = `${clause}\\n`;\n  }\n  return `(${sanitizedClause})`;\n}\n/** Logic formerly in viz.py's process_query_filters */\nexport default function processFilters(formData) {\n  // Split adhoc_filters into four fields according to\n  // (1) clause (WHERE or HAVING)\n  // (2) expressionType\n  //     2.1 SIMPLE (subject + operator + comparator)\n  //     2.2 SQL (freeform SQL expression))\n  const { adhoc_filters, extras = {}, filters = [], where } = formData;\n  const simpleWhere = filters;\n  const freeformWhere = [];\n  if (where)\n  freeformWhere.push(where);\n  const freeformHaving = [];\n  (adhoc_filters || []).forEach((filter) => {\n    const { clause } = filter;\n    if (isSimpleAdhocFilter(filter)) {\n      const filterClause = convertFilter(filter);\n      if (clause === 'WHERE') {\n        simpleWhere.push(filterClause);\n      }\n    } else\n    {\n      const { sqlExpression } = filter;\n      if (clause === 'WHERE') {\n        freeformWhere.push(sqlExpression);\n      } else\n      {\n        freeformHaving.push(sqlExpression);\n      }\n    }\n  });\n  // some filter-related fields need to go in `extras`\n  extras.having = freeformHaving.map(sanitizeClause).join(' AND ');\n  extras.where = freeformWhere.map(sanitizeClause).join(' AND ');\n  return {\n    filters: simpleWhere,\n    extras };\n\n}","map":{"version":3,"mappings":"iGAAA;;;;;;;;;;;;;;;;;;AAsBA,SAASA,mBAAT,QAAoC,gBAApC;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AAEA,SAASC,cAAT,CAAwBC,MAAxB,EAAsC;EACpC,IAAIC,eAAe,GAAGD,MAAtB;EACA,IAAI,gCAAM,MAAN,OAAM,EAAU,IAAV,CAAV,EAA2B;IACzBC,eAAe,GAAG,GAAGD,MAAM,IAA3B;EACD;EACD,OAAO,IAAIC,eAAe,GAA1B;AACD;AAED;AACA,eAAc,SAAUC,cAAV,CACZC,QADY,EACoB;EAEhC;EACA;EACA;EACA;EACA;EACA,MAAM,EAAEC,aAAF,EAAiBC,MAAM,GAAG,EAA1B,EAA8BC,OAAO,GAAG,EAAxC,EAA4CC,KAA5C,KAAsDJ,QAA5D;EACA,MAAMK,WAAW,GAA8BF,OAA/C;EAEA,MAAMG,aAAa,GAAa,EAAhC;EACA,IAAIF,KAAJ;EAAWE,aAAa,CAACC,IAAd,CAAmBH,KAAnB;EACX,MAAMI,cAAc,GAAa,EAAjC;EAEA,CAACP,aAAa,IAAI,EAAlB,EAAsBQ,OAAtB,CAA8B,OAAM,KAAG;IACrC,MAAM,EAAEZ,MAAF,KAAaa,MAAnB;IACA,IAAIhB,mBAAmB,CAACgB,MAAD,CAAvB,EAAiC;MAC/B,MAAMC,YAAY,GAAGhB,aAAa,CAACe,MAAD,CAAlC;MACA,IAAIb,MAAM,KAAK,OAAf,EAAwB;QACtBQ,WAAW,CAACE,IAAZ,CAAiBI,YAAjB;MACD;IACF,CALD;IAKO;MACL,MAAM,EAAEC,aAAF,KAAoBF,MAA1B;MACA,IAAIb,MAAM,KAAK,OAAf,EAAwB;QACtBS,aAAa,CAACC,IAAd,CAAmBK,aAAnB;MACD,CAFD;MAEO;QACLJ,cAAc,CAACD,IAAf,CAAoBK,aAApB;MACD;IACF;EACF,CAfD;EAiBA;EACAV,MAAM,CAACW,MAAP,GAAgBL,cAAc,CAACM,GAAf,CAAmBlB,cAAnB,EAAmCmB,IAAnC,CAAwC,OAAxC,CAAhB;EACAb,MAAM,CAACE,KAAP,GAAeE,aAAa,CAACQ,GAAd,CAAkBlB,cAAlB,EAAkCmB,IAAlC,CAAuC,OAAvC,CAAf;EAEA,OAAO;IACLZ,OAAO,EAAEE,WADJ;IAELH,MAFK,EAAP;;AAID","names":["isSimpleAdhocFilter","convertFilter","sanitizeClause","clause","sanitizedClause","processFilters","formData","adhoc_filters","extras","filters","where","simpleWhere","freeformWhere","push","freeformHaving","forEach","filter","filterClause","sqlExpression","having","map","join"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/query/processFilters.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable camelcase */\nimport { QueryFormData } from './types/QueryFormData';\nimport { QueryObjectFilterClause } from './types/Query';\nimport { isSimpleAdhocFilter } from './types/Filter';\nimport convertFilter from './convertFilter';\n\nfunction sanitizeClause(clause: string): string {\n  let sanitizedClause = clause;\n  if (clause.includes('--')) {\n    sanitizedClause = `${clause}\\n`;\n  }\n  return `(${sanitizedClause})`;\n}\n\n/** Logic formerly in viz.py's process_query_filters */\nexport default function processFilters(\n  formData: Partial<QueryFormData>,\n): Partial<QueryFormData> {\n  // Split adhoc_filters into four fields according to\n  // (1) clause (WHERE or HAVING)\n  // (2) expressionType\n  //     2.1 SIMPLE (subject + operator + comparator)\n  //     2.2 SQL (freeform SQL expression))\n  const { adhoc_filters, extras = {}, filters = [], where } = formData;\n  const simpleWhere: QueryObjectFilterClause[] = filters;\n\n  const freeformWhere: string[] = [];\n  if (where) freeformWhere.push(where);\n  const freeformHaving: string[] = [];\n\n  (adhoc_filters || []).forEach(filter => {\n    const { clause } = filter;\n    if (isSimpleAdhocFilter(filter)) {\n      const filterClause = convertFilter(filter);\n      if (clause === 'WHERE') {\n        simpleWhere.push(filterClause);\n      }\n    } else {\n      const { sqlExpression } = filter;\n      if (clause === 'WHERE') {\n        freeformWhere.push(sqlExpression);\n      } else {\n        freeformHaving.push(sqlExpression);\n      }\n    }\n  });\n\n  // some filter-related fields need to go in `extras`\n  extras.having = freeformHaving.map(sanitizeClause).join(' AND ');\n  extras.where = freeformWhere.map(sanitizeClause).join(' AND ');\n\n  return {\n    filters: simpleWhere,\n    extras,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}