{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint max-len: 0 */\n/**\n * When determining if a component is a valid child of another component we must consider both\n *   - parent + child component types\n *   - component depth, or depth of nesting of container components\n *\n * We consider types because some components aren't containers (e.g. a heading) and we consider\n * depth to prevent infinite nesting of container components.\n *\n * The following example container nestings should be valid, which means that some containers\n * don't increase the (depth) of their children, namely tabs and tab:\n *   (a) root (0) > grid (1) >                         row (2) > column (3) > row (4) > non-container (5)\n *   (b) root (0) > grid (1) >    tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n *   (c) root (0) > top-tab (1) >                      row (2) > column (3) > row (4) > non-container (5)\n *   (d) root (0) > top-tab (1) > tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n */\nimport { CHART_TYPE, COLUMN_TYPE, DASHBOARD_GRID_TYPE, DASHBOARD_ROOT_TYPE, DIVIDER_TYPE, HEADER_TYPE, MARKDOWN_TYPE, ROW_TYPE, TABS_TYPE, TAB_TYPE, DYNAMIC_TYPE } from './componentTypes';\nimport { DASHBOARD_ROOT_DEPTH as rootDepth } from './constants';\nconst depthOne = rootDepth + 1;\n// const depthTwo = rootDepth + 2; // Meantime no need\nconst depthThree = rootDepth + 3;\nconst depthFour = rootDepth + 4;\nconst depthFive = rootDepth + 5;\n// when moving components around the depth of child is irrelevant, note these are parent depths\nconst parentMaxDepthLookup = {\n  [DASHBOARD_ROOT_TYPE]: {\n    [TABS_TYPE]: rootDepth,\n    [DASHBOARD_GRID_TYPE]: rootDepth },\n\n  [DASHBOARD_GRID_TYPE]: {\n    [CHART_TYPE]: depthOne,\n    [DYNAMIC_TYPE]: depthOne,\n    [MARKDOWN_TYPE]: depthOne,\n    [COLUMN_TYPE]: depthOne,\n    [DIVIDER_TYPE]: depthOne,\n    [HEADER_TYPE]: depthOne,\n    [ROW_TYPE]: depthOne,\n    [TABS_TYPE]: depthOne },\n\n  [ROW_TYPE]: {\n    [CHART_TYPE]: depthFour,\n    [DYNAMIC_TYPE]: depthFour,\n    [MARKDOWN_TYPE]: depthFour,\n    [COLUMN_TYPE]: depthFour },\n\n  [TABS_TYPE]: {\n    [TAB_TYPE]: depthThree },\n\n  [TAB_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [DYNAMIC_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [COLUMN_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree },\n\n  [COLUMN_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree },\n\n  // these have no valid children\n  [CHART_TYPE]: {},\n  [DYNAMIC_TYPE]: {},\n  [DIVIDER_TYPE]: {},\n  [HEADER_TYPE]: {},\n  [MARKDOWN_TYPE]: {} };\n\nexport default function isValidChild(child) {\n  const { parentType, childType, parentDepth } = child;\n  if (!parentType || !childType || typeof parentDepth !== 'number') {\n    return false;\n  }\n  const maxParentDepth = (parentMaxDepthLookup[parentType] || {})[childType];\n  return typeof maxParentDepth === 'number' && parentDepth <= maxParentDepth;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAkBA;AACA;;;;;;;;;;;;;;;AAeA,SACEA,UADF,EAEEC,WAFF,EAGEC,mBAHF,EAIEC,mBAJF,EAKEC,YALF,EAMEC,WANF,EAOEC,aAPF,EAQEC,QARF,EASEC,SATF,EAUEC,QAVF,EAWEC,YAXF,QAYO,kBAZP;AAcA,SAASC,oBAAoB,IAAIC,SAAjC,QAAkD,aAAlD;AAEA,MAAMC,QAAQ,GAAGD,SAAS,GAAG,CAA7B;AACA;AACA,MAAME,UAAU,GAAGF,SAAS,GAAG,CAA/B;AACA,MAAMG,SAAS,GAAGH,SAAS,GAAG,CAA9B;AACA,MAAMI,SAAS,GAAGJ,SAAS,GAAG,CAA9B;AAEA;AACA,MAAMK,oBAAoB,GAAG;EAC3B,CAACd,mBAAD,GAAuB;IACrB,CAACK,SAAD,GAAaI,SADQ;IAErB,CAACV,mBAAD,GAAuBU,SAFF,EADI;;EAM3B,CAACV,mBAAD,GAAuB;IACrB,CAACF,UAAD,GAAca,QADO;IAErB,CAACH,YAAD,GAAgBG,QAFK;IAGrB,CAACP,aAAD,GAAiBO,QAHI;IAIrB,CAACZ,WAAD,GAAeY,QAJM;IAKrB,CAACT,YAAD,GAAgBS,QALK;IAMrB,CAACR,WAAD,GAAeQ,QANM;IAOrB,CAACN,QAAD,GAAYM,QAPS;IAQrB,CAACL,SAAD,GAAaK,QARQ,EANI;;EAiB3B,CAACN,QAAD,GAAY;IACV,CAACP,UAAD,GAAce,SADJ;IAEV,CAACL,YAAD,GAAgBK,SAFN;IAGV,CAACT,aAAD,GAAiBS,SAHP;IAIV,CAACd,WAAD,GAAec,SAJL,EAjBe;;EAwB3B,CAACP,SAAD,GAAa;IACX,CAACC,QAAD,GAAYK,UADD,EAxBc;;EA4B3B,CAACL,QAAD,GAAY;IACV,CAACT,UAAD,GAAcgB,SADJ;IAEV,CAACN,YAAD,GAAgBM,SAFN;IAGV,CAACV,aAAD,GAAiBU,SAHP;IAIV,CAACf,WAAD,GAAea,UAJL;IAKV,CAACV,YAAD,GAAgBY,SALN;IAMV,CAACX,WAAD,GAAeW,SANL;IAOV,CAACT,QAAD,GAAYO,UAPF;IAQV,CAACN,SAAD,GAAaM,UARH,EA5Be;;EAuC3B,CAACb,WAAD,GAAe;IACb,CAACD,UAAD,GAAcgB,SADD;IAEb,CAACX,WAAD,GAAeW,SAFF;IAGb,CAACV,aAAD,GAAiBU,SAHJ;IAIb,CAACT,QAAD,GAAYO,UAJC;IAKb,CAACV,YAAD,GAAgBU,UALH;IAMb,CAACN,SAAD,GAAaM,UANA,EAvCY;;EAgD3B;EACA,CAACd,UAAD,GAAc,EAjDa;EAkD3B,CAACU,YAAD,GAAgB,EAlDW;EAmD3B,CAACN,YAAD,GAAgB,EAnDW;EAoD3B,CAACC,WAAD,GAAe,EApDY;EAqD3B,CAACC,aAAD,GAAiB,EArDU,EAA7B;;AA8DA,eAAc,SAAUY,YAAV,CAAuBC,KAAvB,EAA+C;EAC3D,MAAM,EAAEC,UAAF,EAAcC,SAAd,EAAyBC,WAAzB,KAAyCH,KAA/C;EACA,IAAI,CAACC,UAAD,IAAe,CAACC,SAAhB,IAA6B,OAAOC,WAAP,KAAuB,QAAxD,EAAkE;IAChE,OAAO,KAAP;EACD;EAED,MAAMC,cAAc,GAAuB,CAACN,oBAAoB,CAC9DG,UAD8D,CAApB,IAEvC,EAFsC,EAElCC,SAFkC,CAA3C;EAIA,OAAO,OAAOE,cAAP,KAA0B,QAA1B,IAAsCD,WAAW,IAAIC,cAA5D;AACD","names":["CHART_TYPE","COLUMN_TYPE","DASHBOARD_GRID_TYPE","DASHBOARD_ROOT_TYPE","DIVIDER_TYPE","HEADER_TYPE","MARKDOWN_TYPE","ROW_TYPE","TABS_TYPE","TAB_TYPE","DYNAMIC_TYPE","DASHBOARD_ROOT_DEPTH","rootDepth","depthOne","depthThree","depthFour","depthFive","parentMaxDepthLookup","isValidChild","child","parentType","childType","parentDepth","maxParentDepth"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/dashboard/util/isValidChild.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint max-len: 0 */\n/**\n * When determining if a component is a valid child of another component we must consider both\n *   - parent + child component types\n *   - component depth, or depth of nesting of container components\n *\n * We consider types because some components aren't containers (e.g. a heading) and we consider\n * depth to prevent infinite nesting of container components.\n *\n * The following example container nestings should be valid, which means that some containers\n * don't increase the (depth) of their children, namely tabs and tab:\n *   (a) root (0) > grid (1) >                         row (2) > column (3) > row (4) > non-container (5)\n *   (b) root (0) > grid (1) >    tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n *   (c) root (0) > top-tab (1) >                      row (2) > column (3) > row (4) > non-container (5)\n *   (d) root (0) > top-tab (1) > tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n */\nimport {\n  CHART_TYPE,\n  COLUMN_TYPE,\n  DASHBOARD_GRID_TYPE,\n  DASHBOARD_ROOT_TYPE,\n  DIVIDER_TYPE,\n  HEADER_TYPE,\n  MARKDOWN_TYPE,\n  ROW_TYPE,\n  TABS_TYPE,\n  TAB_TYPE,\n  DYNAMIC_TYPE,\n} from './componentTypes';\n\nimport { DASHBOARD_ROOT_DEPTH as rootDepth } from './constants';\n\nconst depthOne = rootDepth + 1;\n// const depthTwo = rootDepth + 2; // Meantime no need\nconst depthThree = rootDepth + 3;\nconst depthFour = rootDepth + 4;\nconst depthFive = rootDepth + 5;\n\n// when moving components around the depth of child is irrelevant, note these are parent depths\nconst parentMaxDepthLookup = {\n  [DASHBOARD_ROOT_TYPE]: {\n    [TABS_TYPE]: rootDepth,\n    [DASHBOARD_GRID_TYPE]: rootDepth,\n  },\n\n  [DASHBOARD_GRID_TYPE]: {\n    [CHART_TYPE]: depthOne,\n    [DYNAMIC_TYPE]: depthOne,\n    [MARKDOWN_TYPE]: depthOne,\n    [COLUMN_TYPE]: depthOne,\n    [DIVIDER_TYPE]: depthOne,\n    [HEADER_TYPE]: depthOne,\n    [ROW_TYPE]: depthOne,\n    [TABS_TYPE]: depthOne,\n  },\n\n  [ROW_TYPE]: {\n    [CHART_TYPE]: depthFour,\n    [DYNAMIC_TYPE]: depthFour,\n    [MARKDOWN_TYPE]: depthFour,\n    [COLUMN_TYPE]: depthFour,\n  },\n\n  [TABS_TYPE]: {\n    [TAB_TYPE]: depthThree,\n  },\n\n  [TAB_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [DYNAMIC_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [COLUMN_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree,\n  },\n\n  [COLUMN_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree,\n  },\n\n  // these have no valid children\n  [CHART_TYPE]: {},\n  [DYNAMIC_TYPE]: {},\n  [DIVIDER_TYPE]: {},\n  [HEADER_TYPE]: {},\n  [MARKDOWN_TYPE]: {},\n};\n\ninterface IsValidChildProps {\n  parentType?: string;\n  childType?: string;\n  parentDepth?: unknown;\n}\n\nexport default function isValidChild(child: IsValidChildProps): boolean {\n  const { parentType, childType, parentDepth } = child;\n  if (!parentType || !childType || typeof parentDepth !== 'number') {\n    return false;\n  }\n\n  const maxParentDepth: number | undefined = (parentMaxDepthLookup[\n    parentType\n  ] || {})[childType];\n\n  return typeof maxParentDepth === 'number' && parentDepth <= maxParentDepth;\n}\n"]},"metadata":{},"sourceType":"module"}