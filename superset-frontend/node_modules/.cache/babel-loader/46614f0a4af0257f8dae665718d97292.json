{"ast":null,"code":"import \"core-js/modules/es.regexp.flags.js\"; /* [LICENSE TBD] */\n/* eslint-disable */\nexport default function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [] };\n\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n  this,\n  [\n  'render',\n  'resize',\n  'highlight',\n  'brush',\n  'brushend',\n  'axesreorder'].\n  concat(d3.keys(__))),\n\n  w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n  h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n  flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false },\n\n  xscale = d3.scale.ordinal(),\n  yscale = {},\n  dragging = {},\n  line = d3.svg.line(),\n  axis = d3.svg.axis().orient('left').ticks(5),\n  g, // groups for axes, brushes\n  ctx = {},\n  canvas = {},\n  clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n        domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      } };\n\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n      scales.\n      map(function (p, i) {\n        return yscale[p].domain();\n      }).\n      reduce(function (a, b) {\n        return a.concat(b);\n      }));\n\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n        d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n    $V([\n    centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n    centroids[0].e(2)]));\n\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n    $V([\n    centroids[cols - 1].e(1) +\n    a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n    centroids[cols - 1].e(2)]));\n\n\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n      cps[i].e(1),\n      cps[i].e(2),\n      cps[i + 1].e(1),\n      cps[i + 1].e(2),\n      cps[i + 2].e(1),\n      cps[i + 2].e(2));\n\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n      \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      } else {\n        ctx.lineTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n  pc,\n  axis,\n  'ticks',\n  'orient',\n  'tickValues',\n  'tickSubdivide',\n  'tickSize',\n  'tickPadding',\n  'tickFormat');\n\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n    d3.behavior.\n    drag().\n    on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).\n    on('drag', function (d) {\n      dragging[d] = Math.min(\n      w(),\n      Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).\n    on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n      j = __.dimensions.indexOf(d),\n      elem = this,\n      parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions);\n        // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).\n      transition().\n      attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        } } },\n\n\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    } };\n\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n    strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n      id = strum.dims.i,\n      points = [strum.p1, strum.p2],\n      line = svg.selectAll('line#strum-' + id).data([strum]),\n      circles = svg.selectAll('circle#strum-' + id).data(points),\n      drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n        Math.max(strum.minX + 1, ev.x),\n        strum.maxX);\n\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h() };\n\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n        Math.max(strum.minX + 1, ev.x - __.margin.left),\n        strum.maxX);\n\n        strum.p2[1] = Math.min(\n        Math.max(strum.minY, ev.y - __.margin.top),\n        strum.maxY);\n\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n      p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n      m1 = 1 - width / p1[0],\n      b1 = p1[1] * (1 - m1),\n      m2 = 1 - width / p2[0],\n      b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n        y = p[1],\n        y1 = m1 * x + b1,\n        y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n      brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n        test = containmentTest(strum, strums.width(id)),\n        d1 = strum.dims.left,\n        d2 = strum.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n      svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      } };\n\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n    strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n      id = arc.dims.i,\n      points = [arc.p2, arc.p3],\n      line = svg.selectAll('line#arc-' + id).data([\n      { p1: arc.p1, p2: arc.p2 },\n      { p1: arc.p1, p2: arc.p3 }]),\n\n      circles = svg.selectAll('circle#arc-' + id).data(points),\n      drag = d3.behavior.drag(),\n      path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n        angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0) };\n\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n        Math.max(arc.minX + 1, ev.x - __.margin.left),\n        arc.maxX);\n\n        arc.p2[1] = Math.min(\n        Math.max(arc.minY, ev.y - __.margin.top),\n        arc.maxY);\n\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n      brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n        test = containmentTest(arc),\n        d1 = arc.dims.left,\n        d2 = arc.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        a = arcs.width(id),\n        b = y1(d[d1]) - y2(d[d2]),\n        c = hypothenuse(a, b),\n        angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n      svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n        b = p1[1] - p2[1],\n        c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n        b = arc.p1[1] - arc.p2[1],\n        c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      } };\n\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin });\n\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)) };\n\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n  _rate = 10, // number of calls per frame\n  _clear = function () {}, // clearing function\n  _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};","map":{"version":3,"names":["config","__","data","highlighted","dimensions","dimensionTitles","dimensionTitleRotation","types","brushed","brushedColor","alphaOnBrushed","mode","rate","width","height","margin","top","right","bottom","left","nullValueSeparator","nullValueSeparatorPadding","color","composite","alpha","bundlingStrength","bundleDimension","smoothness","showControlPoints","hideAxis","extend","pc","selection","d3","select","clientWidth","clientHeight","forEach","layer","canvas","append","attr","ctx","getContext","svg","events","dispatch","apply","concat","keys","w","h","flags","brushable","reorderable","axes","interactive","debug","xscale","scale","ordinal","yscale","dragging","line","axis","orient","ticks","g","clusterCentroids","side_effects","on","d","foreground","globalCompositeOperation","value","globalAlpha","strokeStyle","resize","brushedQueue","foregroundQueue","domain","render","updateAxes","length","detectDimensions","autoscale","compute_cluster_centroids","without","state","getset","rebind","obj","key","x","arguments","old","call","previous","target","source","arr","item","filter","elem","indexOf","getRange","defaultScales","date","k","extent","getTime","rangePoints","time","range","number","linear","string","counts","map","p","undefined","Object","getOwnPropertyNames","sort","a","b","selectAll","style","lineWidth","highlight","flip","reverse","commonScale","global","type","t","scales","i","reduce","detectDimensionTypes","toType","v","toString","match","toLowerCase","toTypeCoerceNumbers","parseFloat","col","renderBrushed","isBrushed","object","brush","currentMode","brushState","hasOwnProperty","default","clear","path_foreground","renderQueue","queue","path_brushed","clusterCounts","row","scaled","has","set","count","get","compute_centroids","centroids","cols","position","y","push","$V","cx","cy","leftCentroid","rightCentroid","centroid","compute_control_points","cps","e","mid","diff","subtract","add","shadows","axisDots","r","marks","startAngle","endAngle","Math","PI","min","pow","beginPath","arc","stroke","fill","single_curve","moveTo","j","fillRect","bezierCurveTo","color_path","single_path","paths","clearRect","getNullPosition","console","log","lineTo","functor","path_highlight","fillStyle","flipAxisAndUpdatePCP","dimension","parentElement","transition","duration","rotateLabels","delta","event","deltaY","preventDefault","dimensionLabels","createAxes","removeAxes","enter","each","transform","class","text","remove","g_data","exit","brushMode","behavior","drag","__origin__","max","dx","parent","previousElementSibling","axesreorder","insertBefore","children","appendChild","reorder","rowdata","dims","slice","pixelDifference","localeCompare","reordered","some","val","index","unhighlight","adjacent_pairs","ret","modes","None","install","uninstall","selected","predicate","brushUpdated","newSelection","brushPredicate","String","toUpperCase","brushModes","brushReset","brushes","is_brushed","empty","actives","extents","within","every","brushExtents","ascending","brushSelections","brushFor","sourceEvent","stopPropagation","brushend","strums","strumRect","drawStrum","strum","activePoint","id","points","p1","p2","circles","ev","minX","maxX","minY","maxY","onDragEnd","dimensionsForPoint","dim","next","onDragStart","mouse","active","onDrag","containmentTest","m1","b1","m2","b2","y1","y2","ids","isNaN","crossesStrum","test","d1","d2","point","removeStrum","consecutive","first","second","insert","multibrush","extentAdaption","resizeAdaption","arcs","p3","path","angle","innerRadius","hypothenuse","sqrt","rad","c","deg","signedAngle","tmp","asin","outerRadius","sAngle","uAngle","classed","intersection","version","func","_queue","_rate","_clear","_i","rq","invalidate","valid","doFrame","end","timer","remaining"],"sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js"],"sourcesContent":["/* [LICENSE TBD] */\n/* eslint-disable */\nexport default function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [],\n  };\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection\n      .append('svg')\n      .attr('width', __.width)\n      .attr('height', __.height)\n      .append('svg:g')\n      .attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')',\n      );\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n      this,\n      [\n        'render',\n        'resize',\n        'highlight',\n        'brush',\n        'brushend',\n        'axesreorder',\n      ].concat(d3.keys(__)),\n    ),\n    w = function () {\n      return __.width - __.margin.right - __.margin.left;\n    },\n    h = function () {\n      return __.height - __.margin.top - __.margin.bottom;\n    },\n    flags = {\n      brushable: false,\n      reorderable: false,\n      axes: false,\n      interactive: false,\n      debug: false,\n    },\n    xscale = d3.scale.ordinal(),\n    yscale = {},\n    dragging = {},\n    line = d3.svg.line(),\n    axis = d3.svg.axis().orient('left').ticks(5),\n    g, // groups for axes, brushes\n    ctx = {},\n    canvas = {},\n    clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch\n    .apply(this, d3.keys(__))\n    .on('composite', function (d) {\n      ctx.foreground.globalCompositeOperation = d.value;\n      ctx.brushed.globalCompositeOperation = d.value;\n    })\n    .on('alpha', function (d) {\n      ctx.foreground.globalAlpha = d.value;\n      ctx.brushed.globalAlpha = d.value;\n    })\n    .on('brushedColor', function (d) {\n      ctx.brushed.strokeStyle = d.value;\n    })\n    .on('width', function (d) {\n      pc.resize();\n    })\n    .on('height', function (d) {\n      pc.resize();\n    })\n    .on('margin', function (d) {\n      pc.resize();\n    })\n    .on('rate', function (d) {\n      brushedQueue.rate(d.value);\n      foregroundQueue.rate(d.value);\n    })\n    .on('dimensions', function (d) {\n      xscale.domain(__.dimensions);\n      if (flags.interactive) {\n        pc.render().updateAxes();\n      }\n    })\n    .on('bundleDimension', function (d) {\n      if (!__.dimensions.length) pc.detectDimensions();\n      if (!(__.dimensions[0] in yscale)) pc.autoscale();\n      if (typeof d.value === 'number') {\n        if (d.value < __.dimensions.length) {\n          __.bundleDimension = __.dimensions[d.value];\n        } else if (d.value < __.hideAxis.length) {\n          __.bundleDimension = __.hideAxis[d.value];\n        }\n      } else {\n        __.bundleDimension = d.value;\n      }\n\n      __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n    })\n    .on('hideAxis', function (d) {\n      if (!__.dimensions.length) pc.detectDimensions();\n      pc.dimensions(without(__.dimensions, d.value));\n    });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n        h() +\n          1 -\n          __.nullValueSeparatorPadding.bottom -\n          __.nullValueSeparatorPadding.top,\n        1,\n      ];\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n        h() + 1,\n        1 +\n          __.nullValueSeparatorPadding.bottom +\n          __.nullValueSeparatorPadding.top,\n      ];\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n          domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      },\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection\n      .selectAll('canvas')\n      .style('margin-top', __.margin.top + 'px')\n      .style('margin-left', __.margin.left + 'px')\n      .attr('width', w() + 2)\n      .attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n        scales\n          .map(function (p, i) {\n            return yscale[p].domain();\n          })\n          .reduce(function (a, b) {\n            return a.concat(b);\n          }),\n      );\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n          d3.extent(__.data, function (d) {\n            return +d[k];\n          }),\n        );\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString\n      .call(v)\n      .match(/\\s([a-zA-Z]+)/)[1]\n      .toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3\n    .renderQueue(path_foreground)\n    .rate(50)\n    .clear(function () {\n      pc.clear('foreground');\n      pc.clear('highlight');\n    });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3\n    .renderQueue(path_brushed)\n    .rate(50)\n    .clear(function () {\n      pc.clear('brushed');\n    });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids\n            .get(yscale[__.bundleDimension](row[__.bundleDimension]))\n            .get(p[i]);\n          var rightCentroid = __.clusterCentroids\n            .get(yscale[__.bundleDimension](row[__.bundleDimension]))\n            .get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n      $V([\n        centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n        centroids[0].e(2),\n      ]),\n    );\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n      $V([\n        centroids[cols - 1].e(1) +\n          a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n        centroids[cols - 1].e(2),\n      ]),\n    );\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n        cps[i].e(1),\n        cps[i].e(2),\n        cps[i + 1].e(1),\n        cps[i + 1].e(2),\n        cps[i + 2].e(1),\n        cps[i + 2].e(2),\n      );\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n      (__.bundleDimension !== null && __.bundlingStrength > 0) ||\n      __.smoothness > 0\n    ) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n        (__.bundleDimension !== null && __.bundlingStrength > 0) ||\n        __.smoothness > 0\n      ) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n        \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\",\n      );\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]),\n        );\n      } else {\n        ctx.lineTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]),\n        );\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n    pc,\n    axis,\n    'ticks',\n    'orient',\n    'tickValues',\n    'tickSubdivide',\n    'tickSize',\n    'tickPadding',\n    'tickFormat',\n  );\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement)\n      .transition()\n      .duration(1100)\n      .call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg\n      .selectAll('text.label')\n      .attr(\n        'transform',\n        'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      );\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg\n      .selectAll('.dimension')\n      .data(__.dimensions, function (d) {\n        return d;\n      })\n      .enter()\n      .append('svg:g')\n      .attr('class', 'dimension')\n      .attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n\n    // Add an axis and title.\n    g.append('svg:g')\n      .attr('class', 'axis')\n      .attr('transform', 'translate(0,0)')\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      })\n      .append('svg:text')\n      .attr({\n        'text-anchor': 'middle',\n        y: 0,\n        transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n        x: 0,\n        class: 'label',\n      })\n      .text(dimensionLabels)\n      .on('dblclick', flipAxisAndUpdatePCP)\n      .on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg\n        .append('line')\n        .attr('x1', 0)\n        .attr('y1', 1 + __.nullValueSeparatorPadding.top)\n        .attr('x2', w())\n        .attr('y2', 1 + __.nullValueSeparatorPadding.top)\n        .attr('stroke-width', 1)\n        .attr('stroke', '#777')\n        .attr('fill', 'none')\n        .attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg\n        .append('line')\n        .attr('x1', 0)\n        .attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom)\n        .attr('x2', w())\n        .attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom)\n        .attr('stroke-width', 1)\n        .attr('stroke', '#777')\n        .attr('fill', 'none')\n        .attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data\n      .enter()\n      .append('svg:g')\n      .attr('class', 'dimension')\n      .attr('transform', function (p) {\n        return 'translate(' + position(p) + ')';\n      })\n      .style('opacity', 0)\n      .append('svg:g')\n      .attr('class', 'axis')\n      .attr('transform', 'translate(0,0)')\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      })\n      .append('svg:text')\n      .attr({\n        'text-anchor': 'middle',\n        y: 0,\n        transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n        x: 0,\n        class: 'label',\n      })\n      .text(dimensionLabels)\n      .on('dblclick', flipAxisAndUpdatePCP)\n      .on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data\n      .select('.axis')\n      .transition()\n      .duration(1100)\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      });\n    g_data\n      .select('.label')\n      .transition()\n      .duration(1100)\n      .text(dimensionLabels)\n      .attr(\n        'transform',\n        'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      );\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition()\n      .duration(1100)\n      .attr('transform', function (p) {\n        return 'translate(' + position(p) + ')';\n      })\n      .style('opacity', 1);\n\n    pc.svg\n      .selectAll('.axis')\n      .transition()\n      .duration(1100)\n      .each(function (d) {\n        d3.select(this).call(axis.scale(yscale[d]));\n      });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n      d3.behavior\n        .drag()\n        .on('dragstart', function (d) {\n          dragging[d] = this.__origin__ = xscale(d);\n        })\n        .on('drag', function (d) {\n          dragging[d] = Math.min(\n            w(),\n            Math.max(0, (this.__origin__ += d3.event.dx)),\n          );\n          __.dimensions.sort(function (a, b) {\n            return position(a) - position(b);\n          });\n          xscale.domain(__.dimensions);\n          pc.render();\n          g.attr('transform', function (d) {\n            return 'translate(' + position(d) + ')';\n          });\n        })\n        .on('dragend', function (d) {\n          // Let's see if the order has changed and send out an event if so.\n          var i = 0,\n            j = __.dimensions.indexOf(d),\n            elem = this,\n            parent = this.parentElement;\n\n          while ((elem = elem.previousElementSibling) != null) ++i;\n          if (i !== j) {\n            events.axesreorder.call(pc, __.dimensions);\n            // We now also want to reorder the actual dom elements that represent\n            // the axes. That is, the g.dimension elements. If we don't do this,\n            // we get a weird and confusing transition when updateAxes is called.\n            // This is due to the fact that, initially the nth g.dimension element\n            // represents the nth axis. However, after a manual reordering,\n            // without reordering the dom elements, the nth dom elements no longer\n            // necessarily represents the nth axis.\n            //\n            // i is the original index of the dom element\n            // j is the new index of the dom element\n            if (i > j) {\n              // Element moved left\n              parent.insertBefore(this, parent.children[j - 1]);\n            } else {\n              // Element moved right\n              if (j + 1 < parent.children.length) {\n                parent.insertBefore(this, parent.children[j + 1]);\n              } else {\n                parent.appendChild(this);\n              }\n            }\n          }\n\n          delete this.__origin__;\n          delete dragging[d];\n          d3.select(this)\n            .transition()\n            .attr('transform', 'translate(' + xscale(d) + ')');\n          pc.render();\n        }),\n    );\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition()\n        .duration(1500)\n        .attr('transform', function (d) {\n          return 'translate(' + xscale(d) + ')';\n        });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        },\n      },\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    },\n  };\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]\n            );\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n            );\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]\n            );\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n            );\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]\n          );\n        },\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush\n        .y(yscale[axis])\n        .on('brushstart', function () {\n          if (d3.event.sourceEvent !== null) {\n            d3.event.sourceEvent.stopPropagation();\n          }\n        })\n        .on('brush', function () {\n          brushUpdated(selected());\n        })\n        .on('brushend', function () {\n          events.brushend.call(pc, __.brushed);\n        });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g')\n        .attr('class', 'brush')\n        .each(function (d) {\n          d3.select(this).call(brushFor(d));\n        })\n        .selectAll('rect')\n        .style('visibility', null)\n        .attr('x', -15)\n        .attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents,\n    };\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n      strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n        id = strum.dims.i,\n        points = [strum.p1, strum.p2],\n        line = svg.selectAll('line#strum-' + id).data([strum]),\n        circles = svg.selectAll('circle#strum-' + id).data(points),\n        drag = d3.behavior.drag();\n\n      line\n        .enter()\n        .append('line')\n        .attr('id', 'strum-' + id)\n        .attr('class', 'strum');\n\n      line\n        .attr('x1', function (d) {\n          return d.p1[0];\n        })\n        .attr('y1', function (d) {\n          return d.p1[1];\n        })\n        .attr('x2', function (d) {\n          return d.p2[0];\n        })\n        .attr('y2', function (d) {\n          return d.p2[1];\n        })\n        .attr('stroke', 'black')\n        .attr('stroke-width', 2);\n\n      drag\n        .on('drag', function (d, i) {\n          var ev = d3.event;\n          i = i + 1;\n          strum['p' + i][0] = Math.min(\n            Math.max(strum.minX + 1, ev.x),\n            strum.maxX,\n          );\n          strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n          drawStrum(strum, i - 1);\n        })\n        .on('dragend', onDragEnd());\n\n      circles\n        .enter()\n        .append('circle')\n        .attr('id', 'strum-' + id)\n        .attr('class', 'strum');\n\n      circles\n        .attr('cx', function (d) {\n          return d[0];\n        })\n        .attr('cy', function (d) {\n          return d[1];\n        })\n        .attr('r', 5)\n        .style('opacity', function (d, i) {\n          return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n        })\n        .on('mouseover', function () {\n          d3.select(this).style('opacity', 0.8);\n        })\n        .on('mouseout', function () {\n          d3.select(this).style('opacity', 0);\n        })\n        .call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        (dims = dimensionsForPoint(p)),\n          (strum = {\n            p1: p,\n            dims: dims,\n            minX: xscale(dims.left),\n            maxX: xscale(dims.right),\n            minY: 0,\n            maxY: h(),\n          });\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n          Math.max(strum.minX + 1, ev.x - __.margin.left),\n          strum.maxX,\n        );\n        strum.p2[1] = Math.min(\n          Math.max(strum.minY, ev.y - __.margin.top),\n          strum.maxY,\n        );\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n          y = p[1],\n          y1 = m1 * x + b1,\n          y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n        brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n          test = containmentTest(strum, strums.width(id)),\n          d1 = strum.dims.left,\n          d2 = strum.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n        svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n          strum &&\n          strum.p1[0] === strum.p2[0] &&\n          strum.p1[1] === strum.p2[1]\n        ) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first\n              ? i + i < length && __.dimensions[i + 1] === second\n              : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection\n        .select('svg')\n        .append('g')\n        .attr('id', 'strums')\n        .attr(\n          'transform',\n          'translate(' + __.margin.left + ',' + __.margin.top + ')',\n        );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag\n        .on('dragstart', onDragStart(strums))\n        .on('drag', onDrag(strums))\n        .on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection\n        .select('svg')\n        .insert('rect', 'g#strums')\n        .attr('id', 'strum-events')\n        .attr('x', __.margin.left)\n        .attr('y', __.margin.top)\n        .attr('width', w())\n        .attr('height', h() + 2)\n        .style('opacity', 0)\n        .call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      },\n    };\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        },\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush\n        .y(yscale[axis])\n        .on('brushstart', function () {\n          if (d3.event.sourceEvent !== null) {\n            d3.event.sourceEvent.stopPropagation();\n          }\n        })\n        .on('brush', function () {\n          brushUpdated(selected());\n        })\n        .on('brushend', function () {\n          // d3.svg.multibrush clears extents just before calling 'brushend'\n          // so we have to update here again.\n          // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n          // to avoid unnecessary computation.\n          brushUpdated(selected());\n          events.brushend.call(pc, __.brushed);\n        })\n        .extentAdaption(function (selection) {\n          selection.style('visibility', null).attr('x', -15).attr('width', 30);\n        })\n        .resizeAdaption(function (selection) {\n          selection.selectAll('rect').attr('x', -15).attr('width', 30);\n        });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g')\n        .attr('class', 'brush')\n        .each(function (d) {\n          d3.select(this).call(brushFor(d));\n        })\n        .selectAll('rect')\n        .style('visibility', null)\n        .attr('x', -15)\n        .attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents,\n    };\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n      strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n        id = arc.dims.i,\n        points = [arc.p2, arc.p3],\n        line = svg.selectAll('line#arc-' + id).data([\n          { p1: arc.p1, p2: arc.p2 },\n          { p1: arc.p1, p2: arc.p3 },\n        ]),\n        circles = svg.selectAll('circle#arc-' + id).data(points),\n        drag = d3.behavior.drag(),\n        path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path\n        .enter()\n        .append('path')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc')\n        .style('fill', 'orange')\n        .style('opacity', 0.5);\n\n      path\n        .attr('d', arc.arc)\n        .attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line\n        .enter()\n        .append('line')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc');\n\n      line\n        .attr('x1', function (d) {\n          return d.p1[0];\n        })\n        .attr('y1', function (d) {\n          return d.p1[1];\n        })\n        .attr('x2', function (d) {\n          return d.p2[0];\n        })\n        .attr('y2', function (d) {\n          return d.p2[1];\n        })\n        .attr('stroke', 'black')\n        .attr('stroke-width', 2);\n\n      drag\n        .on('drag', function (d, i) {\n          var ev = d3.event,\n            angle = 0;\n\n          i = i + 2;\n\n          arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n          arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n          angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n          if (\n            (arc.startAngle < Math.PI &&\n              arc.endAngle < Math.PI &&\n              angle < Math.PI) ||\n            (arc.startAngle >= Math.PI &&\n              arc.endAngle >= Math.PI &&\n              angle >= Math.PI)\n          ) {\n            if (i === 2) {\n              arc.endAngle = angle;\n              arc.arc.endAngle(angle);\n            } else if (i === 3) {\n              arc.startAngle = angle;\n              arc.arc.startAngle(angle);\n            }\n          }\n\n          drawStrum(arc, i - 2);\n        })\n        .on('dragend', onDragEnd());\n\n      circles\n        .enter()\n        .append('circle')\n        .attr('id', 'arc-' + id)\n        .attr('class', 'arc');\n\n      circles\n        .attr('cx', function (d) {\n          return d[0];\n        })\n        .attr('cy', function (d) {\n          return d[1];\n        })\n        .attr('r', 5)\n        .style('opacity', function (d, i) {\n          return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n        })\n        .on('mouseover', function () {\n          d3.select(this).style('opacity', 0.8);\n        })\n        .on('mouseout', function () {\n          d3.select(this).style('opacity', 0);\n        })\n        .call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        (dims = dimensionsForPoint(p)),\n          (arc = {\n            p1: p,\n            dims: dims,\n            minX: xscale(dims.left),\n            maxX: xscale(dims.right),\n            minY: 0,\n            maxY: h(),\n            startAngle: undefined,\n            endAngle: undefined,\n            arc: d3.svg.arc().innerRadius(0),\n          });\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n          Math.max(arc.minX + 1, ev.x - __.margin.left),\n          arc.maxX,\n        );\n        arc.p2[1] = Math.min(\n          Math.max(arc.minY, ev.y - __.margin.top),\n          arc.maxY,\n        );\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = (function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    })();\n\n    var deg = (function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    })();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n        brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n          test = containmentTest(arc),\n          d1 = arc.dims.left,\n          d2 = arc.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          a = arcs.width(id),\n          b = y1(d[d1]) - y2(d[d2]),\n          c = hypothenuse(a, b),\n          angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n        svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc\n            .outerRadius(arcs.length(arcs.active))\n            .startAngle(angle)\n            .endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n          b = p1[1] - p2[1],\n          c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n          b = arc.p1[1] - arc.p2[1],\n          c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first\n              ? i + i < length && __.dimensions[i + 1] === second\n              : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection\n        .select('svg')\n        .append('g')\n        .attr('id', 'arcs')\n        .attr(\n          'transform',\n          'translate(' + __.margin.left + ',' + __.margin.top + ')',\n        );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag\n        .on('dragstart', onDragStart(arcs))\n        .on('drag', onDrag(arcs))\n        .on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection\n        .select('svg')\n        .insert('rect', 'g#arcs')\n        .attr('id', 'arc-events')\n        .attr('x', __.margin.left)\n        .attr('y', __.margin.top)\n        .attr('width', w())\n        .attr('height', h() + 2)\n        .style('opacity', 0)\n        .call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      },\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection\n      .select('svg')\n      .attr('width', __.width)\n      .attr('height', __.height);\n    pc.svg.attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')',\n    );\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin,\n    });\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n        ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n          (a.x - b.x) * (c.x * d.y - c.y * d.x)) /\n        ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n        ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n          (a.y - b.y) * (c.x * d.y - c.y * d.x)) /\n        ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows'\n    );\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n    _rate = 10, // number of calls per frame\n    _clear = function () {}, // clearing function\n    _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}