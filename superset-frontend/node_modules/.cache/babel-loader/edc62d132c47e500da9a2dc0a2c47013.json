{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, ensureIsInt, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA as DEFAULT_RADAR_FORM_DATA, EchartsRadarLabelType } from './types';\nimport { DEFAULT_LEGEND_FORM_DATA, OpacityEnum } from '../constants';\nimport { extractGroupbyLabel, getChartPadding, getColtypesMapping, getLegendProps } from '../utils/series';\nimport { defaultGrid } from '../defaults';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function formatLabel(_ref) {let { params, labelType, numberFormatter } = _ref;\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsRadarLabelType.Value:\n      return formattedValue;\n    case EchartsRadarLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;}\n\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters } = chartProps;\n  const refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby, labelType, labelPosition, legendOrientation, legendType, legendMargin, metrics = [], numberFormat, dateFormat, showLabels, showLegend, isCircle, columnConfig, sliceId } = {\n    ...DEFAULT_LEGEND_FORM_DATA,\n    ...DEFAULT_RADAR_FORM_DATA,\n    ...formData };\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter,\n    labelType });\n\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const metricLabelAndMaxValueMap = new Map();\n  const columnsLabelMap = new Map();\n  const transformedData = [];\n  data.forEach((datum) => {var _context;\n    const joinedName = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat) });\n\n    // map(joined_name: [columnLabel_1, columnLabel_2, ...])\n    columnsLabelMap.set(joinedName, groupbyLabels.map((col) => datum[col]));\n    // put max value of series into metricLabelAndMaxValueMap\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [metricLabel, value] of Object.entries(datum)) {\n      if (metricLabelAndMaxValueMap.has(metricLabel)) {\n        metricLabelAndMaxValueMap.set(metricLabel, Math.max(value, ensureIsInt(metricLabelAndMaxValueMap.get(metricLabel), Number.MIN_SAFE_INTEGER)));\n      } else\n      {\n        metricLabelAndMaxValueMap.set(metricLabel, value);\n      }\n    }\n    const isFiltered = filterState.selectedValues &&\n    !_includesInstanceProperty(_context = filterState.selectedValues).call(_context, joinedName);\n    // generate transformedData\n    transformedData.push({\n      value: metricLabels.map((metricLabel) => datum[metricLabel]),\n      name: joinedName,\n      itemStyle: {\n        color: colorFn(joinedName, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.Transparent :\n        OpacityEnum.NonTransparent },\n\n      lineStyle: {\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent },\n\n      label: {\n        show: showLabels,\n        position: labelPosition,\n        formatter } });\n\n\n  });\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex((_ref2) => {let { name } = _ref2;return name === selectedValue;});\n    return {\n      ...acc,\n      [index]: selectedValue };\n\n  }, {});\n  const indicator = metricLabels.map((metricLabel) => {var _columnConfig$metricL;\n    const maxValueInControl = columnConfig == null ? void 0 : (_columnConfig$metricL = columnConfig[metricLabel]) == null ? void 0 : _columnConfig$metricL.radarMetricMaxValue;\n    // Ensure that 0 is at the center of the polar coordinates\n    const metricValueAsMax = metricLabelAndMaxValueMap.get(metricLabel) === 0 ?\n    Number.MAX_SAFE_INTEGER :\n    metricLabelAndMaxValueMap.get(metricLabel);\n    const max = maxValueInControl === null ? metricValueAsMax : maxValueInControl;\n    return {\n      name: metricLabel,\n      max };\n\n  });\n  const series = [\n  {\n    type: 'radar',\n    ...getChartPadding(showLegend, legendOrientation, legendMargin),\n    animation: false,\n    emphasis: {\n      label: {\n        show: true,\n        fontWeight: 'bold',\n        backgroundColor: theme.colors.grayscale.light5 } },\n\n\n    data: transformedData }];\n\n\n  const echartOptions = {\n    grid: {\n      ...defaultGrid },\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item' },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: Array.from(columnsLabelMap.keys()) },\n\n    series,\n    radar: {\n      shape: isCircle ? 'circle' : 'polygon',\n      indicator } };\n\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    emitCrossFilters,\n    setDataMask,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(formatLabel, \"formatLabel\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Radar/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Radar/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","ensureIsInt","getColumnLabel","getMetricLabel","getNumberFormatter","getTimeFormatter","DEFAULT_FORM_DATA","DEFAULT_RADAR_FORM_DATA","EchartsRadarLabelType","DEFAULT_LEGEND_FORM_DATA","OpacityEnum","extractGroupbyLabel","getChartPadding","getColtypesMapping","getLegendProps","defaultGrid","getDefaultTooltip","formatLabel","params","labelType","numberFormatter","name","value","formattedValue","Value","KeyValue","transformProps","chartProps","formData","height","hooks","filterState","queriesData","width","theme","inContextMenu","emitCrossFilters","refs","data","coltypeMapping","colorScheme","groupby","labelPosition","legendOrientation","legendType","legendMargin","metrics","numberFormat","dateFormat","showLabels","showLegend","isCircle","columnConfig","sliceId","setDataMask","onContextMenu","colorFn","getScale","formatter","metricLabels","map","groupbyLabels","metricLabelAndMaxValueMap","Map","columnsLabelMap","transformedData","forEach","joinedName","datum","timeFormatter","set","col","metricLabel","Object","entries","has","Math","max","get","Number","MIN_SAFE_INTEGER","isFiltered","selectedValues","push","itemStyle","color","opacity","Transparent","NonTransparent","lineStyle","SemiTransparent","label","show","position","reduce","acc","selectedValue","index","findIndex","indicator","maxValueInControl","radarMetricMaxValue","metricValueAsMax","MAX_SAFE_INTEGER","series","type","animation","emphasis","fontWeight","backgroundColor","colors","grayscale","light5","echartOptions","grid","tooltip","trigger","legend","Array","from","keys","radar","shape","labelMap","fromEntries"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Radar/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  ensureIsInt,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n  NumberFormatter,\n} from '@superset-ui/core';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { RadarSeriesDataItemOption } from 'echarts/types/src/chart/radar/RadarSeries';\nimport { EChartsCoreOption, RadarSeriesOption } from 'echarts';\nimport {\n  DEFAULT_FORM_DATA as DEFAULT_RADAR_FORM_DATA,\n  EchartsRadarChartProps,\n  EchartsRadarFormData,\n  EchartsRadarLabelType,\n  RadarChartTransformedProps,\n} from './types';\nimport { DEFAULT_LEGEND_FORM_DATA, OpacityEnum } from '../constants';\nimport {\n  extractGroupbyLabel,\n  getChartPadding,\n  getColtypesMapping,\n  getLegendProps,\n} from '../utils/series';\nimport { defaultGrid } from '../defaults';\nimport { Refs } from '../types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function formatLabel({\n  params,\n  labelType,\n  numberFormatter,\n}: {\n  params: CallbackDataParams;\n  labelType: EchartsRadarLabelType;\n  numberFormatter: NumberFormatter;\n}): string {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value as number);\n\n  switch (labelType) {\n    case EchartsRadarLabelType.Value:\n      return formattedValue;\n    case EchartsRadarLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\n\nexport default function transformProps(\n  chartProps: EchartsRadarChartProps,\n): RadarChartTransformedProps {\n  const {\n    formData,\n    height,\n    hooks,\n    filterState,\n    queriesData,\n    width,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const refs: Refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n\n  const {\n    colorScheme,\n    groupby,\n    labelType,\n    labelPosition,\n    legendOrientation,\n    legendType,\n    legendMargin,\n    metrics = [],\n    numberFormat,\n    dateFormat,\n    showLabels,\n    showLegend,\n    isCircle,\n    columnConfig,\n    sliceId,\n  }: EchartsRadarFormData = {\n    ...DEFAULT_LEGEND_FORM_DATA,\n    ...DEFAULT_RADAR_FORM_DATA,\n    ...formData,\n  };\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params: CallbackDataParams) =>\n    formatLabel({\n      params,\n      numberFormatter,\n      labelType,\n    });\n\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n\n  const metricLabelAndMaxValueMap = new Map<string, number>();\n  const columnsLabelMap = new Map<string, string[]>();\n  const transformedData: RadarSeriesDataItemOption[] = [];\n  data.forEach(datum => {\n    const joinedName = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat),\n    });\n    // map(joined_name: [columnLabel_1, columnLabel_2, ...])\n    columnsLabelMap.set(\n      joinedName,\n      groupbyLabels.map(col => datum[col] as string),\n    );\n\n    // put max value of series into metricLabelAndMaxValueMap\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [metricLabel, value] of Object.entries(datum)) {\n      if (metricLabelAndMaxValueMap.has(metricLabel)) {\n        metricLabelAndMaxValueMap.set(\n          metricLabel,\n          Math.max(\n            value as number,\n            ensureIsInt(\n              metricLabelAndMaxValueMap.get(metricLabel),\n              Number.MIN_SAFE_INTEGER,\n            ),\n          ),\n        );\n      } else {\n        metricLabelAndMaxValueMap.set(metricLabel, value as number);\n      }\n    }\n\n    const isFiltered =\n      filterState.selectedValues &&\n      !filterState.selectedValues.includes(joinedName);\n\n    // generate transformedData\n    transformedData.push({\n      value: metricLabels.map(metricLabel => datum[metricLabel]),\n      name: joinedName,\n      itemStyle: {\n        color: colorFn(joinedName, sliceId),\n        opacity: isFiltered\n          ? OpacityEnum.Transparent\n          : OpacityEnum.NonTransparent,\n      },\n      lineStyle: {\n        opacity: isFiltered\n          ? OpacityEnum.SemiTransparent\n          : OpacityEnum.NonTransparent,\n      },\n      label: {\n        show: showLabels,\n        position: labelPosition,\n        formatter,\n      },\n    } as RadarSeriesDataItemOption);\n  });\n\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = transformedData.findIndex(\n        ({ name }) => name === selectedValue,\n      );\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  const indicator = metricLabels.map(metricLabel => {\n    const maxValueInControl = columnConfig?.[metricLabel]?.radarMetricMaxValue;\n    // Ensure that 0 is at the center of the polar coordinates\n    const metricValueAsMax =\n      metricLabelAndMaxValueMap.get(metricLabel) === 0\n        ? Number.MAX_SAFE_INTEGER\n        : metricLabelAndMaxValueMap.get(metricLabel);\n    const max =\n      maxValueInControl === null ? metricValueAsMax : maxValueInControl;\n    return {\n      name: metricLabel,\n      max,\n    };\n  });\n\n  const series: RadarSeriesOption[] = [\n    {\n      type: 'radar',\n      ...getChartPadding(showLegend, legendOrientation, legendMargin),\n      animation: false,\n      emphasis: {\n        label: {\n          show: true,\n          fontWeight: 'bold',\n          backgroundColor: theme.colors.grayscale.light5,\n        },\n      },\n      data: transformedData,\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: Array.from(columnsLabelMap.keys()),\n    },\n    series,\n    radar: {\n      shape: isCircle ? 'circle' : 'polygon',\n      indicator,\n    },\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    emitCrossFilters,\n    setDataMask,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}