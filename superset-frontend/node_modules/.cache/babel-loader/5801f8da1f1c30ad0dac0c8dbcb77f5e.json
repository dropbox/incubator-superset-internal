{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataMaskType, ensureIsArray, FeatureFlag, getColumnLabel, isFeatureEnabled, NativeFilterType, NO_TIME_RANGE } from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterBoxScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { areObjectsEqual } from 'src/reduxUtils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nexport const extractLabel = (filter) => {var _filter$label;\n  if (filter != null && filter.label && !(filter != null && (_filter$label = filter.label) != null && _includesInstanceProperty(_filter$label).call(_filter$label, undefined))) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, _ref) => {let [key, value] = _ref;return {\n        ...map,\n        [key]: value };},\n    {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => {var _context;return _includesInstanceProperty(_context = getChartIdsInFilterBoxScope({\n      filterScope: filter.scopes[column] })).call(_context,\n    chartId);}).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter }));\n\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => getColumnLabel(filter.column)));};\nexport const getCrossFilterIndicator = (chartId, dataMask, dashboardLayout) => {var _dataMask$extraFormDa, _filters$, _dashboardLayoutItem$, _dashboardLayoutItem$2, _dashboardLayoutItem$3;\n  const filterState = dataMask == null ? void 0 : dataMask.filterState;\n  const filters = dataMask == null ? void 0 : (_dataMask$extraFormDa = dataMask.extraFormData) == null ? void 0 : _dataMask$extraFormDa.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState == null ? void 0 : filterState.filters;\n  const column = (filters == null ? void 0 : (_filters$ = filters[0]) == null ? void 0 : _filters$.col) || filtersState && Object.keys(filtersState)[0];\n  const dashboardLayoutItem = Object.values(dashboardLayout).find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartId;});\n  const filterObject = {\n    column,\n    name: (dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$ = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$.sliceNameOverride) || (\n    dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$2 = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$2.sliceName) ||\n    '',\n    path: [\n    ...((_dashboardLayoutItem$3 = dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.parents) != null ? _dashboardLayoutItem$3 : []),\n    (dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.id) || ''],\n\n    value: label };\n\n  return filterObject;\n};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter((_ref2) => {let [key] = _ref2;return matchingFilters.find((filter) => filter.datasourceId === key);}).\n  map((_ref3) => {let [, datasource] = _ref3;return datasource;});\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources };\n\n  return indicators;\n};\nconst getStatus = (_ref4) => {let { label, column, type = DataMaskType.NativeFilters, rejectedColumns, appliedColumns } = _ref4;\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS = type === DataMaskType.CrossFilters ?\n  IndicatorStatus.CrossFilterApplied :\n  IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns != null && rejectedColumns.has(column))\n  return IndicatorStatus.Incompatible;\n  if (column && appliedColumns != null && appliedColumns.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = function (dataMask, chartId, dashboardLayout, chartConfiguration, appliedColumns, rejectedColumns, filterEmitter) {if (chartConfiguration === void 0) {chartConfiguration = defaultChartConfig;}if (filterEmitter === void 0) {filterEmitter = false;}\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration).\n    filter((chartConfig) => {var _chartConfig$crossFil, _chartConfig$crossFil2;\n      const inScope = (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : (_chartConfig$crossFil2 = _chartConfig$crossFil.chartsInScope) == null ? void 0 : _includesInstanceProperty(_chartConfig$crossFil2).call(_chartConfig$crossFil2, chartId);\n      if (!filterEmitter && inScope) {\n        return true;\n      }\n      if (filterEmitter && !inScope) {\n        return true;\n      }\n      return false;\n    }).\n    map((chartConfig) => {\n      const filterIndicator = getCrossFilterIndicator(Number(chartConfig.id), dataMask[chartConfig.id], dashboardLayout);\n      const filterStatus = getStatus({\n        label: filterIndicator.value,\n        column: filterIndicator.column ?\n        getColumnLabel(filterIndicator.column) :\n        undefined,\n        type: DataMaskType.CrossFilters,\n        appliedColumns,\n        rejectedColumns });\n\n      return { ...filterIndicator, status: filterStatus };\n    }).\n    filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  return crossFilterIndicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nexport const selectNativeIndicatorsForChart = function (nativeFilters, dataMask, chartId, chart, dashboardLayout, chartConfiguration) {if (chartConfiguration === void 0) {chartConfiguration = defaultChartConfig;}\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dashboardLayout) === dashboardLayout &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  let nativeFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators =\n    nativeFilters &&\n    Object.values(nativeFilters).\n    filter((nativeFilter) => {var _nativeFilter$chartsI;return nativeFilter.type === NativeFilterType.NATIVE_FILTER && ((_nativeFilter$chartsI =\n      nativeFilter.chartsInScope) == null ? void 0 : _includesInstanceProperty(_nativeFilter$chartsI).call(_nativeFilter$chartsI, chartId));}).\n    map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _nativeFilter$targets3, _dataMask$nativeFilte;\n      const column = (_nativeFilter$targets = nativeFilter.targets) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets[0]) == null ? void 0 : (_nativeFilter$targets3 = _nativeFilter$targets2.column) == null ? void 0 : _nativeFilter$targets3.name;\n      const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n      const label = extractLabel(filterState);\n      return {\n        column,\n        name: nativeFilter.name,\n        path: [nativeFilter.id],\n        status: getStatus({\n          label,\n          column,\n          rejectedColumns,\n          appliedColumns }),\n\n        value: label };\n\n    });\n  }\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = selectChartCrossFilters(dataMask, chartId, dashboardLayout, chartConfiguration, appliedColumns, rejectedColumns);\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns };\n\n  return indicators;\n};","map":{"version":3,"mappings":"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","names":["DataMaskType","ensureIsArray","FeatureFlag","getColumnLabel","isFeatureEnabled","NativeFilterType","NO_TIME_RANGE","TIME_FILTER_MAP","getChartIdsInFilterBoxScope","areObjectsEqual","IndicatorStatus","TIME_GRANULARITY_FIELDS","Set","Object","values","extractLabel","filter","label","undefined","value","join","selectIndicatorValue","columnKey","datasource","columns","arrValues","Array","isArray","isDateFilter","length","has","timeGranularityMap","time_grain_sqla","granularity","reduce","map","key","selectIndicatorsForChartFromFilter","chartId","filterDataSource","appliedColumns","rejectedColumns","getStatus","column","Applied","Incompatible","Unset","keys","filterScope","scopes","name","labels","status","path","directPathToFilter","getAppliedColumns","chart","queriesResponse","applied_filters","getRejectedColumns","rejected_filters","getCrossFilterIndicator","dataMask","dashboardLayout","filterState","filters","extraFormData","filtersState","col","dashboardLayoutItem","find","meta","filterObject","sliceNameOverride","sliceName","parents","id","cachedIndicatorsForChart","cachedDashboardFilterDataForChart","selectIndicatorsForChart","datasources","matchingFilters","matchingDatasources","entries","datasourceId","cachedFilterData","indicators","acc","concat","sort","a","b","localeCompare","type","NativeFilters","hasValue","APPLIED_STATUS","CrossFilters","CrossFilterApplied","defaultChartConfig","selectChartCrossFilters","chartConfiguration","filterEmitter","crossFilterIndicators","DASHBOARD_CROSS_FILTERS","inScope","chartConfig","crossFilters","chartsInScope","filterIndicator","Number","filterStatus","cachedNativeIndicatorsForChart","cachedNativeFilterDataForChart","selectNativeIndicatorsForChart","nativeFilters","nativeFilterIndicators","DASHBOARD_NATIVE_FILTERS","nativeFilter","NATIVE_FILTER","targets"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DataMask,\n  DataMaskStateWithId,\n  DataMaskType,\n  ensureIsArray,\n  FeatureFlag,\n  Filters,\n  FilterState,\n  getColumnLabel,\n  isFeatureEnabled,\n  NativeFilterType,\n  NO_TIME_RANGE,\n  QueryFormColumn,\n} from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterBoxScope } from 'src/dashboard/util/activeDashboardFilters';\nimport {\n  ChartConfiguration,\n  DashboardLayout,\n  Layout,\n} from 'src/dashboard/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the Dataset type in superset-ui is incorrect.\n// Should patch it here until the Dataset type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n  verbose_map?: Record<string, string>;\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nexport const extractLabel = (filter?: FilterState): string | null => {\n  if (filter?.label && !filter?.label?.includes(undefined)) {\n    return filter.label;\n  }\n  if (filter?.value) {\n    return ensureIsArray(filter?.value).join(', ');\n  }\n  return null;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === NO_TIME_RANGE) ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterBoxScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map((filter: any) =>\n      getColumnLabel(filter.column),\n    ),\n  );\n\nexport type Indicator = {\n  column?: QueryFormColumn;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\nexport type CrossFilterIndicator = Indicator & { emitterId: number };\n\nexport const getCrossFilterIndicator = (\n  chartId: number,\n  dataMask: DataMask,\n  dashboardLayout: DashboardLayout,\n) => {\n  const filterState = dataMask?.filterState;\n  const filters = dataMask?.extraFormData?.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState?.filters;\n  const column =\n    filters?.[0]?.col || (filtersState && Object.keys(filtersState)[0]);\n\n  const dashboardLayoutItem = Object.values(dashboardLayout).find(\n    layoutItem => layoutItem?.meta?.chartId === chartId,\n  );\n  const filterObject: Indicator = {\n    column,\n    name:\n      dashboardLayoutItem?.meta?.sliceNameOverride ||\n      dashboardLayoutItem?.meta?.sliceName ||\n      '',\n    path: [\n      ...(dashboardLayoutItem?.parents ?? []),\n      dashboardLayoutItem?.id || '',\n    ],\n    value: label,\n  };\n  return filterObject;\n};\n\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  chart: any,\n): Indicator[] => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter(\n    filter => filter.chartId !== chartId,\n  );\n  const matchingDatasources = Object.entries(datasources)\n    .filter(([key]) =>\n      matchingFilters.find(filter => filter.datasourceId === key),\n    )\n    .map(([, datasource]) => datasource);\n\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (\n    cachedIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    areObjectsEqual(cachedFilterData?.matchingFilters, matchingFilters) &&\n    areObjectsEqual(cachedFilterData?.matchingDatasources, matchingDatasources)\n  ) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce(\n    (acc, filter) =>\n      acc.concat(\n        selectIndicatorsForChartFromFilter(\n          chartId,\n          filter,\n          datasources[filter.datasourceId] || {},\n          appliedColumns,\n          rejectedColumns,\n        ),\n      ),\n    [] as Indicator[],\n  );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources,\n  };\n  return indicators;\n};\n\nconst getStatus = ({\n  label,\n  column,\n  type = DataMaskType.NativeFilters,\n  rejectedColumns,\n  appliedColumns,\n}: {\n  label: string | null;\n  column?: string;\n  type?: DataMaskType;\n  rejectedColumns?: Set<string>;\n  appliedColumns?: Set<string>;\n}): IndicatorStatus => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS =\n    type === DataMaskType.CrossFilters\n      ? IndicatorStatus.CrossFilterApplied\n      : IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns?.has(column))\n    return IndicatorStatus.Incompatible;\n  if (column && appliedColumns?.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\n\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n  filterEmitter = false,\n): Indicator[] | CrossFilterIndicator[] => {\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration)\n      .filter(chartConfig => {\n        const inScope =\n          chartConfig.crossFilters?.chartsInScope?.includes(chartId);\n        if (!filterEmitter && inScope) {\n          return true;\n        }\n        if (filterEmitter && !inScope) {\n          return true;\n        }\n        return false;\n      })\n      .map(chartConfig => {\n        const filterIndicator = getCrossFilterIndicator(\n          Number(chartConfig.id),\n          dataMask[chartConfig.id],\n          dashboardLayout,\n        );\n        const filterStatus = getStatus({\n          label: filterIndicator.value,\n          column: filterIndicator.column\n            ? getColumnLabel(filterIndicator.column)\n            : undefined,\n          type: DataMaskType.CrossFilters,\n          appliedColumns,\n          rejectedColumns,\n        });\n\n        return { ...filterIndicator, status: filterStatus };\n      })\n      .filter(filter => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n\n  return crossFilterIndicators;\n};\n\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart: any = {};\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: Filters,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  chart: any,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n): Indicator[] => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (\n    cachedNativeIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    cachedFilterData?.nativeFilters === nativeFilters &&\n    cachedFilterData?.dashboardLayout === dashboardLayout &&\n    cachedFilterData?.chartConfiguration === chartConfiguration &&\n    cachedFilterData?.dataMask === dataMask\n  ) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n\n  let nativeFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators =\n      nativeFilters &&\n      Object.values(nativeFilters)\n        .filter(\n          nativeFilter =>\n            nativeFilter.type === NativeFilterType.NATIVE_FILTER &&\n            nativeFilter.chartsInScope?.includes(chartId),\n        )\n        .map(nativeFilter => {\n          const column = nativeFilter.targets?.[0]?.column?.name;\n          const filterState = dataMask[nativeFilter.id]?.filterState;\n          const label = extractLabel(filterState);\n          return {\n            column,\n            name: nativeFilter.name,\n            path: [nativeFilter.id],\n            status: getStatus({\n              label,\n              column,\n              rejectedColumns,\n              appliedColumns,\n            }),\n            value: label,\n          };\n        });\n  }\n\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = selectChartCrossFilters(\n      dataMask,\n      chartId,\n      dashboardLayout,\n      chartConfiguration,\n      appliedColumns,\n      rejectedColumns,\n    );\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns,\n  };\n  return indicators;\n};\n"]},"metadata":{},"sourceType":"module"}