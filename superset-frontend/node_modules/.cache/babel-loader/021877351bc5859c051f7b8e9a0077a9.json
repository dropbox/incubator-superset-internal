{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment from 'moment';\n\n// array with the minimum values of each part of a timestamp -- note that\n// months are zero-indexed in JavaScript\nconst truncatePartTo = [\n1, // year\n0, // month\n1, // day\n0, // hour\n0, // minute\n0, // second\n0 // millisecond\n];\n\nexport function truncate(timestamp, step) {\n  /*\n   * Truncate timestamp down to duration resolution.\n   */\n  const lowerBound = moment(timestamp).subtract(step);\n  const explodedTimestamp = timestamp.toArray();\n  const explodedLowerBound = lowerBound.toArray();\n\n  const firstDiffIndex = explodedTimestamp.\n  map((part, i) => explodedLowerBound[i] !== part).\n  indexOf(true);\n  const dateParts = explodedTimestamp.map((part, i) => {\n    if (i === firstDiffIndex) {\n      // truncate down to closest `truncatePartTo[i] + n * step`\n      const difference = part - explodedLowerBound[i];\n\n      return part - (part - truncatePartTo[i]) % difference;\n    }\n    if (i < firstDiffIndex || firstDiffIndex === -1) {\n      return part;\n    }\n\n    return truncatePartTo[i];\n  });\n\n  return moment(dateParts);\n}\n\nfunction getStepSeconds(step, start) {\n  /* Return number of seconds in a step.\n   *\n   * The step might be ambiguous, eg, \"1 month\" has a variable number of\n   * seconds, which is why we need to know the start time.\n   */\n  const startMilliseconds = parseInt(moment(start).format('x'), 10);\n  const endMilliseconds = parseInt(moment(start).add(step).format('x'), 10);\n\n  return endMilliseconds - startMilliseconds;\n}\n\nexport function getPlaySliderParams(timestamps, timeGrain) {\n  const minTimestamp = moment(\n  Number(timestamps.reduce((a, b) => a < b ? a : b)));\n\n  const maxTimestamp = moment(\n  Number(timestamps.reduce((a, b) => a > b ? a : b)));\n\n  let step;\n  let reference;\n\n  if (_includesInstanceProperty(timeGrain).call(timeGrain, '/')) {\n    // Here, time grain is a time interval instead of a simple duration, either\n    // `reference/duration` or `duration/reference`. We need to parse the\n    // duration and make sure that start and end are in the right places. For\n    // example, if `reference` is a Saturday and `duration` is 1 week (P1W)\n    // then both start and end should be Saturdays.\n    const parts = timeGrain.split('/', 2);\n    if (parts[0].endsWith('Z')) {\n      // ISO string\n      reference = moment(parts[0]);\n      step = moment.duration(parts[1]);\n    } else {\n      reference = moment(parts[1]);\n      step = moment.duration(parts[0]);\n    }\n  } else {\n    step = moment.duration(timeGrain);\n    reference = truncate(minTimestamp, step);\n  }\n\n  // find the largest `reference + n * step` smaller than the minimum timestamp\n  let start;\n  const minValue = minTimestamp.valueOf();\n  for (start = reference.clone(); start.valueOf() < minValue;) {\n    start.add(step);\n  }\n  for (; start.valueOf() > minValue;) {\n    start.subtract(step);\n  }\n\n  // find the smallest `reference + n * step` larger than the maximum timestamp\n  let end;\n  const maxValue = maxTimestamp.valueOf();\n  for (end = reference.clone(); end.valueOf() > maxValue;) {\n    end.subtract(step);\n  }\n  for (; end.valueOf() < maxValue;) {\n    end.add(step);\n  }\n\n  const values =\n  timeGrain != null ? [start, start.clone().add(step)] : [start, end];\n  const disabled = timestamps.every((timestamp) => timestamp === null);\n\n  return {\n    start: parseInt(start.format('x'), 10),\n    end: parseInt(end.format('x'), 10),\n    getStep: getStepSeconds.bind(this, step),\n    values: values.map((v) => parseInt(v.format('x'), 10)),\n    disabled };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(truncatePartTo, \"truncatePartTo\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils/time.js\");reactHotLoader.register(truncate, \"truncate\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils/time.js\");reactHotLoader.register(getStepSeconds, \"getStepSeconds\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils/time.js\");reactHotLoader.register(getPlaySliderParams, \"getPlaySliderParams\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils/time.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["moment","truncatePartTo","truncate","timestamp","step","lowerBound","subtract","explodedTimestamp","toArray","explodedLowerBound","firstDiffIndex","map","part","i","indexOf","dateParts","difference","getStepSeconds","start","startMilliseconds","parseInt","format","endMilliseconds","add","getPlaySliderParams","timestamps","timeGrain","minTimestamp","Number","reduce","a","b","maxTimestamp","reference","parts","split","endsWith","duration","minValue","valueOf","clone","end","maxValue","values","disabled","every","getStep","bind","v"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils/time.js"],"sourcesContent":["/* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment from 'moment';\n\n// array with the minimum values of each part of a timestamp -- note that\n// months are zero-indexed in JavaScript\nconst truncatePartTo = [\n  1, // year\n  0, // month\n  1, // day\n  0, // hour\n  0, // minute\n  0, // second\n  0, // millisecond\n];\n\nexport function truncate(timestamp, step) {\n  /*\n   * Truncate timestamp down to duration resolution.\n   */\n  const lowerBound = moment(timestamp).subtract(step);\n  const explodedTimestamp = timestamp.toArray();\n  const explodedLowerBound = lowerBound.toArray();\n\n  const firstDiffIndex = explodedTimestamp\n    .map((part, i) => explodedLowerBound[i] !== part)\n    .indexOf(true);\n  const dateParts = explodedTimestamp.map((part, i) => {\n    if (i === firstDiffIndex) {\n      // truncate down to closest `truncatePartTo[i] + n * step`\n      const difference = part - explodedLowerBound[i];\n\n      return part - ((part - truncatePartTo[i]) % difference);\n    }\n    if (i < firstDiffIndex || firstDiffIndex === -1) {\n      return part;\n    }\n\n    return truncatePartTo[i];\n  });\n\n  return moment(dateParts);\n}\n\nfunction getStepSeconds(step, start) {\n  /* Return number of seconds in a step.\n   *\n   * The step might be ambiguous, eg, \"1 month\" has a variable number of\n   * seconds, which is why we need to know the start time.\n   */\n  const startMilliseconds = parseInt(moment(start).format('x'), 10);\n  const endMilliseconds = parseInt(moment(start).add(step).format('x'), 10);\n\n  return endMilliseconds - startMilliseconds;\n}\n\nexport function getPlaySliderParams(timestamps, timeGrain) {\n  const minTimestamp = moment(\n    Number(timestamps.reduce((a, b) => (a < b ? a : b))),\n  );\n  const maxTimestamp = moment(\n    Number(timestamps.reduce((a, b) => (a > b ? a : b))),\n  );\n  let step;\n  let reference;\n\n  if (timeGrain.includes('/')) {\n    // Here, time grain is a time interval instead of a simple duration, either\n    // `reference/duration` or `duration/reference`. We need to parse the\n    // duration and make sure that start and end are in the right places. For\n    // example, if `reference` is a Saturday and `duration` is 1 week (P1W)\n    // then both start and end should be Saturdays.\n    const parts = timeGrain.split('/', 2);\n    if (parts[0].endsWith('Z')) {\n      // ISO string\n      reference = moment(parts[0]);\n      step = moment.duration(parts[1]);\n    } else {\n      reference = moment(parts[1]);\n      step = moment.duration(parts[0]);\n    }\n  } else {\n    step = moment.duration(timeGrain);\n    reference = truncate(minTimestamp, step);\n  }\n\n  // find the largest `reference + n * step` smaller than the minimum timestamp\n  let start;\n  const minValue = minTimestamp.valueOf();\n  for (start = reference.clone(); start.valueOf() < minValue; ) {\n    start.add(step);\n  }\n  for (; start.valueOf() > minValue; ) {\n    start.subtract(step);\n  }\n\n  // find the smallest `reference + n * step` larger than the maximum timestamp\n  let end;\n  const maxValue = maxTimestamp.valueOf();\n  for (end = reference.clone(); end.valueOf() > maxValue; ) {\n    end.subtract(step);\n  }\n  for (; end.valueOf() < maxValue; ) {\n    end.add(step);\n  }\n\n  const values =\n    timeGrain != null ? [start, start.clone().add(step)] : [start, end];\n  const disabled = timestamps.every(timestamp => timestamp === null);\n\n  return {\n    start: parseInt(start.format('x'), 10),\n    end: parseInt(end.format('x'), 10),\n    getStep: getStepSeconds.bind(this, step),\n    values: values.map(v => parseInt(v.format('x'), 10)),\n    disabled,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}