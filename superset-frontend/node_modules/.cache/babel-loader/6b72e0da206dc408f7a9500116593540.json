{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { DTTM_ALIAS, AxisType, getTimeFormatter, getColumnLabel, getNumberFormatter } from '@superset-ui/core';\nimport Echart from '../components/Echart';\nimport { formatSeriesName } from '../utils/series';\nimport { ExtraControls } from '../components/ExtraControls';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst TIMER_DURATION = 300;\nexport default function EchartsTimeseries(_ref) {let { formData, height, width, echartOptions, groupby, labelMap, selectedValues, setDataMask, setControlValue, legendData = [], onContextMenu, onLegendStateChanged, onFocusedSeries, xValueFormatter, xAxis, refs, emitCrossFilters, coltypeMapping } = _ref;\n  const { stack } = formData;\n  const echartRef = useRef(null);\n  // eslint-disable-next-line no-param-reassign\n  refs.echartRef = echartRef;\n  const clickTimer = useRef();\n  const extraControlRef = useRef(null);\n  const [extraControlHeight, setExtraControlHeight] = useState(0);\n  useEffect(() => {var _extraControlRef$curr;\n    const updatedHeight = ((_extraControlRef$curr = extraControlRef.current) == null ? void 0 : _extraControlRef$curr.offsetHeight) || 0;\n    setExtraControlHeight(updatedHeight);\n  }, [formData.showExtraControls]);\n  const getModelInfo = (target, globalModel) => {\n    let el = target;\n    let model = null;\n    while (el) {\n      // eslint-disable-next-line no-underscore-dangle\n      const modelInfo = el.__ecComponentInfo;\n      if (modelInfo != null) {\n        model = globalModel.getComponent(modelInfo.mainType, modelInfo.index);\n        break;\n      }\n      el = el.parent;\n    }\n    return model;\n  };\n  const getCrossFilterDataMask = useCallback((value) => {\n    const selected = Object.values(selectedValues);\n    let values;\n    if (_includesInstanceProperty(selected).call(selected, value)) {\n      values = selected.filter((v) => v !== value);\n    } else\n    {\n      values = [value];\n    }\n    const groupbyValues = values.map((value) => labelMap[value]);\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length === 0 ?\n          [] :\n          groupby.map((col, idx) => {\n            const val = groupbyValues.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL' };\n\n            return {\n              col,\n              op: 'IN',\n              val: val };\n\n          }) },\n\n        filterState: {\n          label: groupbyValues.length ? groupbyValues : undefined,\n          value: groupbyValues.length ? groupbyValues : null,\n          selectedValues: values.length ? values : null } },\n\n\n      isCurrentValueSelected: _includesInstanceProperty(selected).call(selected, value) };\n\n  }, [groupby, labelMap, selectedValues]);\n  const handleChange = useCallback((value) => {\n    if (!emitCrossFilters) {\n      return;\n    }\n    setDataMask(getCrossFilterDataMask(value).dataMask);\n  }, [emitCrossFilters, setDataMask, getCrossFilterDataMask]);\n  const eventHandlers = {\n    click: (props) => {\n      if (clickTimer.current) {\n        clearTimeout(clickTimer.current);\n      }\n      // Ensure that double-click events do not trigger single click event. So we put it in the timer.\n      clickTimer.current = setTimeout(() => {\n        const { seriesName: name } = props;\n        handleChange(name);\n      }, TIMER_DURATION);\n    },\n    mouseout: () => {\n      onFocusedSeries(null);\n    },\n    mouseover: (params) => {\n      onFocusedSeries(params.seriesName);\n    },\n    legendselectchanged: (payload) => {\n      onLegendStateChanged == null ? void 0 : onLegendStateChanged(payload.selected);\n    },\n    legendselectall: (payload) => {\n      onLegendStateChanged == null ? void 0 : onLegendStateChanged(payload.selected);\n    },\n    legendinverseselect: (payload) => {\n      onLegendStateChanged == null ? void 0 : onLegendStateChanged(payload.selected);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {var _labelMap$seriesName;\n        eventParams.event.stop();\n        const { data, seriesName } = eventParams;\n        const drillToDetailFilters = [];\n        const drillByFilters = [];\n        const pointerEvent = eventParams.event.event;\n        const values = [\n        ...(eventParams.name ? [eventParams.name] : []),\n        ...((_labelMap$seriesName = labelMap[seriesName]) != null ? _labelMap$seriesName : [])];\n\n        if (data && xAxis.type === AxisType.time) {\n          drillToDetailFilters.push({\n            col:\n            // if the xAxis is '__timestamp', granularity_sqla will be the column of filter\n            xAxis.label === DTTM_ALIAS ?\n            formData.granularitySqla :\n            xAxis.label,\n            grain: formData.timeGrainSqla,\n            op: '==',\n            val: data[0],\n            formattedVal: xValueFormatter(data[0]) });\n\n        }\n        [\n        ...(xAxis.type === AxisType.category && data ? [xAxis.label] : []),\n        ...formData.groupby].\n        forEach((dimension, i) => drillToDetailFilters.push({\n          col: dimension,\n          op: '==',\n          val: values[i],\n          formattedVal: String(values[i]) }));\n\n        formData.groupby.forEach((dimension, i) => {\n          const val = labelMap[seriesName][i];\n          drillByFilters.push({\n            col: dimension,\n            op: '==',\n            val,\n            formattedVal: formatSeriesName(values[i], {\n              timeFormatter: getTimeFormatter(formData.dateFormat),\n              numberFormatter: getNumberFormatter(formData.numberFormat),\n              coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(dimension)] }) });\n\n\n        });\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: getCrossFilterDataMask(seriesName),\n          drillBy: { filters: drillByFilters, groupbyFieldName: 'groupby' } });\n\n      }\n    } };\n\n  const zrEventHandlers = {\n    dblclick: (params) => {var _echartRef$current;\n      // clear single click timer\n      if (clickTimer.current) {\n        clearTimeout(clickTimer.current);\n      }\n      const pointInPixel = [params.offsetX, params.offsetY];\n      const echartInstance = (_echartRef$current = echartRef.current) == null ? void 0 : _echartRef$current.getEchartInstance();\n      if (echartInstance != null && echartInstance.containPixel('grid', pointInPixel)) {var _params$target;\n        // do not trigger if click unstacked chart's blank area\n        if (!stack && ((_params$target = params.target) == null ? void 0 : _params$target.type) === 'ec-polygon')\n        return;\n        // @ts-ignore\n        const globalModel = echartInstance.getModel();\n        const model = getModelInfo(params.target, globalModel);\n        if (model) {\n          const { name } = model;\n          const legendState = legendData.reduce((previous, datum) => ({\n            ...previous,\n            [datum]: datum === name }),\n          {});\n          onLegendStateChanged == null ? void 0 : onLegendStateChanged(legendState);\n        }\n      }\n    } };\n\n  return ___EmotionJSX(React.Fragment, null,\n  ___EmotionJSX(\"div\", { ref: extraControlRef },\n  ___EmotionJSX(ExtraControls, { formData: formData, setControlValue: setControlValue })),\n\n  ___EmotionJSX(Echart, { ref: echartRef, refs: refs, height: height - extraControlHeight, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, zrEventHandlers: zrEventHandlers, selectedValues: selectedValues }));\n\n}","map":{"version":3,"mappings":"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","names":["React","useCallback","useEffect","useRef","useState","DTTM_ALIAS","AxisType","getTimeFormatter","getColumnLabel","getNumberFormatter","Echart","formatSeriesName","ExtraControls","TIMER_DURATION","EchartsTimeseries","formData","height","width","echartOptions","groupby","labelMap","selectedValues","setDataMask","setControlValue","legendData","onContextMenu","onLegendStateChanged","onFocusedSeries","xValueFormatter","xAxis","refs","emitCrossFilters","coltypeMapping","stack","echartRef","clickTimer","extraControlRef","extraControlHeight","setExtraControlHeight","updatedHeight","current","offsetHeight","showExtraControls","getModelInfo","target","globalModel","el","model","modelInfo","__ecComponentInfo","getComponent","mainType","index","parent","getCrossFilterDataMask","value","selected","Object","values","filter","v","groupbyValues","map","dataMask","extraFormData","filters","length","col","idx","val","undefined","op","filterState","label","isCurrentValueSelected","handleChange","eventHandlers","click","clearTimeout","setTimeout","seriesName","name","props","mouseout","mouseover","params","legendselectchanged","payload","legendselectall","legendinverseselect","contextmenu","eventParams","event","stop","data","drillToDetailFilters","drillByFilters","pointerEvent","type","time","push","granularitySqla","grain","timeGrainSqla","formattedVal","category","forEach","dimension","i","String","timeFormatter","dateFormat","numberFormatter","numberFormat","coltype","clientX","clientY","drillToDetail","crossFilter","drillBy","groupbyFieldName","zrEventHandlers","dblclick","pointInPixel","offsetX","offsetY","echartInstance","getEchartInstance","containPixel","getModel","legendState","reduce","previous","datum"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/EchartsTimeseries.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport {\n  DTTM_ALIAS,\n  BinaryQueryObjectFilterClause,\n  AxisType,\n  getTimeFormatter,\n  getColumnLabel,\n  getNumberFormatter,\n  LegendState,\n} from '@superset-ui/core';\nimport { ViewRootGroup } from 'echarts/types/src/util/types';\nimport GlobalModel from 'echarts/types/src/model/Global';\nimport ComponentModel from 'echarts/types/src/model/Component';\nimport { EchartsHandler, EventHandlers } from '../types';\nimport Echart from '../components/Echart';\nimport { TimeseriesChartTransformedProps } from './types';\nimport { formatSeriesName } from '../utils/series';\nimport { ExtraControls } from '../components/ExtraControls';\n\nconst TIMER_DURATION = 300;\n\nexport default function EchartsTimeseries({\n  formData,\n  height,\n  width,\n  echartOptions,\n  groupby,\n  labelMap,\n  selectedValues,\n  setDataMask,\n  setControlValue,\n  legendData = [],\n  onContextMenu,\n  onLegendStateChanged,\n  onFocusedSeries,\n  xValueFormatter,\n  xAxis,\n  refs,\n  emitCrossFilters,\n  coltypeMapping,\n}: TimeseriesChartTransformedProps) {\n  const { stack } = formData;\n  const echartRef = useRef<EchartsHandler | null>(null);\n  // eslint-disable-next-line no-param-reassign\n  refs.echartRef = echartRef;\n  const clickTimer = useRef<ReturnType<typeof setTimeout>>();\n  const extraControlRef = useRef<HTMLDivElement>(null);\n  const [extraControlHeight, setExtraControlHeight] = useState(0);\n  useEffect(() => {\n    const updatedHeight = extraControlRef.current?.offsetHeight || 0;\n    setExtraControlHeight(updatedHeight);\n  }, [formData.showExtraControls]);\n\n  const getModelInfo = (target: ViewRootGroup, globalModel: GlobalModel) => {\n    let el = target;\n    let model: ComponentModel | null = null;\n    while (el) {\n      // eslint-disable-next-line no-underscore-dangle\n      const modelInfo = el.__ecComponentInfo;\n      if (modelInfo != null) {\n        model = globalModel.getComponent(modelInfo.mainType, modelInfo.index);\n        break;\n      }\n      el = el.parent;\n    }\n    return model;\n  };\n\n  const getCrossFilterDataMask = useCallback(\n    (value: string) => {\n      const selected: string[] = Object.values(selectedValues);\n      let values: string[];\n      if (selected.includes(value)) {\n        values = selected.filter(v => v !== value);\n      } else {\n        values = [value];\n      }\n      const groupbyValues = values.map(value => labelMap[value]);\n      return {\n        dataMask: {\n          extraFormData: {\n            filters:\n              values.length === 0\n                ? []\n                : groupby.map((col, idx) => {\n                    const val = groupbyValues.map(v => v[idx]);\n                    if (val === null || val === undefined)\n                      return {\n                        col,\n                        op: 'IS NULL' as const,\n                      };\n                    return {\n                      col,\n                      op: 'IN' as const,\n                      val: val as (string | number | boolean)[],\n                    };\n                  }),\n          },\n          filterState: {\n            label: groupbyValues.length ? groupbyValues : undefined,\n            value: groupbyValues.length ? groupbyValues : null,\n            selectedValues: values.length ? values : null,\n          },\n        },\n        isCurrentValueSelected: selected.includes(value),\n      };\n    },\n    [groupby, labelMap, selectedValues],\n  );\n\n  const handleChange = useCallback(\n    (value: string) => {\n      if (!emitCrossFilters) {\n        return;\n      }\n      setDataMask(getCrossFilterDataMask(value).dataMask);\n    },\n    [emitCrossFilters, setDataMask, getCrossFilterDataMask],\n  );\n\n  const eventHandlers: EventHandlers = {\n    click: props => {\n      if (clickTimer.current) {\n        clearTimeout(clickTimer.current);\n      }\n      // Ensure that double-click events do not trigger single click event. So we put it in the timer.\n      clickTimer.current = setTimeout(() => {\n        const { seriesName: name } = props;\n        handleChange(name);\n      }, TIMER_DURATION);\n    },\n    mouseout: () => {\n      onFocusedSeries(null);\n    },\n    mouseover: params => {\n      onFocusedSeries(params.seriesName);\n    },\n    legendselectchanged: payload => {\n      onLegendStateChanged?.(payload.selected);\n    },\n    legendselectall: payload => {\n      onLegendStateChanged?.(payload.selected);\n    },\n    legendinverseselect: payload => {\n      onLegendStateChanged?.(payload.selected);\n    },\n    contextmenu: async eventParams => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, seriesName } = eventParams;\n        const drillToDetailFilters: BinaryQueryObjectFilterClause[] = [];\n        const drillByFilters: BinaryQueryObjectFilterClause[] = [];\n        const pointerEvent = eventParams.event.event;\n        const values = [\n          ...(eventParams.name ? [eventParams.name] : []),\n          ...(labelMap[seriesName] ?? []),\n        ];\n        if (data && xAxis.type === AxisType.time) {\n          drillToDetailFilters.push({\n            col:\n              // if the xAxis is '__timestamp', granularity_sqla will be the column of filter\n              xAxis.label === DTTM_ALIAS\n                ? formData.granularitySqla\n                : xAxis.label,\n            grain: formData.timeGrainSqla,\n            op: '==',\n            val: data[0],\n            formattedVal: xValueFormatter(data[0]),\n          });\n        }\n        [\n          ...(xAxis.type === AxisType.category && data ? [xAxis.label] : []),\n          ...formData.groupby,\n        ].forEach((dimension, i) =>\n          drillToDetailFilters.push({\n            col: dimension,\n            op: '==',\n            val: values[i],\n            formattedVal: String(values[i]),\n          }),\n        );\n        formData.groupby.forEach((dimension, i) => {\n          const val = labelMap[seriesName][i];\n          drillByFilters.push({\n            col: dimension,\n            op: '==',\n            val,\n            formattedVal: formatSeriesName(values[i], {\n              timeFormatter: getTimeFormatter(formData.dateFormat),\n              numberFormatter: getNumberFormatter(formData.numberFormat),\n              coltype: coltypeMapping?.[getColumnLabel(dimension)],\n            }),\n          });\n        });\n\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: getCrossFilterDataMask(seriesName),\n          drillBy: { filters: drillByFilters, groupbyFieldName: 'groupby' },\n        });\n      }\n    },\n  };\n\n  const zrEventHandlers: EventHandlers = {\n    dblclick: params => {\n      // clear single click timer\n      if (clickTimer.current) {\n        clearTimeout(clickTimer.current);\n      }\n      const pointInPixel = [params.offsetX, params.offsetY];\n      const echartInstance = echartRef.current?.getEchartInstance();\n      if (echartInstance?.containPixel('grid', pointInPixel)) {\n        // do not trigger if click unstacked chart's blank area\n        if (!stack && params.target?.type === 'ec-polygon') return;\n        // @ts-ignore\n        const globalModel = echartInstance.getModel();\n        const model = getModelInfo(params.target, globalModel);\n        if (model) {\n          const { name } = model;\n          const legendState: LegendState = legendData.reduce(\n            (previous, datum) => ({\n              ...previous,\n              [datum]: datum === name,\n            }),\n            {},\n          );\n          onLegendStateChanged?.(legendState);\n        }\n      }\n    },\n  };\n\n  return (\n    <>\n      <div ref={extraControlRef}>\n        <ExtraControls formData={formData} setControlValue={setControlValue} />\n      </div>\n      <Echart\n        ref={echartRef}\n        refs={refs}\n        height={height - extraControlHeight}\n        width={width}\n        echartOptions={echartOptions}\n        eventHandlers={eventHandlers}\n        zrEventHandlers={zrEventHandlers}\n        selectedValues={selectedValues}\n      />\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}