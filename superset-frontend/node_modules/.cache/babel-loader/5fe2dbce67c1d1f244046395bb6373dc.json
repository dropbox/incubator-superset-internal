{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { NativeFilterType, logging } from '@superset-ui/core';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const hasCircularDependency = function (dependencyMap, filterId, trace) {if (trace === void 0) {trace = [];}\n  if (_includesInstanceProperty(trace).call(trace, filterId)) {\n    return true;\n  }\n  const dependencies = dependencyMap.get(filterId);\n  if (dependencies) {\n    return dependencies.some((dependency) => hasCircularDependency(dependencyMap, dependency, [...trace, filterId]));\n  }\n  return false;\n};\nexport const validateForm = async (form, currentFilterId, setCurrentFilterId) => {\n  try {\n    let formValues;\n    try {\n      formValues = await form.validateFields();\n    }\n    catch (error) {var _error$errorFields;\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!(error != null && (_error$errorFields = error.errorFields) != null && _error$errorFields.length) && error != null && error.outOfDate) {\n        formValues = error.values;\n      } else\n      {\n        throw error;\n      }\n    }\n    return formValues;\n  }\n  catch (error) {\n    logging.warn('Filter configuration failed:', error);\n    if (!error.errorFields || !error.errorFields.length)\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some((field) => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find((field) => field.name[0] === 'filters');\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (filterConfigMap, filterIds, removedFilters, saveForm, values) => async () => {\n  const newFilterConfig = filterIds.\n  filter((id) => !removedFilters[id]).\n  map((id) => {var _values$filters, _formInputs$controlVa, _formInputs$requiredF, _formInputs$defaultDa;\n    // create a filter config object from the form inputs\n    const formInputs = (_values$filters = values.filters) == null ? void 0 : _values$filters[id];\n    // if user didn't open a filter, return the original config\n    if (!formInputs)\n    return filterConfigMap[id];\n    if (formInputs.type === NativeFilterType.DIVIDER) {\n      return {\n        id,\n        type: NativeFilterType.DIVIDER,\n        scope: {\n          rootPath: [DASHBOARD_ROOT_ID],\n          excluded: [] },\n\n        title: formInputs.title,\n        description: formInputs.description };\n\n    }\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      adhoc_filters: formInputs.adhoc_filters,\n      time_range: formInputs.time_range,\n      controlValues: (_formInputs$controlVa = formInputs.controlValues) != null ? _formInputs$controlVa : {},\n      granularity_sqla: formInputs.granularity_sqla,\n      requiredFirst: Object.values((_formInputs$requiredF = formInputs.requiredFirst) != null ? _formInputs$requiredF : {}).find((rf) => rf),\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      // for now there will only ever be one target\n      targets: [target],\n      defaultDataMask: (_formInputs$defaultDa = formInputs.defaultDataMask) != null ? _formInputs$defaultDa : getInitialDataMask(),\n      cascadeParentIds: formInputs.dependencies || [],\n      scope: formInputs.scope,\n      sortMetric: formInputs.sortMetric,\n      type: formInputs.type,\n      description: (formInputs.description || '').trim() };\n\n  });\n  await saveForm(newFilterConfig);\n};\nexport const createHandleRemoveItem = (setRemovedFilters, setOrderedFilters, setSaveAlertVisible) => (filterId) => {\n  const completeFilterRemoval = (filterId) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: false } }));\n\n    setOrderedFilters((orderedFilters) => orderedFilters.filter((filter) => filter !== filterId));\n  };\n  // first set up the timer to completely remove it\n  const timerId = window.setTimeout(() => {\n    completeFilterRemoval(filterId);\n  }, REMOVAL_DELAY_SECS * 1000);\n  // mark the filter state as \"removal in progress\"\n  setRemovedFilters((removedFilters) => ({\n    ...removedFilters,\n    [filterId]: { isPending: true, timerId } }));\n\n  setSaveAlertVisible(false);\n};\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const NATIVE_FILTER_DIVIDER_PREFIX = 'NATIVE_FILTER_DIVIDER-';\nexport const generateFilterId = (type) => {\n  const prefix = type === NativeFilterType.NATIVE_FILTER ?\n  NATIVE_FILTER_PREFIX :\n  NATIVE_FILTER_DIVIDER_PREFIX;\n  return `${prefix}${shortid.generate()}`;\n};\nexport const getFilterIds = (config) => config.map((filter) => filter.id);","map":{"version":3,"mappings":"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","names":["shortid","getInitialDataMask","NativeFilterType","logging","DASHBOARD_ROOT_ID","REMOVAL_DELAY_SECS","hasCircularDependency","dependencyMap","filterId","trace","dependencies","get","some","dependency","validateForm","form","currentFilterId","setCurrentFilterId","formValues","validateFields","error","errorFields","length","outOfDate","values","warn","field","name","filterError","find","createHandleSave","filterConfigMap","filterIds","removedFilters","saveForm","newFilterConfig","filter","id","map","formInputs","filters","type","DIVIDER","scope","rootPath","excluded","title","description","target","dataset","datasetId","value","column","adhoc_filters","time_range","controlValues","granularity_sqla","requiredFirst","Object","rf","filterType","targets","defaultDataMask","cascadeParentIds","sortMetric","trim","createHandleRemoveItem","setRemovedFilters","setOrderedFilters","setSaveAlertVisible","completeFilterRemoval","isPending","orderedFilters","timerId","window","setTimeout","NATIVE_FILTER_PREFIX","NATIVE_FILTER_DIVIDER_PREFIX","generateFilterId","prefix","NATIVE_FILTER","generate","getFilterIds","config"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { FormInstance } from 'src/components';\nimport shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport {\n  Filter,\n  FilterConfiguration,\n  NativeFilterType,\n  Divider,\n  NativeFilterTarget,\n  logging,\n} from '@superset-ui/core';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nimport { FilterRemoval, NativeFiltersForm } from './types';\n\nexport const REMOVAL_DELAY_SECS = 5;\n\nexport const hasCircularDependency = (\n  dependencyMap: Map<string, string[]>,\n  filterId: string,\n  trace: string[] = [],\n): boolean => {\n  if (trace.includes(filterId)) {\n    return true;\n  }\n  const dependencies = dependencyMap.get(filterId);\n  if (dependencies) {\n    return dependencies.some(dependency =>\n      hasCircularDependency(dependencyMap, dependency, [...trace, filterId]),\n    );\n  }\n  return false;\n};\n\nexport const validateForm = async (\n  form: FormInstance<NativeFiltersForm>,\n  currentFilterId: string,\n  setCurrentFilterId: Function,\n) => {\n  try {\n    let formValues: NativeFiltersForm;\n    try {\n      formValues = (await form.validateFields()) as NativeFiltersForm;\n    } catch (error) {\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!error?.errorFields?.length && error?.outOfDate) {\n        formValues = error.values;\n      } else {\n        throw error;\n      }\n    }\n    return formValues;\n  } catch (error) {\n    logging.warn('Filter configuration failed:', error);\n\n    if (!error.errorFields || !error.errorFields.length) return null; // not a validation error\n\n    // the name is in array format since the fields are nested\n    type ErrorFields = { name: ['filters', string, string] }[];\n    const errorFields = error.errorFields as ErrorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some(field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find(\n        field => field.name[0] === 'filters',\n      );\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\n\nexport const createHandleSave =\n  (\n    filterConfigMap: Record<string, Filter | Divider>,\n    filterIds: string[],\n    removedFilters: Record<string, FilterRemoval>,\n    saveForm: Function,\n    values: NativeFiltersForm,\n  ) =>\n  async () => {\n    const newFilterConfig: FilterConfiguration = filterIds\n      .filter(id => !removedFilters[id])\n      .map(id => {\n        // create a filter config object from the form inputs\n        const formInputs = values.filters?.[id];\n        // if user didn't open a filter, return the original config\n        if (!formInputs) return filterConfigMap[id];\n        if (formInputs.type === NativeFilterType.DIVIDER) {\n          return {\n            id,\n            type: NativeFilterType.DIVIDER,\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [],\n            },\n            title: formInputs.title,\n            description: formInputs.description,\n          };\n        }\n        const target: Partial<NativeFilterTarget> = {};\n        if (formInputs.dataset) {\n          target.datasetId = formInputs.dataset.value;\n        }\n        if (formInputs.dataset && formInputs.column) {\n          target.column = { name: formInputs.column };\n        }\n        return {\n          id,\n          adhoc_filters: formInputs.adhoc_filters,\n          time_range: formInputs.time_range,\n          controlValues: formInputs.controlValues ?? {},\n          granularity_sqla: formInputs.granularity_sqla,\n          requiredFirst: Object.values(formInputs.requiredFirst ?? {}).find(\n            rf => rf,\n          ),\n          name: formInputs.name,\n          filterType: formInputs.filterType,\n          // for now there will only ever be one target\n          targets: [target],\n          defaultDataMask: formInputs.defaultDataMask ?? getInitialDataMask(),\n          cascadeParentIds: formInputs.dependencies || [],\n          scope: formInputs.scope,\n          sortMetric: formInputs.sortMetric,\n          type: formInputs.type,\n          description: (formInputs.description || '').trim(),\n        };\n      });\n\n    await saveForm(newFilterConfig);\n  };\n\nexport const createHandleRemoveItem =\n  (\n    setRemovedFilters: (\n      value:\n        | ((\n            prevState: Record<string, FilterRemoval>,\n          ) => Record<string, FilterRemoval>)\n        | Record<string, FilterRemoval>,\n    ) => void,\n    setOrderedFilters: (\n      val: string[] | ((prevState: string[]) => string[]),\n    ) => void,\n    setSaveAlertVisible: Function,\n  ) =>\n  (filterId: string) => {\n    const completeFilterRemoval = (filterId: string) => {\n      // the filter state will actually stick around in the form,\n      // and the filterConfig/newFilterIds, but we use removedFilters\n      // to mark it as removed.\n      setRemovedFilters(removedFilters => ({\n        ...removedFilters,\n        [filterId]: { isPending: false },\n      }));\n      setOrderedFilters((orderedFilters: string[]) =>\n        orderedFilters.filter(filter => filter !== filterId),\n      );\n    };\n\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(() => {\n      completeFilterRemoval(filterId);\n    }, REMOVAL_DELAY_SECS * 1000);\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId },\n    }));\n    setSaveAlertVisible(false);\n  };\n\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const NATIVE_FILTER_DIVIDER_PREFIX = 'NATIVE_FILTER_DIVIDER-';\nexport const generateFilterId = (type: NativeFilterType) => {\n  const prefix =\n    type === NativeFilterType.NATIVE_FILTER\n      ? NATIVE_FILTER_PREFIX\n      : NATIVE_FILTER_DIVIDER_PREFIX;\n  return `${prefix}${shortid.generate()}`;\n};\n\nexport const getFilterIds = (config: FilterConfiguration) =>\n  config.map(filter => filter.id);\n"]},"metadata":{},"sourceType":"module"}