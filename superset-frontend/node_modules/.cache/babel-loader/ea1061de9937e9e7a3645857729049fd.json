{"ast":null,"code":"import _isObject from \"lodash/isObject\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useDispatch } from 'react-redux';\n\nimport rison from 'rison';\nimport { SupersetClient, runningQueryStateList } from '@superset-ui/core';\nimport useInterval from 'src/SqlLab/utils/useInterval';\nimport { refreshQueries, clearInactiveQueries } from 'src/SqlLab/actions/sqlLab';\nexport const QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n// returns true if the Query.state matches one of the specifc values indicating the query is still processing on server\nexport const isQueryRunning = (q) => _includesInstanceProperty(runningQueryStateList).call(runningQueryStateList, q == null ? void 0 : q.state);\n// returns true if at least one query is running and within the max age to poll timeframe\nexport const shouldCheckForQueries = (queryList) => {\n  let shouldCheck = false;\n  const now = Date.now();\n  if (_isObject(queryList)) {\n    shouldCheck = Object.values(queryList).some((q) => isQueryRunning(q) && now - (q == null ? void 0 : q.startDttm) < MAX_QUERY_AGE_TO_POLL);\n  }\n  return shouldCheck;\n};\nfunction QueryAutoRefresh(_ref) {let { queries, queriesLastUpdate } = _ref;\n  // We do not want to spam requests in the case of slow connections and potentially receive responses out of order\n  // pendingRequest check ensures we only have one active http call to check for query statuses\n  const pendingRequestRef = useRef(false);\n  const cleanInactiveRequestRef = useRef(false);\n  const dispatch = useDispatch();\n  const checkForRefresh = () => {\n    const shouldRequestChecking = shouldCheckForQueries(queries);\n    if (!pendingRequestRef.current && shouldRequestChecking) {\n      const params = rison.encode({\n        last_updated_ms: queriesLastUpdate - QUERY_UPDATE_BUFFER_MS });\n\n      pendingRequestRef.current = true;\n      SupersetClient.get({\n        endpoint: `/api/v1/query/updated_since?q=${params}`,\n        timeout: QUERY_TIMEOUT_LIMIT }).\n\n      then((_ref2) => {let { json } = _ref2;\n        if (json) {var _jsonPayload$result;\n          const jsonPayload = json;\n          if (jsonPayload != null && (_jsonPayload$result = jsonPayload.result) != null && _jsonPayload$result.length) {var _jsonPayload$result$r, _jsonPayload$result2;\n            const queries = (_jsonPayload$result$r = jsonPayload == null ? void 0 : (_jsonPayload$result2 = jsonPayload.result) == null ? void 0 : _jsonPayload$result2.reduce((acc, current) => {\n              acc[current.id] = current;\n              return acc;\n            }, {})) != null ? _jsonPayload$result$r : {};\n            dispatch(refreshQueries(queries));\n          } else\n          {\n            dispatch(clearInactiveQueries());\n          }\n        }\n      }).\n      catch(() => {}).\n      finally(() => {\n        pendingRequestRef.current = false;\n      });\n    }\n    if (!cleanInactiveRequestRef.current && !shouldRequestChecking) {\n      dispatch(clearInactiveQueries());\n      cleanInactiveRequestRef.current = true;\n    }\n  };\n  // Solves issue where direct usage of setInterval in function components\n  // uses stale props / state from closure\n  // See comments in the useInterval.ts file for more information\n  useInterval(() => {\n    checkForRefresh();\n  }, QUERY_UPDATE_FREQ);\n  return null;\n}__signature__(QueryAutoRefresh, \"useRef{pendingRequestRef}\\nuseRef{cleanInactiveRequestRef}\\nuseDispatch{dispatch}\\nuseInterval{}\", () => [useDispatch, useInterval]);const _default =\nQueryAutoRefresh;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(QUERY_UPDATE_FREQ, \"QUERY_UPDATE_FREQ\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QUERY_UPDATE_BUFFER_MS, \"QUERY_UPDATE_BUFFER_MS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(MAX_QUERY_AGE_TO_POLL, \"MAX_QUERY_AGE_TO_POLL\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QUERY_TIMEOUT_LIMIT, \"QUERY_TIMEOUT_LIMIT\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(isQueryRunning, \"isQueryRunning\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(shouldCheckForQueries, \"shouldCheckForQueries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QueryAutoRefresh, \"QueryAutoRefresh\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["useRef","useDispatch","rison","SupersetClient","runningQueryStateList","useInterval","refreshQueries","clearInactiveQueries","QUERY_UPDATE_FREQ","QUERY_UPDATE_BUFFER_MS","MAX_QUERY_AGE_TO_POLL","QUERY_TIMEOUT_LIMIT","isQueryRunning","q","state","shouldCheckForQueries","queryList","shouldCheck","now","Date","Object","values","some","startDttm","QueryAutoRefresh","queries","queriesLastUpdate","pendingRequestRef","cleanInactiveRequestRef","dispatch","checkForRefresh","shouldRequestChecking","current","params","encode","last_updated_ms","get","endpoint","timeout","then","json","jsonPayload","result","length","reduce","acc","id","catch","finally"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { isObject } from 'lodash';\nimport rison from 'rison';\nimport {\n  SupersetClient,\n  Query,\n  runningQueryStateList,\n  QueryResponse,\n} from '@superset-ui/core';\nimport { QueryDictionary } from 'src/SqlLab/types';\nimport useInterval from 'src/SqlLab/utils/useInterval';\nimport {\n  refreshQueries,\n  clearInactiveQueries,\n} from 'src/SqlLab/actions/sqlLab';\n\nexport const QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n\nexport interface QueryAutoRefreshProps {\n  queries: QueryDictionary;\n  queriesLastUpdate: number;\n}\n\n// returns true if the Query.state matches one of the specifc values indicating the query is still processing on server\nexport const isQueryRunning = (q: Query): boolean =>\n  runningQueryStateList.includes(q?.state);\n\n// returns true if at least one query is running and within the max age to poll timeframe\nexport const shouldCheckForQueries = (queryList: QueryDictionary): boolean => {\n  let shouldCheck = false;\n  const now = Date.now();\n  if (isObject(queryList)) {\n    shouldCheck = Object.values(queryList).some(\n      q => isQueryRunning(q) && now - q?.startDttm < MAX_QUERY_AGE_TO_POLL,\n    );\n  }\n  return shouldCheck;\n};\n\nfunction QueryAutoRefresh({\n  queries,\n  queriesLastUpdate,\n}: QueryAutoRefreshProps) {\n  // We do not want to spam requests in the case of slow connections and potentially receive responses out of order\n  // pendingRequest check ensures we only have one active http call to check for query statuses\n  const pendingRequestRef = useRef(false);\n  const cleanInactiveRequestRef = useRef(false);\n  const dispatch = useDispatch();\n\n  const checkForRefresh = () => {\n    const shouldRequestChecking = shouldCheckForQueries(queries);\n    if (!pendingRequestRef.current && shouldRequestChecking) {\n      const params = rison.encode({\n        last_updated_ms: queriesLastUpdate - QUERY_UPDATE_BUFFER_MS,\n      });\n\n      pendingRequestRef.current = true;\n      SupersetClient.get({\n        endpoint: `/api/v1/query/updated_since?q=${params}`,\n        timeout: QUERY_TIMEOUT_LIMIT,\n      })\n        .then(({ json }) => {\n          if (json) {\n            const jsonPayload = json as { result?: QueryResponse[] };\n            if (jsonPayload?.result?.length) {\n              const queries =\n                jsonPayload?.result?.reduce((acc, current) => {\n                  acc[current.id] = current;\n                  return acc;\n                }, {}) ?? {};\n              dispatch(refreshQueries(queries));\n            } else {\n              dispatch(clearInactiveQueries());\n            }\n          }\n        })\n        .catch(() => {})\n        .finally(() => {\n          pendingRequestRef.current = false;\n        });\n    }\n    if (!cleanInactiveRequestRef.current && !shouldRequestChecking) {\n      dispatch(clearInactiveQueries());\n      cleanInactiveRequestRef.current = true;\n    }\n  };\n\n  // Solves issue where direct usage of setInterval in function components\n  // uses stale props / state from closure\n  // See comments in the useInterval.ts file for more information\n  useInterval(() => {\n    checkForRefresh();\n  }, QUERY_UPDATE_FREQ);\n\n  return null;\n}\n\nexport default QueryAutoRefresh;\n"]},"metadata":{},"sourceType":"module"}