{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment from 'moment';\nimport { SEPARATOR } from './dateFilterUtils';\nimport { SEVEN_DAYS_AGO, MIDNIGHT, MOMENT_FORMAT } from './constants';\n/**\n * RegExp to test a string for a full ISO 8601 Date\n * Does not do any sort of date validation, only checks if the string is according to the ISO 8601 spec.\n *  YYYY-MM-DDThh:mm:ss\n *  YYYY-MM-DDThh:mm:ssTZD\n *  YYYY-MM-DDThh:mm:ss.sTZD\n * @see: https://www.w3.org/TR/NOTE-datetime\n */\nconst iso8601 = String.raw`\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.\\d+)?(?:(?:[+-]\\d\\d:\\d\\d)|Z)?`;\nconst datetimeConstant = String.raw`(?:TODAY|NOW)`;\nconst grainValue = String.raw`[+-]?[1-9][0-9]*`;\nconst grain = String.raw`YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND`;\nconst CUSTOM_RANGE_EXPRESSION = RegExp(String.raw`^DATEADD\\(DATETIME\\(\"(${iso8601}|${datetimeConstant})\"\\),\\s(${grainValue}),\\s(${grain})\\)$`, 'i');\nexport const ISO8601_AND_CONSTANT = RegExp(String.raw`^${iso8601}$|^${datetimeConstant}$`, 'i');\nconst DATETIME_CONSTANT = ['now', 'today'];\nconst defaultCustomRange = {\n  sinceDatetime: SEVEN_DAYS_AGO,\n  sinceMode: 'relative',\n  sinceGrain: 'day',\n  sinceGrainValue: -7,\n  untilDatetime: MIDNIGHT,\n  untilMode: 'specific',\n  untilGrain: 'day',\n  untilGrainValue: 7,\n  anchorMode: 'now',\n  anchorValue: 'now' };\n\nconst SPECIFIC_MODE = ['specific', 'today', 'now'];\nexport const dttmToMoment = (dttm) => {\n  if (dttm === 'now') {\n    return moment().utc().startOf('second');\n  }\n  if (dttm === 'today') {\n    return moment().utc().startOf('day');\n  }\n  return moment(dttm);\n};\nexport const dttmToString = (dttm) => dttmToMoment(dttm).format(MOMENT_FORMAT);\nexport const customTimeRangeDecode = (timeRange) => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n  if (splitDateRange.length === 2) {\n    const [since, until] = splitDateRange;\n    // specific : specific\n    if (ISO8601_AND_CONSTANT.test(since) && ISO8601_AND_CONSTANT.test(until)) {\n      const sinceMode = _includesInstanceProperty(DATETIME_CONSTANT).call(DATETIME_CONSTANT, since) ? since : 'specific';\n      const untilMode = _includesInstanceProperty(DATETIME_CONSTANT).call(DATETIME_CONSTANT, until) ? until : 'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceDatetime: since,\n          untilDatetime: until,\n          sinceMode,\n          untilMode },\n\n        matchedFlag: true };\n\n    }\n    // relative : specific\n    const sinceCapturedGroup = since.match(CUSTOM_RANGE_EXPRESSION);\n    if (sinceCapturedGroup &&\n    ISO8601_AND_CONSTANT.test(until) &&\n    _includesInstanceProperty(since).call(since, until)) {\n      const [dttm, grainValue, grain] = sinceCapturedGroup.slice(1);\n      const untilMode = _includesInstanceProperty(DATETIME_CONSTANT).call(DATETIME_CONSTANT, until) ? until : 'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceGrain: grain,\n          sinceGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          sinceMode: 'relative',\n          untilMode },\n\n        matchedFlag: true };\n\n    }\n    // specific : relative\n    const untilCapturedGroup = until.match(CUSTOM_RANGE_EXPRESSION);\n    if (ISO8601_AND_CONSTANT.test(since) &&\n    untilCapturedGroup &&\n    _includesInstanceProperty(until).call(until, since)) {\n      const [dttm, grainValue, grain] = [...untilCapturedGroup.slice(1)];\n      const sinceMode = _includesInstanceProperty(DATETIME_CONSTANT).call(DATETIME_CONSTANT, since) ? since : 'specific';\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          untilGrain: grain,\n          untilGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          untilMode: 'relative',\n          sinceMode },\n\n        matchedFlag: true };\n\n    }\n    // relative : relative\n    if (sinceCapturedGroup && untilCapturedGroup) {\n      const [sinceDttm, sinceGrainValue, sinceGrain] = [\n      ...sinceCapturedGroup.slice(1)];\n\n      const [untileDttm, untilGrainValue, untilGrain] = [\n      ...untilCapturedGroup.slice(1)];\n\n      if (sinceDttm === untileDttm) {\n        return {\n          customRange: {\n            ...defaultCustomRange,\n            sinceGrain: sinceGrain,\n            sinceGrainValue: parseInt(sinceGrainValue, 10),\n            sinceDatetime: sinceDttm,\n            untilGrain: untilGrain,\n            untilGrainValue: parseInt(untilGrainValue, 10),\n            untilDatetime: untileDttm,\n            anchorValue: sinceDttm,\n            sinceMode: 'relative',\n            untilMode: 'relative',\n            anchorMode: sinceDttm === 'now' ? 'now' : 'specific' },\n\n          matchedFlag: true };\n\n      }\n    }\n  }\n  return {\n    customRange: defaultCustomRange,\n    matchedFlag: false };\n\n};\nexport const customTimeRangeEncode = (customRange) => {\n  const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue, untilDatetime, untilMode, untilGrain, untilGrainValue, anchorValue } = { ...customRange };\n  // specific : specific\n  if (_includesInstanceProperty(SPECIFIC_MODE).call(SPECIFIC_MODE, sinceMode) && _includesInstanceProperty(SPECIFIC_MODE).call(SPECIFIC_MODE, untilMode)) {\n    const since = sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    return `${since} : ${until}`;\n  }\n  // specific : relative\n  if (_includesInstanceProperty(SPECIFIC_MODE).call(SPECIFIC_MODE, sinceMode) && untilMode === 'relative') {\n    const since = sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = `DATEADD(DATETIME(\"${since}\"), ${untilGrainValue}, ${untilGrain})`;\n    return `${since} : ${until}`;\n  }\n  // relative : specific\n  if (sinceMode === 'relative' && _includesInstanceProperty(SPECIFIC_MODE).call(SPECIFIC_MODE, untilMode)) {\n    const until = untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    const since = `DATEADD(DATETIME(\"${until}\"), ${-Math.abs(sinceGrainValue)}, ${sinceGrain})`;\n    return `${since} : ${until}`;\n  }\n  // relative : relative\n  const since = `DATEADD(DATETIME(\"${anchorValue}\"), ${-Math.abs(sinceGrainValue)}, ${sinceGrain})`;\n  const until = `DATEADD(DATETIME(\"${anchorValue}\"), ${untilGrainValue}, ${untilGrain})`;\n  return `${since} : ${until}`;\n};","map":{"version":3,"mappings":"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","names":["moment","SEPARATOR","SEVEN_DAYS_AGO","MIDNIGHT","MOMENT_FORMAT","iso8601","String","raw","datetimeConstant","grainValue","grain","CUSTOM_RANGE_EXPRESSION","RegExp","ISO8601_AND_CONSTANT","DATETIME_CONSTANT","defaultCustomRange","sinceDatetime","sinceMode","sinceGrain","sinceGrainValue","untilDatetime","untilMode","untilGrain","untilGrainValue","anchorMode","anchorValue","SPECIFIC_MODE","dttmToMoment","dttm","utc","startOf","dttmToString","format","customTimeRangeDecode","timeRange","splitDateRange","split","length","since","until","test","customRange","matchedFlag","sinceCapturedGroup","match","slice","parseInt","untilCapturedGroup","sinceDttm","untileDttm","customTimeRangeEncode","Math","abs"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/components/controls/DateFilterControl/utils/dateParser.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport moment, { Moment } from 'moment';\nimport {\n  CustomRangeDecodeType,\n  CustomRangeType,\n  DateTimeGrainType,\n  DateTimeModeType,\n} from 'src/explore/components/controls/DateFilterControl/types';\nimport { SEPARATOR } from './dateFilterUtils';\nimport { SEVEN_DAYS_AGO, MIDNIGHT, MOMENT_FORMAT } from './constants';\n\n/**\n * RegExp to test a string for a full ISO 8601 Date\n * Does not do any sort of date validation, only checks if the string is according to the ISO 8601 spec.\n *  YYYY-MM-DDThh:mm:ss\n *  YYYY-MM-DDThh:mm:ssTZD\n *  YYYY-MM-DDThh:mm:ss.sTZD\n * @see: https://www.w3.org/TR/NOTE-datetime\n */\nconst iso8601 = String.raw`\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.\\d+)?(?:(?:[+-]\\d\\d:\\d\\d)|Z)?`;\nconst datetimeConstant = String.raw`(?:TODAY|NOW)`;\nconst grainValue = String.raw`[+-]?[1-9][0-9]*`;\nconst grain = String.raw`YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND`;\nconst CUSTOM_RANGE_EXPRESSION = RegExp(\n  String.raw`^DATEADD\\(DATETIME\\(\"(${iso8601}|${datetimeConstant})\"\\),\\s(${grainValue}),\\s(${grain})\\)$`,\n  'i',\n);\nexport const ISO8601_AND_CONSTANT = RegExp(\n  String.raw`^${iso8601}$|^${datetimeConstant}$`,\n  'i',\n);\nconst DATETIME_CONSTANT = ['now', 'today'];\nconst defaultCustomRange: CustomRangeType = {\n  sinceDatetime: SEVEN_DAYS_AGO,\n  sinceMode: 'relative',\n  sinceGrain: 'day',\n  sinceGrainValue: -7,\n  untilDatetime: MIDNIGHT,\n  untilMode: 'specific',\n  untilGrain: 'day',\n  untilGrainValue: 7,\n  anchorMode: 'now',\n  anchorValue: 'now',\n};\nconst SPECIFIC_MODE = ['specific', 'today', 'now'];\n\nexport const dttmToMoment = (dttm: string): Moment => {\n  if (dttm === 'now') {\n    return moment().utc().startOf('second');\n  }\n  if (dttm === 'today') {\n    return moment().utc().startOf('day');\n  }\n  return moment(dttm);\n};\n\nexport const dttmToString = (dttm: string): string =>\n  dttmToMoment(dttm).format(MOMENT_FORMAT);\n\nexport const customTimeRangeDecode = (\n  timeRange: string,\n): CustomRangeDecodeType => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n\n  if (splitDateRange.length === 2) {\n    const [since, until] = splitDateRange;\n\n    // specific : specific\n    if (ISO8601_AND_CONSTANT.test(since) && ISO8601_AND_CONSTANT.test(until)) {\n      const sinceMode = (\n        DATETIME_CONSTANT.includes(since) ? since : 'specific'\n      ) as DateTimeModeType;\n      const untilMode = (\n        DATETIME_CONSTANT.includes(until) ? until : 'specific'\n      ) as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceDatetime: since,\n          untilDatetime: until,\n          sinceMode,\n          untilMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // relative : specific\n    const sinceCapturedGroup = since.match(CUSTOM_RANGE_EXPRESSION);\n    if (\n      sinceCapturedGroup &&\n      ISO8601_AND_CONSTANT.test(until) &&\n      since.includes(until)\n    ) {\n      const [dttm, grainValue, grain] = sinceCapturedGroup.slice(1);\n      const untilMode = (\n        DATETIME_CONSTANT.includes(until) ? until : 'specific'\n      ) as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          sinceGrain: grain as DateTimeGrainType,\n          sinceGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          sinceMode: 'relative',\n          untilMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // specific : relative\n    const untilCapturedGroup = until.match(CUSTOM_RANGE_EXPRESSION);\n    if (\n      ISO8601_AND_CONSTANT.test(since) &&\n      untilCapturedGroup &&\n      until.includes(since)\n    ) {\n      const [dttm, grainValue, grain] = [...untilCapturedGroup.slice(1)];\n      const sinceMode = (\n        DATETIME_CONSTANT.includes(since) ? since : 'specific'\n      ) as DateTimeModeType;\n      return {\n        customRange: {\n          ...defaultCustomRange,\n          untilGrain: grain as DateTimeGrainType,\n          untilGrainValue: parseInt(grainValue, 10),\n          sinceDatetime: dttm,\n          untilDatetime: dttm,\n          untilMode: 'relative',\n          sinceMode,\n        },\n        matchedFlag: true,\n      };\n    }\n\n    // relative : relative\n    if (sinceCapturedGroup && untilCapturedGroup) {\n      const [sinceDttm, sinceGrainValue, sinceGrain] = [\n        ...sinceCapturedGroup.slice(1),\n      ];\n      const [untileDttm, untilGrainValue, untilGrain] = [\n        ...untilCapturedGroup.slice(1),\n      ];\n      if (sinceDttm === untileDttm) {\n        return {\n          customRange: {\n            ...defaultCustomRange,\n            sinceGrain: sinceGrain as DateTimeGrainType,\n            sinceGrainValue: parseInt(sinceGrainValue, 10),\n            sinceDatetime: sinceDttm,\n            untilGrain: untilGrain as DateTimeGrainType,\n            untilGrainValue: parseInt(untilGrainValue, 10),\n            untilDatetime: untileDttm,\n            anchorValue: sinceDttm,\n            sinceMode: 'relative',\n            untilMode: 'relative',\n            anchorMode: sinceDttm === 'now' ? 'now' : 'specific',\n          },\n          matchedFlag: true,\n        };\n      }\n    }\n  }\n\n  return {\n    customRange: defaultCustomRange,\n    matchedFlag: false,\n  };\n};\n\nexport const customTimeRangeEncode = (customRange: CustomRangeType): string => {\n  const {\n    sinceDatetime,\n    sinceMode,\n    sinceGrain,\n    sinceGrainValue,\n    untilDatetime,\n    untilMode,\n    untilGrain,\n    untilGrainValue,\n    anchorValue,\n  } = { ...customRange };\n  // specific : specific\n  if (SPECIFIC_MODE.includes(sinceMode) && SPECIFIC_MODE.includes(untilMode)) {\n    const since =\n      sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until =\n      untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    return `${since} : ${until}`;\n  }\n\n  // specific : relative\n  if (SPECIFIC_MODE.includes(sinceMode) && untilMode === 'relative') {\n    const since =\n      sinceMode === 'specific' ? dttmToString(sinceDatetime) : sinceMode;\n    const until = `DATEADD(DATETIME(\"${since}\"), ${untilGrainValue}, ${untilGrain})`;\n    return `${since} : ${until}`;\n  }\n\n  // relative : specific\n  if (sinceMode === 'relative' && SPECIFIC_MODE.includes(untilMode)) {\n    const until =\n      untilMode === 'specific' ? dttmToString(untilDatetime) : untilMode;\n    const since = `DATEADD(DATETIME(\"${until}\"), ${-Math.abs(\n      sinceGrainValue,\n    )}, ${sinceGrain})`;\n    return `${since} : ${until}`;\n  }\n\n  // relative : relative\n  const since = `DATEADD(DATETIME(\"${anchorValue}\"), ${-Math.abs(\n    sinceGrainValue,\n  )}, ${sinceGrain})`;\n  const until = `DATEADD(DATETIME(\"${anchorValue}\"), ${untilGrainValue}, ${untilGrain})`;\n  return `${since} : ${until}`;\n};\n"]},"metadata":{},"sourceType":"module"}