{"ast":null,"code":"import _invert from \"lodash/invert\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CategoricalColorNamespace, GenericDataType, getNumberFormatter, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isTimeseriesAnnotationLayer, getXAxisLabel, isPhysicalColumn, isDefined, ensureIsArray } from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { DEFAULT_FORM_DATA } from './types';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport { getOverMaxHiddenFormatter, currentSeries, dedupSeries, extractSeries, getAxisType, getColtypesMapping, getLegendProps, extractDataTotalValues, extractShowValueIndexes } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding, getTooltipTimeFormatter, getXAxisFormatter, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from '../Timeseries/transformers';\nimport { TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, formData, queriesData, hooks, filterState, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  const { verboseMap = {} } = datasource;\n  const { label_map: labelMap } = queriesData[0];\n  const { label_map: labelMapB } = queriesData[1];\n  const data1 = queriesData[0].data || [];\n  const data2 = queriesData[1].data || [];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]) };\n\n  const { area, areaB, annotationLayers, colorScheme, contributionMode, legendOrientation, legendType, logAxis, logAxisSecondary, markerEnabled, markerEnabledB, markerSize, markerSizeB, opacity, opacityB, minorSplitLine, seriesType, seriesTypeB, showLegend, showValue, showValueB, stack, stackB, truncateYAxis, tooltipTimeFormat, yAxisFormat, yAxisFormatSecondary, xAxisTimeFormat, yAxisBounds, yAxisBoundsSecondary, yAxisIndex, yAxisIndexB, yAxisTitleSecondary, zoomable, richTooltip, tooltipSortByMetric, xAxisLabelRotation, groupby, groupbyB, xAxis: xAxisOrig, xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId, timeGrainSqla, percentageThreshold } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel });\n\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series = [];\n  const formatter = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormat);\n  const formatterSecondary = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormatSecondary);\n  const primarySeries = new Set();\n  const secondarySeries = new Set();\n  const mapSeriesIdToAxis = (seriesOption, index) => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id);\n    } else\n    {\n      primarySeries.add(seriesOption.id);\n    }\n  };\n  rawSeriesA.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndex));\n  rawSeriesB.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndexB));\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack });\n\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack });\n\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedDataA, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel });\n\n  const { totalStackedValues: totalStackedValuesB, thresholdValues: thresholdValuesB } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel });\n\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data1, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data1, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(parseYAxisBound);\n  const maxLabelFormatter = getOverMaxHiddenFormatter({ max, formatter });\n  const maxLabelFormatterSecondary = getOverMaxHiddenFormatter({\n    max: maxSecondary,\n    formatter: formatterSecondary });\n\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeriesA.forEach((entry) => {\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      showValue,\n      stack: Boolean(stack),\n      yAxisIndex,\n      filterState,\n      seriesKey: entry.name,\n      sliceId,\n      queryIndex: 0,\n      formatter: seriesType === EchartsTimeseriesSeriesType.Bar ?\n      maxLabelFormatter :\n      formatter,\n      showValueIndexes: showValueIndexesA,\n      totalStackedValues,\n      thresholdValues });\n\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  rawSeriesB.forEach((entry) => {\n    const entryName = String(entry.name || '');\n    const seriesName = `${inverted[entryName] || entryName} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area: areaB,\n      markerEnabled: markerEnabledB,\n      markerSize: markerSizeB,\n      areaOpacity: opacityB,\n      seriesType: seriesTypeB,\n      showValue: showValueB,\n      stack: Boolean(stackB),\n      yAxisIndex: yAxisIndexB,\n      filterState,\n      seriesKey: primarySeries.has(entry.name) ?\n      `${entry.name} (1)` :\n      entry.name,\n      sliceId,\n      queryIndex: 1,\n      formatter: seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      maxLabelFormatterSecondary :\n      formatterSecondary,\n      showValueIndexes: showValueIndexesB,\n      totalStackedValues: totalStackedValuesB,\n      thresholdValues: thresholdValuesB });\n\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (min === undefined)\n    min = 0;\n    if (max === undefined)\n    max = 1;\n    if (minSecondary === undefined)\n    minSecondary = 0;\n    if (maxSecondary === undefined)\n    maxSecondary = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding },\n\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation },\n\n      minInterval: xAxisType === 'time' && timeGrainSqla ?\n      TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n      0 },\n\n    yAxis: [\n    {\n      ...defaultYAxis,\n      type: logAxis ? 'log' : 'value',\n      min,\n      max,\n      minorTick: { show: true },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: { formatter },\n      scale: truncateYAxis,\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n      alignTicks },\n\n    {\n      ...defaultYAxis,\n      type: logAxisSecondary ? 'log' : 'value',\n      min: minSecondary,\n      max: maxSecondary,\n      minorTick: { show: true },\n      splitLine: { show: false },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: { formatter: formatterSecondary },\n      scale: truncateYAxis,\n      name: yAxisTitleSecondary,\n      alignTicks }],\n\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const xValue = richTooltip ?\n        params[0].value[0] :\n        params.value[0];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n        const rows = [`${tooltipFormatter(xValue)}`];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue);\n        Object.keys(forecastValues).forEach((key) => {\n          const value = forecastValues[key];\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ? formatter : formatterSecondary });\n\n          if (currentSeries.name === key) {\n            rows.push(`<span style=\"font-weight: 700\">${content}</span>`);\n          } else\n          {\n            rows.push(`<span style=\"opacity: 0.7\">${content}</span>`);\n          }\n        });\n        return rows.join('<br />');\n      } },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      // @ts-ignore\n      data: rawSeriesA.\n      concat(rawSeriesB).\n      filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n      ForecastSeriesEnum.Observation).\n      map((entry) => entry.name || '').\n      concat(extractAnnotationLabels(annotationLayers, annotationData)) },\n\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom' } } } },\n\n\n\n\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom }] :\n\n\n    [] };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType },\n\n    refs,\n    coltypeMapping };\n\n}","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","GenericDataType","getNumberFormatter","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isTimeseriesAnnotationLayer","getXAxisLabel","isPhysicalColumn","isDefined","ensureIsArray","getOriginalSeries","DEFAULT_FORM_DATA","EchartsTimeseriesSeriesType","ForecastSeriesEnum","parseYAxisBound","getOverMaxHiddenFormatter","currentSeries","dedupSeries","extractSeries","getAxisType","getColtypesMapping","getLegendProps","extractDataTotalValues","extractShowValueIndexes","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getPadding","getTooltipTimeFormatter","getXAxisFormatter","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","TIMESERIES_CONSTANTS","TIMEGRAIN_TO_TIMESTAMP","getDefaultTooltip","transformProps","chartProps","width","height","formData","queriesData","hooks","filterState","datasource","theme","inContextMenu","emitCrossFilters","verboseMap","label_map","labelMap","labelMapB","data1","data","data2","annotationData","coltypeMapping","area","areaB","annotationLayers","colorScheme","contributionMode","legendOrientation","legendType","logAxis","logAxisSecondary","markerEnabled","markerEnabledB","markerSize","markerSizeB","opacity","opacityB","minorSplitLine","seriesType","seriesTypeB","showLegend","showValue","showValueB","stack","stackB","truncateYAxis","tooltipTimeFormat","yAxisFormat","yAxisFormatSecondary","xAxisTimeFormat","yAxisBounds","yAxisBoundsSecondary","yAxisIndex","yAxisIndexB","yAxisTitleSecondary","zoomable","richTooltip","tooltipSortByMetric","xAxisLabelRotation","groupby","groupbyB","xAxis","xAxisOrig","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","timeGrainSqla","percentageThreshold","refs","colorScale","getScale","xAxisLabel","rawFormData","x_axis","rebasedDataA","rawSeriesA","fillNeighborValue","undefined","rebasedDataB","rawSeriesB","dataTypes","xAxisDataType","xAxisType","series","formatter","formatterSecondary","primarySeries","Set","secondarySeries","mapSeriesIdToAxis","seriesOption","index","add","id","forEach","showValueIndexesA","showValueIndexesB","totalStackedValues","thresholdValues","xAxisCol","totalStackedValuesB","thresholdValuesB","Boolean","filter","layer","show","push","min","max","map","minSecondary","maxSecondary","maxLabelFormatter","maxLabelFormatterSecondary","array","time_compare","inverted","entryName","String","entry","name","seriesName","colorScaleKey","transformedSeries","areaOpacity","seriesKey","queryIndex","Bar","showValueIndexes","has","tooltipFormatter","TEMPORAL","xAxisFormatter","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","setDataMask","onContextMenu","alignTicks","echartOptions","useUTC","grid","type","nameGap","nameLocation","axisLabel","rotate","minInterval","yAxis","minorTick","scale","splitLine","tooltip","trigger","params","xValue","value","forecastValue","sort","a","b","rows","forecastValues","Object","keys","key","content","join","legend","concat","Observation","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","bottom","zoomBottom","seriesBreakdown","length","selectedValues","xValueFormatter","label"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  CategoricalColorNamespace,\n  GenericDataType,\n  getNumberFormatter,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isTimeseriesAnnotationLayer,\n  QueryFormData,\n  TimeseriesChartDataResponseResult,\n  TimeseriesDataRecord,\n  getXAxisLabel,\n  isPhysicalColumn,\n  isDefined,\n  ensureIsArray,\n} from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport {\n  DEFAULT_FORM_DATA,\n  EchartsMixedTimeseriesFormData,\n  EchartsMixedTimeseriesChartTransformedProps,\n  EchartsMixedTimeseriesProps,\n} from './types';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  Refs,\n} from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport {\n  getOverMaxHiddenFormatter,\n  currentSeries,\n  dedupSeries,\n  extractSeries,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  extractDataTotalValues,\n  extractShowValueIndexes,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getPadding,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from '../Timeseries/transformers';\nimport { TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport default function transformProps(\n  chartProps: EchartsMixedTimeseriesProps,\n): EchartsMixedTimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const { verboseMap = {} } = datasource;\n  const { label_map: labelMap } =\n    queriesData[0] as TimeseriesChartDataResponseResult;\n  const { label_map: labelMapB } =\n    queriesData[1] as TimeseriesChartDataResponseResult;\n  const data1 = (queriesData[0].data || []) as TimeseriesDataRecord[];\n  const data2 = (queriesData[1].data || []) as TimeseriesDataRecord[];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]),\n  };\n  const {\n    area,\n    areaB,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    legendOrientation,\n    legendType,\n    logAxis,\n    logAxisSecondary,\n    markerEnabled,\n    markerEnabledB,\n    markerSize,\n    markerSizeB,\n    opacity,\n    opacityB,\n    minorSplitLine,\n    seriesType,\n    seriesTypeB,\n    showLegend,\n    showValue,\n    showValueB,\n    stack,\n    stackB,\n    truncateYAxis,\n    tooltipTimeFormat,\n    yAxisFormat,\n    yAxisFormatSecondary,\n    xAxisTimeFormat,\n    yAxisBounds,\n    yAxisBoundsSecondary,\n    yAxisIndex,\n    yAxisIndexB,\n    yAxisTitleSecondary,\n    zoomable,\n    richTooltip,\n    tooltipSortByMetric,\n    xAxisLabelRotation,\n    groupby,\n    groupbyB,\n    xAxis: xAxisOrig,\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n    timeGrainSqla,\n    percentageThreshold,\n  }: EchartsMixedTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n\n  const refs: Refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n\n  let xAxisLabel = getXAxisLabel(\n    chartProps.rawFormData as QueryFormData,\n  ) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series: SeriesOption[] = [];\n  const formatter = getNumberFormatter(contributionMode ? ',.0%' : yAxisFormat);\n  const formatterSecondary = getNumberFormatter(\n    contributionMode ? ',.0%' : yAxisFormatSecondary,\n  );\n\n  const primarySeries = new Set<string>();\n  const secondarySeries = new Set<string>();\n  const mapSeriesIdToAxis = (\n    seriesOption: SeriesOption,\n    index?: number,\n  ): void => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id as string);\n    } else {\n      primarySeries.add(seriesOption.id as string);\n    }\n  };\n  rawSeriesA.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndex),\n  );\n  rawSeriesB.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndexB),\n  );\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack,\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack,\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedDataA,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n    },\n  );\n  const {\n    totalStackedValues: totalStackedValuesB,\n    thresholdValues: thresholdValuesB,\n  } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n  });\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data1,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data1,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(\n    parseYAxisBound,\n  );\n\n  const maxLabelFormatter = getOverMaxHiddenFormatter({ max, formatter });\n  const maxLabelFormatterSecondary = getOverMaxHiddenFormatter({\n    max: maxSecondary,\n    formatter: formatterSecondary,\n  });\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeriesA.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        showValue,\n        stack: Boolean(stack),\n        yAxisIndex,\n        filterState,\n        seriesKey: entry.name,\n        sliceId,\n        queryIndex: 0,\n        formatter:\n          seriesType === EchartsTimeseriesSeriesType.Bar\n            ? maxLabelFormatter\n            : formatter,\n        showValueIndexes: showValueIndexesA,\n        totalStackedValues,\n        thresholdValues,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  rawSeriesB.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = `${inverted[entryName] || entryName} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area: areaB,\n        markerEnabled: markerEnabledB,\n        markerSize: markerSizeB,\n        areaOpacity: opacityB,\n        seriesType: seriesTypeB,\n        showValue: showValueB,\n        stack: Boolean(stackB),\n        yAxisIndex: yAxisIndexB,\n        filterState,\n        seriesKey: primarySeries.has(entry.name as string)\n          ? `${entry.name} (1)`\n          : entry.name,\n        sliceId,\n        queryIndex: 1,\n        formatter:\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n            ? maxLabelFormatterSecondary\n            : formatterSecondary,\n        showValueIndexes: showValueIndexesB,\n        totalStackedValues: totalStackedValuesB,\n        thresholdValues: thresholdValuesB,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (min === undefined) min = 0;\n    if (max === undefined) max = 1;\n    if (minSecondary === undefined) minSecondary = 0;\n    if (maxSecondary === undefined) maxSecondary = 1;\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n\n  const chartPadding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisTitleOffset,\n    zoomable,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation,\n      },\n      minInterval:\n        xAxisType === 'time' && timeGrainSqla\n          ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n          : 0,\n    },\n    yAxis: [\n      {\n        ...defaultYAxis,\n        type: logAxis ? 'log' : 'value',\n        min,\n        max,\n        minorTick: { show: true },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: { formatter },\n        scale: truncateYAxis,\n        name: yAxisTitle,\n        nameGap: convertInteger(yAxisTitleMargin),\n        nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n        alignTicks,\n      },\n      {\n        ...defaultYAxis,\n        type: logAxisSecondary ? 'log' : 'value',\n        min: minSecondary,\n        max: maxSecondary,\n        minorTick: { show: true },\n        splitLine: { show: false },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: { formatter: formatterSecondary },\n        scale: truncateYAxis,\n        name: yAxisTitleSecondary,\n        alignTicks,\n      },\n    ],\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const xValue: number = richTooltip\n          ? params[0].value[0]\n          : params.value[0];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[1] - a.data[1]);\n        }\n\n        const rows: Array<string> = [`${tooltipFormatter(xValue)}`];\n        const forecastValues =\n          extractForecastValuesFromTooltipParams(forecastValue);\n\n        Object.keys(forecastValues).forEach(key => {\n          const value = forecastValues[key];\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ? formatter : formatterSecondary,\n          });\n          if (currentSeries.name === key) {\n            rows.push(`<span style=\"font-weight: 700\">${content}</span>`);\n          } else {\n            rows.push(`<span style=\"opacity: 0.7\">${content}</span>`);\n          }\n        });\n        return rows.join('<br />');\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n      ),\n      // @ts-ignore\n      data: rawSeriesA\n        .concat(rawSeriesB)\n        .filter(\n          entry =>\n            extractForecastSeriesContext((entry.name || '') as string).type ===\n            ForecastSeriesEnum.Observation,\n        )\n        .map(entry => entry.name || '')\n        .concat(extractAnnotationLabels(annotationLayers, annotationData)),\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom',\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}