{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { ensureIsArray } from '@superset-ui/core';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\nfunction execControlValidator(control, processedState) {\n  const validators = control.validators;\n  const { externalValidationErrors = [] } = control;\n  const errors = [];\n  if (validators && validators.length > 0) {\n    validators.forEach((validator) => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  if (control.type === 'SelectControl' &&\n  !control.freeForm &&\n  control.choices &&\n  control.value) {\n    const alteredControl = { ...control };\n    const choices = control.choices;\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map((c) => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter((el) => _includesInstanceProperty(choiceValues).call(choiceValues, el));\n      return alteredControl;\n    }\n    if (!control.multi && !_includesInstanceProperty(choiceValues).call(choiceValues, value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState) };\n\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // InitialValue is used for setting value for the control,\n  // this value is not recalculated. The default value will override it.\n  if (typeof state.initialValue === 'function') {\n    state.initialValue = state.initialValue(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.initialValue === 'function') {\n      delete state.initialValue;\n    }\n  }\n  if (state.initialValue) {\n    value = state.initialValue;\n    delete state.initialValue;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\nexport function getControlStateFromControlConfig(controlConfig, controlPanelState, value) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState != null && controlPanelState.controls || controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(getControlConfig(controlKey, vizType), state, value);\n}\nexport function getAllControlsState(vizType, datasourceType, state, formData) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach((section) => section.controlSetRows.forEach((fieldsetRow) => fieldsetRow.forEach((field) => {\n    if (field != null && field.config && field.name) {\n      const { config, name } = field;\n      controlsState[name] = getControlStateFromControlConfig(config, state, formData[name]);\n    }\n  })));\n  return controlsState;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(execControlValidator, \"execControlValidator\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(handleMissingChoice, \"handleMissingChoice\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(applyMapStateToPropsToControl, \"applyMapStateToPropsToControl\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlStateFromControlConfig, \"getControlStateFromControlConfig\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlState, \"getControlState\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getAllControlsState, \"getAllControlsState\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["ensureIsArray","getSectionsToRender","getControlConfig","execControlValidator","control","processedState","validators","externalValidationErrors","errors","length","forEach","error","validator","call","value","push","validationErrors","handleMissingChoice","type","freeForm","choices","alteredControl","choiceValues","map","c","multi","filter","el","applyMapStateToPropsToControl","controlState","controlPanelState","mapStateToProps","state","initialValue","default","undefined","Array","isArray","getControlStateFromControlConfig","controlConfig","controls","getControlState","controlKey","vizType","getAllControlsState","datasourceType","formData","controlsState","section","controlSetRows","fieldsetRow","field","config","name"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/getControlState.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ReactNode } from 'react';\nimport {\n  DatasourceType,\n  ensureIsArray,\n  JsonValue,\n  QueryFormData,\n} from '@superset-ui/core';\nimport {\n  ControlConfig,\n  ControlPanelState,\n  ControlState,\n  ControlType,\n  ControlValueValidator,\n  CustomControlItem,\n} from '@superset-ui/chart-controls';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\n\ntype ValidationError = JsonValue;\n\nfunction execControlValidator<T = ControlType>(\n  control: ControlState<T>,\n  processedState: ControlState<T>,\n) {\n  const validators = control.validators as ControlValueValidator[] | undefined;\n  const { externalValidationErrors = [] } = control;\n  const errors: ValidationError[] = [];\n  if (validators && validators.length > 0) {\n    validators.forEach(validator => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice<T = ControlType>(control: ControlState<T>) {\n  // If the value is not valid anymore based on choices, clear it\n  if (\n    control.type === 'SelectControl' &&\n    !control.freeForm &&\n    control.choices &&\n    control.value\n  ) {\n    const alteredControl = { ...control };\n    const choices = control.choices as [JsonValue, ReactNode][];\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map(c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter(el => choiceValues.includes(el));\n      return alteredControl;\n    }\n    if (!control.multi && !choiceValues.includes(value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\n\nexport function applyMapStateToPropsToControl<T = ControlType>(\n  controlState: ControlState<T>,\n  controlPanelState: Partial<ControlPanelState> | null,\n) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState),\n    };\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n\n  // InitialValue is used for setting value for the control,\n  // this value is not recalculated. The default value will override it.\n  if (typeof state.initialValue === 'function') {\n    state.initialValue = state.initialValue(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.initialValue === 'function') {\n      delete state.initialValue;\n    }\n  }\n  if (state.initialValue) {\n    value = state.initialValue;\n    delete state.initialValue;\n  }\n\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\n\nexport function getControlStateFromControlConfig<T = ControlType>(\n  controlConfig: ControlConfig<T> | null,\n  controlPanelState: Partial<ControlPanelState> | null,\n  value?: JsonValue,\n) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value } as ControlState<T>;\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState?.controls || controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\n\nexport function getControlState(\n  controlKey: string,\n  vizType: string,\n  state: Partial<ControlPanelState>,\n  value?: JsonValue,\n) {\n  return getControlStateFromControlConfig(\n    getControlConfig(controlKey, vizType),\n    state,\n    value,\n  );\n}\n\nexport function getAllControlsState(\n  vizType: string,\n  datasourceType: DatasourceType,\n  state: ControlPanelState | null,\n  formData: QueryFormData,\n) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach(section =>\n    section.controlSetRows.forEach(fieldsetRow =>\n      fieldsetRow.forEach((field: CustomControlItem) => {\n        if (field?.config && field.name) {\n          const { config, name } = field;\n          controlsState[name] = getControlStateFromControlConfig(\n            config,\n            state,\n            formData[name],\n          );\n        }\n      }),\n    ),\n  );\n  return controlsState;\n}\n"]},"metadata":{},"sourceType":"module"}