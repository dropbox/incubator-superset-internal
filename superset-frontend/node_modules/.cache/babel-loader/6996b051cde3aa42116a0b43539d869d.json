{"ast":null,"code":"import _isString from \"lodash/isString\";import { makeApi, CategoricalColorNamespace, t } from '@superset-ui/core';\n\nimport { getErrorText } from 'src/utils/getClientErrorObject';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport { onSave } from './dashboardState';\nexport const DASHBOARD_INFO_UPDATED = 'DASHBOARD_INFO_UPDATED';\nexport function updateColorSchema(metadata, labelColors) {\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(metadata == null ? void 0 : metadata.color_namespace);\n  const colorMap = _isString(labelColors) ?\n  JSON.parse(labelColors) :\n  labelColors;\n  Object.keys(colorMap).forEach((label) => {\n    categoricalNamespace.setColor(label, colorMap[label]);\n  });\n}\n// updates partially changed dashboard info\nexport function dashboardInfoChanged(newInfo) {\n  const { metadata } = newInfo;\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(metadata == null ? void 0 : metadata.color_namespace);\n  categoricalNamespace.resetColors();\n  if (metadata != null && metadata.shared_label_colors) {\n    updateColorSchema(metadata, metadata == null ? void 0 : metadata.shared_label_colors);\n  }\n  if (metadata != null && metadata.label_colors) {\n    updateColorSchema(metadata, metadata == null ? void 0 : metadata.label_colors);\n  }\n  return { type: DASHBOARD_INFO_UPDATED, newInfo };\n}\nexport const SAVE_CHART_CONFIG_BEGIN = 'SAVE_CHART_CONFIG_BEGIN';\nexport const SAVE_CHART_CONFIG_COMPLETE = 'SAVE_CHART_CONFIG_COMPLETE';\nexport const SAVE_CHART_CONFIG_FAIL = 'SAVE_CHART_CONFIG_FAIL';\nexport const saveChartConfiguration = (_ref) => {let { chartConfiguration, globalChartConfiguration } = _ref;return async (dispatch, getState) => {\n    dispatch({\n      type: SAVE_CHART_CONFIG_BEGIN,\n      chartConfiguration,\n      globalChartConfiguration });\n\n    const { id, metadata } = getState().dashboardInfo;\n    // TODO extract this out when makeApi supports url parameters\n    const updateDashboard = makeApi({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}` });\n\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          chart_configuration: chartConfiguration != null ? chartConfiguration : metadata.chart_configuration,\n          global_chart_configuration: globalChartConfiguration != null ? globalChartConfiguration : metadata.global_chart_configuration }) });\n\n\n      dispatch(dashboardInfoChanged({\n        metadata: JSON.parse(response.result.json_metadata) }));\n\n      dispatch({\n        type: SAVE_CHART_CONFIG_COMPLETE,\n        chartConfiguration,\n        globalChartConfiguration });\n\n    }\n    catch (err) {\n      dispatch({\n        type: SAVE_CHART_CONFIG_FAIL,\n        chartConfiguration,\n        globalChartConfiguration });\n\n      dispatch(addDangerToast(t('Failed to save cross-filter scoping')));\n    }\n  };};\nexport const SET_FILTER_BAR_ORIENTATION = 'SET_FILTER_BAR_ORIENTATION';\nexport function setFilterBarOrientation(filterBarOrientation) {\n  return { type: SET_FILTER_BAR_ORIENTATION, filterBarOrientation };\n}\nexport const SET_CROSS_FILTERS_ENABLED = 'SET_CROSS_FILTERS_ENABLED';\nexport function setCrossFiltersEnabled(crossFiltersEnabled) {\n  return { type: SET_CROSS_FILTERS_ENABLED, crossFiltersEnabled };\n}\nexport function saveFilterBarOrientation(orientation) {\n  return async (dispatch, getState) => {\n    const { id, metadata } = getState().dashboardInfo;\n    const updateDashboard = makeApi({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}` });\n\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          filter_bar_orientation: orientation }) });\n\n\n      const updatedDashboard = response.result;\n      const lastModifiedTime = response.last_modified_time;\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        if (metadata.filter_bar_orientation) {\n          dispatch(setFilterBarOrientation(metadata.filter_bar_orientation));\n        }\n      }\n      if (lastModifiedTime) {\n        dispatch(onSave(lastModifiedTime));\n      }\n    }\n    catch (errorObject) {\n      const errorText = await getErrorText(errorObject, 'dashboard');\n      dispatch(addDangerToast(errorText));\n      throw errorObject;\n    }\n  };\n}\nexport function saveCrossFiltersSetting(crossFiltersEnabled) {\n  return async (dispatch, getState) => {\n    const { id, metadata } = getState().dashboardInfo;\n    const updateDashboard = makeApi({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}` });\n\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          cross_filters_enabled: crossFiltersEnabled }) });\n\n\n      const updatedDashboard = response.result;\n      const lastModifiedTime = response.last_modified_time;\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(setCrossFiltersEnabled(metadata.cross_filters_enabled));\n      }\n      if (lastModifiedTime) {\n        dispatch(onSave(lastModifiedTime));\n      }\n    }\n    catch (errorObject) {\n      const errorText = await getErrorText(errorObject, 'dashboard');\n      dispatch(addDangerToast(errorText));\n      throw errorObject;\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["makeApi","CategoricalColorNamespace","t","getErrorText","addDangerToast","onSave","DASHBOARD_INFO_UPDATED","updateColorSchema","metadata","labelColors","categoricalNamespace","getNamespace","color_namespace","colorMap","JSON","parse","Object","keys","forEach","setColor","label","dashboardInfoChanged","newInfo","resetColors","shared_label_colors","label_colors","type","SAVE_CHART_CONFIG_BEGIN","SAVE_CHART_CONFIG_COMPLETE","SAVE_CHART_CONFIG_FAIL","saveChartConfiguration","chartConfiguration","globalChartConfiguration","dispatch","getState","id","dashboardInfo","updateDashboard","method","endpoint","response","json_metadata","stringify","chart_configuration","global_chart_configuration","result","err","SET_FILTER_BAR_ORIENTATION","setFilterBarOrientation","filterBarOrientation","SET_CROSS_FILTERS_ENABLED","setCrossFiltersEnabled","crossFiltersEnabled","saveFilterBarOrientation","orientation","filter_bar_orientation","updatedDashboard","lastModifiedTime","last_modified_time","errorObject","errorText","saveCrossFiltersSetting","cross_filters_enabled"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/actions/dashboardInfo.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Dispatch } from 'redux';\nimport { makeApi, CategoricalColorNamespace, t } from '@superset-ui/core';\nimport { isString } from 'lodash';\nimport { getErrorText } from 'src/utils/getClientErrorObject';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport {\n  ChartConfiguration,\n  DashboardInfo,\n  FilterBarOrientation,\n  GlobalChartCrossFilterConfig,\n  RootState,\n} from 'src/dashboard/types';\nimport { onSave } from './dashboardState';\n\nexport const DASHBOARD_INFO_UPDATED = 'DASHBOARD_INFO_UPDATED';\n\nexport function updateColorSchema(\n  metadata: Record<string, any>,\n  labelColors: Record<string, string>,\n) {\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    metadata?.color_namespace,\n  );\n  const colorMap = isString(labelColors)\n    ? JSON.parse(labelColors)\n    : labelColors;\n  Object.keys(colorMap).forEach(label => {\n    categoricalNamespace.setColor(label, colorMap[label]);\n  });\n}\n\n// updates partially changed dashboard info\nexport function dashboardInfoChanged(newInfo: { metadata: any }) {\n  const { metadata } = newInfo;\n\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    metadata?.color_namespace,\n  );\n\n  categoricalNamespace.resetColors();\n\n  if (metadata?.shared_label_colors) {\n    updateColorSchema(metadata, metadata?.shared_label_colors);\n  }\n\n  if (metadata?.label_colors) {\n    updateColorSchema(metadata, metadata?.label_colors);\n  }\n\n  return { type: DASHBOARD_INFO_UPDATED, newInfo };\n}\nexport const SAVE_CHART_CONFIG_BEGIN = 'SAVE_CHART_CONFIG_BEGIN';\nexport const SAVE_CHART_CONFIG_COMPLETE = 'SAVE_CHART_CONFIG_COMPLETE';\nexport const SAVE_CHART_CONFIG_FAIL = 'SAVE_CHART_CONFIG_FAIL';\n\nexport const saveChartConfiguration =\n  ({\n    chartConfiguration,\n    globalChartConfiguration,\n  }: {\n    chartConfiguration?: ChartConfiguration;\n    globalChartConfiguration?: GlobalChartCrossFilterConfig;\n  }) =>\n  async (dispatch: Dispatch, getState: () => RootState) => {\n    dispatch({\n      type: SAVE_CHART_CONFIG_BEGIN,\n      chartConfiguration,\n      globalChartConfiguration,\n    });\n    const { id, metadata } = getState().dashboardInfo;\n\n    // TODO extract this out when makeApi supports url parameters\n    const updateDashboard = makeApi<\n      Partial<DashboardInfo>,\n      { result: DashboardInfo }\n    >({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}`,\n    });\n\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          chart_configuration:\n            chartConfiguration ?? metadata.chart_configuration,\n          global_chart_configuration:\n            globalChartConfiguration ?? metadata.global_chart_configuration,\n        }),\n      });\n      dispatch(\n        dashboardInfoChanged({\n          metadata: JSON.parse(response.result.json_metadata),\n        }),\n      );\n      dispatch({\n        type: SAVE_CHART_CONFIG_COMPLETE,\n        chartConfiguration,\n        globalChartConfiguration,\n      });\n    } catch (err) {\n      dispatch({\n        type: SAVE_CHART_CONFIG_FAIL,\n        chartConfiguration,\n        globalChartConfiguration,\n      });\n      dispatch(addDangerToast(t('Failed to save cross-filter scoping')));\n    }\n  };\n\nexport const SET_FILTER_BAR_ORIENTATION = 'SET_FILTER_BAR_ORIENTATION';\n\nexport function setFilterBarOrientation(\n  filterBarOrientation: FilterBarOrientation,\n) {\n  return { type: SET_FILTER_BAR_ORIENTATION, filterBarOrientation };\n}\n\nexport const SET_CROSS_FILTERS_ENABLED = 'SET_CROSS_FILTERS_ENABLED';\n\nexport function setCrossFiltersEnabled(crossFiltersEnabled: boolean) {\n  return { type: SET_CROSS_FILTERS_ENABLED, crossFiltersEnabled };\n}\n\nexport function saveFilterBarOrientation(orientation: FilterBarOrientation) {\n  return async (dispatch: Dispatch, getState: () => RootState) => {\n    const { id, metadata } = getState().dashboardInfo;\n    const updateDashboard = makeApi<\n      Partial<DashboardInfo>,\n      { result: Partial<DashboardInfo>; last_modified_time: number }\n    >({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}`,\n    });\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          filter_bar_orientation: orientation,\n        }),\n      });\n      const updatedDashboard = response.result;\n      const lastModifiedTime = response.last_modified_time;\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        if (metadata.filter_bar_orientation) {\n          dispatch(setFilterBarOrientation(metadata.filter_bar_orientation));\n        }\n      }\n      if (lastModifiedTime) {\n        dispatch(onSave(lastModifiedTime));\n      }\n    } catch (errorObject) {\n      const errorText = await getErrorText(errorObject, 'dashboard');\n      dispatch(addDangerToast(errorText));\n      throw errorObject;\n    }\n  };\n}\n\nexport function saveCrossFiltersSetting(crossFiltersEnabled: boolean) {\n  return async (dispatch: Dispatch, getState: () => RootState) => {\n    const { id, metadata } = getState().dashboardInfo;\n    const updateDashboard = makeApi<\n      Partial<DashboardInfo>,\n      { result: Partial<DashboardInfo>; last_modified_time: number }\n    >({\n      method: 'PUT',\n      endpoint: `/api/v1/dashboard/${id}`,\n    });\n    try {\n      const response = await updateDashboard({\n        json_metadata: JSON.stringify({\n          ...metadata,\n          cross_filters_enabled: crossFiltersEnabled,\n        }),\n      });\n      const updatedDashboard = response.result;\n      const lastModifiedTime = response.last_modified_time;\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(setCrossFiltersEnabled(metadata.cross_filters_enabled));\n      }\n      if (lastModifiedTime) {\n        dispatch(onSave(lastModifiedTime));\n      }\n    } catch (errorObject) {\n      const errorText = await getErrorText(errorObject, 'dashboard');\n      dispatch(addDangerToast(errorText));\n      throw errorObject;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}