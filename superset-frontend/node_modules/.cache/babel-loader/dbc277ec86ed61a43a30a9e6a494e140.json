{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexport var OverwritePolicy;\n(function (OverwritePolicy) {\n  OverwritePolicy[\"ALLOW\"] = \"ALLOW\";\n  OverwritePolicy[\"PROHIBIT\"] = \"PROHIBIT\";\n  OverwritePolicy[\"WARN\"] = \"WARN\";\n})(OverwritePolicy || (OverwritePolicy = {}));\n/**\n * Registry class\n *\n * !!!!!!!!\n * IF YOU ARE ADDING A NEW REGISTRY TO SUPERSET, CONSIDER USING TypedRegistry\n * !!!!!!!!\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type W Type of value returned from loader function when using registerLoader().\n * Set W=V when does not support asynchronous loader.\n * By default W is set to V | Promise<V> to support\n * both synchronous and asynchronous loaders.\n */\nexport default class Registry {\n\n\n\n\n\n  constructor(config) {if (config === void 0) {config = {};}this.name = void 0;this.overwritePolicy = void 0;this.items = void 0;this.promises = void 0;this.listeners = void 0;\n    const { name = '', overwritePolicy = OverwritePolicy.ALLOW } = config;\n    this.name = name;\n    this.overwritePolicy = overwritePolicy;\n    this.items = {};\n    this.promises = {};\n    this.listeners = new Set();\n  }\n  clear() {\n    const keys = this.keys();\n    this.items = {};\n    this.promises = {};\n    this.notifyListeners(keys);\n    return this;\n  }\n  has(key) {\n    const item = this.items[key];\n    return item !== null && item !== undefined;\n  }\n  registerValue(key, value) {\n    const item = this.items[key];\n    const willOverwrite = this.has(key) && (\n    'value' in item && item.value !== value || 'loader' in item);\n    if (willOverwrite) {\n      if (this.overwritePolicy === OverwritePolicy.WARN) {\n        // eslint-disable-next-line no-console\n        console.warn(`Item with key \"${key}\" already exists. You are assigning a new value.`);\n      } else\n      if (this.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(`Item with key \"${key}\" already exists. Cannot overwrite.`);\n      }\n    }\n    if (!item || willOverwrite) {\n      this.items[key] = { value };\n      delete this.promises[key];\n      this.notifyListeners([key]);\n    }\n    return this;\n  }\n  registerLoader(key, loader) {\n    const item = this.items[key];\n    const willOverwrite = this.has(key) && (\n    'loader' in item && item.loader !== loader || 'value' in item);\n    if (willOverwrite) {\n      if (this.overwritePolicy === OverwritePolicy.WARN) {\n        // eslint-disable-next-line no-console\n        console.warn(`Item with key \"${key}\" already exists. You are assigning a new value.`);\n      } else\n      if (this.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(`Item with key \"${key}\" already exists. Cannot overwrite.`);\n      }\n    }\n    if (!item || willOverwrite) {\n      this.items[key] = { loader };\n      delete this.promises[key];\n      this.notifyListeners([key]);\n    }\n    return this;\n  }\n  get(key) {\n    const item = this.items[key];\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader == null ? void 0 : item.loader();\n      }\n      return item.value;\n    }\n    return undefined;\n  }\n  getAsPromise(key) {\n    const promise = this.promises[key];\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n    const item = this.get(key);\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item);\n      this.promises[key] = newPromise;\n      return newPromise;\n    }\n    return Promise.reject(new Error(`Item with key \"${key}\" is not registered.`));\n  }\n  getMap() {\n    return this.keys().reduce((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n      return map;\n    }, {});\n  }\n  getMapAsPromise() {\n    const keys = this.keys();\n    return Promise.all(keys.map((key) => this.getAsPromise(key))).then((values) => values.reduce((prev, value, i) => {\n      const map = prev;\n      map[keys[i]] = value;\n      return map;\n    }, {}));\n  }\n  keys() {\n    return Object.keys(this.items);\n  }\n  values() {\n    return this.keys().map((key) => this.get(key));\n  }\n  valuesAsPromise() {\n    return Promise.all(this.keys().map((key) => this.getAsPromise(key)));\n  }\n  entries() {\n    return this.keys().map((key) => ({\n      key,\n      value: this.get(key) }));\n\n  }\n  entriesAsPromise() {\n    const keys = this.keys();\n    return this.valuesAsPromise().then((values) => values.map((value, i) => ({\n      key: keys[i],\n      value })));\n\n  }\n  remove(key) {\n    const isChange = this.has(key);\n    delete this.items[key];\n    delete this.promises[key];\n    if (isChange) {\n      this.notifyListeners([key]);\n    }\n    return this;\n  }\n  addListener(listener) {\n    this.listeners.add(listener);\n  }\n  removeListener(listener) {\n    this.listeners.delete(listener);\n  }\n  notifyListeners(keys) {\n    this.listeners.forEach((listener) => {\n      try {\n        listener(keys);\n      }\n      catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('Exception thrown from a registry listener:', e);\n      }\n    });\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(OverwritePolicy, \"OverwritePolicy\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/models/Registry.ts\");reactHotLoader.register(Registry, \"Registry\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/models/Registry.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["OverwritePolicy","Registry","constructor","config","name","overwritePolicy","items","promises","listeners","ALLOW","Set","clear","keys","notifyListeners","has","key","item","undefined","registerValue","value","willOverwrite","WARN","console","warn","PROHIBIT","Error","registerLoader","loader","get","getAsPromise","promise","newPromise","Promise","resolve","reject","getMap","reduce","prev","map","getMapAsPromise","all","then","values","i","Object","valuesAsPromise","entries","entriesAsPromise","remove","isChange","addListener","listener","add","removeListener","delete","forEach","e","error"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/models/Registry.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexport enum OverwritePolicy {\n  ALLOW = 'ALLOW',\n  PROHIBIT = 'PROHIBIT',\n  WARN = 'WARN',\n}\n\ninterface ItemWithValue<T> {\n  value: T;\n}\n\ninterface ItemWithLoader<T> {\n  loader: () => T;\n}\n\n/**\n * Type of value returned from loader function when using registerLoader()\n */\ntype InclusiveLoaderResult<V> = V | Promise<V>;\n\nexport type RegistryValue<V, W extends InclusiveLoaderResult<V>> =\n  | V\n  | W\n  | undefined;\n\nexport type RegistryEntry<V, W extends InclusiveLoaderResult<V>> = {\n  key: string;\n  value: RegistryValue<V, W>;\n};\n\n/**\n * A listener is called whenever a registry's entries change.\n * Keys indicates which entries been affected.\n */\nexport type Listener = (keys: string[]) => void;\n\nexport interface RegistryConfig {\n  name?: string;\n  overwritePolicy?: OverwritePolicy;\n}\n\n/**\n * Registry class\n *\n * !!!!!!!!\n * IF YOU ARE ADDING A NEW REGISTRY TO SUPERSET, CONSIDER USING TypedRegistry\n * !!!!!!!!\n *\n * Can use generic to specify type of item in the registry\n * @type V Type of value\n * @type W Type of value returned from loader function when using registerLoader().\n * Set W=V when does not support asynchronous loader.\n * By default W is set to V | Promise<V> to support\n * both synchronous and asynchronous loaders.\n */\nexport default class Registry<\n  V,\n  W extends InclusiveLoaderResult<V> = InclusiveLoaderResult<V>,\n> {\n  name: string;\n\n  overwritePolicy: OverwritePolicy;\n\n  items: {\n    [key: string]: ItemWithValue<V> | ItemWithLoader<W>;\n  };\n\n  promises: {\n    [key: string]: Promise<V>;\n  };\n\n  listeners: Set<Listener>;\n\n  constructor(config: RegistryConfig = {}) {\n    const { name = '', overwritePolicy = OverwritePolicy.ALLOW } = config;\n    this.name = name;\n    this.overwritePolicy = overwritePolicy;\n    this.items = {};\n    this.promises = {};\n    this.listeners = new Set();\n  }\n\n  clear() {\n    const keys = this.keys();\n\n    this.items = {};\n    this.promises = {};\n    this.notifyListeners(keys);\n\n    return this;\n  }\n\n  has(key: string) {\n    const item = this.items[key];\n\n    return item !== null && item !== undefined;\n  }\n\n  registerValue(key: string, value: V) {\n    const item = this.items[key];\n    const willOverwrite =\n      this.has(key) &&\n      (('value' in item && item.value !== value) || 'loader' in item);\n    if (willOverwrite) {\n      if (this.overwritePolicy === OverwritePolicy.WARN) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Item with key \"${key}\" already exists. You are assigning a new value.`,\n        );\n      } else if (this.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\n          `Item with key \"${key}\" already exists. Cannot overwrite.`,\n        );\n      }\n    }\n    if (!item || willOverwrite) {\n      this.items[key] = { value };\n      delete this.promises[key];\n      this.notifyListeners([key]);\n    }\n\n    return this;\n  }\n\n  registerLoader(key: string, loader: () => W) {\n    const item = this.items[key];\n    const willOverwrite =\n      this.has(key) &&\n      (('loader' in item && item.loader !== loader) || 'value' in item);\n    if (willOverwrite) {\n      if (this.overwritePolicy === OverwritePolicy.WARN) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Item with key \"${key}\" already exists. You are assigning a new value.`,\n        );\n      } else if (this.overwritePolicy === OverwritePolicy.PROHIBIT) {\n        throw new Error(\n          `Item with key \"${key}\" already exists. Cannot overwrite.`,\n        );\n      }\n    }\n    if (!item || willOverwrite) {\n      this.items[key] = { loader };\n      delete this.promises[key];\n      this.notifyListeners([key]);\n    }\n\n    return this;\n  }\n\n  get(key: string): V | W | undefined {\n    const item = this.items[key];\n    if (item !== undefined) {\n      if ('loader' in item) {\n        return item.loader?.();\n      }\n\n      return item.value;\n    }\n\n    return undefined;\n  }\n\n  getAsPromise(key: string): Promise<V> {\n    const promise = this.promises[key];\n\n    if (typeof promise !== 'undefined') {\n      return promise;\n    }\n    const item = this.get(key);\n    if (item !== undefined) {\n      const newPromise = Promise.resolve(item) as Promise<V>;\n      this.promises[key] = newPromise;\n\n      return newPromise;\n    }\n\n    return Promise.reject<V>(\n      new Error(`Item with key \"${key}\" is not registered.`),\n    );\n  }\n\n  getMap() {\n    return this.keys().reduce<{\n      [key: string]: RegistryValue<V, W>;\n    }>((prev, key) => {\n      const map = prev;\n      map[key] = this.get(key);\n\n      return map;\n    }, {});\n  }\n\n  getMapAsPromise() {\n    const keys = this.keys();\n\n    return Promise.all(keys.map(key => this.getAsPromise(key))).then(values =>\n      values.reduce<{\n        [key: string]: V;\n      }>((prev, value, i) => {\n        const map = prev;\n        map[keys[i]] = value;\n\n        return map;\n      }, {}),\n    );\n  }\n\n  keys(): string[] {\n    return Object.keys(this.items);\n  }\n\n  values(): RegistryValue<V, W>[] {\n    return this.keys().map(key => this.get(key));\n  }\n\n  valuesAsPromise(): Promise<V[]> {\n    return Promise.all(this.keys().map(key => this.getAsPromise(key)));\n  }\n\n  entries(): RegistryEntry<V, W>[] {\n    return this.keys().map(key => ({\n      key,\n      value: this.get(key),\n    }));\n  }\n\n  entriesAsPromise(): Promise<{ key: string; value: V }[]> {\n    const keys = this.keys();\n\n    return this.valuesAsPromise().then(values =>\n      values.map((value, i) => ({\n        key: keys[i],\n        value,\n      })),\n    );\n  }\n\n  remove(key: string) {\n    const isChange = this.has(key);\n    delete this.items[key];\n    delete this.promises[key];\n    if (isChange) {\n      this.notifyListeners([key]);\n    }\n\n    return this;\n  }\n\n  addListener(listener: Listener) {\n    this.listeners.add(listener);\n  }\n\n  removeListener(listener: Listener) {\n    this.listeners.delete(listener);\n  }\n\n  private notifyListeners(keys: string[]) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(keys);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('Exception thrown from a registry listener:', e);\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}