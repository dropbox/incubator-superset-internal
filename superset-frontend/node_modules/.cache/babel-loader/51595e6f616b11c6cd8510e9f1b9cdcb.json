{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { CurrencyFormatter, extractTimegrain, GenericDataType, getMetricLabel, getNumberFormatter, getTimeFormatter, getTimeFormatterForGranularity, NumberFormats, QueryMode, smartDateFormatter, TimeFormats } from '@superset-ui/core';\nimport { getColorFormatters } from '@superset-ui/chart-controls';\nimport isEqualColumns from './utils/isEqualColumns';\nimport DateWithFormatter from './utils/DateWithFormatter';\nconst { PERCENT_3_POINT } = NumberFormats;\nconst { DATABASE_DATETIME } = TimeFormats;\nfunction isNumeric(key, data) {if (data === void 0) {data = [];}\n  return data.every((x) => x[key] === null || x[key] === undefined || typeof x[key] === 'number');\n}\nconst processDataRecords = memoizeOne(function processDataRecords(data, columns) {\n  if (!data || !data[0]) {\n    return data || [];\n  }\n  const timeColumns = columns.filter((column) => column.dataType === GenericDataType.TEMPORAL);\n  if (timeColumns.length > 0) {\n    return data.map((x) => {\n      const datum = { ...x };\n      timeColumns.forEach((_ref) => {let { key, formatter } = _ref;\n        // Convert datetime with a custom date class so we can use `String(...)`\n        // formatted value for global search, and `date.getTime()` for sorting.\n        datum[key] = new DateWithFormatter(x[key], {\n          formatter: formatter });\n\n      });\n      return datum;\n    });\n  }\n  return data;\n});\nconst processColumns = memoizeOne(function processColumns(props) {\n  const { datasource: { columnFormats, currencyFormats, verboseMap }, rawFormData: { table_timestamp_format: tableTimestampFormat, metrics: metrics_, percent_metrics: percentMetrics_, column_config: columnConfig = {} }, queriesData } = props;\n  const granularity = extractTimegrain(props.rawFormData);\n  const { data: records, colnames, coltypes } = queriesData[0] || {};\n  // convert `metrics` and `percentMetrics` to the key names in `data.records`\n  const metrics = (metrics_ != null ? metrics_ : []).map(getMetricLabel);\n  const rawPercentMetrics = (percentMetrics_ != null ? percentMetrics_ : []).map(getMetricLabel);\n  // column names for percent metrics always starts with a '%' sign.\n  const percentMetrics = rawPercentMetrics.map((x) => `%${x}`);\n  const metricsSet = new Set(metrics);\n  const percentMetricsSet = new Set(percentMetrics);\n  const rawPercentMetricsSet = new Set(rawPercentMetrics);\n  const columns = (colnames || []).\n  filter((key) =>\n  // if a metric was only added to percent_metrics, they should not show up in the table.\n  !(rawPercentMetricsSet.has(key) && !metricsSet.has(key))).\n  map((key, i) => {\n    const dataType = coltypes[i];\n    const config = columnConfig[key] || {};\n    // for the purpose of presentation, only numeric values are treated as metrics\n    // because users can also add things like `MAX(str_col)` as a metric.\n    const isMetric = metricsSet.has(key) && isNumeric(key, records);\n    const isPercentMetric = percentMetricsSet.has(key);\n    const label = isPercentMetric ?\n    `%${(verboseMap == null ? void 0 : verboseMap[key.replace('%', '')]) || key}` :\n    (verboseMap == null ? void 0 : verboseMap[key]) || key;\n    const isTime = dataType === GenericDataType.TEMPORAL;\n    const isNumber = dataType === GenericDataType.NUMERIC;\n    const savedFormat = columnFormats == null ? void 0 : columnFormats[key];\n    const currency = currencyFormats == null ? void 0 : currencyFormats[key];\n    const numberFormat = config.d3NumberFormat || savedFormat;\n    let formatter;\n    if (isTime || config.d3TimeFormat) {\n      // string types may also apply d3-time format\n      // pick adhoc format first, fallback to column level formats defined in\n      // datasource\n      const customFormat = config.d3TimeFormat || savedFormat;\n      const timeFormat = customFormat || tableTimestampFormat;\n      // When format is \"Adaptive Formatting\" (smart_date)\n      if (timeFormat === smartDateFormatter.id) {\n        if (granularity) {\n          // time column use formats based on granularity\n          formatter = getTimeFormatterForGranularity(granularity);\n        } else\n        if (customFormat) {\n          // other columns respect the column-specific format\n          formatter = getTimeFormatter(customFormat);\n        } else\n        if (isNumeric(key, records)) {\n          // if column is numeric values, it is considered a timestamp64\n          formatter = getTimeFormatter(DATABASE_DATETIME);\n        } else\n        {\n          // if no column-specific format, print cell as is\n          formatter = String;\n        }\n      } else\n      if (timeFormat) {\n        formatter = getTimeFormatter(timeFormat);\n      }\n    } else\n    if (isPercentMetric) {\n      // percent metrics have a default format\n      formatter = getNumberFormatter(numberFormat || PERCENT_3_POINT);\n    } else\n    if (isMetric || isNumber && numberFormat) {\n      formatter = currency ?\n      new CurrencyFormatter({ d3Format: numberFormat, currency }) :\n      getNumberFormatter(numberFormat);\n    }\n    return {\n      key,\n      label,\n      dataType,\n      isNumeric: dataType === GenericDataType.NUMERIC,\n      isMetric,\n      isPercentMetric,\n      formatter,\n      config };\n\n  });\n  return [metrics, percentMetrics, columns];\n}, isEqualColumns);\n/**\n * Automatically set page size based on number of cells.\n */\nconst getPageSize = (pageSize, numRecords, numColumns) => {\n  if (typeof pageSize === 'number') {\n    // NaN is also has typeof === 'number'\n    return pageSize || 0;\n  }\n  if (typeof pageSize === 'string') {\n    return Number(pageSize) || 0;\n  }\n  // when pageSize not set, automatically add pagination if too many records\n  return numRecords * numColumns > 5000 ? 200 : 0;\n};\nconst defaultServerPaginationData = {};\nconst defaultColorFormatters = [];\nconst transformProps = (chartProps) => {var _baseQuery2, _totalQuery, _getColorFormatters;\n  const { height, width, rawFormData: formData, queriesData = [], filterState, ownState: serverPaginationData, hooks: { onAddFilter: onChangeFilter, setDataMask = () => {}, onContextMenu }, emitCrossFilters } = chartProps;\n  const { align_pn: alignPositiveNegative = true, color_pn: colorPositiveNegative = true, show_cell_bars: showCellBars = true, include_search: includeSearch = false, page_length: pageLength, server_pagination: serverPagination = false, server_page_length: serverPageLength = 10, order_desc: sortDesc = false, query_mode: queryMode, show_totals: showTotals, conditional_formatting: conditionalFormatting, allow_rearrange_columns: allowRearrangeColumns } = formData;\n  const timeGrain = extractTimegrain(formData);\n  const [metrics, percentMetrics, columns] = processColumns(chartProps);\n  let baseQuery;\n  let countQuery;\n  let totalQuery;\n  let rowCount;\n  if (serverPagination) {var _countQuery$data$0$ro, _countQuery, _countQuery$data, _countQuery$data$;\n    [baseQuery, countQuery, totalQuery] = queriesData;\n    rowCount = (_countQuery$data$0$ro = (_countQuery = countQuery) == null ? void 0 : (_countQuery$data = _countQuery.data) == null ? void 0 : (_countQuery$data$ = _countQuery$data[0]) == null ? void 0 : _countQuery$data$.rowcount) != null ? _countQuery$data$0$ro : 0;\n  } else\n  {var _baseQuery$rowcount, _baseQuery;\n    [baseQuery, totalQuery] = queriesData;\n    rowCount = (_baseQuery$rowcount = (_baseQuery = baseQuery) == null ? void 0 : _baseQuery.rowcount) != null ? _baseQuery$rowcount : 0;\n  }\n  const data = processDataRecords((_baseQuery2 = baseQuery) == null ? void 0 : _baseQuery2.data, columns);\n  const totals = showTotals && queryMode === QueryMode.aggregate ? (_totalQuery =\n  totalQuery) == null ? void 0 : _totalQuery.data[0] :\n  undefined;\n  const columnColorFormatters = (_getColorFormatters = getColorFormatters(conditionalFormatting, data)) != null ? _getColorFormatters : defaultColorFormatters;\n  return {\n    height,\n    width,\n    isRawRecords: queryMode === QueryMode.raw,\n    data,\n    totals,\n    columns,\n    serverPagination,\n    metrics,\n    percentMetrics,\n    serverPaginationData: serverPagination ?\n    serverPaginationData :\n    defaultServerPaginationData,\n    setDataMask,\n    alignPositiveNegative,\n    colorPositiveNegative,\n    showCellBars,\n    sortDesc,\n    includeSearch,\n    rowCount,\n    pageSize: serverPagination ?\n    serverPageLength :\n    getPageSize(pageLength, data.length, columns.length),\n    filters: filterState.filters,\n    emitCrossFilters,\n    onChangeFilter,\n    columnColorFormatters,\n    timeGrain,\n    allowRearrangeColumns,\n    onContextMenu };\n\n};\nexport default transformProps;","map":{"version":3,"mappings":"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","names":["memoizeOne","CurrencyFormatter","extractTimegrain","GenericDataType","getMetricLabel","getNumberFormatter","getTimeFormatter","getTimeFormatterForGranularity","NumberFormats","QueryMode","smartDateFormatter","TimeFormats","getColorFormatters","isEqualColumns","DateWithFormatter","PERCENT_3_POINT","DATABASE_DATETIME","isNumeric","key","data","every","x","undefined","processDataRecords","columns","timeColumns","filter","column","dataType","TEMPORAL","length","map","datum","forEach","formatter","processColumns","props","datasource","columnFormats","currencyFormats","verboseMap","rawFormData","table_timestamp_format","tableTimestampFormat","metrics","metrics_","percent_metrics","percentMetrics_","column_config","columnConfig","queriesData","granularity","records","colnames","coltypes","rawPercentMetrics","percentMetrics","metricsSet","Set","percentMetricsSet","rawPercentMetricsSet","has","i","config","isMetric","isPercentMetric","label","replace","isTime","isNumber","NUMERIC","savedFormat","currency","numberFormat","d3NumberFormat","d3TimeFormat","customFormat","timeFormat","id","String","d3Format","getPageSize","pageSize","numRecords","numColumns","Number","defaultServerPaginationData","defaultColorFormatters","transformProps","chartProps","height","width","formData","filterState","ownState","serverPaginationData","hooks","onAddFilter","onChangeFilter","setDataMask","onContextMenu","emitCrossFilters","align_pn","alignPositiveNegative","color_pn","colorPositiveNegative","show_cell_bars","showCellBars","include_search","includeSearch","page_length","pageLength","server_pagination","serverPagination","server_page_length","serverPageLength","order_desc","sortDesc","query_mode","queryMode","show_totals","showTotals","conditional_formatting","conditionalFormatting","allow_rearrange_columns","allowRearrangeColumns","timeGrain","baseQuery","countQuery","totalQuery","rowCount","rowcount","totals","aggregate","columnColorFormatters","isRawRecords","raw","filters"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-table/src/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport {\n  CurrencyFormatter,\n  DataRecord,\n  extractTimegrain,\n  GenericDataType,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n  getTimeFormatterForGranularity,\n  NumberFormats,\n  QueryMode,\n  smartDateFormatter,\n  TimeFormats,\n  TimeFormatter,\n} from '@superset-ui/core';\nimport {\n  ColorFormatters,\n  getColorFormatters,\n} from '@superset-ui/chart-controls';\n\nimport isEqualColumns from './utils/isEqualColumns';\nimport DateWithFormatter from './utils/DateWithFormatter';\nimport {\n  DataColumnMeta,\n  TableChartProps,\n  TableChartTransformedProps,\n} from './types';\n\nconst { PERCENT_3_POINT } = NumberFormats;\nconst { DATABASE_DATETIME } = TimeFormats;\n\nfunction isNumeric(key: string, data: DataRecord[] = []) {\n  return data.every(\n    x => x[key] === null || x[key] === undefined || typeof x[key] === 'number',\n  );\n}\n\nconst processDataRecords = memoizeOne(function processDataRecords(\n  data: DataRecord[] | undefined,\n  columns: DataColumnMeta[],\n) {\n  if (!data || !data[0]) {\n    return data || [];\n  }\n  const timeColumns = columns.filter(\n    column => column.dataType === GenericDataType.TEMPORAL,\n  );\n\n  if (timeColumns.length > 0) {\n    return data.map(x => {\n      const datum = { ...x };\n      timeColumns.forEach(({ key, formatter }) => {\n        // Convert datetime with a custom date class so we can use `String(...)`\n        // formatted value for global search, and `date.getTime()` for sorting.\n        datum[key] = new DateWithFormatter(x[key], {\n          formatter: formatter as TimeFormatter,\n        });\n      });\n      return datum;\n    });\n  }\n  return data;\n});\n\nconst processColumns = memoizeOne(function processColumns(\n  props: TableChartProps,\n) {\n  const {\n    datasource: { columnFormats, currencyFormats, verboseMap },\n    rawFormData: {\n      table_timestamp_format: tableTimestampFormat,\n      metrics: metrics_,\n      percent_metrics: percentMetrics_,\n      column_config: columnConfig = {},\n    },\n    queriesData,\n  } = props;\n  const granularity = extractTimegrain(props.rawFormData);\n  const { data: records, colnames, coltypes } = queriesData[0] || {};\n  // convert `metrics` and `percentMetrics` to the key names in `data.records`\n  const metrics = (metrics_ ?? []).map(getMetricLabel);\n  const rawPercentMetrics = (percentMetrics_ ?? []).map(getMetricLabel);\n  // column names for percent metrics always starts with a '%' sign.\n  const percentMetrics = rawPercentMetrics.map((x: string) => `%${x}`);\n  const metricsSet = new Set(metrics);\n  const percentMetricsSet = new Set(percentMetrics);\n  const rawPercentMetricsSet = new Set(rawPercentMetrics);\n\n  const columns: DataColumnMeta[] = (colnames || [])\n    .filter(\n      key =>\n        // if a metric was only added to percent_metrics, they should not show up in the table.\n        !(rawPercentMetricsSet.has(key) && !metricsSet.has(key)),\n    )\n    .map((key: string, i) => {\n      const dataType = coltypes[i];\n      const config = columnConfig[key] || {};\n      // for the purpose of presentation, only numeric values are treated as metrics\n      // because users can also add things like `MAX(str_col)` as a metric.\n      const isMetric = metricsSet.has(key) && isNumeric(key, records);\n      const isPercentMetric = percentMetricsSet.has(key);\n      const label = isPercentMetric\n        ? `%${verboseMap?.[key.replace('%', '')] || key}`\n        : verboseMap?.[key] || key;\n      const isTime = dataType === GenericDataType.TEMPORAL;\n      const isNumber = dataType === GenericDataType.NUMERIC;\n      const savedFormat = columnFormats?.[key];\n      const currency = currencyFormats?.[key];\n      const numberFormat = config.d3NumberFormat || savedFormat;\n\n      let formatter;\n\n      if (isTime || config.d3TimeFormat) {\n        // string types may also apply d3-time format\n        // pick adhoc format first, fallback to column level formats defined in\n        // datasource\n        const customFormat = config.d3TimeFormat || savedFormat;\n        const timeFormat = customFormat || tableTimestampFormat;\n        // When format is \"Adaptive Formatting\" (smart_date)\n        if (timeFormat === smartDateFormatter.id) {\n          if (granularity) {\n            // time column use formats based on granularity\n            formatter = getTimeFormatterForGranularity(granularity);\n          } else if (customFormat) {\n            // other columns respect the column-specific format\n            formatter = getTimeFormatter(customFormat);\n          } else if (isNumeric(key, records)) {\n            // if column is numeric values, it is considered a timestamp64\n            formatter = getTimeFormatter(DATABASE_DATETIME);\n          } else {\n            // if no column-specific format, print cell as is\n            formatter = String;\n          }\n        } else if (timeFormat) {\n          formatter = getTimeFormatter(timeFormat);\n        }\n      } else if (isPercentMetric) {\n        // percent metrics have a default format\n        formatter = getNumberFormatter(numberFormat || PERCENT_3_POINT);\n      } else if (isMetric || (isNumber && numberFormat)) {\n        formatter = currency\n          ? new CurrencyFormatter({ d3Format: numberFormat, currency })\n          : getNumberFormatter(numberFormat);\n      }\n      return {\n        key,\n        label,\n        dataType,\n        isNumeric: dataType === GenericDataType.NUMERIC,\n        isMetric,\n        isPercentMetric,\n        formatter,\n        config,\n      };\n    });\n  return [metrics, percentMetrics, columns] as [\n    typeof metrics,\n    typeof percentMetrics,\n    typeof columns,\n  ];\n},\nisEqualColumns);\n\n/**\n * Automatically set page size based on number of cells.\n */\nconst getPageSize = (\n  pageSize: number | string | null | undefined,\n  numRecords: number,\n  numColumns: number,\n) => {\n  if (typeof pageSize === 'number') {\n    // NaN is also has typeof === 'number'\n    return pageSize || 0;\n  }\n  if (typeof pageSize === 'string') {\n    return Number(pageSize) || 0;\n  }\n  // when pageSize not set, automatically add pagination if too many records\n  return numRecords * numColumns > 5000 ? 200 : 0;\n};\n\nconst defaultServerPaginationData = {};\nconst defaultColorFormatters = [] as ColorFormatters;\nconst transformProps = (\n  chartProps: TableChartProps,\n): TableChartTransformedProps => {\n  const {\n    height,\n    width,\n    rawFormData: formData,\n    queriesData = [],\n    filterState,\n    ownState: serverPaginationData,\n    hooks: {\n      onAddFilter: onChangeFilter,\n      setDataMask = () => {},\n      onContextMenu,\n    },\n    emitCrossFilters,\n  } = chartProps;\n\n  const {\n    align_pn: alignPositiveNegative = true,\n    color_pn: colorPositiveNegative = true,\n    show_cell_bars: showCellBars = true,\n    include_search: includeSearch = false,\n    page_length: pageLength,\n    server_pagination: serverPagination = false,\n    server_page_length: serverPageLength = 10,\n    order_desc: sortDesc = false,\n    query_mode: queryMode,\n    show_totals: showTotals,\n    conditional_formatting: conditionalFormatting,\n    allow_rearrange_columns: allowRearrangeColumns,\n  } = formData;\n  const timeGrain = extractTimegrain(formData);\n\n  const [metrics, percentMetrics, columns] = processColumns(chartProps);\n\n  let baseQuery;\n  let countQuery;\n  let totalQuery;\n  let rowCount;\n  if (serverPagination) {\n    [baseQuery, countQuery, totalQuery] = queriesData;\n    rowCount = (countQuery?.data?.[0]?.rowcount as number) ?? 0;\n  } else {\n    [baseQuery, totalQuery] = queriesData;\n    rowCount = baseQuery?.rowcount ?? 0;\n  }\n  const data = processDataRecords(baseQuery?.data, columns);\n  const totals =\n    showTotals && queryMode === QueryMode.aggregate\n      ? totalQuery?.data[0]\n      : undefined;\n  const columnColorFormatters =\n    getColorFormatters(conditionalFormatting, data) ?? defaultColorFormatters;\n\n  return {\n    height,\n    width,\n    isRawRecords: queryMode === QueryMode.raw,\n    data,\n    totals,\n    columns,\n    serverPagination,\n    metrics,\n    percentMetrics,\n    serverPaginationData: serverPagination\n      ? serverPaginationData\n      : defaultServerPaginationData,\n    setDataMask,\n    alignPositiveNegative,\n    colorPositiveNegative,\n    showCellBars,\n    sortDesc,\n    includeSearch,\n    rowCount,\n    pageSize: serverPagination\n      ? serverPageLength\n      : getPageSize(pageLength, data.length, columns.length),\n    filters: filterState.filters,\n    emitCrossFilters,\n    onChangeFilter,\n    columnColorFormatters,\n    timeGrain,\n    allowRearrangeColumns,\n    onContextMenu,\n  };\n};\n\nexport default transformProps;\n"]},"metadata":{},"sourceType":"module"}