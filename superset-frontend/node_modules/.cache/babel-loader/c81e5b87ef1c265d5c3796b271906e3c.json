{"ast":null,"code":"import _invert from \"lodash/invert\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CategoricalColorNamespace, ensureIsArray, GenericDataType, getMetricLabel, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, t, buildCustomFormatters, getCustomFormatter } from '@superset-ui/core';\nimport { extractExtraMetrics, getOriginalSeries, isDerivedSeries } from '@superset-ui/chart-controls';\nimport { OrientationType } from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport { calculateLowerLogTick, dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, getAxisType, getColtypesMapping, getLegendProps } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastSeriesContexts, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getBaselineSeriesForStream, getPadding, getTooltipTimeFormatter, getXAxisFormatter, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from './transformers';\nimport { StackControlsValue, TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getYAxisFormatter } from '../utils/getYAxisFormatter';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, filterState, legendState, formData, hooks, queriesData, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, columnFormats = {}, currencyFormats = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } = queryData;\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n  const { area, annotationLayers, colorScheme, contributionMode, forecastEnabled, groupby, legendOrientation, legendType, legendMargin, logAxis, markerEnabled, markerSize, metrics, minorSplitLine, onlyTotal, opacity, orientation, percentageThreshold, richTooltip, seriesType, showLegend, showValue, sliceId, sortSeriesType, sortSeriesAscending, timeGrainSqla, timeCompare, stack, tooltipTimeFormat, tooltipSortByMetric, truncateYAxis, xAxis: xAxisOrig, xAxisLabelRotation, xAxisSortSeries, xAxisSortSeriesAscending, xAxisTimeFormat, xAxisTitle, xAxisTitleMargin, yAxisBounds, yAxisFormat, yAxisTitle, yAxisTitleMargin, yAxisTitlePosition, zoomable } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (entry[1].length > groupby.length &&\n    Array.isArray(timeCompare) &&\n    _includesInstanceProperty(timeCompare).call(timeCompare, entry[1][0])) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedData, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n    legendState });\n\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(getMetricLabel);\n  const isMultiSeries = groupby.length || metrics.length > 1;\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n    xAxisSortSeriesAscending: isMultiSeries ?\n    xAxisSortSeriesAscending :\n    undefined });\n\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState });\n\n  const seriesContexts = extractForecastSeriesContexts(Object.values(rawSeries).map((series) => series.name));\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series = [];\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = getNumberFormatter(',.0%');\n  const defaultFormatter = getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(metrics, currencyFormats, columnFormats, yAxisFormat);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeries.forEach((entry) => {var _getCustomFormatter, _labelMap$seriesName;\n    const lineStyle = isDerivedSeries(entry, chartProps.rawFormData) ?\n    { type: 'dashed' } :\n    {};\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      filterState,\n      seriesContexts,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      legendState,\n      stack,\n      formatter: forcePercentFormatter ?\n      percentFormatter : (_getCustomFormatter =\n      getCustomFormatter(customFormatters, metrics, (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0])) != null ? _getCustomFormatter : defaultFormatter,\n      showValue,\n      onlyTotal,\n      totalStackedValues: sortedTotalValues,\n      showValueIndexes,\n      thresholdValues,\n      richTooltip,\n      sliceId,\n      isHorizontal,\n      lineStyle });\n\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: transformedSeries.data.map((row) => {var _row$;return [row[0], (_row$ = row[1]) != null ? _row$ : 0];}) });\n\n      } else\n      {\n        series.push(transformedSeries);\n      }\n    }\n  });\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(series.map((entry) => entry.data), seriesType);\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = series.findIndex((_ref) => {let { name } = _ref;return name === selectedValue;});\n    return {\n      ...acc,\n      [index]: selectedValue };\n\n  }, {});\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (min === undefined)\n    min = 0;\n    if (max === undefined)\n    max = 1;\n  } else\n  if (logAxis && min === undefined && minPositiveValue !== undefined) {\n    min = calculateLowerLogTick(minPositiveValue);\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const { setDataMask = () => {}, setControlValue = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(showLegend, legendOrientation, addYAxisLabelOffset, zoomable, legendMargin, addXAxisLabelOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const legendData = rawSeries.\n  filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n  ForecastSeriesEnum.Observation).\n  map((entry) => entry.name || '').\n  concat(extractAnnotationLabels(annotationLayers, annotationData));\n  let xAxis = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation },\n\n    minInterval: xAxisType === 'time' && timeGrainSqla ?\n    TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n    0 };\n\n  let yAxis = {\n    ...defaultYAxis,\n    type: logAxis ? 'log' : 'value',\n    min,\n    max,\n    minorTick: { show: true },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(metrics, forcePercentFormatter, customFormatters, yAxisFormat) },\n\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end' };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding },\n\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue = richTooltip ?\n        params[0].value[xIndex] :\n        params.value[xIndex];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n        const rows = [];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n        Object.keys(forecastValues).forEach((key) => {var _labelMap$key, _getCustomFormatter2;\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          const formatterKey = groupby.length === 0 ? inverted[key] : (_labelMap$key = labelMap[key]) == null ? void 0 : _labelMap$key[0];\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: forcePercentFormatter ?\n            percentFormatter : (_getCustomFormatter2 =\n            getCustomFormatter(customFormatters, metrics, formatterKey)) != null ? _getCustomFormatter2 :\n            defaultFormatter });\n\n          const contentStyle = key === focusedSeries ? 'font-weight: 700' : 'opacity: 0.7';\n          rows.push(`<span style=\"${contentStyle}\">${content}</span>`);\n        });\n        if (stack) {\n          rows.reverse();\n        }\n        rows.unshift(`${tooltipFormatter(xValue)}`);\n        return rows.join('<br />');\n      } },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable, legendState),\n      data: legendData },\n\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom') } } } },\n\n\n\n\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom }] :\n\n\n    [] };\n\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType },\n\n    refs,\n    coltypeMapping: dataTypes };\n\n}","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","ensureIsArray","GenericDataType","getMetricLabel","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","t","buildCustomFormatters","getCustomFormatter","extractExtraMetrics","getOriginalSeries","isDerivedSeries","OrientationType","DEFAULT_FORM_DATA","ForecastSeriesEnum","parseYAxisBound","calculateLowerLogTick","dedupSeries","extractDataTotalValues","extractSeries","extractShowValueIndexes","getAxisType","getColtypesMapping","getLegendProps","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastSeriesContexts","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getBaselineSeriesForStream","getPadding","getTooltipTimeFormatter","getXAxisFormatter","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","StackControlsValue","TIMESERIES_CONSTANTS","TIMEGRAIN_TO_TIMESTAMP","getDefaultTooltip","getYAxisFormatter","transformProps","chartProps","width","height","filterState","legendState","formData","hooks","queriesData","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","columnFormats","currencyFormats","queryData","data","label_map","dataTypes","annotationData","area","annotationLayers","colorScheme","contributionMode","forecastEnabled","groupby","legendOrientation","legendType","legendMargin","logAxis","markerEnabled","markerSize","metrics","minorSplitLine","onlyTotal","opacity","orientation","percentageThreshold","richTooltip","seriesType","showLegend","showValue","sliceId","sortSeriesType","sortSeriesAscending","timeGrainSqla","timeCompare","stack","tooltipTimeFormat","tooltipSortByMetric","truncateYAxis","xAxis","xAxisOrig","xAxisLabelRotation","xAxisSortSeries","xAxisSortSeriesAscending","xAxisTimeFormat","xAxisTitle","xAxisTitleMargin","yAxisBounds","yAxisFormat","yAxisTitle","yAxisTitleMargin","yAxisTitlePosition","zoomable","refs","labelMap","Object","entries","reduce","acc","entry","length","Array","isArray","shift","colorScale","getScale","rebasedData","xAxisLabel","rawFormData","x_axis","isHorizontal","horizontal","totalStackedValues","thresholdValues","xAxisCol","extraMetricLabels","map","isMultiSeries","rawSeries","sortedTotalValues","minPositiveValue","fillNeighborValue","undefined","showValueIndexes","seriesContexts","values","series","name","isAreaExpand","Expand","xAxisDataType","xAxisType","forcePercentFormatter","Boolean","percentFormatter","defaultFormatter","customFormatters","array","time_compare","inverted","forEach","lineStyle","type","entryName","String","seriesName","colorScaleKey","transformedSeries","areaOpacity","formatter","Stream","push","row","baselineSeries","unshift","selectedValues","selectedValue","index","findIndex","filter","layer","show","min","max","tooltipFormatter","TEMPORAL","xAxisFormatter","setDataMask","setControlValue","onContextMenu","onLegendStateChanged","addYAxisLabelOffset","addXAxisLabelOffset","padding","legendData","Observation","concat","nameGap","nameLocation","axisLabel","hideOverlap","rotate","minInterval","yAxis","minorTick","scale","bottom","left","inverse","echartOptions","useUTC","grid","tooltip","trigger","params","xIndex","yIndex","xValue","value","forecastValue","sort","a","b","rows","forecastValues","keys","key","observation","formatterKey","content","contentStyle","reverse","join","legend","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","yAxisIndex","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","zoomBottom","onFocusedSeries","xValueFormatter","label","coltypeMapping"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  CategoricalColorNamespace,\n  ensureIsArray,\n  GenericDataType,\n  getMetricLabel,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  t,\n  TimeseriesChartDataResponseResult,\n  buildCustomFormatters,\n  getCustomFormatter,\n} from '@superset-ui/core';\nimport {\n  extractExtraMetrics,\n  getOriginalSeries,\n  isDerivedSeries,\n} from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport { ZRLineType } from 'echarts/types/src/util/types';\nimport {\n  EchartsTimeseriesChartProps,\n  EchartsTimeseriesFormData,\n  TimeseriesChartTransformedProps,\n  OrientationType,\n} from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum, ForecastValue, Refs } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport {\n  calculateLowerLogTick,\n  dedupSeries,\n  extractDataTotalValues,\n  extractSeries,\n  extractShowValueIndexes,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastSeriesContexts,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getBaselineSeriesForStream,\n  getPadding,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from './transformers';\nimport {\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n  TIMEGRAIN_TO_TIMESTAMP,\n} from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getYAxisFormatter } from '../utils/getYAxisFormatter';\n\nexport default function transformProps(\n  chartProps: EchartsTimeseriesChartProps,\n): TimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    filterState,\n    legendState,\n    formData,\n    hooks,\n    queriesData,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    columnFormats = {},\n    currencyFormats = {},\n  } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } =\n    queryData as TimeseriesChartDataResponseResult;\n\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n\n  const {\n    area,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    forecastEnabled,\n    groupby,\n    legendOrientation,\n    legendType,\n    legendMargin,\n    logAxis,\n    markerEnabled,\n    markerSize,\n    metrics,\n    minorSplitLine,\n    onlyTotal,\n    opacity,\n    orientation,\n    percentageThreshold,\n    richTooltip,\n    seriesType,\n    showLegend,\n    showValue,\n    sliceId,\n    sortSeriesType,\n    sortSeriesAscending,\n    timeGrainSqla,\n    timeCompare,\n    stack,\n    tooltipTimeFormat,\n    tooltipSortByMetric,\n    truncateYAxis,\n    xAxis: xAxisOrig,\n    xAxisLabelRotation,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n    xAxisTimeFormat,\n    xAxisTitle,\n    xAxisTitleMargin,\n    yAxisBounds,\n    yAxisFormat,\n    yAxisTitle,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    zoomable,\n  }: EchartsTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs: Refs = {};\n\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (\n      entry[1].length > groupby.length &&\n      Array.isArray(timeCompare) &&\n      timeCompare.includes(entry[1][0])\n    ) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedData,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n      legendState,\n    },\n  );\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(\n    getMetricLabel,\n  );\n\n  const isMultiSeries = groupby.length || metrics.length > 1;\n\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(\n    rebasedData,\n    {\n      fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n      xAxis: xAxisLabel,\n      extraMetricLabels,\n      stack,\n      totalStackedValues,\n      isHorizontal,\n      sortSeriesType,\n      sortSeriesAscending,\n      xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n      xAxisSortSeriesAscending: isMultiSeries\n        ? xAxisSortSeriesAscending\n        : undefined,\n    },\n  );\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState,\n  });\n  const seriesContexts = extractForecastSeriesContexts(\n    Object.values(rawSeries).map(series => series.name as string),\n  );\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n\n  const xAxisType = getAxisType(xAxisDataType);\n  const series: SeriesOption[] = [];\n\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = getNumberFormatter(',.0%');\n  const defaultFormatter = getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(\n    metrics,\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeries.forEach(entry => {\n    const lineStyle = isDerivedSeries(entry, chartProps.rawFormData)\n      ? { type: 'dashed' as ZRLineType }\n      : {};\n\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        filterState,\n        seriesContexts,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        legendState,\n        stack,\n        formatter: forcePercentFormatter\n          ? percentFormatter\n          : getCustomFormatter(\n              customFormatters,\n              metrics,\n              labelMap[seriesName]?.[0],\n            ) ?? defaultFormatter,\n        showValue,\n        onlyTotal,\n        totalStackedValues: sortedTotalValues,\n        showValueIndexes,\n        thresholdValues,\n        richTooltip,\n        sliceId,\n        isHorizontal,\n        lineStyle,\n      },\n    );\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: (transformedSeries.data as any).map(\n            (row: [string | number, number]) => [row[0], row[1] ?? 0],\n          ),\n        });\n      } else {\n        series.push(transformedSeries);\n      }\n    }\n  });\n\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(\n      series.map(entry => entry.data) as [string | number, number][][],\n      seriesType,\n    );\n\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = series.findIndex(({ name }) => name === selectedValue);\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (min === undefined) min = 0;\n    if (max === undefined) max = 1;\n  } else if (logAxis && min === undefined && minPositiveValue !== undefined) {\n    min = calculateLowerLogTick(minPositiveValue);\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const {\n    setDataMask = () => {},\n    setControlValue = () => {},\n    onContextMenu,\n    onLegendStateChanged,\n  } = hooks;\n\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisLabelOffset,\n    zoomable,\n    legendMargin,\n    addXAxisLabelOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const legendData = rawSeries\n    .filter(\n      entry =>\n        extractForecastSeriesContext(entry.name || '').type ===\n        ForecastSeriesEnum.Observation,\n    )\n    .map(entry => entry.name || '')\n    .concat(extractAnnotationLabels(annotationLayers, annotationData));\n\n  let xAxis: any = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation,\n    },\n    minInterval:\n      xAxisType === 'time' && timeGrainSqla\n        ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n        : 0,\n  };\n  let yAxis: any = {\n    ...defaultYAxis,\n    type: logAxis ? 'log' : 'value',\n    min,\n    max,\n    minorTick: { show: true },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(\n        metrics,\n        forcePercentFormatter,\n        customFormatters,\n        yAxisFormat,\n      ),\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n  };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding,\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue: number = richTooltip\n          ? params[0].value[xIndex]\n          : params.value[xIndex];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n\n        const rows: string[] = [];\n        const forecastValues: Record<string, ForecastValue> =\n          extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n\n        Object.keys(forecastValues).forEach(key => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          const formatterKey =\n            groupby.length === 0 ? inverted[key] : labelMap[key]?.[0];\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: forcePercentFormatter\n              ? percentFormatter\n              : getCustomFormatter(customFormatters, metrics, formatterKey) ??\n                defaultFormatter,\n          });\n          const contentStyle =\n            key === focusedSeries ? 'font-weight: 700' : 'opacity: 0.7';\n          rows.push(`<span style=\"${contentStyle}\">${content}</span>`);\n        });\n        if (stack) {\n          rows.reverse();\n        }\n        rows.unshift(`${tooltipFormatter(xValue)}`);\n        return rows.join('<br />');\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n        legendState,\n      ),\n      data: legendData as string[],\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom'),\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping: dataTypes,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}