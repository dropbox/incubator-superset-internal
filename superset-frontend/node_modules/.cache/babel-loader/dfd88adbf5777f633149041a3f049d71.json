{"ast":null,"code":"import _isNumber from \"lodash/isNumber\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { DTTM_ALIAS } from '@superset-ui/core';\nimport { ForecastSeriesEnum } from '../types';\nimport { sanitizeHtml } from './series';\nconst seriesTypeRegex = new RegExp(`(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`);\nexport const extractForecastSeriesContext = (seriesName) => {\n  const name = seriesName;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch)\n  return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2] };\n\n};\nexport const extractForecastSeriesContexts = (seriesNames) => seriesNames.reduce((agg, name) => {\n  const context = extractForecastSeriesContext(name);\n  const currentContexts = agg[context.name] || [];\n  currentContexts.push(context.type);\n  return { ...agg, [context.name]: currentContexts };\n}, {});\nexport const extractForecastValuesFromTooltipParams = function (params, isHorizontal) {if (isHorizontal === void 0) {isHorizontal = false;}\n  const values = {};\n  params.forEach((param) => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (_isNumber(numericValue)) {\n      if (!(context.name in values))\n      values[context.name] = {\n        marker: marker || '' };\n\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n      forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n      forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n      forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n      forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\nexport const formatForecastTooltipSeries = (_ref) => {let { seriesName, observation, forecastTrend, forecastLower, forecastUpper, marker, formatter } = _ref;\n  let row = `${marker}${sanitizeHtml(seriesName)}: `;\n  let isObservation = false;\n  if (_isNumber(observation)) {\n    isObservation = true;\n    row += `${formatter(observation)}`;\n  }\n  if (forecastTrend) {\n    if (isObservation)\n    row += ', ';\n    row += `ŷ = ${formatter(forecastTrend)}`;\n  }\n  if (forecastLower && forecastUpper)\n    // the lower bound needs to be added to the upper bound\n    row = `${row.trim()} (${formatter(forecastLower)}, ${formatter(forecastLower + forecastUpper)})`;\n  return `${row.trim()}`;\n};\nexport function rebaseForecastDatum(data, verboseMap) {if (verboseMap === void 0) {verboseMap = {};}\n  const keys = data.length ? Object.keys(data[0]) : [];\n  return data.map((row) => {\n    const newRow = {};\n    keys.forEach((key) => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey = key !== DTTM_ALIAS && verboseMap[forecastContext.name] ?\n      `${verboseMap[forecastContext.name]}${forecastContext.type}` :\n      key;\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key];\n      if (forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n      _includesInstanceProperty(keys).call(keys, lowerForecastKey) &&\n      value !== null &&\n      row[lowerForecastKey] !== null) {\n        value -= row[lowerForecastKey];\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}","map":{"version":3,"mappings":"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","names":["DTTM_ALIAS","ForecastSeriesEnum","sanitizeHtml","seriesTypeRegex","RegExp","ForecastLower","ForecastTrend","ForecastUpper","extractForecastSeriesContext","seriesName","name","regexMatch","exec","type","Observation","extractForecastSeriesContexts","seriesNames","reduce","agg","context","currentContexts","push","extractForecastValuesFromTooltipParams","params","isHorizontal","values","forEach","marker","seriesId","value","param","numericValue","forecastValues","observation","forecastTrend","forecastLower","forecastUpper","formatForecastTooltipSeries","formatter","row","isObservation","trim","rebaseForecastDatum","data","verboseMap","keys","length","Object","map","newRow","forecastContext","key","verboseKey","lowerForecastKey"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isNumber } from 'lodash';\nimport { DataRecord, DTTM_ALIAS, ValueFormatter } from '@superset-ui/core';\nimport { OptionName } from 'echarts/types/src/util/types';\nimport { TooltipMarker } from 'echarts/types/src/util/format';\nimport {\n  ForecastSeriesContext,\n  ForecastSeriesEnum,\n  ForecastValue,\n} from '../types';\nimport { sanitizeHtml } from './series';\n\nconst seriesTypeRegex = new RegExp(\n  `(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`,\n);\nexport const extractForecastSeriesContext = (\n  seriesName: OptionName,\n): ForecastSeriesContext => {\n  const name = seriesName as string;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch) return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2] as ForecastSeriesEnum,\n  };\n};\n\nexport const extractForecastSeriesContexts = (\n  seriesNames: string[],\n): { [key: string]: ForecastSeriesEnum[] } =>\n  seriesNames.reduce((agg, name) => {\n    const context = extractForecastSeriesContext(name);\n    const currentContexts = agg[context.name] || [];\n    currentContexts.push(context.type);\n    return { ...agg, [context.name]: currentContexts };\n  }, {} as { [key: string]: ForecastSeriesEnum[] });\n\nexport const extractForecastValuesFromTooltipParams = (\n  params: any[],\n  isHorizontal = false,\n): Record<string, ForecastValue> => {\n  const values: Record<string, ForecastValue> = {};\n  params.forEach(param => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (isNumber(numericValue)) {\n      if (!(context.name in values))\n        values[context.name] = {\n          marker: marker || '',\n        };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n        forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n        forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n        forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n        forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\n\nexport const formatForecastTooltipSeries = ({\n  seriesName,\n  observation,\n  forecastTrend,\n  forecastLower,\n  forecastUpper,\n  marker,\n  formatter,\n}: ForecastValue & {\n  seriesName: string;\n  marker: TooltipMarker;\n  formatter: ValueFormatter;\n}): string => {\n  let row = `${marker}${sanitizeHtml(seriesName)}: `;\n  let isObservation = false;\n  if (isNumber(observation)) {\n    isObservation = true;\n    row += `${formatter(observation)}`;\n  }\n  if (forecastTrend) {\n    if (isObservation) row += ', ';\n    row += `ŷ = ${formatter(forecastTrend)}`;\n  }\n  if (forecastLower && forecastUpper)\n    // the lower bound needs to be added to the upper bound\n    row = `${row.trim()} (${formatter(forecastLower)}, ${formatter(\n      forecastLower + forecastUpper,\n    )})`;\n  return `${row.trim()}`;\n};\n\nexport function rebaseForecastDatum(\n  data: DataRecord[],\n  verboseMap: Record<string, string> = {},\n) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n\n  return data.map(row => {\n    const newRow: DataRecord = {};\n    keys.forEach(key => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey =\n        key !== DTTM_ALIAS && verboseMap[forecastContext.name]\n          ? `${verboseMap[forecastContext.name]}${forecastContext.type}`\n          : key;\n\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key] as number | null;\n      if (\n        forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n        keys.includes(lowerForecastKey) &&\n        value !== null &&\n        row[lowerForecastKey] !== null\n      ) {\n        value -= row[lowerForecastKey] as number;\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}