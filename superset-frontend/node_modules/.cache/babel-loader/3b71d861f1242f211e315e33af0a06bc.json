{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable no-dupe-class-members */\nimport { scaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getSharedLabelColor from './SharedLabelColorSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\nclass CategoricalColorScale extends ExtensibleFunction {\n\n\n\n\n\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} parentForcedColors optional parameter that comes from parent\n   * (usually CategoricalColorNamespace) and supersede this.forcedColors\n   */\n  constructor(colors, parentForcedColors) {if (parentForcedColors === void 0) {parentForcedColors = {};}\n    super((value, sliceId) => this.getColor(value, sliceId));this.originColors = void 0;this.colors = void 0;this.scale = void 0;this.parentForcedColors = void 0;this.forcedColors = void 0;this.multiple = void 0;\n    this.originColors = colors;\n    this.colors = colors;\n    this.scale = scaleOrdinal();\n    this.scale.range(colors);\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(parentForcedColors).forEach((_ref) => {let [key, value] = _ref;\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        parentForcedColors[key] = colors[value % colors.length];\n      }\n    });\n    // all indexes have been replaced by a fixed color\n    this.parentForcedColors = parentForcedColors;\n    this.forcedColors = {};\n    this.multiple = 0;\n  }\n  removeSharedLabelColorFromRange(sharedColorMap, cleanedValue) {\n    // make sure we don't overwrite the origin colors\n    const updatedRange = [...this.originColors];\n    // remove the color option from shared color\n    sharedColorMap.forEach((value, key) => {\n      if (key !== cleanedValue) {\n        const index = updatedRange.indexOf(value);\n        updatedRange.splice(index, 1);\n      }\n    });\n    this.range(updatedRange.length > 0 ? updatedRange : this.originColors);\n  }\n  getColor(value, sliceId) {var _this$parentForcedCol, _this$forcedColors;\n    const cleanedValue = stringifyAndTrim(value);\n    const sharedLabelColor = getSharedLabelColor();\n    const sharedColorMap = sharedLabelColor.getColorMap();\n    const sharedColor = sharedColorMap.get(cleanedValue);\n    // priority: parentForcedColors > forcedColors > labelColors\n    let color = ((_this$parentForcedCol = this.parentForcedColors) == null ? void 0 : _this$parentForcedCol[cleanedValue]) || ((_this$forcedColors =\n    this.forcedColors) == null ? void 0 : _this$forcedColors[cleanedValue]) ||\n    sharedColor;\n    if (isFeatureEnabled(FeatureFlag.USE_ANALAGOUS_COLORS)) {\n      const multiple = Math.floor(this.domain().length / this.originColors.length);\n      if (multiple > this.multiple) {\n        this.multiple = multiple;\n        const newRange = getAnalogousColors(this.originColors, multiple);\n        this.range(this.originColors.concat(newRange));\n      }\n    }\n    const newColor = this.scale(cleanedValue);\n    if (!color) {\n      color = newColor;\n      if (isFeatureEnabled(FeatureFlag.AVOID_COLORS_COLLISION)) {\n        this.removeSharedLabelColorFromRange(sharedColorMap, cleanedValue);\n        color = this.scale(cleanedValue);\n      }\n    }\n    sharedLabelColor.addSlice(cleanedValue, color, sliceId);\n    return color;\n  }\n  /**\n   * Enforce specific color for given value\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   */\n  setColor(value, forcedColor) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n  /**\n   * Get a mapping of data values to colors\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap = {};\n    this.scale.domain().forEach((value) => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n    return {\n      ...colorMap,\n      ...this.forcedColors,\n      ...this.parentForcedColors };\n\n  }\n  /**\n   * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(this.scale.range(), this.parentForcedColors);\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n  domain(newDomain) {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n    this.scale.domain(newDomain);\n    return this;\n  }\n  range(newRange) {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n  unknown(value) {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n    this.scale.unknown(value);\n    return this;\n  }}\n\nexport default CategoricalColorScale;","map":{"version":3,"mappings":"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","names":["scaleOrdinal","ExtensibleFunction","stringifyAndTrim","getSharedLabelColor","getAnalogousColors","FeatureFlag","isFeatureEnabled","CategoricalColorScale","constructor","colors","parentForcedColors","value","sliceId","getColor","originColors","scale","forcedColors","multiple","range","Object","entries","forEach","key","length","removeSharedLabelColorFromRange","sharedColorMap","cleanedValue","updatedRange","index","indexOf","splice","sharedLabelColor","getColorMap","sharedColor","get","color","USE_ANALAGOUS_COLORS","Math","floor","domain","newRange","concat","newColor","AVOID_COLORS_COLLISION","addSlice","setColor","forcedColor","colorMap","toString","copy","unknown","newDomain"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable no-dupe-class-members */\nimport { scaleOrdinal, ScaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport { ColorsInitLookup, ColorsLookup } from './types';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getSharedLabelColor from './SharedLabelColorSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\n\n// Use type augmentation to correct the fact that\n// an instance of CategoricalScale is also a function\ninterface CategoricalColorScale {\n  (x: { toString(): string }, y?: number): string;\n}\n\nclass CategoricalColorScale extends ExtensibleFunction {\n  originColors: string[];\n\n  colors: string[];\n\n  scale: ScaleOrdinal<{ toString(): string }, string>;\n\n  parentForcedColors: ColorsLookup;\n\n  forcedColors: ColorsLookup;\n\n  multiple: number;\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} parentForcedColors optional parameter that comes from parent\n   * (usually CategoricalColorNamespace) and supersede this.forcedColors\n   */\n  constructor(colors: string[], parentForcedColors: ColorsInitLookup = {}) {\n    super((value: string, sliceId?: number) => this.getColor(value, sliceId));\n\n    this.originColors = colors;\n    this.colors = colors;\n    this.scale = scaleOrdinal<{ toString(): string }, string>();\n    this.scale.range(colors);\n\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(parentForcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        parentForcedColors[key] = colors[value % colors.length];\n      }\n    });\n\n    // all indexes have been replaced by a fixed color\n    this.parentForcedColors = parentForcedColors as ColorsLookup;\n    this.forcedColors = {};\n    this.multiple = 0;\n  }\n\n  removeSharedLabelColorFromRange(\n    sharedColorMap: Map<string, string>,\n    cleanedValue: string,\n  ) {\n    // make sure we don't overwrite the origin colors\n    const updatedRange = [...this.originColors];\n    // remove the color option from shared color\n    sharedColorMap.forEach((value: string, key: string) => {\n      if (key !== cleanedValue) {\n        const index = updatedRange.indexOf(value);\n        updatedRange.splice(index, 1);\n      }\n    });\n    this.range(updatedRange.length > 0 ? updatedRange : this.originColors);\n  }\n\n  getColor(value?: string, sliceId?: number) {\n    const cleanedValue = stringifyAndTrim(value);\n    const sharedLabelColor = getSharedLabelColor();\n    const sharedColorMap = sharedLabelColor.getColorMap();\n    const sharedColor = sharedColorMap.get(cleanedValue);\n\n    // priority: parentForcedColors > forcedColors > labelColors\n    let color =\n      this.parentForcedColors?.[cleanedValue] ||\n      this.forcedColors?.[cleanedValue] ||\n      sharedColor;\n\n    if (isFeatureEnabled(FeatureFlag.USE_ANALAGOUS_COLORS)) {\n      const multiple = Math.floor(\n        this.domain().length / this.originColors.length,\n      );\n      if (multiple > this.multiple) {\n        this.multiple = multiple;\n        const newRange = getAnalogousColors(this.originColors, multiple);\n        this.range(this.originColors.concat(newRange));\n      }\n    }\n    const newColor = this.scale(cleanedValue);\n    if (!color) {\n      color = newColor;\n      if (isFeatureEnabled(FeatureFlag.AVOID_COLORS_COLLISION)) {\n        this.removeSharedLabelColorFromRange(sharedColorMap, cleanedValue);\n        color = this.scale(cleanedValue);\n      }\n    }\n\n    sharedLabelColor.addSlice(cleanedValue, color, sliceId);\n\n    return color;\n  }\n\n  /**\n   * Enforce specific color for given value\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   */\n  setColor(value: string, forcedColor: string) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n\n  /**\n   * Get a mapping of data values to colors\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap: { [key: string]: string | undefined } = {};\n    this.scale.domain().forEach(value => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n\n    return {\n      ...colorMap,\n      ...this.forcedColors,\n      ...this.parentForcedColors,\n    };\n  }\n\n  /**\n   * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(\n      this.scale.range(),\n      this.parentForcedColors,\n    );\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n\n    return copy;\n  }\n\n  /**\n   * Returns the scale's current domain.\n   */\n  domain(): { toString(): string }[];\n\n  /**\n   * Expands the domain to include the specified array of values.\n   */\n  domain(newDomain: { toString(): string }[]): this;\n\n  domain(newDomain?: { toString(): string }[]): unknown {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n\n    this.scale.domain(newDomain);\n    return this;\n  }\n\n  /**\n   * Returns the scale's current range.\n   */\n  range(): string[];\n\n  /**\n   * Sets the range of the ordinal scale to the specified array of values.\n   *\n   * The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on.\n   *\n   * If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range.\n   *\n   * @param newRange Array of range values.\n   */\n  range(newRange: string[]): this;\n\n  range(newRange?: string[]): unknown {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n\n  /**\n   * Returns the current unknown value, which defaults to \"implicit\".\n   */\n  unknown(): string | { name: 'implicit' };\n\n  /**\n   * Sets the output value of the scale for unknown input values and returns this scale.\n   * The implicit value enables implicit domain construction. scaleImplicit can be used as a convenience to set the implicit value.\n   *\n   * @param value Unknown value to be used or scaleImplicit to set implicit scale generation.\n   */\n  unknown(value: string | { name: 'implicit' }): this;\n\n  unknown(value?: string | { name: 'implicit' }): unknown {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n\n    this.scale.unknown(value);\n    return this;\n  }\n}\n\nexport default CategoricalColorScale;\n"]},"metadata":{},"sourceType":"module"}