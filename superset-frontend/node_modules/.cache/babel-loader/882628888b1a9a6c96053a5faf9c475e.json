{"ast":null,"code":"import _invert from \"lodash/invert\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { AxisType, CategoricalColorNamespace, ensureIsArray, GenericDataType, getMetricLabel, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, t } from '@superset-ui/core';\nimport { extractExtraMetrics, getOriginalSeries, isDerivedSeries } from '@superset-ui/chart-controls';\nimport { OrientationType } from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport { currentSeries, dedupSeries, extractSeries, getAxisType, getColtypesMapping, getLegendProps, extractDataTotalValues, extractShowValueIndexes } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastSeriesContexts, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getBaselineSeriesForStream, getPadding, getTooltipTimeFormatter, getXAxisFormatter, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from './transformers';\nimport { StackControlsValue, TIMESERIES_CONSTANTS, TIMEGRAIN_TO_TIMESTAMP } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, filterState, formData, hooks, queriesData, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  const { verboseMap = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } = queryData;\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n  const { area, annotationLayers, colorScheme, contributionMode, forecastEnabled, groupby, legendOrientation, legendType, legendMargin, logAxis, markerEnabled, markerSize, metrics, minorSplitLine, onlyTotal, opacity, orientation, percentageThreshold, richTooltip, seriesType, showLegend, showValue, sliceId, sortSeriesType, sortSeriesAscending, timeGrainSqla, timeCompare, stack, tooltipTimeFormat, tooltipSortByMetric, truncateYAxis, xAxis: xAxisOrig, xAxisLabelRotation, xAxisSortSeries, xAxisSortSeriesAscending, xAxisTimeFormat, xAxisTitle, xAxisTitleMargin, yAxisBounds, yAxisFormat, yAxisTitle, yAxisTitleMargin, yAxisTitlePosition, zoomable } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (entry[1].length > groupby.length &&\n    Array.isArray(timeCompare) &&\n    _includesInstanceProperty(timeCompare).call(timeCompare, entry[1][0])) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedData, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel });\n\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(getMetricLabel);\n  const isMultiSeries = groupby.length || metrics.length > 1;\n  const [rawSeries, sortedTotalValues] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n    xAxisSortSeriesAscending: isMultiSeries ?\n    xAxisSortSeriesAscending :\n    undefined });\n\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal });\n\n  const seriesContexts = extractForecastSeriesContexts(Object.values(rawSeries).map((series) => series.name));\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(xAxisDataType);\n  const series = [];\n  const formatter = getNumberFormatter(contributionMode || isAreaExpand ? ',.0%' : yAxisFormat);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeries.forEach((entry) => {\n    const lineStyle = isDerivedSeries(entry, chartProps.rawFormData) ?\n    { type: 'dashed' } :\n    {};\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      filterState,\n      seriesContexts,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      stack,\n      formatter,\n      showValue,\n      onlyTotal,\n      totalStackedValues: sortedTotalValues,\n      showValueIndexes,\n      thresholdValues,\n      richTooltip,\n      sliceId,\n      isHorizontal,\n      lineStyle });\n\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: transformedSeries.data.map((row) => {var _row$;return [row[0], (_row$ = row[1]) != null ? _row$ : 0];}) });\n\n      } else\n      {\n        series.push(transformedSeries);\n      }\n    }\n  });\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(series.map((entry) => entry.data), seriesType);\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = series.findIndex((_ref) => {let { name } = _ref;return name === selectedValue;});\n    return {\n      ...acc,\n      [index]: selectedValue };\n\n  }, {});\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (min === undefined)\n    min = 0;\n    if (max === undefined)\n    max = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.TEMPORAL ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const { setDataMask = () => {}, setControlValue = () => {}, onContextMenu } = hooks;\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(showLegend, legendOrientation, addYAxisLabelOffset, zoomable, legendMargin, addXAxisLabelOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const legendData = rawSeries.\n  filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n  ForecastSeriesEnum.Observation).\n  map((entry) => entry.name || '').\n  concat(extractAnnotationLabels(annotationLayers, annotationData));\n  let xAxis = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation },\n\n    minInterval: xAxisType === AxisType.time && timeGrainSqla ?\n    TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n    0 };\n\n  if (xAxisType === AxisType.time) {\n    /**\n     * Overriding default behavior (false) for time axis regardless of the granilarity.\n     * Not including this in the initial declaration above so if echarts changes the default\n     * behavior for other axist types we won't unintentionally override it\n     */\n    xAxis.axisLabel.showMaxLabel = null;\n  }\n  let yAxis = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.log : AxisType.value,\n    min,\n    max,\n    minorTick: { show: true },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: { formatter },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end' };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding },\n\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue = richTooltip ?\n        params[0].value[xIndex] :\n        params.value[xIndex];\n        const forecastValue = richTooltip ? params : [params];\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n        const rows = [];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n        Object.keys(forecastValues).forEach((key) => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter });\n\n          if (currentSeries.name === key) {\n            rows.push(`<span style=\"font-weight: 700\">${content}</span>`);\n          } else\n          {\n            rows.push(`<span style=\"opacity: 0.7\">${content}</span>`);\n          }\n        });\n        if (stack) {\n          rows.reverse();\n        }\n        rows.unshift(`${tooltipFormatter(xValue)}`);\n        return rows.join('<br />');\n      } },\n\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      data: legendData },\n\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom') } } } },\n\n\n\n\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom }] :\n\n\n    [] };\n\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType },\n\n    refs,\n    coltypeMapping: dataTypes };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(transformProps, \"transformProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["AxisType","CategoricalColorNamespace","ensureIsArray","GenericDataType","getMetricLabel","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","t","extractExtraMetrics","getOriginalSeries","isDerivedSeries","OrientationType","DEFAULT_FORM_DATA","ForecastSeriesEnum","parseYAxisBound","currentSeries","dedupSeries","extractSeries","getAxisType","getColtypesMapping","getLegendProps","extractDataTotalValues","extractShowValueIndexes","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastSeriesContexts","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","convertInteger","defaultGrid","defaultYAxis","getBaselineSeriesForStream","getPadding","getTooltipTimeFormatter","getXAxisFormatter","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","StackControlsValue","TIMESERIES_CONSTANTS","TIMEGRAIN_TO_TIMESTAMP","getDefaultTooltip","transformProps","chartProps","width","height","filterState","formData","hooks","queriesData","datasource","theme","inContextMenu","emitCrossFilters","verboseMap","queryData","data","label_map","dataTypes","annotationData","area","annotationLayers","colorScheme","contributionMode","forecastEnabled","groupby","legendOrientation","legendType","legendMargin","logAxis","markerEnabled","markerSize","metrics","minorSplitLine","onlyTotal","opacity","orientation","percentageThreshold","richTooltip","seriesType","showLegend","showValue","sliceId","sortSeriesType","sortSeriesAscending","timeGrainSqla","timeCompare","stack","tooltipTimeFormat","tooltipSortByMetric","truncateYAxis","xAxis","xAxisOrig","xAxisLabelRotation","xAxisSortSeries","xAxisSortSeriesAscending","xAxisTimeFormat","xAxisTitle","xAxisTitleMargin","yAxisBounds","yAxisFormat","yAxisTitle","yAxisTitleMargin","yAxisTitlePosition","zoomable","refs","labelMap","Object","entries","reduce","acc","entry","length","Array","isArray","shift","colorScale","getScale","rebasedData","xAxisLabel","rawFormData","x_axis","isHorizontal","horizontal","totalStackedValues","thresholdValues","xAxisCol","extraMetricLabels","map","isMultiSeries","rawSeries","sortedTotalValues","fillNeighborValue","undefined","showValueIndexes","seriesContexts","values","series","name","isAreaExpand","Expand","xAxisDataType","xAxisType","formatter","array","time_compare","inverted","forEach","lineStyle","type","entryName","String","seriesName","colorScaleKey","transformedSeries","areaOpacity","Stream","push","row","baselineSeries","unshift","selectedValues","selectedValue","index","findIndex","filter","layer","show","min","max","tooltipFormatter","TEMPORAL","xAxisFormatter","setDataMask","setControlValue","onContextMenu","addYAxisLabelOffset","addXAxisLabelOffset","padding","legendData","Observation","concat","nameGap","nameLocation","axisLabel","hideOverlap","rotate","minInterval","time","showMaxLabel","yAxis","log","value","minorTick","scale","bottom","left","inverse","echartOptions","useUTC","grid","tooltip","trigger","params","xIndex","yIndex","xValue","forecastValue","sort","a","b","rows","forecastValues","keys","key","observation","content","reverse","join","legend","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","yAxisIndex","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","zoomBottom","xValueFormatter","label","coltypeMapping"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  AxisType,\n  CategoricalColorNamespace,\n  ensureIsArray,\n  GenericDataType,\n  getMetricLabel,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  t,\n  TimeseriesChartDataResponseResult,\n} from '@superset-ui/core';\nimport {\n  extractExtraMetrics,\n  getOriginalSeries,\n  isDerivedSeries,\n} from '@superset-ui/chart-controls';\nimport { EChartsCoreOption, SeriesOption } from 'echarts';\nimport { ZRLineType } from 'echarts/types/src/util/types';\nimport {\n  EchartsTimeseriesChartProps,\n  EchartsTimeseriesFormData,\n  TimeseriesChartTransformedProps,\n  OrientationType,\n} from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum, ForecastValue, Refs } from '../types';\nimport { parseYAxisBound } from '../utils/controls';\nimport {\n  currentSeries,\n  dedupSeries,\n  extractSeries,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  extractDataTotalValues,\n  extractShowValueIndexes,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastSeriesContexts,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getBaselineSeriesForStream,\n  getPadding,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from './transformers';\nimport {\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n  TIMEGRAIN_TO_TIMESTAMP,\n} from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport default function transformProps(\n  chartProps: EchartsTimeseriesChartProps,\n): TimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    filterState,\n    formData,\n    hooks,\n    queriesData,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const { verboseMap = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } =\n    queryData as TimeseriesChartDataResponseResult;\n\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n\n  const {\n    area,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    forecastEnabled,\n    groupby,\n    legendOrientation,\n    legendType,\n    legendMargin,\n    logAxis,\n    markerEnabled,\n    markerSize,\n    metrics,\n    minorSplitLine,\n    onlyTotal,\n    opacity,\n    orientation,\n    percentageThreshold,\n    richTooltip,\n    seriesType,\n    showLegend,\n    showValue,\n    sliceId,\n    sortSeriesType,\n    sortSeriesAscending,\n    timeGrainSqla,\n    timeCompare,\n    stack,\n    tooltipTimeFormat,\n    tooltipSortByMetric,\n    truncateYAxis,\n    xAxis: xAxisOrig,\n    xAxisLabelRotation,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n    xAxisTimeFormat,\n    xAxisTitle,\n    xAxisTitleMargin,\n    yAxisBounds,\n    yAxisFormat,\n    yAxisTitle,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    zoomable,\n  }: EchartsTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs: Refs = {};\n\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (\n      entry[1].length > groupby.length &&\n      Array.isArray(timeCompare) &&\n      timeCompare.includes(entry[1][0])\n    ) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedData,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n    },\n  );\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(\n    getMetricLabel,\n  );\n\n  const isMultiSeries = groupby.length || metrics.length > 1;\n\n  const [rawSeries, sortedTotalValues] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n    xAxisSortSeriesAscending: isMultiSeries\n      ? xAxisSortSeriesAscending\n      : undefined,\n  });\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n  });\n  const seriesContexts = extractForecastSeriesContexts(\n    Object.values(rawSeries).map(series => series.name as string),\n  );\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n\n  const xAxisType = getAxisType(xAxisDataType);\n  const series: SeriesOption[] = [];\n  const formatter = getNumberFormatter(\n    contributionMode || isAreaExpand ? ',.0%' : yAxisFormat,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeries.forEach(entry => {\n    const lineStyle = isDerivedSeries(entry, chartProps.rawFormData)\n      ? { type: 'dashed' as ZRLineType }\n      : {};\n\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        filterState,\n        seriesContexts,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        stack,\n        formatter,\n        showValue,\n        onlyTotal,\n        totalStackedValues: sortedTotalValues,\n        showValueIndexes,\n        thresholdValues,\n        richTooltip,\n        sliceId,\n        isHorizontal,\n        lineStyle,\n      },\n    );\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: (transformedSeries.data as any).map(\n            (row: [string | number, number]) => [row[0], row[1] ?? 0],\n          ),\n        });\n      } else {\n        series.push(transformedSeries);\n      }\n    }\n  });\n\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(\n      series.map(entry => entry.data) as [string | number, number][][],\n      seriesType,\n    );\n\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = series.findIndex(({ name }) => name === selectedValue);\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  let [min, max] = (yAxisBounds || []).map(parseYAxisBound);\n\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (min === undefined) min = 0;\n    if (max === undefined) max = 1;\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.TEMPORAL\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const {\n    setDataMask = () => {},\n    setControlValue = () => {},\n    onContextMenu,\n  } = hooks;\n\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisLabelOffset,\n    zoomable,\n    legendMargin,\n    addXAxisLabelOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const legendData = rawSeries\n    .filter(\n      entry =>\n        extractForecastSeriesContext(entry.name || '').type ===\n        ForecastSeriesEnum.Observation,\n    )\n    .map(entry => entry.name || '')\n    .concat(extractAnnotationLabels(annotationLayers, annotationData));\n\n  let xAxis: any = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation,\n    },\n    minInterval:\n      xAxisType === AxisType.time && timeGrainSqla\n        ? TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla]\n        : 0,\n  };\n\n  if (xAxisType === AxisType.time) {\n    /**\n     * Overriding default behavior (false) for time axis regardless of the granilarity.\n     * Not including this in the initial declaration above so if echarts changes the default\n     * behavior for other axist types we won't unintentionally override it\n     */\n    xAxis.axisLabel.showMaxLabel = null;\n  }\n\n  let yAxis: any = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.log : AxisType.value,\n    min,\n    max,\n    minorTick: { show: true },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: { formatter },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n  };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n    yAxis.inverse = true;\n  }\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding,\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue: number = richTooltip\n          ? params[0].value[xIndex]\n          : params.value[xIndex];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        if (richTooltip && tooltipSortByMetric) {\n          forecastValue.sort((a, b) => b.data[yIndex] - a.data[yIndex]);\n        }\n\n        const rows: string[] = [];\n        const forecastValues: Record<string, ForecastValue> =\n          extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n\n        Object.keys(forecastValues).forEach(key => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const content = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter,\n          });\n          if (currentSeries.name === key) {\n            rows.push(`<span style=\"font-weight: 700\">${content}</span>`);\n          } else {\n            rows.push(`<span style=\"opacity: 0.7\">${content}</span>`);\n          }\n        });\n        if (stack) {\n          rows.reverse();\n        }\n        rows.unshift(`${tooltipFormatter(xValue)}`);\n        return rows.join('<br />');\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n      ),\n      data: legendData as string[],\n    },\n    series: dedupSeries(series),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom'),\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping: dataTypes,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}