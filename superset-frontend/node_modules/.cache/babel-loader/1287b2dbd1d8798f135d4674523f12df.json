{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";import _orderBy from \"lodash/orderBy\";import _minBy from \"lodash/minBy\";import _meanBy from \"lodash/meanBy\";import _maxBy from \"lodash/maxBy\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AxisType, DTTM_ALIAS, ensureIsArray, GenericDataType, NumberFormats, NumberFormatter, normalizeTimestamp } from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts';\n\nimport { NULL_STRING, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\nimport { LegendOrientation } from '../types';\nimport { defaultLegendPadding } from '../defaults';\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nexport function extractDataTotalValues(data, opts) {\n  const totalStackedValues = [];\n  const thresholdValues = [];\n  const { stack, percentageThreshold, xAxisCol } = opts;\n  if (stack) {\n    data.forEach((datum) => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + value;\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push((percentageThreshold || 0) / 100 * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues };\n\n}\nexport function extractShowValueIndexes(series, opts) {\n  const showValueIndexes = [];\n  if (opts.stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      data.forEach((datum, dataIndex) => {\n        if (!opts.onlyTotal && datum[opts.isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (opts.onlyTotal) {\n          if (datum[opts.isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (!showValueIndexes[dataIndex] &&\n          datum[opts.isHorizontal ? 0 : 1] !== null) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\nexport function sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending) {\n  const seriesNames = Object.keys(rows[0]).\n  filter((key) => key !== xAxis).\n  filter((key) => !_includesInstanceProperty(extraMetricLabels).call(extraMetricLabels, key));\n  let aggregator;\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = (name) => ({ name, value: _sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = (name) => {var _minBy2;return { name, value: (_minBy2 = _minBy(rows, name)) == null ? void 0 : _minBy2[name] };};\n      break;\n    case SortSeriesType.Max:\n      aggregator = (name) => {var _maxBy2;return { name, value: (_maxBy2 = _maxBy(rows, name)) == null ? void 0 : _maxBy2[name] };};\n      break;\n    case SortSeriesType.Avg:\n      aggregator = (name) => ({ name, value: _meanBy(rows, name) });\n      break;\n    default:\n      aggregator = (name) => ({ name, value: name.toLowerCase() });\n      break;}\n\n  const sortedValues = seriesNames.map(aggregator);\n  return _orderBy(sortedValues, ['value'], [sortSeriesAscending ? 'asc' : 'desc']).map((_ref) => {let { name } = _ref;return name;});\n}\nexport function sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey = '';\n    let aggregate;\n    let entries = 0;\n    Object.entries(row).forEach((_ref2) => {let [key, value] = _ref2;\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (xAxisSortSeries === SortSeriesType.Name ||\n      typeof value !== 'number') {\n        return;\n      }\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else\n          {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n          aggregate === undefined || isValueDefined && value < aggregate ?\n          value :\n          aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n          aggregate === undefined || isValueDefined && value > aggregate ?\n          value :\n          aggregate;\n          break;\n        default:\n          break;}\n\n    });\n    if (xAxisSortSeries === SortSeriesType.Avg &&\n    entries > 0 &&\n    aggregate !== undefined) {\n      aggregate /= entries;\n    }\n    const value = xAxisSortSeries === SortSeriesType.Name && typeof sortKey === 'string' ?\n    sortKey.toLowerCase() :\n    aggregate;\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx] };\n\n  });\n  return _orderBy(sortedRows, ['value'], [xAxisSortSeriesAscending ? 'asc' : 'desc']).map((_ref3) => {let { row, totalStackedValue } = _ref3;return { row, totalStackedValue };});\n}\nexport function extractSeries(data, opts) {if (opts === void 0) {opts = {};}\n  const { fillNeighborValue, xAxis = DTTM_ALIAS, extraMetricLabels = [], removeNulls = false, stack = false, totalStackedValues = [], isHorizontal = false, sortSeriesType, sortSeriesAscending, xAxisSortSeries, xAxisSortSeriesAscending } = opts;\n  if (data.length === 0)\n  return [[], []];\n  const rows = data.map((datum) => ({\n    ...datum,\n    [xAxis]: datum[xAxis] }));\n\n  const sortedSeries = sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending);\n  const sortedRows = isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending) ?\n  sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) :\n  rows.map((row, idx) => ({\n    row,\n    totalStackedValue: totalStackedValues[idx] }));\n\n  const finalSeries = sortedSeries.map((name) => ({\n    id: name,\n    name,\n    data: sortedRows.\n    map((_ref4, idx) => {var _rows, _rows2;let { row, totalStackedValue } = _ref4;\n      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[name]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[name]);\n      const isFillNeighborValue = !isDefined(row[name]) &&\n      isNextToDefinedValue &&\n      fillNeighborValue !== undefined;\n      let value = row[name];\n      if (isFillNeighborValue) {\n        value = fillNeighborValue;\n      } else\n      if (stack === StackControlsValue.Expand &&\n      totalStackedValue !== undefined) {\n        value = (value || 0) / totalStackedValue;\n      }\n      return [row[xAxis], value];\n    }).\n    filter((obs) => !removeNulls || obs[0] !== null && obs[1] !== null).\n    map((obs) => isHorizontal ? [obs[1], obs[0]] : obs) }));\n\n  return [\n  finalSeries,\n  sortedRows.map((_ref5) => {let { totalStackedValue } = _ref5;return totalStackedValue;})];\n\n}\nexport function formatSeriesName(name, _temp) {let { numberFormatter, timeFormatter, coltype } = _temp === void 0 ? {} : _temp;\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.TEMPORAL) {\n    const normalizedName = typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d = normalizedName instanceof Date ?\n    normalizedName :\n    new Date(normalizedName);\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\nexport const getColtypesMapping = (_ref6) => {let { coltypes = [], colnames = [] } = _ref6;return colnames.reduce((accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }), {});};\nexport function extractGroupbyLabel(_ref7) {let { datum = {}, groupby, numberFormatter, timeFormatter, coltypeMapping = {} } = _ref7;\n  return ensureIsArray(groupby).\n  map((val) => formatSeriesName(datum[val], {\n    numberFormatter,\n    timeFormatter,\n    ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }) })).\n\n  join(', ');\n}\nexport function getLegendProps(type, orientation, show, theme, zoomable) {var _context;if (zoomable === void 0) {zoomable = false;}\n  const legend = {\n    orient: _includesInstanceProperty(_context = [LegendOrientation.Top, LegendOrientation.Bottom]).call(_context, orientation) ?\n    'horizontal' :\n    'vertical',\n    show,\n    type,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base } };\n\n\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;}\n\n  return legend;\n}\nexport function getChartPadding(show, orientation, margin, padding) {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else\n  if (margin === null ||\n  margin === undefined ||\n  typeof margin === 'string') {\n    legendMargin = defaultLegendPadding[orientation];\n  } else\n  {\n    legendMargin = margin;\n  }\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom: bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0) };\n\n}\nexport function dedupSeries(series) {\n  const counter = new Map();\n  return series.map((row) => {\n    let { id } = row;\n    if (id === undefined)\n    return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}` };\n\n  });\n}\nexport function sanitizeHtml(text) {\n  return format.encodeHTML(text);\n}\n// TODO: Better use other method to maintain this state\nexport const currentSeries = {\n  name: '',\n  legend: '' };\n\nexport function getAxisType(dataType) {\n  if (dataType === GenericDataType.TEMPORAL) {\n    return AxisType.time;\n  }\n  return AxisType.category;\n}\nexport function getOverMaxHiddenFormatter(config) {if (config === void 0) {config = {};}\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n  return new NumberFormatter({\n    formatFunc: (value) => `${shouldHideIfOverMax && value > max ?\n    '' :\n    (formatter == null ? void 0 : formatter.format(value)) || value}`,\n    id: NumberFormats.OVER_MAX_HIDDEN });\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isDefined, \"isDefined\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractDataTotalValues, \"extractDataTotalValues\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractShowValueIndexes, \"extractShowValueIndexes\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortAndFilterSeries, \"sortAndFilterSeries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortRows, \"sortRows\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractSeries, \"extractSeries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(formatSeriesName, \"formatSeriesName\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getColtypesMapping, \"getColtypesMapping\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractGroupbyLabel, \"extractGroupbyLabel\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getLegendProps, \"getLegendProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getChartPadding, \"getChartPadding\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(dedupSeries, \"dedupSeries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sanitizeHtml, \"sanitizeHtml\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(currentSeries, \"currentSeries\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getAxisType, \"getAxisType\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getOverMaxHiddenFormatter, \"getOverMaxHiddenFormatter\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["AxisType","DTTM_ALIAS","ensureIsArray","GenericDataType","NumberFormats","NumberFormatter","normalizeTimestamp","SortSeriesType","format","NULL_STRING","StackControlsValue","TIMESERIES_CONSTANTS","LegendOrientation","defaultLegendPadding","isDefined","value","undefined","extractDataTotalValues","data","opts","totalStackedValues","thresholdValues","stack","percentageThreshold","xAxisCol","forEach","values","Object","keys","datum","reduce","prev","curr","push","extractShowValueIndexes","series","showValueIndexes","entry","seriesIndex","dataIndex","onlyTotal","isHorizontal","sortAndFilterSeries","rows","xAxis","extraMetricLabels","sortSeriesType","sortSeriesAscending","seriesNames","filter","key","aggregator","Sum","name","Min","Max","Avg","toLowerCase","sortedValues","map","sortRows","xAxisSortSeries","xAxisSortSeriesAscending","sortedRows","row","idx","sortKey","aggregate","entries","isValueDefined","Name","totalStackedValue","extractSeries","fillNeighborValue","removeNulls","length","sortedSeries","finalSeries","id","isNextToDefinedValue","isFillNeighborValue","Expand","obs","formatSeriesName","numberFormatter","timeFormatter","coltype","toString","Date","TEMPORAL","normalizedName","d","toISOString","getColtypesMapping","coltypes","colnames","accumulator","item","index","extractGroupbyLabel","groupby","coltypeMapping","val","join","getLegendProps","type","orientation","show","theme","zoomable","legend","orient","Top","Bottom","selector","selectorLabel","fontFamily","typography","families","sansSerif","fontSize","sizes","s","color","colors","grayscale","base","borderColor","Left","left","Right","right","top","legendRightTopOffset","bottom","legendTopRightOffset","getChartPadding","margin","padding","legendMargin","dedupSeries","counter","Map","String","count","get","suffix","set","sanitizeHtml","text","encodeHTML","currentSeries","getAxisType","dataType","time","category","getOverMaxHiddenFormatter","config","max","formatter","shouldHideIfOverMax","formatFunc","OVER_MAX_HIDDEN"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AxisType,\n  ChartDataResponseResult,\n  DataRecord,\n  DataRecordValue,\n  DTTM_ALIAS,\n  ensureIsArray,\n  GenericDataType,\n  NumberFormats,\n  NumberFormatter,\n  TimeFormatter,\n  SupersetTheme,\n  normalizeTimestamp,\n} from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format, LegendComponentOption, SeriesOption } from 'echarts';\nimport { maxBy, meanBy, minBy, orderBy, sumBy } from 'lodash';\nimport {\n  NULL_STRING,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport { LegendOrientation, LegendType, StackType } from '../types';\nimport { defaultLegendPadding } from '../defaults';\n\nfunction isDefined<T>(value: T | undefined | null): boolean {\n  return value !== undefined && value !== null;\n}\n\nexport function extractDataTotalValues(\n  data: DataRecord[],\n  opts: {\n    stack: StackType;\n    percentageThreshold: number;\n    xAxisCol: string;\n  },\n): {\n  totalStackedValues: number[];\n  thresholdValues: number[];\n} {\n  const totalStackedValues: number[] = [];\n  const thresholdValues: number[] = [];\n  const { stack, percentageThreshold, xAxisCol } = opts;\n  if (stack) {\n    data.forEach(datum => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + (value as number);\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push(((percentageThreshold || 0) / 100) * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues,\n  };\n}\n\nexport function extractShowValueIndexes(\n  series: SeriesOption[],\n  opts: {\n    stack: StackType;\n    onlyTotal?: boolean;\n    isHorizontal?: boolean;\n  },\n): number[] {\n  const showValueIndexes: number[] = [];\n  if (opts.stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      (data as [any, number][]).forEach((datum, dataIndex) => {\n        if (!opts.onlyTotal && datum[opts.isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (opts.onlyTotal) {\n          if (datum[opts.isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (\n            !showValueIndexes[dataIndex] &&\n            datum[opts.isHorizontal ? 0 : 1] !== null\n          ) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\n\nexport function sortAndFilterSeries(\n  rows: DataRecord[],\n  xAxis: string,\n  extraMetricLabels: any[],\n  sortSeriesType?: SortSeriesType,\n  sortSeriesAscending?: boolean,\n): string[] {\n  const seriesNames = Object.keys(rows[0])\n    .filter(key => key !== xAxis)\n    .filter(key => !extraMetricLabels.includes(key));\n\n  let aggregator: (name: string) => { name: string; value: any };\n\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = name => ({ name, value: sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = name => ({ name, value: minBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Max:\n      aggregator = name => ({ name, value: maxBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Avg:\n      aggregator = name => ({ name, value: meanBy(rows, name) });\n      break;\n    default:\n      aggregator = name => ({ name, value: name.toLowerCase() });\n      break;\n  }\n\n  const sortedValues = seriesNames.map(aggregator);\n\n  return orderBy(\n    sortedValues,\n    ['value'],\n    [sortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ name }) => name);\n}\n\nexport function sortRows(\n  rows: DataRecord[],\n  totalStackedValues: number[],\n  xAxis: string,\n  xAxisSortSeries: SortSeriesType,\n  xAxisSortSeriesAscending: boolean,\n) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey: DataRecordValue = '';\n    let aggregate: number | undefined;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (\n        xAxisSortSeries === SortSeriesType.Name ||\n        typeof value !== 'number'\n      ) {\n        return;\n      }\n\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value < aggregate)\n              ? value\n              : aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value > aggregate)\n              ? value\n              : aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (\n      xAxisSortSeries === SortSeriesType.Avg &&\n      entries > 0 &&\n      aggregate !== undefined\n    ) {\n      aggregate /= entries;\n    }\n\n    const value =\n      xAxisSortSeries === SortSeriesType.Name && typeof sortKey === 'string'\n        ? sortKey.toLowerCase()\n        : aggregate;\n\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx],\n    };\n  });\n\n  return orderBy(\n    sortedRows,\n    ['value'],\n    [xAxisSortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\n\nexport function extractSeries(\n  data: DataRecord[],\n  opts: {\n    fillNeighborValue?: number;\n    xAxis?: string;\n    extraMetricLabels?: string[];\n    removeNulls?: boolean;\n    stack?: StackType;\n    totalStackedValues?: number[];\n    isHorizontal?: boolean;\n    sortSeriesType?: SortSeriesType;\n    sortSeriesAscending?: boolean;\n    xAxisSortSeries?: SortSeriesType;\n    xAxisSortSeriesAscending?: boolean;\n  } = {},\n): [SeriesOption[], number[]] {\n  const {\n    fillNeighborValue,\n    xAxis = DTTM_ALIAS,\n    extraMetricLabels = [],\n    removeNulls = false,\n    stack = false,\n    totalStackedValues = [],\n    isHorizontal = false,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n  } = opts;\n  if (data.length === 0) return [[], []];\n  const rows: DataRecord[] = data.map(datum => ({\n    ...datum,\n    [xAxis]: datum[xAxis],\n  }));\n  const sortedSeries = sortAndFilterSeries(\n    rows,\n    xAxis,\n    extraMetricLabels,\n    sortSeriesType,\n    sortSeriesAscending,\n  );\n  const sortedRows =\n    isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending)\n      ? sortRows(\n          rows,\n          totalStackedValues,\n          xAxis,\n          xAxisSortSeries!,\n          xAxisSortSeriesAscending!,\n        )\n      : rows.map((row, idx) => ({\n          row,\n          totalStackedValue: totalStackedValues[idx],\n        }));\n\n  const finalSeries = sortedSeries.map(name => ({\n    id: name,\n    name,\n    data: sortedRows\n      .map(({ row, totalStackedValue }, idx) => {\n        const isNextToDefinedValue =\n          isDefined(rows[idx - 1]?.[name]) || isDefined(rows[idx + 1]?.[name]);\n        const isFillNeighborValue =\n          !isDefined(row[name]) &&\n          isNextToDefinedValue &&\n          fillNeighborValue !== undefined;\n        let value: DataRecordValue | undefined = row[name];\n        if (isFillNeighborValue) {\n          value = fillNeighborValue;\n        } else if (\n          stack === StackControlsValue.Expand &&\n          totalStackedValue !== undefined\n        ) {\n          value = ((value || 0) as number) / totalStackedValue;\n        }\n        return [row[xAxis], value];\n      })\n      .filter(obs => !removeNulls || (obs[0] !== null && obs[1] !== null))\n      .map(obs => (isHorizontal ? [obs[1], obs[0]] : obs)),\n  }));\n  return [\n    finalSeries,\n    sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n  ];\n}\n\nexport function formatSeriesName(\n  name: DataRecordValue | undefined,\n  {\n    numberFormatter,\n    timeFormatter,\n    coltype,\n  }: {\n    numberFormatter?: NumberFormatter;\n    timeFormatter?: TimeFormatter;\n    coltype?: GenericDataType;\n  } = {},\n): string {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.TEMPORAL) {\n    const normalizedName =\n      typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d =\n      normalizedName instanceof Date\n        ? normalizedName\n        : new Date(normalizedName);\n\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\n\nexport const getColtypesMapping = ({\n  coltypes = [],\n  colnames = [],\n}: Pick<ChartDataResponseResult, 'coltypes' | 'colnames'>): Record<\n  string,\n  GenericDataType\n> =>\n  colnames.reduce(\n    (accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }),\n    {},\n  );\n\nexport function extractGroupbyLabel({\n  datum = {},\n  groupby,\n  numberFormatter,\n  timeFormatter,\n  coltypeMapping = {},\n}: {\n  datum?: DataRecord;\n  groupby?: string[] | null;\n  numberFormatter?: NumberFormatter;\n  timeFormatter?: TimeFormatter;\n  coltypeMapping?: Record<string, GenericDataType>;\n}): string {\n  return ensureIsArray(groupby)\n    .map(val =>\n      formatSeriesName(datum[val], {\n        numberFormatter,\n        timeFormatter,\n        ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }),\n      }),\n    )\n    .join(', ');\n}\n\nexport function getLegendProps(\n  type: LegendType,\n  orientation: LegendOrientation,\n  show: boolean,\n  theme: SupersetTheme,\n  zoomable = false,\n): LegendComponentOption | LegendComponentOption[] {\n  const legend: LegendComponentOption | LegendComponentOption[] = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(\n      orientation,\n    )\n      ? 'horizontal'\n      : 'vertical',\n    show,\n    type,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base,\n    },\n  };\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\n\nexport function getChartPadding(\n  show: boolean,\n  orientation: LegendOrientation,\n  margin?: string | number | null,\n  padding?: { top?: number; bottom?: number; left?: number; right?: number },\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else if (\n    margin === null ||\n    margin === undefined ||\n    typeof margin === 'string'\n  ) {\n    legendMargin = defaultLegendPadding[orientation];\n  } else {\n    legendMargin = margin;\n  }\n\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom:\n      bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n  };\n}\n\nexport function dedupSeries(series: SeriesOption[]): SeriesOption[] {\n  const counter = new Map<string, number>();\n  return series.map(row => {\n    let { id } = row;\n    if (id === undefined) return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`,\n    };\n  });\n}\n\nexport function sanitizeHtml(text: string): string {\n  return format.encodeHTML(text);\n}\n\n// TODO: Better use other method to maintain this state\nexport const currentSeries = {\n  name: '',\n  legend: '',\n};\n\nexport function getAxisType(dataType?: GenericDataType): AxisType {\n  if (dataType === GenericDataType.TEMPORAL) {\n    return AxisType.time;\n  }\n  return AxisType.category;\n}\n\nexport function getOverMaxHiddenFormatter(\n  config: {\n    max?: number;\n    formatter?: NumberFormatter;\n  } = {},\n) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n\n  return new NumberFormatter({\n    formatFunc: value =>\n      `${\n        shouldHideIfOverMax && value > max\n          ? ''\n          : formatter?.format(value) || value\n      }`,\n    id: NumberFormats.OVER_MAX_HIDDEN,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}