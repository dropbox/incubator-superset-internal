{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useLayoutEffect, useState, useRef } from 'react';\n/**\n * This hook encapsulates logic to support truncation of child HTML\n * elements contained in a fixed-width parent HTML element.  Given\n * a ref to the parent element and optionally a ref to the \"+x\"\n * component that shows the number of truncated items, this hook\n * will return the number of elements that are not fully visible\n * (including those completely hidden) and whether any elements\n * are completely hidden.\n */\nconst useChildElementTruncation = (elementRef, plusRef) => {var _elementRef$current, _elementRef$current2;\n  const [elementsTruncated, setElementsTruncated] = useState(0);\n  const [hasHiddenElements, setHasHiddenElements] = useState(false);\n  const previousEffectInfoRef = useRef({\n    scrollWidth: 0,\n    parentElementWidth: 0,\n    plusRefWidth: 0 });\n\n  useLayoutEffect(() => {var _currentElement$paren;\n    const currentElement = elementRef.current;\n    const plusRefElement = plusRef == null ? void 0 : plusRef.current;\n    if (!currentElement) {\n      return;\n    }\n    const { scrollWidth, clientWidth, childNodes } = currentElement;\n    // By using the result of this effect to truncate content\n    // we're effectively changing it's size.\n    // That will trigger another pass at this effect.\n    // Depending on the content elements width, that second rerender could\n    // yield a different truncate count, thus potentially leading to a\n    // rendering loop.\n    // There's only a need to recompute if the parent width or the width of\n    // the child nodes changes.\n    const previousEffectInfo = previousEffectInfoRef.current;\n    const parentElementWidth = ((_currentElement$paren = currentElement.parentElement) == null ? void 0 : _currentElement$paren.clientWidth) || 0;\n    const plusRefWidth = (plusRefElement == null ? void 0 : plusRefElement.offsetWidth) || 0;\n    previousEffectInfoRef.current = {\n      scrollWidth,\n      parentElementWidth,\n      plusRefWidth };\n\n    if (previousEffectInfo.parentElementWidth === parentElementWidth &&\n    previousEffectInfo.scrollWidth === scrollWidth &&\n    previousEffectInfo.plusRefWidth === plusRefWidth) {\n      return;\n    }\n    if (scrollWidth > clientWidth) {\n      // \"...\" is around 6px wide\n      const truncationWidth = 6;\n      const plusSize = (plusRefElement == null ? void 0 : plusRefElement.offsetWidth) || 0;\n      const maxWidth = clientWidth - truncationWidth;\n      const elementsCount = childNodes.length;\n      let width = 0;\n      let hiddenElements = 0;\n      for (let i = 0; i < elementsCount; i += 1) {\n        const itemWidth = childNodes[i].offsetWidth;\n        const remainingWidth = maxWidth - truncationWidth - width - plusSize;\n        // assures it shows +{number} only when the item is not visible\n        if (remainingWidth <= 0) {\n          hiddenElements += 1;\n        }\n        width += itemWidth;\n      }\n      if (elementsCount > 1 && hiddenElements) {\n        setHasHiddenElements(true);\n        setElementsTruncated(hiddenElements);\n      } else\n      {\n        setHasHiddenElements(false);\n        setElementsTruncated(1);\n      }\n    } else\n    {\n      setHasHiddenElements(false);\n      setElementsTruncated(0);\n    }\n  }, [(_elementRef$current =\n  elementRef.current) == null ? void 0 : _elementRef$current.offsetWidth, (_elementRef$current2 =\n  elementRef.current) == null ? void 0 : _elementRef$current2.clientWidth,\n  elementRef]);\n\n  return [elementsTruncated, hasHiddenElements];\n};\nexport default useChildElementTruncation;","map":{"version":3,"mappings":"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","names":["useLayoutEffect","useState","useRef","useChildElementTruncation","elementRef","plusRef","elementsTruncated","setElementsTruncated","hasHiddenElements","setHasHiddenElements","previousEffectInfoRef","scrollWidth","parentElementWidth","plusRefWidth","currentElement","current","plusRefElement","clientWidth","childNodes","previousEffectInfo","parentElement","offsetWidth","truncationWidth","plusSize","maxWidth","elementsCount","length","width","hiddenElements","i","itemWidth","remainingWidth"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/packages/superset-ui-core/src/hooks/useTruncation/useChildElementTruncation.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { RefObject, useLayoutEffect, useState, useRef } from 'react';\n\n/**\n * This hook encapsulates logic to support truncation of child HTML\n * elements contained in a fixed-width parent HTML element.  Given\n * a ref to the parent element and optionally a ref to the \"+x\"\n * component that shows the number of truncated items, this hook\n * will return the number of elements that are not fully visible\n * (including those completely hidden) and whether any elements\n * are completely hidden.\n */\nconst useChildElementTruncation = (\n  elementRef: RefObject<HTMLElement>,\n  plusRef?: RefObject<HTMLElement>,\n) => {\n  const [elementsTruncated, setElementsTruncated] = useState(0);\n  const [hasHiddenElements, setHasHiddenElements] = useState(false);\n\n  const previousEffectInfoRef = useRef({\n    scrollWidth: 0,\n    parentElementWidth: 0,\n    plusRefWidth: 0,\n  });\n\n  useLayoutEffect(() => {\n    const currentElement = elementRef.current;\n    const plusRefElement = plusRef?.current;\n\n    if (!currentElement) {\n      return;\n    }\n\n    const { scrollWidth, clientWidth, childNodes } = currentElement;\n\n    // By using the result of this effect to truncate content\n    // we're effectively changing it's size.\n    // That will trigger another pass at this effect.\n    // Depending on the content elements width, that second rerender could\n    // yield a different truncate count, thus potentially leading to a\n    // rendering loop.\n    // There's only a need to recompute if the parent width or the width of\n    // the child nodes changes.\n    const previousEffectInfo = previousEffectInfoRef.current;\n    const parentElementWidth = currentElement.parentElement?.clientWidth || 0;\n    const plusRefWidth = plusRefElement?.offsetWidth || 0;\n    previousEffectInfoRef.current = {\n      scrollWidth,\n      parentElementWidth,\n      plusRefWidth,\n    };\n\n    if (\n      previousEffectInfo.parentElementWidth === parentElementWidth &&\n      previousEffectInfo.scrollWidth === scrollWidth &&\n      previousEffectInfo.plusRefWidth === plusRefWidth\n    ) {\n      return;\n    }\n\n    if (scrollWidth > clientWidth) {\n      // \"...\" is around 6px wide\n      const truncationWidth = 6;\n      const plusSize = plusRefElement?.offsetWidth || 0;\n      const maxWidth = clientWidth - truncationWidth;\n      const elementsCount = childNodes.length;\n\n      let width = 0;\n      let hiddenElements = 0;\n      for (let i = 0; i < elementsCount; i += 1) {\n        const itemWidth = (childNodes[i] as HTMLElement).offsetWidth;\n        const remainingWidth = maxWidth - truncationWidth - width - plusSize;\n\n        // assures it shows +{number} only when the item is not visible\n        if (remainingWidth <= 0) {\n          hiddenElements += 1;\n        }\n        width += itemWidth;\n      }\n\n      if (elementsCount > 1 && hiddenElements) {\n        setHasHiddenElements(true);\n        setElementsTruncated(hiddenElements);\n      } else {\n        setHasHiddenElements(false);\n        setElementsTruncated(1);\n      }\n    } else {\n      setHasHiddenElements(false);\n      setElementsTruncated(0);\n    }\n  }, [\n    elementRef.current?.offsetWidth,\n    elementRef.current?.clientWidth,\n    elementRef,\n  ]);\n\n  return [elementsTruncated, hasHiddenElements];\n};\n\nexport default useChildElementTruncation;\n"]},"metadata":{},"sourceType":"module"}