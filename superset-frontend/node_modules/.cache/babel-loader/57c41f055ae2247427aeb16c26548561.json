{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { css, styled, usePrevious } from '@superset-ui/core';\nimport { queryEditorSetSelectedText } from 'src/SqlLab/actions/sqlLab';\nimport { FullSQLEditor as AceEditor } from 'src/components/AsyncAceEditor';\nimport useQueryEditor from 'src/SqlLab/hooks/useQueryEditor';\nimport { useAnnotations } from './useAnnotations';\nimport { useKeywords } from './useKeywords';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst StyledAceEditor = styled(AceEditor)`\n  ${(_ref) => {let { theme } = _ref;return css`\n    && {\n      // double class is better than !important\n      border: 1px solid ${theme.colors.grayscale.light2};\n      font-feature-settings: 'liga' off, 'calt' off;\n\n      &.ace_autocomplete {\n        // Use !important because Ace Editor applies extra CSS at the last second\n        // when opening the autocomplete.\n        width: ${theme.gridUnit * 130}px !important;\n      }\n\n      .ace_scroller {\n        background-color: ${theme.colors.grayscale.light4};\n      }\n    }\n  `;}}\n`;\nconst AceEditorWrapper = (_ref2) => {var _queryEditor$sql;let { autocomplete, onBlur = () => {}, onChange = () => {}, queryEditorId, height, hotkeys } = _ref2;\n  const dispatch = useDispatch();\n  const queryEditor = useQueryEditor(queryEditorId, [\n  'id',\n  'dbId',\n  'sql',\n  'schema',\n  'templateParams']);\n\n  const currentSql = (_queryEditor$sql = queryEditor.sql) != null ? _queryEditor$sql : '';\n  const [sql, setSql] = useState(currentSql);\n  // The editor changeSelection is called multiple times in a row,\n  // faster than React reconciliation process, so the selected text\n  // needs to be stored out of the state to ensure changes to it\n  // get saved immediately\n  const currentSelectionCache = useRef('');\n  useEffect(() => {\n    // Making sure no text is selected from previous mount\n    dispatch(queryEditorSetSelectedText(queryEditor, null));\n  }, []);\n  const prevSql = usePrevious(currentSql);\n  useEffect(() => {\n    if (currentSql !== prevSql) {\n      setSql(currentSql);\n    }\n  }, [currentSql]);\n  const onBlurSql = () => {\n    onBlur(sql);\n  };\n  const onAltEnter = () => {\n    onBlur(sql);\n  };\n  const onEditorLoad = (editor) => {\n    editor.commands.addCommand({\n      name: 'runQuery',\n      bindKey: { win: 'Alt-enter', mac: 'Alt-enter' },\n      exec: () => {\n        onAltEnter();\n      } });\n\n    hotkeys.forEach((keyConfig) => {\n      editor.commands.addCommand({\n        name: keyConfig.name,\n        bindKey: { win: keyConfig.key, mac: keyConfig.key },\n        exec: keyConfig.func });\n\n    });\n    editor.$blockScrolling = Infinity; // eslint-disable-line no-param-reassign\n    editor.selection.on('changeSelection', () => {\n      const selectedText = editor.getSelectedText();\n      // Backspace trigger 1 character selection, ignoring\n      if (selectedText !== currentSelectionCache.current &&\n      selectedText.length !== 1) {\n        dispatch(queryEditorSetSelectedText(queryEditor, selectedText));\n      }\n      currentSelectionCache.current = selectedText;\n    });\n  };\n  const onChangeText = (text) => {\n    setSql(text);\n    onChange(text);\n  };\n  const { data: annotations } = useAnnotations({\n    dbId: queryEditor.dbId,\n    schema: queryEditor.schema,\n    sql: currentSql,\n    templateParams: queryEditor.templateParams });\n\n  const keywords = useKeywords({\n    queryEditorId,\n    dbId: queryEditor.dbId,\n    schema: queryEditor.schema },\n  !autocomplete);\n  return ___EmotionJSX(StyledAceEditor, { keywords: keywords, onLoad: onEditorLoad, onBlur: onBlurSql, height: height, onChange: onChangeText, width: \"100%\", editorProps: { $blockScrolling: true }, enableLiveAutocompletion: autocomplete, value: sql, annotations: annotations });\n};\nexport default AceEditorWrapper;","map":{"version":3,"mappings":"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","names":["React","useState","useEffect","useRef","useDispatch","css","styled","usePrevious","queryEditorSetSelectedText","FullSQLEditor","AceEditor","useQueryEditor","useAnnotations","useKeywords","StyledAceEditor","theme","colors","grayscale","light2","gridUnit","light4","AceEditorWrapper","autocomplete","onBlur","onChange","queryEditorId","height","hotkeys","dispatch","queryEditor","currentSql","sql","setSql","currentSelectionCache","prevSql","onBlurSql","onAltEnter","onEditorLoad","editor","commands","addCommand","name","bindKey","win","mac","exec","forEach","keyConfig","key","func","$blockScrolling","Infinity","selection","on","selectedText","getSelectedText","current","length","onChangeText","text","data","annotations","dbId","schema","templateParams","keywords"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/SqlLab/components/AceEditorWrapper/index.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { css, styled, usePrevious } from '@superset-ui/core';\n\nimport { queryEditorSetSelectedText } from 'src/SqlLab/actions/sqlLab';\nimport { FullSQLEditor as AceEditor } from 'src/components/AsyncAceEditor';\nimport useQueryEditor from 'src/SqlLab/hooks/useQueryEditor';\nimport { useAnnotations } from './useAnnotations';\nimport { useKeywords } from './useKeywords';\n\ntype HotKey = {\n  key: string;\n  descr: string;\n  name: string;\n  func: () => void;\n};\n\ntype AceEditorWrapperProps = {\n  autocomplete: boolean;\n  onBlur: (sql: string) => void;\n  onChange: (sql: string) => void;\n  queryEditorId: string;\n  height: string;\n  hotkeys: HotKey[];\n};\n\nconst StyledAceEditor = styled(AceEditor)`\n  ${({ theme }) => css`\n    && {\n      // double class is better than !important\n      border: 1px solid ${theme.colors.grayscale.light2};\n      font-feature-settings: 'liga' off, 'calt' off;\n\n      &.ace_autocomplete {\n        // Use !important because Ace Editor applies extra CSS at the last second\n        // when opening the autocomplete.\n        width: ${theme.gridUnit * 130}px !important;\n      }\n\n      .ace_scroller {\n        background-color: ${theme.colors.grayscale.light4};\n      }\n    }\n  `}\n`;\n\nconst AceEditorWrapper = ({\n  autocomplete,\n  onBlur = () => {},\n  onChange = () => {},\n  queryEditorId,\n  height,\n  hotkeys,\n}: AceEditorWrapperProps) => {\n  const dispatch = useDispatch();\n  const queryEditor = useQueryEditor(queryEditorId, [\n    'id',\n    'dbId',\n    'sql',\n    'schema',\n    'templateParams',\n  ]);\n\n  const currentSql = queryEditor.sql ?? '';\n\n  const [sql, setSql] = useState(currentSql);\n\n  // The editor changeSelection is called multiple times in a row,\n  // faster than React reconciliation process, so the selected text\n  // needs to be stored out of the state to ensure changes to it\n  // get saved immediately\n  const currentSelectionCache = useRef('');\n\n  useEffect(() => {\n    // Making sure no text is selected from previous mount\n    dispatch(queryEditorSetSelectedText(queryEditor, null));\n  }, []);\n\n  const prevSql = usePrevious(currentSql);\n\n  useEffect(() => {\n    if (currentSql !== prevSql) {\n      setSql(currentSql);\n    }\n  }, [currentSql]);\n\n  const onBlurSql = () => {\n    onBlur(sql);\n  };\n\n  const onAltEnter = () => {\n    onBlur(sql);\n  };\n\n  const onEditorLoad = (editor: any) => {\n    editor.commands.addCommand({\n      name: 'runQuery',\n      bindKey: { win: 'Alt-enter', mac: 'Alt-enter' },\n      exec: () => {\n        onAltEnter();\n      },\n    });\n\n    hotkeys.forEach(keyConfig => {\n      editor.commands.addCommand({\n        name: keyConfig.name,\n        bindKey: { win: keyConfig.key, mac: keyConfig.key },\n        exec: keyConfig.func,\n      });\n    });\n\n    editor.$blockScrolling = Infinity; // eslint-disable-line no-param-reassign\n    editor.selection.on('changeSelection', () => {\n      const selectedText = editor.getSelectedText();\n\n      // Backspace trigger 1 character selection, ignoring\n      if (\n        selectedText !== currentSelectionCache.current &&\n        selectedText.length !== 1\n      ) {\n        dispatch(queryEditorSetSelectedText(queryEditor, selectedText));\n      }\n\n      currentSelectionCache.current = selectedText;\n    });\n  };\n\n  const onChangeText = (text: string) => {\n    setSql(text);\n    onChange(text);\n  };\n\n  const { data: annotations } = useAnnotations({\n    dbId: queryEditor.dbId,\n    schema: queryEditor.schema,\n    sql: currentSql,\n    templateParams: queryEditor.templateParams,\n  });\n\n  const keywords = useKeywords(\n    {\n      queryEditorId,\n      dbId: queryEditor.dbId,\n      schema: queryEditor.schema,\n    },\n    !autocomplete,\n  );\n\n  return (\n    <StyledAceEditor\n      keywords={keywords}\n      onLoad={onEditorLoad}\n      onBlur={onBlurSql}\n      height={height}\n      onChange={onChangeText}\n      width=\"100%\"\n      editorProps={{ $blockScrolling: true }}\n      enableLiveAutocompletion={autocomplete}\n      value={sql}\n      annotations={annotations}\n    />\n  );\n};\n\nexport default AceEditorWrapper;\n"]},"metadata":{},"sourceType":"module"}