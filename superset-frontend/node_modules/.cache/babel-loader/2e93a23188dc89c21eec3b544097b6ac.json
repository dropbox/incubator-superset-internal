{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { useCallback, useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { FeatureFlag, getCategoricalSchemeRegistry, isFeatureEnabled, SupersetClient, useComponentDidUpdate } from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\nimport pick from 'lodash/pick';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { dashboardInfoChanged } from 'src/dashboard/actions/dashboardInfo';\nimport { setColorScheme } from 'src/dashboard/actions/dashboardState';\nimport jsonStringify from 'json-stringify-pretty-compact';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabIndex, getRootLevelTabsComponent } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  return useMemo(() => nativeFilters ?\n  Object.values(nativeFilters).map((filter) => pick(filter, ['id', 'scope', 'type'])) :\n  [], [JSON.stringify(nativeFilters)]);\n};__signature__(useNativeFilterScopes, \"useSelector{nativeFilters}\\nuseMemo{}\", () => [useSelector]);\nconst DashboardContainer = (_ref) => {let { topLevelTabs } = _ref;\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const chartIds = useSelector((state) => Object.values(state.charts).map((chart) => chart.id));\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild });\n\n    return nextTabIndex > -1 ?\n    nextTabIndex :\n    getRootLevelTabIndex(dashboardLayout, directPathToChild);\n  }, [dashboardLayout, directPathToChild]);\n  useEffect(() => {\n    if (!isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) ||\n    nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map((filterScope) => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: [] };\n\n      }\n      const chartsInScope = getChartIdsInFilterScope(filterScope.scope, chartIds, dashboardLayout);\n      const tabsInScope = findTabsWithChartsInScope(dashboardLayout, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope };\n\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n  const verifyUpdateColorScheme = useCallback(() => {\n    const currentMetadata = dashboardInfo.metadata;\n    if (currentMetadata != null && currentMetadata.color_scheme) {\n      const metadata = { ...currentMetadata };\n      const colorScheme = metadata == null ? void 0 : metadata.color_scheme;\n      const colorSchemeDomain = (metadata == null ? void 0 : metadata.color_scheme_domain) || [];\n      const categoricalSchemes = getCategoricalSchemeRegistry();\n      const registryColorScheme = categoricalSchemes.get(colorScheme, true) || undefined;\n      const registryColorSchemeDomain = (registryColorScheme == null ? void 0 : registryColorScheme.colors) || [];\n      const defaultColorScheme = categoricalSchemes.defaultKey;\n      const colorSchemeExists = !!registryColorScheme;\n      const updateDashboardData = () => {\n        SupersetClient.put({\n          endpoint: `/api/v1/dashboard/${dashboardInfo.id}`,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            json_metadata: jsonStringify(metadata) }) }).\n\n        catch((e) => console.log(e));\n      };\n      const updateColorScheme = (scheme) => {\n        dispatch(setColorScheme(scheme));\n      };\n      const updateDashboard = () => {\n        dispatch(dashboardInfoChanged({\n          metadata }));\n\n        updateDashboardData();\n      };\n      // selected color scheme does not exist anymore\n      // must fallback to the available default one\n      if (!colorSchemeExists) {var _categoricalSchemes$g;\n        const updatedScheme = (defaultColorScheme == null ? void 0 : defaultColorScheme.toString()) || 'supersetColors';\n        metadata.color_scheme = updatedScheme;\n        metadata.color_scheme_domain =\n        ((_categoricalSchemes$g = categoricalSchemes.get(defaultColorScheme)) == null ? void 0 : _categoricalSchemes$g.colors) || [];\n        // reset shared_label_colors\n        // TODO: Requires regenerating the shared_label_colors after\n        // fixing a bug which affects their generation on dashboards with tabs\n        metadata.shared_label_colors = {};\n        updateColorScheme(updatedScheme);\n        updateDashboard();\n      } else\n      {\n        // if this dashboard does not have a color_scheme_domain saved\n        // must create one and store it for the first time\n        if (colorSchemeExists && !colorSchemeDomain.length) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          updateDashboard();\n        }\n        // if the color_scheme_domain is not the same as the registry domain\n        // must update the existing color_scheme_domain\n        if (colorSchemeExists &&\n        colorSchemeDomain.length &&\n        registryColorSchemeDomain.toString() !== colorSchemeDomain.toString()) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          // reset shared_label_colors\n          // TODO: Requires regenerating the shared_label_colors after\n          // fixing a bug which affects their generation on dashboards with tabs\n          metadata.shared_label_colors = {};\n          updateColorScheme(colorScheme);\n          updateDashboard();\n        }\n      }\n    }\n  }, [chartIds]);\n  useComponentDidUpdate(verifyUpdateColorScheme);\n  const childIds = topLevelTabs ?\n  topLevelTabs.children :\n  [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  return ___EmotionJSX(\"div\", { className: \"grid-container\", \"data-test\": \"grid-container\" },\n  ___EmotionJSX(ParentSize, null,\n  (_ref2) => {let { width } = _ref2;return (\n      /*\n      We use a TabContainer irrespective of whether top-level tabs exist to maintain\n      a consistent React component tree. This avoids expensive mounts/unmounts of\n      the entire dashboard upon adding/removing top-level tabs, which would otherwise\n      happen because of React's diffing algorithm\n    */\n      ___EmotionJSX(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: () => ___EmotionJSX(React.Fragment, null), fullWidth: false, animated: false, allowOverflow: true },\n      childIds.map((id, index) =>\n      // Matching the key of the first TabPane irrespective of topLevelTabs\n      // lets us keep the same React component tree when !!topLevelTabs changes.\n      // This avoids expensive mounts/unmounts of the entire dashboard.\n      ___EmotionJSX(Tabs.TabPane, { key: index === 0 ? DASHBOARD_GRID_ID : index.toString() },\n      ___EmotionJSX(DashboardGrid, { gridComponent: dashboardLayout[id]\n        // see isValidChild for why tabs do not increment the depth of their children\n        , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n        , width: width, isComponentVisible: index === tabIndex })))));}));\n\n\n\n\n};__signature__(DashboardContainer, \"useNativeFilterScopes{nativeFilterScopes}\\nuseDispatch{dispatch}\\nuseSelector{dashboardLayout}\\nuseSelector{dashboardInfo}\\nuseSelector{directPathToChild}\\nuseSelector{chartIds}\\nuseMemo{tabIndex}\\nuseEffect{}\\nuseCallback{verifyUpdateColorScheme}\\nuseComponentDidUpdate{}\", () => [useNativeFilterScopes, useDispatch, useSelector, useSelector, useSelector, useSelector, useComponentDidUpdate]);const _default =\nDashboardContainer;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(useNativeFilterScopes, \"useNativeFilterScopes\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(DashboardContainer, \"DashboardContainer\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["React","useCallback","useEffect","useMemo","useDispatch","useSelector","FeatureFlag","getCategoricalSchemeRegistry","isFeatureEnabled","SupersetClient","useComponentDidUpdate","ParentSize","pick","Tabs","DashboardGrid","DASHBOARD_GRID_ID","DASHBOARD_ROOT_DEPTH","getChartIdsInFilterScope","findTabIndexByComponentId","setInScopeStatusOfFilters","dashboardInfoChanged","setColorScheme","jsonStringify","NATIVE_FILTER_DIVIDER_PREFIX","findTabsWithChartsInScope","getRootLevelTabIndex","getRootLevelTabsComponent","useNativeFilterScopes","nativeFilters","state","filters","Object","values","map","filter","JSON","stringify","DashboardContainer","topLevelTabs","nativeFilterScopes","dispatch","dashboardLayout","present","dashboardInfo","directPathToChild","dashboardState","chartIds","charts","chart","id","tabIndex","nextTabIndex","currentComponent","DASHBOARD_NATIVE_FILTERS","length","scopes","filterScope","startsWith","filterId","tabsInScope","chartsInScope","scope","Array","from","verifyUpdateColorScheme","currentMetadata","metadata","color_scheme","colorScheme","colorSchemeDomain","color_scheme_domain","categoricalSchemes","registryColorScheme","get","undefined","registryColorSchemeDomain","colors","defaultColorScheme","defaultKey","colorSchemeExists","updateDashboardData","put","endpoint","headers","body","json_metadata","catch","console","log","e","updateColorScheme","scheme","updateDashboard","updatedScheme","toString","shared_label_colors","childIds","children","min","Math","activeKey","width","index"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { FC, useCallback, useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport {\n  FeatureFlag,\n  Filter,\n  Filters,\n  getCategoricalSchemeRegistry,\n  isFeatureEnabled,\n  SupersetClient,\n  useComponentDidUpdate,\n} from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\nimport pick from 'lodash/pick';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport {\n  DashboardInfo,\n  DashboardLayout,\n  LayoutItem,\n  RootState,\n} from 'src/dashboard/types';\nimport {\n  DASHBOARD_GRID_ID,\n  DASHBOARD_ROOT_DEPTH,\n} from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { dashboardInfoChanged } from 'src/dashboard/actions/dashboardInfo';\nimport { setColorScheme } from 'src/dashboard/actions/dashboardState';\nimport jsonStringify from 'json-stringify-pretty-compact';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabIndex, getRootLevelTabsComponent } from './utils';\n\ntype DashboardContainerProps = {\n  topLevelTabs?: LayoutItem;\n};\n\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector<RootState, Filters>(\n    state => state.nativeFilters?.filters,\n  );\n  return useMemo(\n    () =>\n      nativeFilters\n        ? Object.values(nativeFilters).map((filter: Filter) =>\n            pick(filter, ['id', 'scope', 'type']),\n          )\n        : [],\n    [JSON.stringify(nativeFilters)],\n  );\n};\n\nconst DashboardContainer: FC<DashboardContainerProps> = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n\n  const dashboardLayout = useSelector<RootState, DashboardLayout>(\n    state => state.dashboardLayout.present,\n  );\n  const dashboardInfo = useSelector<RootState, DashboardInfo>(\n    state => state.dashboardInfo,\n  );\n  const directPathToChild = useSelector<RootState, string[]>(\n    state => state.dashboardState.directPathToChild,\n  );\n  const chartIds = useSelector<RootState, number[]>(state =>\n    Object.values(state.charts).map(chart => chart.id),\n  );\n\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild,\n    });\n\n    return nextTabIndex > -1\n      ? nextTabIndex\n      : getRootLevelTabIndex(dashboardLayout, directPathToChild);\n  }, [dashboardLayout, directPathToChild]);\n\n  useEffect(() => {\n    if (\n      !isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) ||\n      nativeFilterScopes.length === 0\n    ) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map(filterScope => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: [],\n        };\n      }\n      const chartsInScope: number[] = getChartIdsInFilterScope(\n        filterScope.scope,\n        chartIds,\n        dashboardLayout,\n      );\n      const tabsInScope = findTabsWithChartsInScope(\n        dashboardLayout,\n        chartsInScope,\n      );\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope,\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [nativeFilterScopes, dashboardLayout, dispatch]);\n\n  const verifyUpdateColorScheme = useCallback(() => {\n    const currentMetadata = dashboardInfo.metadata;\n    if (currentMetadata?.color_scheme) {\n      const metadata = { ...currentMetadata };\n      const colorScheme = metadata?.color_scheme;\n      const colorSchemeDomain = metadata?.color_scheme_domain || [];\n      const categoricalSchemes = getCategoricalSchemeRegistry();\n      const registryColorScheme =\n        categoricalSchemes.get(colorScheme, true) || undefined;\n      const registryColorSchemeDomain = registryColorScheme?.colors || [];\n      const defaultColorScheme = categoricalSchemes.defaultKey;\n      const colorSchemeExists = !!registryColorScheme;\n\n      const updateDashboardData = () => {\n        SupersetClient.put({\n          endpoint: `/api/v1/dashboard/${dashboardInfo.id}`,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            json_metadata: jsonStringify(metadata),\n          }),\n        }).catch(e => console.log(e));\n      };\n      const updateColorScheme = (scheme: string) => {\n        dispatch(setColorScheme(scheme));\n      };\n      const updateDashboard = () => {\n        dispatch(\n          dashboardInfoChanged({\n            metadata,\n          }),\n        );\n        updateDashboardData();\n      };\n      // selected color scheme does not exist anymore\n      // must fallback to the available default one\n      if (!colorSchemeExists) {\n        const updatedScheme =\n          defaultColorScheme?.toString() || 'supersetColors';\n        metadata.color_scheme = updatedScheme;\n        metadata.color_scheme_domain =\n          categoricalSchemes.get(defaultColorScheme)?.colors || [];\n\n        // reset shared_label_colors\n        // TODO: Requires regenerating the shared_label_colors after\n        // fixing a bug which affects their generation on dashboards with tabs\n        metadata.shared_label_colors = {};\n\n        updateColorScheme(updatedScheme);\n        updateDashboard();\n      } else {\n        // if this dashboard does not have a color_scheme_domain saved\n        // must create one and store it for the first time\n        if (colorSchemeExists && !colorSchemeDomain.length) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n          updateDashboard();\n        }\n        // if the color_scheme_domain is not the same as the registry domain\n        // must update the existing color_scheme_domain\n        if (\n          colorSchemeExists &&\n          colorSchemeDomain.length &&\n          registryColorSchemeDomain.toString() !== colorSchemeDomain.toString()\n        ) {\n          metadata.color_scheme_domain = registryColorSchemeDomain;\n\n          // reset shared_label_colors\n          // TODO: Requires regenerating the shared_label_colors after\n          // fixing a bug which affects their generation on dashboards with tabs\n          metadata.shared_label_colors = {};\n\n          updateColorScheme(colorScheme);\n          updateDashboard();\n        }\n      }\n    }\n  }, [chartIds]);\n\n  useComponentDidUpdate(verifyUpdateColorScheme);\n\n  const childIds: string[] = topLevelTabs\n    ? topLevelTabs.children\n    : [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n\n  return (\n    <div className=\"grid-container\" data-test=\"grid-container\">\n      <ParentSize>\n        {({ width }) => (\n          /*\n            We use a TabContainer irrespective of whether top-level tabs exist to maintain\n            a consistent React component tree. This avoids expensive mounts/unmounts of\n            the entire dashboard upon adding/removing top-level tabs, which would otherwise\n            happen because of React's diffing algorithm\n          */\n          <Tabs\n            id={DASHBOARD_GRID_ID}\n            activeKey={activeKey}\n            renderTabBar={() => <></>}\n            fullWidth={false}\n            animated={false}\n            allowOverflow\n          >\n            {childIds.map((id, index) => (\n              // Matching the key of the first TabPane irrespective of topLevelTabs\n              // lets us keep the same React component tree when !!topLevelTabs changes.\n              // This avoids expensive mounts/unmounts of the entire dashboard.\n              <Tabs.TabPane\n                key={index === 0 ? DASHBOARD_GRID_ID : index.toString()}\n              >\n                <DashboardGrid\n                  gridComponent={dashboardLayout[id]}\n                  // see isValidChild for why tabs do not increment the depth of their children\n                  depth={DASHBOARD_ROOT_DEPTH + 1} // (topLevelTabs ? 0 : 1)}\n                  width={width}\n                  isComponentVisible={index === tabIndex}\n                />\n              </Tabs.TabPane>\n            ))}\n          </Tabs>\n        )}\n      </ParentSize>\n    </div>\n  );\n};\n\nexport default DashboardContainer;\n"]},"metadata":{},"sourceType":"module"}