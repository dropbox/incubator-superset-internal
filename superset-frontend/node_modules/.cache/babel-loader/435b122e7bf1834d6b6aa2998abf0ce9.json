{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t } from '../translation';\nimport { removeDuplicates } from '../utils';\nimport { DTTM_ALIAS } from './constants';\nimport getColumnLabel from './getColumnLabel';\nimport getMetricLabel from './getMetricLabel';\nimport { QueryMode } from './types/QueryFormData';\nimport { hasGenericChartAxes } from './getXAxis';\n/**\n * Extra SQL query related fields from chart form data.\n * Consolidate field values into arrays.\n *\n * @param formData - the (partial) form data obtained from chart controls.\n * @param aliases - additional field aliases that maps arbitrary field names to\n *                  query field names.\n */\nexport default function extractQueryFields(formData, aliases) {\n  const queryFieldAliases = {\n    /** These are predefined for backward compatibility */\n    metric: 'metrics',\n    metric_2: 'metrics',\n    secondary_metric: 'metrics',\n    x: 'metrics',\n    y: 'metrics',\n    size: 'metrics',\n    all_columns: 'columns',\n    series: 'groupby',\n    order_by_cols: 'orderby',\n    ...aliases };\n\n  const { query_mode: queryMode, include_time: includeTime, ...restFormData } = formData;\n  let columns = [];\n  let metrics = [];\n  let orderby = [];\n  Object.entries(restFormData).forEach((_ref) => {let [key, value] = _ref;\n    // ignore `null` or `undefined` value\n    if (value == null) {\n      return;\n    }\n    let normalizedKey = queryFieldAliases[key] || key;\n    // ignore columns when (specifically) in aggregate mode.\n    // For charts that support both aggregate and raw records mode,\n    // we store both `groupby` and `columns` in `formData`, so users can\n    // switch between modes while retaining the selected options for each.\n    if (queryMode === QueryMode.aggregate && normalizedKey === 'columns') {\n      return;\n    }\n    // for the same reason, ignore groupby and metrics in raw records mode\n    if (queryMode === QueryMode.raw && (\n    normalizedKey === 'groupby' || normalizedKey === 'metrics')) {\n      return;\n    }\n    // groupby has been deprecated in QueryObject: https://github.com/apache/superset/pull/9366\n    if (normalizedKey === 'groupby') {\n      normalizedKey = 'columns';\n    }\n    if (normalizedKey === 'metrics') {\n      metrics = metrics.concat(value);\n    } else\n    if (normalizedKey === 'columns') {\n      // currently the columns field only accept pre-defined columns (string shortcut)\n      columns = columns.concat(value);\n    } else\n    if (normalizedKey === 'orderby') {\n      orderby = orderby.concat(value);\n    }\n  });\n  if (!hasGenericChartAxes && includeTime && !_includesInstanceProperty(columns).call(columns, DTTM_ALIAS)) {\n    columns.unshift(DTTM_ALIAS);\n  }\n  return {\n    columns: removeDuplicates(columns.filter((col) => col !== ''), getColumnLabel),\n    metrics: queryMode === QueryMode.raw ?\n    undefined :\n    removeDuplicates(metrics, getMetricLabel),\n    orderby: orderby.length > 0 ?\n    orderby.map((item) => {\n      // value can be in the format of `['[\"col1\", true]', '[\"col2\", false]'],\n      // where the option strings come directly from `order_by_choices`.\n      if (typeof item === 'string') {\n        try {\n          return JSON.parse(item);\n        }\n        catch (error) {\n          throw new Error(t('Found invalid orderby options'));\n        }\n      }\n      return item;\n    }) :\n    undefined };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(extractQueryFields, \"extractQueryFields\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/query/extractQueryFields.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["t","removeDuplicates","DTTM_ALIAS","getColumnLabel","getMetricLabel","QueryMode","hasGenericChartAxes","extractQueryFields","formData","aliases","queryFieldAliases","metric","metric_2","secondary_metric","x","y","size","all_columns","series","order_by_cols","query_mode","queryMode","include_time","includeTime","restFormData","columns","metrics","orderby","Object","entries","forEach","key","value","normalizedKey","aggregate","raw","concat","unshift","filter","col","undefined","length","map","item","JSON","parse","error","Error"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/query/extractQueryFields.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t } from '../translation';\nimport { removeDuplicates } from '../utils';\nimport { DTTM_ALIAS } from './constants';\nimport getColumnLabel from './getColumnLabel';\nimport getMetricLabel from './getMetricLabel';\nimport {\n  QueryFields,\n  QueryFormColumn,\n  QueryFormMetric,\n  QueryFormOrderBy,\n  QueryFieldAliases,\n  FormDataResidual,\n  QueryMode,\n} from './types/QueryFormData';\nimport { hasGenericChartAxes } from './getXAxis';\n\n/**\n * Extra SQL query related fields from chart form data.\n * Consolidate field values into arrays.\n *\n * @param formData - the (partial) form data obtained from chart controls.\n * @param aliases - additional field aliases that maps arbitrary field names to\n *                  query field names.\n */\nexport default function extractQueryFields(\n  formData: FormDataResidual,\n  aliases?: QueryFieldAliases,\n): QueryFields {\n  const queryFieldAliases: QueryFieldAliases = {\n    /** These are predefined for backward compatibility */\n    metric: 'metrics',\n    metric_2: 'metrics',\n    secondary_metric: 'metrics',\n    x: 'metrics',\n    y: 'metrics',\n    size: 'metrics',\n    all_columns: 'columns',\n    series: 'groupby',\n    order_by_cols: 'orderby',\n    ...aliases,\n  };\n  const {\n    query_mode: queryMode,\n    include_time: includeTime,\n    ...restFormData\n  } = formData;\n\n  let columns: QueryFormColumn[] = [];\n  let metrics: QueryFormMetric[] = [];\n  let orderby: QueryFormOrderBy[] = [];\n\n  Object.entries(restFormData).forEach(([key, value]) => {\n    // ignore `null` or `undefined` value\n    if (value == null) {\n      return;\n    }\n\n    let normalizedKey: string = queryFieldAliases[key] || key;\n\n    // ignore columns when (specifically) in aggregate mode.\n    // For charts that support both aggregate and raw records mode,\n    // we store both `groupby` and `columns` in `formData`, so users can\n    // switch between modes while retaining the selected options for each.\n    if (queryMode === QueryMode.aggregate && normalizedKey === 'columns') {\n      return;\n    }\n\n    // for the same reason, ignore groupby and metrics in raw records mode\n    if (\n      queryMode === QueryMode.raw &&\n      (normalizedKey === 'groupby' || normalizedKey === 'metrics')\n    ) {\n      return;\n    }\n\n    // groupby has been deprecated in QueryObject: https://github.com/apache/superset/pull/9366\n    if (normalizedKey === 'groupby') {\n      normalizedKey = 'columns';\n    }\n\n    if (normalizedKey === 'metrics') {\n      metrics = metrics.concat(value);\n    } else if (normalizedKey === 'columns') {\n      // currently the columns field only accept pre-defined columns (string shortcut)\n      columns = columns.concat(value);\n    } else if (normalizedKey === 'orderby') {\n      orderby = orderby.concat(value);\n    }\n  });\n\n  if (!hasGenericChartAxes && includeTime && !columns.includes(DTTM_ALIAS)) {\n    columns.unshift(DTTM_ALIAS);\n  }\n\n  return {\n    columns: removeDuplicates(\n      columns.filter(col => col !== ''),\n      getColumnLabel,\n    ),\n    metrics:\n      queryMode === QueryMode.raw\n        ? undefined\n        : removeDuplicates(metrics, getMetricLabel),\n    orderby:\n      orderby.length > 0\n        ? orderby.map(item => {\n            // value can be in the format of `['[\"col1\", true]', '[\"col2\", false]'],\n            // where the option strings come directly from `order_by_choices`.\n            if (typeof item === 'string') {\n              try {\n                return JSON.parse(item);\n              } catch (error) {\n                throw new Error(t('Found invalid orderby options'));\n              }\n            }\n            return item;\n          })\n        : undefined,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}