{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getNumberFormatter, getMetricLabel, getColumnLabel } from '@superset-ui/core';\nimport range from 'lodash/range';\nimport { parseNumbersList } from '../utils/controls';\nimport { DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA } from './types';\nimport { defaultGaugeSeriesOption, INTERVAL_GAUGE_SERIES_OPTION, OFFSETS, FONT_SIZE_MULTIPLIERS } from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getColtypesMapping } from '../utils/series';\nconst setIntervalBoundsAndColors = (intervals, intervalColorIndices, colorFn, normalizer) => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  }\n  catch (error) {\n    intervalBoundsNonNormalized = [];\n    intervalColorIndicesArray = [];\n  }\n  const intervalBounds = intervalBoundsNonNormalized.map((bound) => bound / normalizer);\n  const intervalColors = intervalColorIndicesArray.map((ind) => colorFn.colors[(ind - 1) % colorFn.colors.length]);\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\nconst calculateAxisLineWidth = (data, fontSize, overlap) => overlap ? fontSize : data.length * fontSize;\nconst calculateMin = (data) => 2 * Math.min(...data.map((d) => d.value).concat([0]));\nconst calculateMax = (data) => 2 * Math.max(...data.map((d) => d.value).concat([0]));\nexport default function transformProps(chartProps) {var _queriesData$, _gaugeSeriesOptions$s, _gaugeSeriesOptions$s2, _gaugeSeriesOptions$a, _gaugeSeriesOptions$a2, _gaugeSeriesOptions$a3, _gaugeSeriesOptions$a4, _gaugeSeriesOptions$d;\n  const { width, height, formData, queriesData, hooks, filterState, theme, emitCrossFilters, datasource } = chartProps;\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const { verboseMap = {} } = datasource;\n  const { groupby, metric, minVal, maxVal, colorScheme, fontSize, numberFormat, animation, showProgress, overlap, roundCap, showAxisTick, showSplitLine, splitNumber, startAngle, endAngle, showPointer, intervals, intervalColorIndices, valueFormatter, sliceId } = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs = {};\n  const data = ((_queriesData$ = queriesData[0]) == null ? void 0 : _queriesData$.data) || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value) => valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle = FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle = FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map();\n  const transformedData = data.map((data_point, index) => {var _context;\n    const name = groupbyLabels.\n    map((column) => `${verboseMap[column] || column}: ${data_point[column]}`).\n    join(', ');\n    columnsLabelMap.set(name, groupbyLabels.map((col) => data_point[col]));\n    let item = {\n      value: data_point[getMetricLabel(metric)],\n      name,\n      itemStyle: {\n        color: colorFn(index, sliceId) },\n\n      title: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`],\n\n        fontSize },\n\n      detail: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle +\n        OFFSETS.titleFromCenter +\n        detailOffsetFromTitle}%`],\n\n        fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize } };\n\n\n    if (filterState.selectedValues &&\n    !_includesInstanceProperty(_context = filterState.selectedValues).call(_context, name)) {\n      item = {\n        ...item,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n          opacity: OpacityEnum.SemiTransparent },\n\n        detail: {\n          show: false },\n\n        title: {\n          show: false } };\n\n\n    }\n    return item;\n  });\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const min = minVal != null ? minVal : calculateMin(transformedData);\n  const max = maxVal != null ? maxVal : calculateMax(transformedData);\n  const axisLabels = range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(...axisLabels.map((label) => numberFormatter(label).length).concat([1]));\n  const normalizer = max;\n  const intervalBoundsAndColors = setIntervalBoundsAndColors(intervals, intervalColorIndices, colorFn, normalizer);\n  const splitLineDistance = axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance = FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n  fontSize *\n  FONT_SIZE_MULTIPLIERS.axisLabelLength *\n  axisLabelLength + (\n  showSplitLine ? splitLineLength : 0) + (\n  showAxisTick ? axisTickLength : 0) +\n  OFFSETS.ticksFromLine -\n  axisLineWidth;\n  const axisTickDistance = axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize };\n\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: (_gaugeSeriesOptions$s = gaugeSeriesOptions.splitLine) == null ? void 0 : (_gaugeSeriesOptions$s2 = _gaugeSeriesOptions$s.lineStyle) == null ? void 0 : _gaugeSeriesOptions$s2.color } };\n\n\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: (_gaugeSeriesOptions$a = gaugeSeriesOptions.axisLine) == null ? void 0 : (_gaugeSeriesOptions$a2 = _gaugeSeriesOptions$a.lineStyle) == null ? void 0 : _gaugeSeriesOptions$a2.color } };\n\n\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: (_gaugeSeriesOptions$a3 = gaugeSeriesOptions.axisLabel) == null ? void 0 : _gaugeSeriesOptions$a3.color };\n\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: (_gaugeSeriesOptions$a4 = gaugeSeriesOptions.axisTick) == null ? void 0 : _gaugeSeriesOptions$a4.lineStyle };\n\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value) => formatValue(value),\n    color: (_gaugeSeriesOptions$d = gaugeSeriesOptions.detail) == null ? void 0 : _gaugeSeriesOptions$d.color };\n\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params) => {\n      const { name, value } = params;\n      return `${name} : ${formatValue(value)}`;\n    } };\n\n  let pointer;\n  if (intervalBoundsAndColors.length) {var _INTERVAL_GAUGE_SERIE, _INTERVAL_GAUGE_SERIE2, _INTERVAL_GAUGE_SERIE3, _INTERVAL_GAUGE_SERIE4, _INTERVAL_GAUGE_SERIE5, _INTERVAL_GAUGE_SERIE6;\n    splitLine.lineStyle.color = (_INTERVAL_GAUGE_SERIE =\n    INTERVAL_GAUGE_SERIES_OPTION.splitLine) == null ? void 0 : (_INTERVAL_GAUGE_SERIE2 = _INTERVAL_GAUGE_SERIE.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE2.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION == null ? void 0 : (_INTERVAL_GAUGE_SERIE3 = INTERVAL_GAUGE_SERIES_OPTION.axisTick) == null ? void 0 : (_INTERVAL_GAUGE_SERIE4 = _INTERVAL_GAUGE_SERIE3.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE4.\n    color;\n    axisLabel.color = (_INTERVAL_GAUGE_SERIE5 = INTERVAL_GAUGE_SERIES_OPTION.axisLabel) == null ? void 0 : _INTERVAL_GAUGE_SERIE5.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: (_INTERVAL_GAUGE_SERIE6 = INTERVAL_GAUGE_SERIES_OPTION.pointer) == null ? void 0 : _INTERVAL_GAUGE_SERIE6.itemStyle };\n\n  } else\n  {\n    pointer = {\n      show: showPointer,\n      showAbove: false };\n\n  }\n  const series = [\n  {\n    type: 'gauge',\n    startAngle,\n    endAngle,\n    min,\n    max,\n    progress,\n    animation,\n    axisLine: axisLine,\n    splitLine,\n    splitNumber,\n    axisLabel,\n    axisTick,\n    pointer,\n    detail,\n    // @ts-ignore\n    tooltip,\n    radius: Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n    center: ['50%', '55%'],\n    data: transformedData }];\n\n\n  const echartOptions = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item' },\n\n    series };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(setIntervalBoundsAndColors, \"setIntervalBoundsAndColors\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateAxisLineWidth, \"calculateAxisLineWidth\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateMin, \"calculateMin\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateMax, \"calculateMax\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","getNumberFormatter","getMetricLabel","getColumnLabel","range","parseNumbersList","DEFAULT_FORM_DATA","DEFAULT_GAUGE_FORM_DATA","defaultGaugeSeriesOption","INTERVAL_GAUGE_SERIES_OPTION","OFFSETS","FONT_SIZE_MULTIPLIERS","OpacityEnum","getDefaultTooltip","getColtypesMapping","setIntervalBoundsAndColors","intervals","intervalColorIndices","colorFn","normalizer","intervalBoundsNonNormalized","intervalColorIndicesArray","error","intervalBounds","map","bound","intervalColors","colors","ind","length","val","idx","color","calculateAxisLineWidth","data","fontSize","overlap","calculateMin","Math","min","d","value","concat","calculateMax","max","transformProps","chartProps","width","height","formData","queriesData","hooks","filterState","theme","emitCrossFilters","datasource","gaugeSeriesOptions","verboseMap","groupby","metric","minVal","maxVal","colorScheme","numberFormat","animation","showProgress","roundCap","showAxisTick","showSplitLine","splitNumber","startAngle","endAngle","showPointer","valueFormatter","sliceId","refs","coltypeMapping","numberFormatter","getScale","axisLineWidth","groupbyLabels","formatValue","replace","axisTickLength","splitLineLength","titleOffsetFromTitle","detailOffsetFromTitle","columnsLabelMap","Map","transformedData","data_point","index","name","column","join","set","col","item","itemStyle","title","offsetCenter","titleFromCenter","detail","detailFontSize","selectedValues","opacity","SemiTransparent","show","setDataMask","onContextMenu","axisLabels","axisLabelLength","label","intervalBoundsAndColors","splitLineDistance","ticksFromLine","axisLabelDistance","axisTickDistance","progress","splitLine","distance","lineStyle","splitLineWidth","axisLine","axisLabel","formatter","axisTick","valueAnimation","tooltip","params","pointer","showAbove","series","type","radius","center","echartOptions","trigger","labelMap","Object","fromEntries"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  QueryFormMetric,\n  CategoricalColorNamespace,\n  CategoricalColorScale,\n  DataRecord,\n  getNumberFormatter,\n  getMetricLabel,\n  getColumnLabel,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, GaugeSeriesOption } from 'echarts';\nimport { GaugeDataItemOption } from 'echarts/types/src/chart/gauge/GaugeSeries';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport range from 'lodash/range';\nimport { parseNumbersList } from '../utils/controls';\nimport {\n  DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA,\n  EchartsGaugeFormData,\n  AxisTickLineStyle,\n  GaugeChartTransformedProps,\n  EchartsGaugeChartProps,\n} from './types';\nimport {\n  defaultGaugeSeriesOption,\n  INTERVAL_GAUGE_SERIES_OPTION,\n  OFFSETS,\n  FONT_SIZE_MULTIPLIERS,\n} from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\nimport { getColtypesMapping } from '../utils/series';\n\nconst setIntervalBoundsAndColors = (\n  intervals: string,\n  intervalColorIndices: string,\n  colorFn: CategoricalColorScale,\n  normalizer: number,\n): Array<[number, string]> => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  } catch (error) {\n    intervalBoundsNonNormalized = [] as number[];\n    intervalColorIndicesArray = [] as number[];\n  }\n\n  const intervalBounds = intervalBoundsNonNormalized.map(\n    bound => bound / normalizer,\n  );\n  const intervalColors = intervalColorIndicesArray.map(\n    ind => colorFn.colors[(ind - 1) % colorFn.colors.length],\n  );\n\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\n\nconst calculateAxisLineWidth = (\n  data: DataRecord[],\n  fontSize: number,\n  overlap: boolean,\n): number => (overlap ? fontSize : data.length * fontSize);\n\nconst calculateMin = (data: GaugeDataItemOption[]) =>\n  2 * Math.min(...data.map(d => d.value as number).concat([0]));\n\nconst calculateMax = (data: GaugeDataItemOption[]) =>\n  2 * Math.max(...data.map(d => d.value as number).concat([0]));\n\nexport default function transformProps(\n  chartProps: EchartsGaugeChartProps,\n): GaugeChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    theme,\n    emitCrossFilters,\n    datasource,\n  } = chartProps;\n\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const { verboseMap = {} } = datasource;\n  const {\n    groupby,\n    metric,\n    minVal,\n    maxVal,\n    colorScheme,\n    fontSize,\n    numberFormat,\n    animation,\n    showProgress,\n    overlap,\n    roundCap,\n    showAxisTick,\n    showSplitLine,\n    splitNumber,\n    startAngle,\n    endAngle,\n    showPointer,\n    intervals,\n    intervalColorIndices,\n    valueFormatter,\n    sliceId,\n  }: EchartsGaugeFormData = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs: Refs = {};\n  const data = (queriesData[0]?.data || []) as DataRecord[];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value: number) =>\n    valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map<string, string[]>();\n\n  const transformedData: GaugeDataItemOption[] = data.map(\n    (data_point, index) => {\n      const name = groupbyLabels\n        .map(column => `${verboseMap[column] || column}: ${data_point[column]}`)\n        .join(', ');\n      columnsLabelMap.set(\n        name,\n        groupbyLabels.map(col => data_point[col] as string),\n      );\n      let item: GaugeDataItemOption = {\n        value: data_point[getMetricLabel(metric as QueryFormMetric)] as number,\n        name,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n        },\n        title: {\n          offsetCenter: [\n            '0%',\n            `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`,\n          ],\n          fontSize,\n        },\n        detail: {\n          offsetCenter: [\n            '0%',\n            `${\n              index * titleOffsetFromTitle +\n              OFFSETS.titleFromCenter +\n              detailOffsetFromTitle\n            }%`,\n          ],\n          fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize,\n        },\n      };\n      if (\n        filterState.selectedValues &&\n        !filterState.selectedValues.includes(name)\n      ) {\n        item = {\n          ...item,\n          itemStyle: {\n            color: colorFn(index, sliceId),\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          detail: {\n            show: false,\n          },\n          title: {\n            show: false,\n          },\n        };\n      }\n      return item;\n    },\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n\n  const min = minVal ?? calculateMin(transformedData);\n  const max = maxVal ?? calculateMax(transformedData);\n  const axisLabels = range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(\n    ...axisLabels.map(label => numberFormatter(label).length).concat([1]),\n  );\n  const normalizer = max;\n  const intervalBoundsAndColors = setIntervalBoundsAndColors(\n    intervals,\n    intervalColorIndices,\n    colorFn,\n    normalizer,\n  );\n  const splitLineDistance =\n    axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance =\n    FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n      fontSize *\n      FONT_SIZE_MULTIPLIERS.axisLabelLength *\n      axisLabelLength +\n    (showSplitLine ? splitLineLength : 0) +\n    (showAxisTick ? axisTickLength : 0) +\n    OFFSETS.ticksFromLine -\n    axisLineWidth;\n  const axisTickDistance =\n    axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize,\n  };\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: gaugeSeriesOptions.splitLine?.lineStyle?.color,\n    },\n  };\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: gaugeSeriesOptions.axisLine?.lineStyle?.color,\n    },\n  };\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: gaugeSeriesOptions.axisLabel?.color,\n  };\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: gaugeSeriesOptions.axisTick?.lineStyle as AxisTickLineStyle,\n  };\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value: number) => formatValue(value),\n    color: gaugeSeriesOptions.detail?.color,\n  };\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params: CallbackDataParams) => {\n      const { name, value } = params;\n      return `${name} : ${formatValue(value as number)}`;\n    },\n  };\n\n  let pointer;\n  if (intervalBoundsAndColors.length) {\n    splitLine.lineStyle.color =\n      INTERVAL_GAUGE_SERIES_OPTION.splitLine?.lineStyle?.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION?.axisTick?.lineStyle\n      ?.color as string;\n    axisLabel.color = INTERVAL_GAUGE_SERIES_OPTION.axisLabel?.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: INTERVAL_GAUGE_SERIES_OPTION.pointer?.itemStyle,\n    };\n  } else {\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n    };\n  }\n\n  const series: GaugeSeriesOption[] = [\n    {\n      type: 'gauge',\n      startAngle,\n      endAngle,\n      min,\n      max,\n      progress,\n      animation,\n      axisLine: axisLine as GaugeSeriesOption['axisLine'],\n      splitLine,\n      splitNumber,\n      axisLabel,\n      axisTick,\n      pointer,\n      detail,\n      // @ts-ignore\n      tooltip,\n      radius:\n        Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n      center: ['50%', '55%'],\n      data: transformedData,\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n    },\n    series,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}