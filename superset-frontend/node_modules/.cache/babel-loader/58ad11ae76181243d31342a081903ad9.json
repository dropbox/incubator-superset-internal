{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getSequentialSchemeRegistry, getTimeFormatter, NumberFormats, t } from '@superset-ui/core';\nimport { OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder } from '../utils/treeBuilder';\nimport { EchartsSunburstLabelType } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function getLinearDomain(treeData, callback) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree) {\n    tree.forEach((treeNode) => {var _treeNode$children;\n      if ((_treeNode$children = treeNode.children) != null && _treeNode$children.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp)\n        min = temp;\n        if (max < temp)\n        max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\nexport function formatLabel(_ref) {let { params, labelType, numberFormatter } = _ref;\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;}\n\n}\nexport function formatTooltip(_ref2) {let { params, numberFormatter, colorByCategory, totalValue, metricLabel, secondaryMetricLabel, theme } = _ref2;\n  const { data, treePathInfo = [] } = params;\n  const node = data;\n  const formattedValue = numberFormatter(node.value);\n  const formattedSecondaryValue = numberFormatter(node.secondaryValue);\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(node.secondaryValue / node.value);\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode = treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n  const result = [\n  `<div style=\"\n      font-size: ${theme.typography.sizes.m}px;\n      color: ${theme.colors.grayscale.base}\"\n     >`,\n  `<div style=\"font-weight: ${theme.typography.weights.bold}\">\n      ${node.name}\n     </div>`,\n  `<div\">\n      ${absolutePercentage} of total\n     </div>`];\n\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(node.value / parentNode.value);\n    result.push(`\n    <div>\n      ${conditionalPercentage} of ${parentNode.name}\n    </div>`);\n  }\n  result.push(`<div>\n    ${metricLabel}: ${formattedValue}${colorByCategory ?\n  '' :\n  `, ${secondaryMetricLabel}: ${formattedSecondaryValue}`}\n     </div>`, colorByCategory ?\n  '' :\n  `<div>${metricLabel}/${secondaryMetricLabel}: ${compareValuePercentage}</div>`);\n  result.push('</div>');\n  return result.join('\\n');\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { groupby = [], columns = [], metric = '', secondaryMetric = '', colorScheme, linearColorScheme, labelType, numberFormat, dateFormat, showLabels, showLabelsThreshold, showTotal, sliceId } = formData;\n  const refs = {};\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter,\n    labelType });\n\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit };\n\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric ?\n  getMetricLabel(secondaryMetric) :\n  undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(data, columnLabels, metricLabel, secondaryMetricLabel);\n  const totalValue = treeData.reduce((result, treeNode) => result + treeNode.value, 0);\n  const totalSecondaryValue = treeData.reduce((result, treeNode) => result + treeNode.secondaryValue, 0);\n  const categoricalColorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let linearColorScale;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {var _getSequentialSchemeR, _getSequentialSchemeR2;\n    const domain = getLinearDomain(treeData, (node) => node.secondaryValue / node.value);\n    colorByCategory = false;\n    linearColorScale = (_getSequentialSchemeR = getSequentialSchemeRegistry()) == null ? void 0 : (_getSequentialSchemeR2 = _getSequentialSchemeR.\n    get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR2.\n    createLinearScale(domain);\n  }\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else\n  {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n  const traverse = (treeNodes, path, pathRecords) => treeNodes.map((treeNode) => {var _treeNode$children2, _filterState$selected, _filterState$selected2;\n    const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n    const records = [...(pathRecords || []), nodeName];\n    let name = formatSeriesName(nodeName, {\n      numberFormatter,\n      timeFormatter: getTimeFormatter(dateFormat),\n      ...(coltypeMapping[groupBy] && {\n        coltype: coltypeMapping[groupBy] }) });\n\n\n    const newPath = path.concat(name);\n    let item = {\n      records,\n      name,\n      value,\n      secondaryValue,\n      itemStyle: {\n        color: colorByCategory ?\n        categoricalColorScale(name, sliceId) :\n        linearColorScale(secondaryValue / value) } };\n\n\n    if ((_treeNode$children2 = treeNode.children) != null && _treeNode$children2.length) {\n      item.children = traverse(treeNode.children, newPath, records);\n    } else\n    {\n      name = newPath.join(',');\n    }\n    columnsLabelMap.set(name, newPath);\n    if (((_filterState$selected = filterState.selectedValues) == null ? void 0 : (_filterState$selected2 = _filterState$selected[0]) == null ? void 0 : _includesInstanceProperty(_filterState$selected2).call(_filterState$selected2, name)) === false) {\n      item = {\n        ...item,\n        itemStyle: {\n          ...item.itemStyle,\n          opacity: OpacityEnum.SemiTransparent },\n\n        label: {\n          color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})` } };\n\n\n    }\n    return item;\n  });\n  const echartOptions = {\n    grid: {\n      ...defaultGrid },\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => formatTooltip({\n        params,\n        numberFormatter,\n        colorByCategory,\n        totalValue,\n        metricLabel,\n        secondaryMetricLabel,\n        theme }) },\n\n\n    series: [\n    {\n      type: 'sunburst',\n      ...padding,\n      nodeClick: false,\n      emphasis: {\n        focus: 'ancestor',\n        label: {\n          show: showLabels } },\n\n\n      label: {\n        width: radius * 0.6 / (columns.length || 1),\n        show: showLabels,\n        formatter,\n        color: theme.colors.grayscale.dark2,\n        minAngle: minShowLabelAngle,\n        overflow: 'breakAll' },\n\n      radius: [radius * 0.3, radius],\n      data: traverse(treeData, []) }],\n\n\n    graphic: showTotal ?\n    {\n      type: 'text',\n      top: 'center',\n      left: 'center',\n      style: {\n        text: t('Total: %s', numberFormatter(totalValue)),\n        fontSize: 16,\n        fontWeight: 'bold' },\n\n      z: 10 } :\n\n    null };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getLinearDomain, \"getLinearDomain\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(formatLabel, \"formatLabel\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(formatTooltip, \"formatTooltip\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","getColumnLabel","getMetricLabel","getNumberFormatter","getSequentialSchemeRegistry","getTimeFormatter","NumberFormats","t","OpacityEnum","defaultGrid","formatSeriesName","getColtypesMapping","treeBuilder","EchartsSunburstLabelType","getDefaultTooltip","getLinearDomain","treeData","callback","min","max","temp","traverse","tree","forEach","treeNode","children","length","formatLabel","params","labelType","numberFormatter","name","value","formattedValue","Key","Value","KeyValue","formatTooltip","colorByCategory","totalValue","metricLabel","secondaryMetricLabel","theme","data","treePathInfo","node","formattedSecondaryValue","secondaryValue","percentFormatter","PERCENT_2_POINT","compareValuePercentage","absolutePercentage","parentNode","undefined","result","typography","sizes","m","colors","grayscale","base","weights","bold","conditionalPercentage","push","join","transformProps","chartProps","formData","height","hooks","filterState","queriesData","width","inContextMenu","emitCrossFilters","coltypeMapping","groupby","columns","metric","secondaryMetric","colorScheme","linearColorScheme","numberFormat","dateFormat","showLabels","showLabelsThreshold","showTotal","sliceId","refs","formatter","minShowLabelAngle","padding","top","gridUnit","right","bottom","left","containerWidth","containerHeight","visWidth","visHeight","radius","Math","setDataMask","onContextMenu","columnsLabelMap","Map","columnLabels","map","reduce","totalSecondaryValue","categoricalColorScale","getScale","linearColorScale","domain","get","createLinearScale","treeNodes","path","pathRecords","nodeName","groupBy","records","timeFormatter","coltype","newPath","concat","item","itemStyle","color","set","selectedValues","opacity","SemiTransparent","label","echartOptions","grid","tooltip","show","trigger","series","type","nodeClick","emphasis","focus","dark2","minAngle","overflow","graphic","style","text","fontSize","fontWeight","z","labelMap","Object","fromEntries"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  DataRecordValue,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getSequentialSchemeRegistry,\n  getTimeFormatter,\n  NumberFormats,\n  NumberFormatter,\n  SupersetTheme,\n  t,\n} from '@superset-ui/core';\nimport { EChartsCoreOption } from 'echarts';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { Refs } from '../types';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder, TreeNode } from '../utils/treeBuilder';\nimport {\n  EchartsSunburstChartProps,\n  EchartsSunburstLabelType,\n  NodeItemOption,\n  SunburstTransformedProps,\n} from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function getLinearDomain(\n  treeData: TreeNode[],\n  callback: (treeNode: TreeNode) => number,\n) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree: TreeNode[]) {\n    tree.forEach(treeNode => {\n      if (treeNode.children?.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp) min = temp;\n        if (max < temp) max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\n\nexport function formatLabel({\n  params,\n  labelType,\n  numberFormatter,\n}: {\n  params: CallbackDataParams;\n  labelType: EchartsSunburstLabelType;\n  numberFormatter: NumberFormatter;\n}): string {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value as number);\n\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\n\nexport function formatTooltip({\n  params,\n  numberFormatter,\n  colorByCategory,\n  totalValue,\n  metricLabel,\n  secondaryMetricLabel,\n  theme,\n}: {\n  params: CallbackDataParams & {\n    treePathInfo: {\n      name: string;\n      dataIndex: number;\n      value: number;\n    }[];\n  };\n  numberFormatter: NumberFormatter;\n  colorByCategory: boolean;\n  totalValue: number;\n  metricLabel: string;\n  secondaryMetricLabel?: string;\n  theme: SupersetTheme;\n}): string {\n  const { data, treePathInfo = [] } = params;\n  const node = data as TreeNode;\n  const formattedValue = numberFormatter(node.value);\n  const formattedSecondaryValue = numberFormatter(node.secondaryValue);\n\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(\n    node.secondaryValue / node.value,\n  );\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode =\n    treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n\n  const result = [\n    `<div style=\"\n      font-size: ${theme.typography.sizes.m}px;\n      color: ${theme.colors.grayscale.base}\"\n     >`,\n    `<div style=\"font-weight: ${theme.typography.weights.bold}\">\n      ${node.name}\n     </div>`,\n    `<div\">\n      ${absolutePercentage} of total\n     </div>`,\n  ];\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(\n      node.value / parentNode.value,\n    );\n    result.push(`\n    <div>\n      ${conditionalPercentage} of ${parentNode.name}\n    </div>`);\n  }\n  result.push(\n    `<div>\n    ${metricLabel}: ${formattedValue}${\n      colorByCategory\n        ? ''\n        : `, ${secondaryMetricLabel}: ${formattedSecondaryValue}`\n    }\n     </div>`,\n    colorByCategory\n      ? ''\n      : `<div>${metricLabel}/${secondaryMetricLabel}: ${compareValuePercentage}</div>`,\n  );\n  result.push('</div>');\n  return result.join('\\n');\n}\n\nexport default function transformProps(\n  chartProps: EchartsSunburstChartProps,\n): SunburstTransformedProps {\n  const {\n    formData,\n    height,\n    hooks,\n    filterState,\n    queriesData,\n    width,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    groupby = [],\n    columns = [],\n    metric = '',\n    secondaryMetric = '',\n    colorScheme,\n    linearColorScheme,\n    labelType,\n    numberFormat,\n    dateFormat,\n    showLabels,\n    showLabelsThreshold,\n    showTotal,\n    sliceId,\n  } = formData;\n  const refs: Refs = {};\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params: CallbackDataParams) =>\n    formatLabel({\n      params,\n      numberFormatter,\n      labelType,\n    });\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit,\n  };\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map<string, string[]>();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric\n    ? getMetricLabel(secondaryMetric)\n    : undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(\n    data,\n    columnLabels,\n    metricLabel,\n    secondaryMetricLabel,\n  );\n  const totalValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.value,\n    0,\n  );\n  const totalSecondaryValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.secondaryValue,\n    0,\n  );\n\n  const categoricalColorScale = CategoricalColorNamespace.getScale(\n    colorScheme as string,\n  );\n  let linearColorScale: any;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {\n    const domain = getLinearDomain(\n      treeData,\n      node => node.secondaryValue / node.value,\n    );\n    colorByCategory = false;\n    linearColorScale = getSequentialSchemeRegistry()\n      ?.get(linearColorScheme)\n      ?.createLinearScale(domain);\n  }\n\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n\n  const traverse = (\n    treeNodes: TreeNode[],\n    path: string[],\n    pathRecords?: DataRecordValue[],\n  ) =>\n    treeNodes.map(treeNode => {\n      const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n      const records = [...(pathRecords || []), nodeName];\n      let name = formatSeriesName(nodeName, {\n        numberFormatter,\n        timeFormatter: getTimeFormatter(dateFormat),\n        ...(coltypeMapping[groupBy] && {\n          coltype: coltypeMapping[groupBy],\n        }),\n      });\n      const newPath = path.concat(name);\n      let item: NodeItemOption = {\n        records,\n        name,\n        value,\n        secondaryValue,\n        itemStyle: {\n          color: colorByCategory\n            ? categoricalColorScale(name, sliceId)\n            : linearColorScale(secondaryValue / value),\n        },\n      };\n      if (treeNode.children?.length) {\n        item.children = traverse(treeNode.children, newPath, records);\n      } else {\n        name = newPath.join(',');\n      }\n      columnsLabelMap.set(name, newPath);\n      if (filterState.selectedValues?.[0]?.includes(name) === false) {\n        item = {\n          ...item,\n          itemStyle: {\n            ...item.itemStyle,\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          label: {\n            color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`,\n          },\n        };\n      }\n      return item;\n    });\n\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          numberFormatter,\n          colorByCategory,\n          totalValue,\n          metricLabel,\n          secondaryMetricLabel,\n          theme,\n        }),\n    },\n    series: [\n      {\n        type: 'sunburst',\n        ...padding,\n        nodeClick: false,\n        emphasis: {\n          focus: 'ancestor',\n          label: {\n            show: showLabels,\n          },\n        },\n        label: {\n          width: (radius * 0.6) / (columns.length || 1),\n          show: showLabels,\n          formatter,\n          color: theme.colors.grayscale.dark2,\n          minAngle: minShowLabelAngle,\n          overflow: 'breakAll',\n        },\n        radius: [radius * 0.3, radius],\n        data: traverse(treeData, []),\n      },\n    ],\n    graphic: showTotal\n      ? {\n          type: 'text',\n          top: 'center',\n          left: 'center',\n          style: {\n            text: t('Total: %s', numberFormatter(totalValue)),\n            fontSize: 16,\n            fontWeight: 'bold',\n          },\n          z: 10,\n        }\n      : null,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}