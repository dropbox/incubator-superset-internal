{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useRef, useState } from 'react';\nimport { styled, t, useComponentDidUpdate } from '@superset-ui/core';\nimport { Radio } from 'src/components/Radio';\nimport { AntdForm, Typography } from 'src/components';\nimport { ScopingType } from './types';\nimport ScopingTree from './ScopingTree';\nimport { getDefaultScopeValue, isScopingAll } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  & > * {\n    margin-bottom: ${(_ref) => {let { theme } = _ref;return theme.gridUnit;}}px;\n  }\n  padding: 0px ${(_ref2) => {let { theme } = _ref2;return theme.gridUnit * 4;}}px;\n`;\nconst CleanFormItem = styled(AntdForm.Item)`\n  margin-bottom: 0;\n`;\nconst FilterScope = (_ref3) => {let { pathToFormValue = [], formScopingType, formFilterScope, forceUpdate, filterScope, updateFormValues, chartId, initiallyExcludedCharts } = _ref3;\n  const [initialFilterScope] = useState(filterScope || getDefaultScopeValue(chartId, initiallyExcludedCharts));\n  const lastSpecificScope = useRef(initialFilterScope);\n  const [initialScopingType] = useState(isScopingAll(initialFilterScope, chartId) ?\n  ScopingType.all :\n  ScopingType.specific);\n  const [hasScopeBeenModified, setHasScopeBeenModified] = useState(!!filterScope);\n  const onUpdateFormValues = useCallback((formValues) => {\n    if (formScopingType === ScopingType.specific) {\n      lastSpecificScope.current = formValues.scope;\n    }\n    updateFormValues(formValues);\n    setHasScopeBeenModified(true);\n  }, [formScopingType, updateFormValues]);\n  const updateScopes = useCallback(() => {\n    if (filterScope || hasScopeBeenModified) {\n      return;\n    }\n    const newScope = getDefaultScopeValue(chartId, initiallyExcludedCharts);\n    updateFormValues({\n      scope: newScope,\n      scoping: isScopingAll(newScope, chartId) ?\n      ScopingType.all :\n      ScopingType.specific });\n\n  }, [\n  chartId,\n  filterScope,\n  hasScopeBeenModified,\n  initiallyExcludedCharts,\n  updateFormValues]);\n\n  useComponentDidUpdate(updateScopes);\n  return ___EmotionJSX(Wrapper, null,\n  ___EmotionJSX(CleanFormItem, { name: [...pathToFormValue, 'scoping'], initialValue: initialScopingType },\n  ___EmotionJSX(Radio.Group, { onChange: (_ref4) => {let { target: { value } } = _ref4;\n      const scope = value === ScopingType.all ?\n      getDefaultScopeValue(chartId) :\n      lastSpecificScope.current;\n      updateFormValues({ scope });\n      setHasScopeBeenModified(true);\n      forceUpdate();\n    } },\n  ___EmotionJSX(Radio, { value: ScopingType.all }, t('Apply to all panels')),\n  ___EmotionJSX(Radio, { value: ScopingType.specific },\n  t('Apply to specific panels')))),\n\n\n\n  ___EmotionJSX(Typography.Text, { type: \"secondary\" },\n  (formScopingType != null ? formScopingType : initialScopingType) === ScopingType.specific ?\n  t('Only selected panels will be affected by this filter') :\n  t('All panels with this column will be affected by this filter')),\n\n  (formScopingType != null ? formScopingType : initialScopingType) === ScopingType.specific && ___EmotionJSX(ScopingTree, { updateFormValues: onUpdateFormValues, initialScope: initialFilterScope, formScope: formFilterScope, forceUpdate: forceUpdate, chartId: chartId, initiallyExcludedCharts: initiallyExcludedCharts }),\n  ___EmotionJSX(CleanFormItem, { name: [...pathToFormValue, 'scope'], hidden: true, initialValue: initialFilterScope }));\n\n};\nexport default FilterScope;","map":{"version":3,"mappings":"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","names":["React","useCallback","useRef","useState","styled","t","useComponentDidUpdate","Radio","AntdForm","Typography","ScopingType","ScopingTree","getDefaultScopeValue","isScopingAll","Wrapper","div","theme","gridUnit","CleanFormItem","Item","FilterScope","pathToFormValue","formScopingType","formFilterScope","forceUpdate","filterScope","updateFormValues","chartId","initiallyExcludedCharts","initialFilterScope","lastSpecificScope","initialScopingType","all","specific","hasScopeBeenModified","setHasScopeBeenModified","onUpdateFormValues","formValues","current","scope","updateScopes","newScope","scoping","target","value"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/FilterScope.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React, { FC, useCallback, useRef, useState } from 'react';\nimport {\n  NativeFilterScope,\n  styled,\n  t,\n  useComponentDidUpdate,\n} from '@superset-ui/core';\nimport { Radio } from 'src/components/Radio';\nimport { AntdForm, Typography } from 'src/components';\nimport { ScopingType } from './types';\nimport ScopingTree from './ScopingTree';\nimport { getDefaultScopeValue, isScopingAll } from './utils';\n\ntype FilterScopeProps = {\n  pathToFormValue?: string[];\n  updateFormValues: (values: any) => void;\n  formFilterScope?: NativeFilterScope;\n  forceUpdate: Function;\n  filterScope?: NativeFilterScope;\n  formScopingType?: ScopingType;\n  chartId?: number;\n  initiallyExcludedCharts?: number[];\n};\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  & > * {\n    margin-bottom: ${({ theme }) => theme.gridUnit}px;\n  }\n  padding: 0px ${({ theme }) => theme.gridUnit * 4}px;\n`;\n\nconst CleanFormItem = styled(AntdForm.Item)`\n  margin-bottom: 0;\n`;\n\nconst FilterScope: FC<FilterScopeProps> = ({\n  pathToFormValue = [],\n  formScopingType,\n  formFilterScope,\n  forceUpdate,\n  filterScope,\n  updateFormValues,\n  chartId,\n  initiallyExcludedCharts,\n}) => {\n  const [initialFilterScope] = useState(\n    filterScope || getDefaultScopeValue(chartId, initiallyExcludedCharts),\n  );\n  const lastSpecificScope = useRef(initialFilterScope);\n  const [initialScopingType] = useState(\n    isScopingAll(initialFilterScope, chartId)\n      ? ScopingType.all\n      : ScopingType.specific,\n  );\n  const [hasScopeBeenModified, setHasScopeBeenModified] = useState(\n    !!filterScope,\n  );\n\n  const onUpdateFormValues = useCallback(\n    (formValues: any) => {\n      if (formScopingType === ScopingType.specific) {\n        lastSpecificScope.current = formValues.scope;\n      }\n      updateFormValues(formValues);\n      setHasScopeBeenModified(true);\n    },\n    [formScopingType, updateFormValues],\n  );\n\n  const updateScopes = useCallback(() => {\n    if (filterScope || hasScopeBeenModified) {\n      return;\n    }\n\n    const newScope = getDefaultScopeValue(chartId, initiallyExcludedCharts);\n    updateFormValues({\n      scope: newScope,\n      scoping: isScopingAll(newScope, chartId)\n        ? ScopingType.all\n        : ScopingType.specific,\n    });\n  }, [\n    chartId,\n    filterScope,\n    hasScopeBeenModified,\n    initiallyExcludedCharts,\n    updateFormValues,\n  ]);\n  useComponentDidUpdate(updateScopes);\n\n  return (\n    <Wrapper>\n      <CleanFormItem\n        name={[...pathToFormValue, 'scoping']}\n        initialValue={initialScopingType}\n      >\n        <Radio.Group\n          onChange={({ target: { value } }) => {\n            const scope =\n              value === ScopingType.all\n                ? getDefaultScopeValue(chartId)\n                : lastSpecificScope.current;\n            updateFormValues({ scope });\n            setHasScopeBeenModified(true);\n            forceUpdate();\n          }}\n        >\n          <Radio value={ScopingType.all}>{t('Apply to all panels')}</Radio>\n          <Radio value={ScopingType.specific}>\n            {t('Apply to specific panels')}\n          </Radio>\n        </Radio.Group>\n      </CleanFormItem>\n      <Typography.Text type=\"secondary\">\n        {(formScopingType ?? initialScopingType) === ScopingType.specific\n          ? t('Only selected panels will be affected by this filter')\n          : t('All panels with this column will be affected by this filter')}\n      </Typography.Text>\n      {(formScopingType ?? initialScopingType) === ScopingType.specific && (\n        <ScopingTree\n          updateFormValues={onUpdateFormValues}\n          initialScope={initialFilterScope}\n          formScope={formFilterScope}\n          forceUpdate={forceUpdate}\n          chartId={chartId}\n          initiallyExcludedCharts={initiallyExcludedCharts}\n        />\n      )}\n      <CleanFormItem\n        name={[...pathToFormValue, 'scope']}\n        hidden\n        initialValue={initialFilterScope}\n      />\n    </Wrapper>\n  );\n};\n\nexport default FilterScope;\n"]},"metadata":{},"sourceType":"module"}