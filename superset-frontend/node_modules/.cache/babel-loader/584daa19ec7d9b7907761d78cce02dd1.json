{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { css, styled, usePrevious } from '@superset-ui/core';\nimport { areArraysShallowEqual } from 'src/reduxUtils';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport { queryEditorSetSelectedText, queryEditorSetFunctionNames, addTable } from 'src/SqlLab/actions/sqlLab';\nimport { SCHEMA_AUTOCOMPLETE_SCORE, TABLE_AUTOCOMPLETE_SCORE, COLUMN_AUTOCOMPLETE_SCORE, SQL_FUNCTIONS_AUTOCOMPLETE_SCORE } from 'src/SqlLab/constants';\nimport { FullSQLEditor as AceEditor } from 'src/components/AsyncAceEditor';\nimport useQueryEditor from 'src/SqlLab/hooks/useQueryEditor';\nimport { useSchemas, useTables } from 'src/hooks/apiResources';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst StyledAceEditor = styled(AceEditor)`\n  ${(_ref) => {let { theme } = _ref;return css`\n    && {\n      // double class is better than !important\n      border: 1px solid ${theme.colors.grayscale.light2};\n      font-feature-settings: 'liga' off, 'calt' off;\n\n      &.ace_autocomplete {\n        // Use !important because Ace Editor applies extra CSS at the last second\n        // when opening the autocomplete.\n        width: ${theme.gridUnit * 130}px !important;\n      }\n\n      .ace_scroller {\n        background-color: ${theme.colors.grayscale.light4};\n      }\n    }\n  `;}}\n`;\nconst AceEditorWrapper = (_ref2) => {var _queryEditor$sql, _queryEditor$function, _tableData$options, _usePrevious, _usePrevious2, _usePrevious3;let { autocomplete, onBlur = () => {}, onChange = () => {}, queryEditorId, database, extendedTables = [], height, hotkeys } = _ref2;\n  const dispatch = useDispatch();\n  const queryEditor = useQueryEditor(queryEditorId, [\n  'id',\n  'dbId',\n  'sql',\n  'functionNames',\n  'validationResult',\n  'schema']);\n\n  const { data: schemaOptions } = useSchemas({\n    ...(autocomplete && { dbId: queryEditor.dbId }) });\n\n  const { data: tableData } = useTables({\n    ...(autocomplete && {\n      dbId: queryEditor.dbId,\n      schema: queryEditor.schema }) });\n\n\n  const currentSql = (_queryEditor$sql = queryEditor.sql) != null ? _queryEditor$sql : '';\n  const functionNames = (_queryEditor$function = queryEditor.functionNames) != null ? _queryEditor$function : [];\n  // Loading schema, table and column names as auto-completable words\n  const { schemas, schemaWords } = useMemo(() => ({\n    schemas: schemaOptions != null ? schemaOptions : [],\n    schemaWords: (schemaOptions != null ? schemaOptions : []).map((s) => ({\n      name: s.label,\n      value: s.value,\n      score: SCHEMA_AUTOCOMPLETE_SCORE,\n      meta: 'schema' })) }),\n\n  [schemaOptions]);\n  const tables = (_tableData$options = tableData == null ? void 0 : tableData.options) != null ? _tableData$options : [];\n  const [sql, setSql] = useState(currentSql);\n  const [words, setWords] = useState([]);\n  // The editor changeSelection is called multiple times in a row,\n  // faster than React reconciliation process, so the selected text\n  // needs to be stored out of the state to ensure changes to it\n  // get saved immediately\n  const currentSelectionCache = useRef('');\n  useEffect(() => {\n    // Making sure no text is selected from previous mount\n    dispatch(queryEditorSetSelectedText(queryEditor, null));\n    if (queryEditor.dbId) {\n      dispatch(queryEditorSetFunctionNames(queryEditor, queryEditor.dbId));\n    }\n    setAutoCompleter();\n  }, []);\n  const prevTables = (_usePrevious = usePrevious(tables)) != null ? _usePrevious : [];\n  const prevSchemas = (_usePrevious2 = usePrevious(schemas)) != null ? _usePrevious2 : [];\n  const prevExtendedTables = (_usePrevious3 = usePrevious(extendedTables)) != null ? _usePrevious3 : [];\n  const prevSql = usePrevious(currentSql);\n  useEffect(() => {\n    if (!areArraysShallowEqual(tables, prevTables) ||\n    !areArraysShallowEqual(schemas, prevSchemas) ||\n    !areArraysShallowEqual(extendedTables, prevExtendedTables)) {\n      setAutoCompleter();\n    }\n  }, [tables, schemas, extendedTables]);\n  useEffect(() => {\n    if (currentSql !== prevSql) {\n      setSql(currentSql);\n    }\n  }, [currentSql]);\n  const onBlurSql = () => {\n    onBlur(sql);\n  };\n  const onAltEnter = () => {\n    onBlur(sql);\n  };\n  const onEditorLoad = (editor) => {\n    editor.commands.addCommand({\n      name: 'runQuery',\n      bindKey: { win: 'Alt-enter', mac: 'Alt-enter' },\n      exec: () => {\n        onAltEnter();\n      } });\n\n    hotkeys.forEach((keyConfig) => {\n      editor.commands.addCommand({\n        name: keyConfig.name,\n        bindKey: { win: keyConfig.key, mac: keyConfig.key },\n        exec: keyConfig.func });\n\n    });\n    editor.$blockScrolling = Infinity; // eslint-disable-line no-param-reassign\n    editor.selection.on('changeSelection', () => {\n      const selectedText = editor.getSelectedText();\n      // Backspace trigger 1 character selection, ignoring\n      if (selectedText !== currentSelectionCache.current &&\n      selectedText.length !== 1) {\n        dispatch(queryEditorSetSelectedText(queryEditor, selectedText));\n      }\n      currentSelectionCache.current = selectedText;\n    });\n  };\n  const onChangeText = (text) => {\n    setSql(text);\n    onChange(text);\n  };\n  function setAutoCompleter() {\n    const columns = {};\n    const tableWords = tables.map((t) => {\n      const tableName = t.value;\n      const extendedTable = extendedTables.find((et) => et.name === tableName);\n      const cols = (extendedTable == null ? void 0 : extendedTable.columns) || [];\n      cols.forEach((col) => {\n        columns[col.name] = null; // using an object as a unique set\n      });\n      return {\n        name: t.label,\n        value: tableName,\n        score: TABLE_AUTOCOMPLETE_SCORE,\n        meta: 'table' };\n\n    });\n    const columnWords = Object.keys(columns).map((col) => ({\n      name: col,\n      value: col,\n      score: COLUMN_AUTOCOMPLETE_SCORE,\n      meta: 'column' }));\n\n    const functionWords = functionNames.map((func) => ({\n      name: func,\n      value: func,\n      score: SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n      meta: 'function' }));\n\n    const completer = {\n      insertMatch: (editor, data) => {var _context;\n        if (data.meta === 'table') {\n          dispatch(addTable(queryEditor, database, data.value, queryEditor.schema));\n        }\n        let { caption } = data;\n        if (data.meta === 'table' && _includesInstanceProperty(caption).call(caption, ' ')) {\n          caption = `\"${caption}\"`;\n        }\n        // executing https://github.com/thlorenz/brace/blob/3a00c5d59777f9d826841178e1eb36694177f5e6/ext/language_tools.js#L1448\n        editor.completer.insertMatch(`${caption}${_includesInstanceProperty(_context = ['function', 'schema']).call(_context, data.meta) ? '' : ' '}`);\n      } };\n\n    const words = schemaWords.\n    concat(tableWords).\n    concat(columnWords).\n    concat(functionWords).\n    concat(sqlKeywords).\n    map((word) => ({\n      ...word,\n      completer }));\n\n    setWords(words);\n  }\n  const getAceAnnotations = () => {var _validationResult$err;\n    const { validationResult } = queryEditor;\n    const resultIsReady = validationResult == null ? void 0 : validationResult.completed;\n    if (resultIsReady && validationResult != null && (_validationResult$err = validationResult.errors) != null && _validationResult$err.length) {\n      const errors = validationResult.errors.map((err) => ({\n        type: 'error',\n        row: err.line_number - 1,\n        column: err.start_column - 1,\n        text: err.message }));\n\n      return errors;\n    }\n    return [];\n  };\n  return ___EmotionJSX(StyledAceEditor, { keywords: words, onLoad: onEditorLoad, onBlur: onBlurSql, height: height, onChange: onChangeText, width: \"100%\", editorProps: { $blockScrolling: true }, enableLiveAutocompletion: autocomplete, value: sql, annotations: getAceAnnotations() });\n};\nexport default AceEditorWrapper;","map":{"version":3,"mappings":"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","names":["React","useState","useEffect","useRef","useMemo","useDispatch","css","styled","usePrevious","areArraysShallowEqual","sqlKeywords","queryEditorSetSelectedText","queryEditorSetFunctionNames","addTable","SCHEMA_AUTOCOMPLETE_SCORE","TABLE_AUTOCOMPLETE_SCORE","COLUMN_AUTOCOMPLETE_SCORE","SQL_FUNCTIONS_AUTOCOMPLETE_SCORE","FullSQLEditor","AceEditor","useQueryEditor","useSchemas","useTables","StyledAceEditor","theme","colors","grayscale","light2","gridUnit","light4","AceEditorWrapper","autocomplete","onBlur","onChange","queryEditorId","database","extendedTables","height","hotkeys","dispatch","queryEditor","data","schemaOptions","dbId","tableData","schema","currentSql","sql","functionNames","schemas","schemaWords","map","name","s","label","value","score","meta","tables","options","setSql","words","setWords","currentSelectionCache","setAutoCompleter","prevTables","prevSchemas","prevExtendedTables","prevSql","onBlurSql","onAltEnter","onEditorLoad","editor","commands","addCommand","bindKey","win","mac","exec","forEach","keyConfig","key","func","$blockScrolling","Infinity","selection","on","selectedText","getSelectedText","current","length","onChangeText","text","columns","tableWords","tableName","t","extendedTable","find","et","cols","col","columnWords","Object","keys","functionWords","completer","insertMatch","caption","concat","word","getAceAnnotations","validationResult","resultIsReady","completed","errors","err","type","row","line_number","column","start_column","message"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/SqlLab/components/AceEditorWrapper/index.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { css, styled, usePrevious } from '@superset-ui/core';\n\nimport { areArraysShallowEqual } from 'src/reduxUtils';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport {\n  queryEditorSetSelectedText,\n  queryEditorSetFunctionNames,\n  addTable,\n} from 'src/SqlLab/actions/sqlLab';\nimport {\n  SCHEMA_AUTOCOMPLETE_SCORE,\n  TABLE_AUTOCOMPLETE_SCORE,\n  COLUMN_AUTOCOMPLETE_SCORE,\n  SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n} from 'src/SqlLab/constants';\nimport {\n  Editor,\n  AceCompleterKeyword,\n  FullSQLEditor as AceEditor,\n} from 'src/components/AsyncAceEditor';\nimport useQueryEditor from 'src/SqlLab/hooks/useQueryEditor';\nimport { useSchemas, useTables } from 'src/hooks/apiResources';\n\ntype HotKey = {\n  key: string;\n  descr: string;\n  name: string;\n  func: () => void;\n};\n\ntype AceEditorWrapperProps = {\n  autocomplete: boolean;\n  onBlur: (sql: string) => void;\n  onChange: (sql: string) => void;\n  queryEditorId: string;\n  database: any;\n  extendedTables?: Array<{ name: string; columns: any[] }>;\n  height: string;\n  hotkeys: HotKey[];\n};\n\nconst StyledAceEditor = styled(AceEditor)`\n  ${({ theme }) => css`\n    && {\n      // double class is better than !important\n      border: 1px solid ${theme.colors.grayscale.light2};\n      font-feature-settings: 'liga' off, 'calt' off;\n\n      &.ace_autocomplete {\n        // Use !important because Ace Editor applies extra CSS at the last second\n        // when opening the autocomplete.\n        width: ${theme.gridUnit * 130}px !important;\n      }\n\n      .ace_scroller {\n        background-color: ${theme.colors.grayscale.light4};\n      }\n    }\n  `}\n`;\n\nconst AceEditorWrapper = ({\n  autocomplete,\n  onBlur = () => {},\n  onChange = () => {},\n  queryEditorId,\n  database,\n  extendedTables = [],\n  height,\n  hotkeys,\n}: AceEditorWrapperProps) => {\n  const dispatch = useDispatch();\n\n  const queryEditor = useQueryEditor(queryEditorId, [\n    'id',\n    'dbId',\n    'sql',\n    'functionNames',\n    'validationResult',\n    'schema',\n  ]);\n  const { data: schemaOptions } = useSchemas({\n    ...(autocomplete && { dbId: queryEditor.dbId }),\n  });\n  const { data: tableData } = useTables({\n    ...(autocomplete && {\n      dbId: queryEditor.dbId,\n      schema: queryEditor.schema,\n    }),\n  });\n\n  const currentSql = queryEditor.sql ?? '';\n  const functionNames = queryEditor.functionNames ?? [];\n\n  // Loading schema, table and column names as auto-completable words\n  const { schemas, schemaWords } = useMemo(\n    () => ({\n      schemas: schemaOptions ?? [],\n      schemaWords: (schemaOptions ?? []).map(s => ({\n        name: s.label,\n        value: s.value,\n        score: SCHEMA_AUTOCOMPLETE_SCORE,\n        meta: 'schema',\n      })),\n    }),\n    [schemaOptions],\n  );\n  const tables = tableData?.options ?? [];\n\n  const [sql, setSql] = useState(currentSql);\n  const [words, setWords] = useState<AceCompleterKeyword[]>([]);\n\n  // The editor changeSelection is called multiple times in a row,\n  // faster than React reconciliation process, so the selected text\n  // needs to be stored out of the state to ensure changes to it\n  // get saved immediately\n  const currentSelectionCache = useRef('');\n\n  useEffect(() => {\n    // Making sure no text is selected from previous mount\n    dispatch(queryEditorSetSelectedText(queryEditor, null));\n    if (queryEditor.dbId) {\n      dispatch(queryEditorSetFunctionNames(queryEditor, queryEditor.dbId));\n    }\n    setAutoCompleter();\n  }, []);\n\n  const prevTables = usePrevious(tables) ?? [];\n  const prevSchemas = usePrevious(schemas) ?? [];\n  const prevExtendedTables = usePrevious(extendedTables) ?? [];\n  const prevSql = usePrevious(currentSql);\n\n  useEffect(() => {\n    if (\n      !areArraysShallowEqual(tables, prevTables) ||\n      !areArraysShallowEqual(schemas, prevSchemas) ||\n      !areArraysShallowEqual(extendedTables, prevExtendedTables)\n    ) {\n      setAutoCompleter();\n    }\n  }, [tables, schemas, extendedTables]);\n\n  useEffect(() => {\n    if (currentSql !== prevSql) {\n      setSql(currentSql);\n    }\n  }, [currentSql]);\n\n  const onBlurSql = () => {\n    onBlur(sql);\n  };\n\n  const onAltEnter = () => {\n    onBlur(sql);\n  };\n\n  const onEditorLoad = (editor: any) => {\n    editor.commands.addCommand({\n      name: 'runQuery',\n      bindKey: { win: 'Alt-enter', mac: 'Alt-enter' },\n      exec: () => {\n        onAltEnter();\n      },\n    });\n\n    hotkeys.forEach(keyConfig => {\n      editor.commands.addCommand({\n        name: keyConfig.name,\n        bindKey: { win: keyConfig.key, mac: keyConfig.key },\n        exec: keyConfig.func,\n      });\n    });\n\n    editor.$blockScrolling = Infinity; // eslint-disable-line no-param-reassign\n    editor.selection.on('changeSelection', () => {\n      const selectedText = editor.getSelectedText();\n\n      // Backspace trigger 1 character selection, ignoring\n      if (\n        selectedText !== currentSelectionCache.current &&\n        selectedText.length !== 1\n      ) {\n        dispatch(queryEditorSetSelectedText(queryEditor, selectedText));\n      }\n\n      currentSelectionCache.current = selectedText;\n    });\n  };\n\n  const onChangeText = (text: string) => {\n    setSql(text);\n    onChange(text);\n  };\n\n  function setAutoCompleter() {\n    const columns = {};\n\n    const tableWords = tables.map(t => {\n      const tableName = t.value;\n      const extendedTable = extendedTables.find(et => et.name === tableName);\n      const cols = extendedTable?.columns || [];\n      cols.forEach(col => {\n        columns[col.name] = null; // using an object as a unique set\n      });\n\n      return {\n        name: t.label,\n        value: tableName,\n        score: TABLE_AUTOCOMPLETE_SCORE,\n        meta: 'table',\n      };\n    });\n\n    const columnWords = Object.keys(columns).map(col => ({\n      name: col,\n      value: col,\n      score: COLUMN_AUTOCOMPLETE_SCORE,\n      meta: 'column',\n    }));\n\n    const functionWords = functionNames.map(func => ({\n      name: func,\n      value: func,\n      score: SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n      meta: 'function',\n    }));\n\n    const completer = {\n      insertMatch: (editor: Editor, data: any) => {\n        if (data.meta === 'table') {\n          dispatch(\n            addTable(queryEditor, database, data.value, queryEditor.schema),\n          );\n        }\n\n        let { caption } = data;\n        if (data.meta === 'table' && caption.includes(' ')) {\n          caption = `\"${caption}\"`;\n        }\n\n        // executing https://github.com/thlorenz/brace/blob/3a00c5d59777f9d826841178e1eb36694177f5e6/ext/language_tools.js#L1448\n        editor.completer.insertMatch(\n          `${caption}${['function', 'schema'].includes(data.meta) ? '' : ' '}`,\n        );\n      },\n    };\n\n    const words = schemaWords\n      .concat(tableWords)\n      .concat(columnWords)\n      .concat(functionWords)\n      .concat(sqlKeywords)\n      .map(word => ({\n        ...word,\n        completer,\n      }));\n\n    setWords(words);\n  }\n\n  const getAceAnnotations = () => {\n    const { validationResult } = queryEditor;\n    const resultIsReady = validationResult?.completed;\n    if (resultIsReady && validationResult?.errors?.length) {\n      const errors = validationResult.errors.map((err: any) => ({\n        type: 'error',\n        row: err.line_number - 1,\n        column: err.start_column - 1,\n        text: err.message,\n      }));\n      return errors;\n    }\n    return [];\n  };\n\n  return (\n    <StyledAceEditor\n      keywords={words}\n      onLoad={onEditorLoad}\n      onBlur={onBlurSql}\n      height={height}\n      onChange={onChangeText}\n      width=\"100%\"\n      editorProps={{ $blockScrolling: true }}\n      enableLiveAutocompletion={autocomplete}\n      value={sql}\n      annotations={getAceAnnotations()}\n    />\n  );\n};\n\nexport default AceEditorWrapper;\n"]},"metadata":{},"sourceType":"module"}