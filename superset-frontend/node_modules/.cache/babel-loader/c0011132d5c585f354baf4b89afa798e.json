{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback } from 'react';\nimport { getColumnLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport Echart from '../components/Echart';\nimport { formatSeriesName } from '../utils/series';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nexport const extractTreePathInfo = (treePathInfo) => (treePathInfo != null ? treePathInfo : []).\nmap((pathInfo) => (pathInfo == null ? void 0 : pathInfo.name) || '').\nfilter((path) => path !== '');\nexport default function EchartsSunburst(props) {\n  const { height, width, echartOptions, setDataMask, labelMap, selectedValues, formData, onContextMenu, refs, emitCrossFilters, coltypeMapping } = props;\n  const { columns } = formData;\n  const getCrossFilterDataMask = useCallback((treePathInfo) => {\n    const treePath = extractTreePathInfo(treePathInfo);\n    const name = treePath.join(',');\n    const selected = Object.values(selectedValues);\n    let values;\n    if (_includesInstanceProperty(selected).call(selected, name)) {\n      values = selected.filter((v) => v !== name);\n    } else\n    {\n      values = [name];\n    }\n    const labels = values.map((value) => labelMap[value]);\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length === 0 || !columns ?\n          [] :\n          columns.slice(0, treePath.length).map((col, idx) => {\n            const val = labels.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL' };\n\n            return {\n              col,\n              op: 'IN',\n              val: val };\n\n          }) },\n\n        filterState: {\n          value: labels.length ? labels : null,\n          selectedValues: values.length ? values : null } },\n\n\n      isCurrentValueSelected: _includesInstanceProperty(selected).call(selected, name) };\n\n  }, [columns, labelMap, selectedValues]);\n  const handleChange = useCallback((treePathInfo) => {\n    if (!emitCrossFilters) {\n      return;\n    }\n    setDataMask(getCrossFilterDataMask(treePathInfo).dataMask);\n  }, [emitCrossFilters, setDataMask, getCrossFilterDataMask]);\n  const eventHandlers = {\n    click: (props) => {\n      const { treePathInfo } = props;\n      handleChange(treePathInfo);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { records } = data;\n        const treePath = extractTreePathInfo(eventParams.treePathInfo);\n        const pointerEvent = eventParams.event.event;\n        const drillToDetailFilters = [];\n        const drillByFilters = [];\n        if (columns != null && columns.length) {\n          treePath.forEach((path, i) => drillToDetailFilters.push({\n            col: columns[i],\n            op: '==',\n            val: records[i],\n            formattedVal: path }));\n\n          const val = treePath[treePath.length - 1];\n          drillByFilters.push({\n            col: columns[treePath.length - 1],\n            op: '==',\n            val,\n            formattedVal: formatSeriesName(val, {\n              timeFormatter: getTimeFormatter(formData.dateFormat),\n              numberFormatter: getNumberFormatter(formData.numberFormat),\n              coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(columns[treePath.length - 1])] }) });\n\n\n        }\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: getCrossFilterDataMask(treePathInfo),\n          drillBy: { filters: drillByFilters, groupbyFieldName: 'columns' } });\n\n      }\n    } };\n\n  return ___EmotionJSX(Echart, { refs: refs, height: height, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, selectedValues: selectedValues });\n}","map":{"version":3,"mappings":"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","names":["React","useCallback","getColumnLabel","getNumberFormatter","getTimeFormatter","Echart","formatSeriesName","extractTreePathInfo","treePathInfo","map","name","filter","path","EchartsSunburst","props","height","width","echartOptions","setDataMask","labelMap","selectedValues","formData","onContextMenu","refs","emitCrossFilters","coltypeMapping","columns","getCrossFilterDataMask","treePath","join","selected","Object","values","v","labels","value","dataMask","extraFormData","filters","length","slice","col","idx","val","undefined","op","filterState","isCurrentValueSelected","handleChange","eventHandlers","click","contextmenu","eventParams","event","stop","data","records","pointerEvent","drillToDetailFilters","drillByFilters","forEach","i","push","formattedVal","timeFormatter","dateFormat","numberFormatter","numberFormat","coltype","clientX","clientY","drillToDetail","crossFilter","drillBy","groupbyFieldName"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/EchartsSunburst.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback } from 'react';\nimport {\n  BinaryQueryObjectFilterClause,\n  getColumnLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n} from '@superset-ui/core';\nimport { SunburstTransformedProps } from './types';\nimport Echart from '../components/Echart';\nimport { EventHandlers, TreePathInfo } from '../types';\nimport { formatSeriesName } from '../utils/series';\n\nexport const extractTreePathInfo = (treePathInfo: TreePathInfo[] | undefined) =>\n  (treePathInfo ?? [])\n    .map(pathInfo => pathInfo?.name || '')\n    .filter(path => path !== '');\n\nexport default function EchartsSunburst(props: SunburstTransformedProps) {\n  const {\n    height,\n    width,\n    echartOptions,\n    setDataMask,\n    labelMap,\n    selectedValues,\n    formData,\n    onContextMenu,\n    refs,\n    emitCrossFilters,\n    coltypeMapping,\n  } = props;\n  const { columns } = formData;\n\n  const getCrossFilterDataMask = useCallback(\n    (treePathInfo: TreePathInfo[]) => {\n      const treePath = extractTreePathInfo(treePathInfo);\n      const name = treePath.join(',');\n      const selected = Object.values(selectedValues);\n      let values: string[];\n      if (selected.includes(name)) {\n        values = selected.filter(v => v !== name);\n      } else {\n        values = [name];\n      }\n      const labels = values.map(value => labelMap[value]);\n\n      return {\n        dataMask: {\n          extraFormData: {\n            filters:\n              values.length === 0 || !columns\n                ? []\n                : columns.slice(0, treePath.length).map((col, idx) => {\n                    const val = labels.map(v => v[idx]);\n                    if (val === null || val === undefined)\n                      return {\n                        col,\n                        op: 'IS NULL' as const,\n                      };\n                    return {\n                      col,\n                      op: 'IN' as const,\n                      val: val as (string | number | boolean)[],\n                    };\n                  }),\n          },\n          filterState: {\n            value: labels.length ? labels : null,\n            selectedValues: values.length ? values : null,\n          },\n        },\n        isCurrentValueSelected: selected.includes(name),\n      };\n    },\n    [columns, labelMap, selectedValues],\n  );\n\n  const handleChange = useCallback(\n    (treePathInfo: TreePathInfo[]) => {\n      if (!emitCrossFilters) {\n        return;\n      }\n\n      setDataMask(getCrossFilterDataMask(treePathInfo).dataMask);\n    },\n    [emitCrossFilters, setDataMask, getCrossFilterDataMask],\n  );\n\n  const eventHandlers: EventHandlers = {\n    click: props => {\n      const { treePathInfo } = props;\n      handleChange(treePathInfo);\n    },\n    contextmenu: async eventParams => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { records } = data;\n        const treePath = extractTreePathInfo(eventParams.treePathInfo);\n        const pointerEvent = eventParams.event.event;\n        const drillToDetailFilters: BinaryQueryObjectFilterClause[] = [];\n        const drillByFilters: BinaryQueryObjectFilterClause[] = [];\n        if (columns?.length) {\n          treePath.forEach((path, i) =>\n            drillToDetailFilters.push({\n              col: columns[i],\n              op: '==',\n              val: records[i],\n              formattedVal: path,\n            }),\n          );\n          const val = treePath[treePath.length - 1];\n          drillByFilters.push({\n            col: columns[treePath.length - 1],\n            op: '==',\n            val,\n            formattedVal: formatSeriesName(val, {\n              timeFormatter: getTimeFormatter(formData.dateFormat),\n              numberFormatter: getNumberFormatter(formData.numberFormat),\n              coltype:\n                coltypeMapping?.[getColumnLabel(columns[treePath.length - 1])],\n            }),\n          });\n        }\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: getCrossFilterDataMask(treePathInfo),\n          drillBy: { filters: drillByFilters, groupbyFieldName: 'columns' },\n        });\n      }\n    },\n  };\n\n  return (\n    <Echart\n      refs={refs}\n      height={height}\n      width={width}\n      echartOptions={echartOptions}\n      eventHandlers={eventHandlers}\n      selectedValues={selectedValues}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}