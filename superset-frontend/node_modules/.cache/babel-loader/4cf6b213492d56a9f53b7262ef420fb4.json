{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\nDASHBOARD_ROOT_ID,\nDASHBOARD_GRID_ID,\nNEW_COMPONENTS_SOURCE_ID,\nDASHBOARD_HEADER_ID } from\n'../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\nUPDATE_COMPONENTS,\nUPDATE_COMPONENTS_PARENTS_LIST,\nDELETE_COMPONENT,\nCREATE_COMPONENT,\nMOVE_COMPONENT,\nCREATE_TOP_LEVEL_TABS,\nDELETE_TOP_LEVEL_TABS,\nDASHBOARD_TITLE_CHANGED } from\n'../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nexport function recursivelyDeleteChildren(\ncomponentId,\ncomponentParentId,\nnextComponents)\n{\n  // delete child and it's children\n  const component = nextComponents == null ? void 0 : nextComponents[componentId];\n  if (component) {\n    // eslint-disable-next-line no-param-reassign\n    delete nextComponents[componentId];\n\n    const { children = [] } = component;\n    children == null ? void 0 : children.forEach == null ? void 0 : children.forEach((childId) => {\n      recursivelyDeleteChildren(childId, componentId, nextComponents);\n    });\n\n    const parent = nextComponents == null ? void 0 : nextComponents[componentParentId];\n    if (Array.isArray(parent == null ? void 0 : parent.children)) {\n      // may have been deleted in another recursion\n      const componentIndex = parent.children.indexOf(componentId);\n      if (componentIndex > -1) {\n        const nextChildren = [...parent.children];\n        nextChildren.splice(componentIndex, 1);\n        // eslint-disable-next-line no-param-reassign\n        nextComponents[componentParentId] = {\n          ...parent,\n          children: nextChildren };\n\n      }\n    }\n  }\n}\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present };\n\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents } } =\n    action;\n    return {\n      ...state,\n      ...nextComponents };\n\n  },\n\n  [DELETE_COMPONENT](state, action) {var _nextParent$children;\n    const {\n      payload: { id, parentId } } =\n    action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    recursivelyDeleteChildren(id, parentId, nextComponents);\n    const nextParent = nextComponents[parentId];\n    if ((nextParent == null ? void 0 : nextParent.type) === ROW_TYPE && (nextParent == null ? void 0 : (_nextParent$children = nextParent.children) == null ? void 0 : _nextParent$children.length) === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents });\n\n      recursivelyDeleteChildren(parentId, grandparentId, nextComponents);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination });\n\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n      getComponentWidthFromDrop({\n        dropResult,\n        layout: state }) ||\n      undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth } };\n\n\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type });\n\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities };\n\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n      (id) => id !== dragging.id);\n\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id] },\n\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [] },\n\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove] } };\n\n\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n    (component) => component.type === TAB_TYPE);\n\n    const tabsComponent = newEntitiesArray.find(\n    (component) => component.type === TABS_TYPE);\n\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id] };\n\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach((tabId) => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID] };\n\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove };\n\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state };\n\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState });\n\n\n    return {\n      ...nextState };\n\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text } } };\n\n\n\n  } };\n\n\nexport default function layoutReducer(state, action) {if (state === void 0) {state = {};}\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}","map":{"version":3,"names":["DASHBOARD_ROOT_ID","DASHBOARD_GRID_ID","NEW_COMPONENTS_SOURCE_ID","DASHBOARD_HEADER_ID","componentIsResizable","findParentId","getComponentWidthFromDrop","updateComponentParentsList","newComponentFactory","newEntitiesFromDrop","reorderItem","shouldWrapChildInRow","ROW_TYPE","TAB_TYPE","TABS_TYPE","UPDATE_COMPONENTS","UPDATE_COMPONENTS_PARENTS_LIST","DELETE_COMPONENT","CREATE_COMPONENT","MOVE_COMPONENT","CREATE_TOP_LEVEL_TABS","DELETE_TOP_LEVEL_TABS","DASHBOARD_TITLE_CHANGED","HYDRATE_DASHBOARD","recursivelyDeleteChildren","componentId","componentParentId","nextComponents","component","children","forEach","childId","parent","Array","isArray","componentIndex","indexOf","nextChildren","splice","actionHandlers","state","action","data","dashboardLayout","present","payload","id","parentId","nextParent","type","length","grandparentId","layout","dropResult","newEntities","source","destination","dragging","nextEntities","entitiesMap","nextWidth","undefined","meta","width","wrapInRow","parentType","childType","destinationEntity","destinationChildren","newRow","index","parents","concat","rootComponent","topLevelId","topLevelComponent","draggingTabs","draggingTabId","draggingTab","childrenToMove","filter","newEntitiesArray","Object","values","tabComponent","find","tabsComponent","topLevelTabs","tabId","nextState","currentComponent","text","layoutReducer","handler"],"sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/dashboard/reducers/dashboardLayout.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DASHBOARD_ROOT_ID,\n  DASHBOARD_GRID_ID,\n  NEW_COMPONENTS_SOURCE_ID,\n  DASHBOARD_HEADER_ID,\n} from '../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\n  UPDATE_COMPONENTS,\n  UPDATE_COMPONENTS_PARENTS_LIST,\n  DELETE_COMPONENT,\n  CREATE_COMPONENT,\n  MOVE_COMPONENT,\n  CREATE_TOP_LEVEL_TABS,\n  DELETE_TOP_LEVEL_TABS,\n  DASHBOARD_TITLE_CHANGED,\n} from '../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nexport function recursivelyDeleteChildren(\n  componentId,\n  componentParentId,\n  nextComponents,\n) {\n  // delete child and it's children\n  const component = nextComponents?.[componentId];\n  if (component) {\n    // eslint-disable-next-line no-param-reassign\n    delete nextComponents[componentId];\n\n    const { children = [] } = component;\n    children?.forEach?.(childId => {\n      recursivelyDeleteChildren(childId, componentId, nextComponents);\n    });\n\n    const parent = nextComponents?.[componentParentId];\n    if (Array.isArray(parent?.children)) {\n      // may have been deleted in another recursion\n      const componentIndex = parent.children.indexOf(componentId);\n      if (componentIndex > -1) {\n        const nextChildren = [...parent.children];\n        nextChildren.splice(componentIndex, 1);\n        // eslint-disable-next-line no-param-reassign\n        nextComponents[componentParentId] = {\n          ...parent,\n          children: nextChildren,\n        };\n      }\n    }\n  }\n}\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present,\n    };\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents },\n    } = action;\n    return {\n      ...state,\n      ...nextComponents,\n    };\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId },\n    } = action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    recursivelyDeleteChildren(id, parentId, nextComponents);\n    const nextParent = nextComponents[parentId];\n    if (nextParent?.type === ROW_TYPE && nextParent?.children?.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents,\n      });\n      recursivelyDeleteChildren(parentId, grandparentId, nextComponents);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination,\n    });\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n        getComponentWidthFromDrop({\n          dropResult,\n          layout: state,\n        }) || undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth,\n          },\n        };\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type,\n    });\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities,\n    };\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n        id => id !== dragging.id,\n      );\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id],\n        },\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [],\n        },\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove],\n        },\n      };\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n      component => component.type === TAB_TYPE,\n    );\n    const tabsComponent = newEntitiesArray.find(\n      component => component.type === TABS_TYPE,\n    );\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id],\n    };\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach(tabId => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID],\n    };\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove,\n    };\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state,\n    };\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState,\n    });\n\n    return {\n      ...nextState,\n    };\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text,\n        },\n      },\n    };\n  },\n};\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEA,iBADF;AAEEC,iBAFF;AAGEC,wBAHF;AAIEC,mBAJF;AAKO,mBALP;AAMA,OAAOC,oBAAP,MAAiC,8BAAjC;AACA,OAAOC,YAAP,MAAyB,sBAAzB;AACA,OAAOC,yBAAP,MAAsC,mCAAtC;AACA,OAAOC,0BAAP,MAAuC,oCAAvC;AACA,OAAOC,mBAAP,MAAgC,6BAAhC;AACA,OAAOC,mBAAP,MAAgC,6BAAhC;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AACA,OAAOC,oBAAP,MAAiC,8BAAjC;AACA,SAASC,QAAT,EAAmBC,QAAnB,EAA6BC,SAA7B,QAA8C,wBAA9C;;AAEA;AACEC,iBADF;AAEEC,8BAFF;AAGEC,gBAHF;AAIEC,gBAJF;AAKEC,cALF;AAMEC,qBANF;AAOEC,qBAPF;AAQEC,uBARF;AASO,4BATP;;AAWA,SAASC,iBAAT,QAAkC,oBAAlC;;AAEA,OAAO,SAASC,yBAAT;AACLC,WADK;AAELC,iBAFK;AAGLC,cAHK;AAIL;EACA;EACA,MAAMC,SAAS,GAAGD,cAAH,oBAAGA,cAAc,CAAGF,WAAH,CAAhC;EACA,IAAIG,SAAJ,EAAe;IACb;IACA,OAAOD,cAAc,CAACF,WAAD,CAArB;;IAEA,MAAM,EAAEI,QAAQ,GAAG,EAAb,KAAoBD,SAA1B;IACAC,QAAQ,QAAR,YAAAA,QAAQ,CAAEC,OAAV,oBAAAD,QAAQ,CAAEC,OAAV,CAAoB,CAAAC,OAAO,KAAI;MAC7BP,yBAAyB,CAACO,OAAD,EAAUN,WAAV,EAAuBE,cAAvB,CAAzB;IACD,CAFD;;IAIA,MAAMK,MAAM,GAAGL,cAAH,oBAAGA,cAAc,CAAGD,iBAAH,CAA7B;IACA,IAAIO,KAAK,CAACC,OAAN,CAAcF,MAAd,oBAAcA,MAAM,CAAEH,QAAtB,CAAJ,EAAqC;MACnC;MACA,MAAMM,cAAc,GAAGH,MAAM,CAACH,QAAP,CAAgBO,OAAhB,CAAwBX,WAAxB,CAAvB;MACA,IAAIU,cAAc,GAAG,CAAC,CAAtB,EAAyB;QACvB,MAAME,YAAY,GAAG,CAAC,GAAGL,MAAM,CAACH,QAAX,CAArB;QACAQ,YAAY,CAACC,MAAb,CAAoBH,cAApB,EAAoC,CAApC;QACA;QACAR,cAAc,CAACD,iBAAD,CAAd,GAAoC;UAClC,GAAGM,MAD+B;UAElCH,QAAQ,EAAEQ,YAFwB,EAApC;;MAID;IACF;EACF;AACF;;AAED,MAAME,cAAc,GAAG;EACrB,CAAChB,iBAAD,EAAoBiB,KAApB,EAA2BC,MAA3B,EAAmC;IACjC,OAAO;MACL,GAAGA,MAAM,CAACC,IAAP,CAAYC,eAAZ,CAA4BC,OAD1B,EAAP;;EAGD,CALoB;;EAOrB,CAAC7B,iBAAD,EAAoByB,KAApB,EAA2BC,MAA3B,EAAmC;IACjC,MAAM;MACJI,OAAO,EAAE,EAAElB,cAAF,EADL;IAEFc,MAFJ;IAGA,OAAO;MACL,GAAGD,KADE;MAEL,GAAGb,cAFE,EAAP;;EAID,CAfoB;;EAiBrB,CAACV,gBAAD,EAAmBuB,KAAnB,EAA0BC,MAA1B,EAAkC;IAChC,MAAM;MACJI,OAAO,EAAE,EAAEC,EAAF,EAAMC,QAAN,EADL;IAEFN,MAFJ;;IAIA,IAAI,CAACM,QAAD,IAAa,CAACD,EAAd,IAAoB,CAACN,KAAK,CAACM,EAAD,CAA1B,IAAkC,CAACN,KAAK,CAACO,QAAD,CAA5C,EAAwD,OAAOP,KAAP;;IAExD,MAAMb,cAAc,GAAG,EAAE,GAAGa,KAAL,EAAvB;;IAEAhB,yBAAyB,CAACsB,EAAD,EAAKC,QAAL,EAAepB,cAAf,CAAzB;IACA,MAAMqB,UAAU,GAAGrB,cAAc,CAACoB,QAAD,CAAjC;IACA,IAAI,CAAAC,UAAU,QAAV,YAAAA,UAAU,CAAEC,IAAZ,MAAqBrC,QAArB,IAAiC,CAAAoC,UAAU,QAAV,oCAAAA,UAAU,CAAEnB,QAAZ,0CAAsBqB,MAAtB,MAAiC,CAAtE,EAAyE;MACvE,MAAMC,aAAa,GAAG9C,YAAY,CAAC;QACjC0B,OAAO,EAAEgB,QADwB;QAEjCK,MAAM,EAAEzB,cAFyB,EAAD,CAAlC;;MAIAH,yBAAyB,CAACuB,QAAD,EAAWI,aAAX,EAA0BxB,cAA1B,CAAzB;IACD;;IAED,OAAOA,cAAP;EACD,CArCoB;;EAuCrB,CAACT,gBAAD,EAAmBsB,KAAnB,EAA0BC,MAA1B,EAAkC;IAChC,MAAM;MACJI,OAAO,EAAE,EAAEQ,UAAF,EADL;IAEFZ,MAFJ;;IAIA,MAAMa,WAAW,GAAG7C,mBAAmB,CAAC,EAAE4C,UAAF,EAAcD,MAAM,EAAEZ,KAAtB,EAAD,CAAvC;;IAEA,OAAO;MACL,GAAGA,KADE;MAEL,GAAGc,WAFE,EAAP;;EAID,CAlDoB;;EAoDrB,CAACnC,cAAD,EAAiBqB,KAAjB,EAAwBC,MAAxB,EAAgC;IAC9B,MAAM;MACJI,OAAO,EAAE,EAAEQ,UAAF,EADL;IAEFZ,MAFJ;IAGA,MAAM,EAAEc,MAAF,EAAUC,WAAV,EAAuBC,QAAvB,KAAoCJ,UAA1C;;IAEA,IAAI,CAACE,MAAD,IAAW,CAACC,WAAZ,IAA2B,CAACC,QAAhC,EAA0C,OAAOjB,KAAP;;IAE1C,MAAMkB,YAAY,GAAGhD,WAAW,CAAC;MAC/BiD,WAAW,EAAEnB,KADkB;MAE/Be,MAF+B;MAG/BC,WAH+B,EAAD,CAAhC;;;IAMA,IAAIpD,oBAAoB,CAACsD,YAAY,CAACD,QAAQ,CAACX,EAAV,CAAb,CAAxB,EAAqD;MACnD;MACA,MAAMc,SAAS;MACbtD,yBAAyB,CAAC;QACxB+C,UADwB;QAExBD,MAAM,EAAEZ,KAFgB,EAAD,CAAzB;MAGMqB,SAJR,CAFmD,CAMhC;MACnB,IAAI,CAACH,YAAY,CAACD,QAAQ,CAACX,EAAV,CAAZ,CAA0BgB,IAA1B,IAAkC,EAAnC,EAAuCC,KAAvC,KAAiDH,SAArD,EAAgE;QAC9DF,YAAY,CAACD,QAAQ,CAACX,EAAV,CAAZ,GAA4B;UAC1B,GAAGY,YAAY,CAACD,QAAQ,CAACX,EAAV,CADW;UAE1BgB,IAAI,EAAE;YACJ,GAAGJ,YAAY,CAACD,QAAQ,CAACX,EAAV,CAAZ,CAA0BgB,IADzB;YAEJC,KAAK,EAAEH,SAFH,EAFoB,EAA5B;;;MAOD;IACF;;IAED;IACA,MAAMI,SAAS,GAAGrD,oBAAoB,CAAC;MACrCsD,UAAU,EAAET,WAAW,CAACP,IADa;MAErCiB,SAAS,EAAET,QAAQ,CAACR,IAFiB,EAAD,CAAtC;;;IAKA,IAAIe,SAAJ,EAAe;MACb,MAAMG,iBAAiB,GAAGT,YAAY,CAACF,WAAW,CAACV,EAAb,CAAtC;MACA,MAAMsB,mBAAmB,GAAGD,iBAAiB,CAACtC,QAA9C;MACA,MAAMwC,MAAM,GAAG7D,mBAAmB,CAACI,QAAD,CAAlC;MACAyD,MAAM,CAACxC,QAAP,GAAkB,CAACuC,mBAAmB,CAACZ,WAAW,CAACc,KAAb,CAApB,CAAlB;MACAD,MAAM,CAACE,OAAP,GAAiB,CAACJ,iBAAiB,CAACI,OAAlB,IAA6B,EAA9B,EAAkCC,MAAlC,CAAyChB,WAAW,CAACV,EAArD,CAAjB;MACAsB,mBAAmB,CAACZ,WAAW,CAACc,KAAb,CAAnB,GAAyCD,MAAM,CAACvB,EAAhD;MACAY,YAAY,CAACW,MAAM,CAACvB,EAAR,CAAZ,GAA0BuB,MAA1B;IACD;;IAED,OAAO;MACL,GAAG7B,KADE;MAEL,GAAGkB,YAFE,EAAP;;EAID,CAxGoB;;EA0GrB,CAACtC,qBAAD,EAAwBoB,KAAxB,EAA+BC,MAA/B,EAAuC;IACrC,MAAM;MACJI,OAAO,EAAE,EAAEQ,UAAF,EADL;IAEFZ,MAFJ;IAGA,MAAM,EAAEc,MAAF,EAAUE,QAAV,KAAuBJ,UAA7B;;IAEA;IACA,MAAMoB,aAAa,GAAGjC,KAAK,CAACxC,iBAAD,CAA3B;IACA,MAAM0E,UAAU,GAAGD,aAAa,CAAC5C,QAAd,CAAuB,CAAvB,CAAnB;IACA,MAAM8C,iBAAiB,GAAGnC,KAAK,CAACkC,UAAD,CAA/B;;IAEA,IAAInB,MAAM,CAACT,EAAP,KAAc5C,wBAAlB,EAA4C;MAC1C;MACA,MAAM0E,YAAY,GAAGpC,KAAK,CAACiB,QAAQ,CAACX,EAAV,CAA1B;MACA,MAAM+B,aAAa,GAAGD,YAAY,CAAC/C,QAAb,CAAsB,CAAtB,CAAtB;MACA,MAAMiD,WAAW,GAAGtC,KAAK,CAACqC,aAAD,CAAzB;;MAEA;MACA,MAAME,cAAc,GAAG,CAAC,GAAGJ,iBAAiB,CAAC9C,QAAtB,EAAgCmD,MAAhC;MACrB,CAAAlC,EAAE,KAAIA,EAAE,KAAKW,QAAQ,CAACX,EADD,CAAvB;;;MAIA,OAAO;QACL,GAAGN,KADE;QAEL,CAACxC,iBAAD,GAAqB;UACnB,GAAGyE,aADgB;UAEnB5C,QAAQ,EAAE,CAAC4B,QAAQ,CAACX,EAAV,CAFS,EAFhB;;QAML,CAAC4B,UAAD,GAAc;UACZ,GAAGC,iBADS;UAEZ9C,QAAQ,EAAE,EAFE,EANT;;QAUL,CAACgD,aAAD,GAAiB;UACf,GAAGC,WADY;UAEfjD,QAAQ,EAAE,CAAC,GAAGiD,WAAW,CAACjD,QAAhB,EAA0B,GAAGkD,cAA7B,CAFK,EAVZ,EAAP;;;IAeD;;IAED;IACA,MAAMzB,WAAW,GAAG7C,mBAAmB,CAAC,EAAE4C,UAAF,EAAcD,MAAM,EAAEZ,KAAtB,EAAD,CAAvC;IACA,MAAMyC,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc7B,WAAd,CAAzB;IACA,MAAM8B,YAAY,GAAGH,gBAAgB,CAACI,IAAjB;IACnB,CAAAzD,SAAS,KAAIA,SAAS,CAACqB,IAAV,KAAmBpC,QADb,CAArB;;IAGA,MAAMyE,aAAa,GAAGL,gBAAgB,CAACI,IAAjB;IACpB,CAAAzD,SAAS,KAAIA,SAAS,CAACqB,IAAV,KAAmBnC,SADZ,CAAtB;;;IAIAsE,YAAY,CAACvD,QAAb,GAAwB,CAAC,GAAG8C,iBAAiB,CAAC9C,QAAtB,CAAxB;IACAyB,WAAW,CAACoB,UAAD,CAAX,GAA0B,EAAE,GAAGC,iBAAL,EAAwB9C,QAAQ,EAAE,EAAlC,EAA1B;IACAyB,WAAW,CAACtD,iBAAD,CAAX,GAAiC;MAC/B,GAAGyE,aAD4B;MAE/B5C,QAAQ,EAAE,CAACyD,aAAa,CAACxC,EAAf,CAFqB,EAAjC;;;IAKA,OAAO;MACL,GAAGN,KADE;MAEL,GAAGc,WAFE,EAAP;;EAID,CAtKoB;;EAwKrB,CAACjC,qBAAD,EAAwBmB,KAAxB,EAA+B;IAC7B,MAAMiC,aAAa,GAAGjC,KAAK,CAACxC,iBAAD,CAA3B;IACA,MAAM0E,UAAU,GAAGD,aAAa,CAAC5C,QAAd,CAAuB,CAAvB,CAAnB;IACA,MAAM0D,YAAY,GAAG/C,KAAK,CAACkC,UAAD,CAA1B;;IAEA,IAAIa,YAAY,CAACtC,IAAb,KAAsBnC,SAA1B,EAAqC,OAAO0B,KAAP;;IAErC,IAAIuC,cAAc,GAAG,EAArB;IACA,MAAMrB,YAAY,GAAG,EAAE,GAAGlB,KAAL,EAArB;;IAEA+C,YAAY,CAAC1D,QAAb,CAAsBC,OAAtB,CAA8B,CAAA0D,KAAK,KAAI;MACrC,MAAMJ,YAAY,GAAG5C,KAAK,CAACgD,KAAD,CAA1B;MACAT,cAAc,GAAG,CAAC,GAAGA,cAAJ,EAAoB,GAAGK,YAAY,CAACvD,QAApC,CAAjB;MACA,OAAO6B,YAAY,CAAC8B,KAAD,CAAnB;IACD,CAJD;;IAMA,OAAO9B,YAAY,CAACgB,UAAD,CAAnB;;IAEAhB,YAAY,CAAC1D,iBAAD,CAAZ,GAAkC;MAChC,GAAGyE,aAD6B;MAEhC5C,QAAQ,EAAE,CAAC5B,iBAAD,CAFsB,EAAlC;;;IAKAyD,YAAY,CAACzD,iBAAD,CAAZ,GAAkC;MAChC,GAAGuC,KAAK,CAACvC,iBAAD,CADwB;MAEhC4B,QAAQ,EAAEkD,cAFsB,EAAlC;;;IAKA,OAAOrB,YAAP;EACD,CArMoB;;EAuMrB,CAAC1C,8BAAD,EAAiCwB,KAAjC,EAAwC;IACtC,MAAMiD,SAAS,GAAG;MAChB,GAAGjD,KADa,EAAlB;;;IAIAjC,0BAA0B,CAAC;MACzBmF,gBAAgB,EAAED,SAAS,CAACzF,iBAAD,CADF;MAEzBoD,MAAM,EAAEqC,SAFiB,EAAD,CAA1B;;;IAKA,OAAO;MACL,GAAGA,SADE,EAAP;;EAGD,CApNoB;;EAsNrB,CAACnE,uBAAD,EAA0BkB,KAA1B,EAAiCC,MAAjC,EAAyC;IACvC,OAAO;MACL,GAAGD,KADE;MAEL,CAACrC,mBAAD,GAAuB;QACrB,GAAGqC,KAAK,CAACrC,mBAAD,CADa;QAErB2D,IAAI,EAAE;UACJ,GAAGtB,KAAK,CAACrC,mBAAD,CAAL,CAA2B2D,IAD1B;UAEJ6B,IAAI,EAAElD,MAAM,CAACkD,IAFT,EAFe,EAFlB,EAAP;;;;EAUD,CAjOoB,EAAvB;;;AAoOA,eAAe,SAASC,aAAT,CAAuBpD,KAAvB,EAAmCC,MAAnC,EAA2C,KAApBD,KAAoB,cAApBA,KAAoB,GAAZ,EAAY;EACxD,IAAIC,MAAM,CAACQ,IAAP,IAAeV,cAAnB,EAAmC;IACjC,MAAMsD,OAAO,GAAGtD,cAAc,CAACE,MAAM,CAACQ,IAAR,CAA9B;IACA,OAAO4C,OAAO,CAACrD,KAAD,EAAQC,MAAR,CAAd;EACD;;EAED,OAAOD,KAAP;AACD"},"metadata":{},"sourceType":"module"}