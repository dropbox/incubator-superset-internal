{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getMetricLabel, getColumnLabel, getValueFormatter } from '@superset-ui/core';\nimport range from 'lodash/range';\nimport { parseNumbersList } from '../utils/controls';\nimport { DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA } from './types';\nimport { defaultGaugeSeriesOption, INTERVAL_GAUGE_SERIES_OPTION, OFFSETS, FONT_SIZE_MULTIPLIERS } from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getColtypesMapping } from '../utils/series';\nconst setIntervalBoundsAndColors = (intervals, intervalColorIndices, colorFn, normalizer) => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  }\n  catch (error) {\n    intervalBoundsNonNormalized = [];\n    intervalColorIndicesArray = [];\n  }\n  const intervalBounds = intervalBoundsNonNormalized.map((bound) => bound / normalizer);\n  const intervalColors = intervalColorIndicesArray.map((ind) => colorFn.colors[(ind - 1) % colorFn.colors.length]);\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\nconst calculateAxisLineWidth = (data, fontSize, overlap) => overlap ? fontSize : data.length * fontSize;\nconst calculateMin = (data) => 2 * Math.min(...data.map((d) => d.value).concat([0]));\nconst calculateMax = (data) => 2 * Math.max(...data.map((d) => d.value).concat([0]));\nexport default function transformProps(chartProps) {var _queriesData$, _gaugeSeriesOptions$s, _gaugeSeriesOptions$s2, _gaugeSeriesOptions$a, _gaugeSeriesOptions$a2, _gaugeSeriesOptions$a3, _gaugeSeriesOptions$a4, _gaugeSeriesOptions$d;\n  const { width, height, formData, queriesData, hooks, filterState, theme, emitCrossFilters, datasource } = chartProps;\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { groupby, metric, minVal, maxVal, colorScheme, fontSize, numberFormat, animation, showProgress, overlap, roundCap, showAxisTick, showSplitLine, splitNumber, startAngle, endAngle, showPointer, intervals, intervalColorIndices, valueFormatter, sliceId } = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs = {};\n  const data = ((_queriesData$ = queriesData[0]) == null ? void 0 : _queriesData$.data) || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value) => valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle = FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle = FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map();\n  const transformedData = data.map((data_point, index) => {var _context;\n    const name = groupbyLabels.\n    map((column) => `${verboseMap[column] || column}: ${data_point[column]}`).\n    join(', ');\n    columnsLabelMap.set(name, groupbyLabels.map((col) => data_point[col]));\n    let item = {\n      value: data_point[getMetricLabel(metric)],\n      name,\n      itemStyle: {\n        color: colorFn(index, sliceId) },\n\n      title: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`],\n\n        fontSize },\n\n      detail: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle +\n        OFFSETS.titleFromCenter +\n        detailOffsetFromTitle}%`],\n\n        fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize } };\n\n\n    if (filterState.selectedValues &&\n    !_includesInstanceProperty(_context = filterState.selectedValues).call(_context, name)) {\n      item = {\n        ...item,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n          opacity: OpacityEnum.SemiTransparent },\n\n        detail: {\n          show: false },\n\n        title: {\n          show: false } };\n\n\n    }\n    return item;\n  });\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const min = minVal != null ? minVal : calculateMin(transformedData);\n  const max = maxVal != null ? maxVal : calculateMax(transformedData);\n  const axisLabels = range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(...axisLabels.map((label) => numberFormatter(label).length).concat([1]));\n  const normalizer = max;\n  const intervalBoundsAndColors = setIntervalBoundsAndColors(intervals, intervalColorIndices, colorFn, normalizer);\n  const splitLineDistance = axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance = FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n  fontSize *\n  FONT_SIZE_MULTIPLIERS.axisLabelLength *\n  axisLabelLength + (\n  showSplitLine ? splitLineLength : 0) + (\n  showAxisTick ? axisTickLength : 0) +\n  OFFSETS.ticksFromLine -\n  axisLineWidth;\n  const axisTickDistance = axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize };\n\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: (_gaugeSeriesOptions$s = gaugeSeriesOptions.splitLine) == null ? void 0 : (_gaugeSeriesOptions$s2 = _gaugeSeriesOptions$s.lineStyle) == null ? void 0 : _gaugeSeriesOptions$s2.color } };\n\n\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: (_gaugeSeriesOptions$a = gaugeSeriesOptions.axisLine) == null ? void 0 : (_gaugeSeriesOptions$a2 = _gaugeSeriesOptions$a.lineStyle) == null ? void 0 : _gaugeSeriesOptions$a2.color } };\n\n\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: (_gaugeSeriesOptions$a3 = gaugeSeriesOptions.axisLabel) == null ? void 0 : _gaugeSeriesOptions$a3.color };\n\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: (_gaugeSeriesOptions$a4 = gaugeSeriesOptions.axisTick) == null ? void 0 : _gaugeSeriesOptions$a4.lineStyle };\n\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value) => formatValue(value),\n    color: (_gaugeSeriesOptions$d = gaugeSeriesOptions.detail) == null ? void 0 : _gaugeSeriesOptions$d.color };\n\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params) => {\n      const { name, value } = params;\n      return `${name} : ${formatValue(value)}`;\n    } };\n\n  let pointer;\n  if (intervalBoundsAndColors.length) {var _INTERVAL_GAUGE_SERIE, _INTERVAL_GAUGE_SERIE2, _INTERVAL_GAUGE_SERIE3, _INTERVAL_GAUGE_SERIE4, _INTERVAL_GAUGE_SERIE5, _INTERVAL_GAUGE_SERIE6;\n    splitLine.lineStyle.color = (_INTERVAL_GAUGE_SERIE =\n    INTERVAL_GAUGE_SERIES_OPTION.splitLine) == null ? void 0 : (_INTERVAL_GAUGE_SERIE2 = _INTERVAL_GAUGE_SERIE.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE2.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION == null ? void 0 : (_INTERVAL_GAUGE_SERIE3 = INTERVAL_GAUGE_SERIES_OPTION.axisTick) == null ? void 0 : (_INTERVAL_GAUGE_SERIE4 = _INTERVAL_GAUGE_SERIE3.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE4.\n    color;\n    axisLabel.color = (_INTERVAL_GAUGE_SERIE5 = INTERVAL_GAUGE_SERIES_OPTION.axisLabel) == null ? void 0 : _INTERVAL_GAUGE_SERIE5.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: (_INTERVAL_GAUGE_SERIE6 = INTERVAL_GAUGE_SERIES_OPTION.pointer) == null ? void 0 : _INTERVAL_GAUGE_SERIE6.itemStyle };\n\n  } else\n  {\n    pointer = {\n      show: showPointer,\n      showAbove: false };\n\n  }\n  const series = [\n  {\n    type: 'gauge',\n    startAngle,\n    endAngle,\n    min,\n    max,\n    progress,\n    animation,\n    axisLine: axisLine,\n    splitLine,\n    splitNumber,\n    axisLabel,\n    axisTick,\n    pointer,\n    detail,\n    // @ts-ignore\n    tooltip,\n    radius: Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n    center: ['50%', '55%'],\n    data: transformedData }];\n\n\n  const echartOptions = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item' },\n\n    series };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n}","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","getMetricLabel","getColumnLabel","getValueFormatter","range","parseNumbersList","DEFAULT_FORM_DATA","DEFAULT_GAUGE_FORM_DATA","defaultGaugeSeriesOption","INTERVAL_GAUGE_SERIES_OPTION","OFFSETS","FONT_SIZE_MULTIPLIERS","OpacityEnum","getDefaultTooltip","getColtypesMapping","setIntervalBoundsAndColors","intervals","intervalColorIndices","colorFn","normalizer","intervalBoundsNonNormalized","intervalColorIndicesArray","error","intervalBounds","map","bound","intervalColors","colors","ind","length","val","idx","color","calculateAxisLineWidth","data","fontSize","overlap","calculateMin","Math","min","d","value","concat","calculateMax","max","transformProps","chartProps","width","height","formData","queriesData","hooks","filterState","theme","emitCrossFilters","datasource","gaugeSeriesOptions","verboseMap","currencyFormats","columnFormats","groupby","metric","minVal","maxVal","colorScheme","numberFormat","animation","showProgress","roundCap","showAxisTick","showSplitLine","splitNumber","startAngle","endAngle","showPointer","valueFormatter","sliceId","refs","coltypeMapping","numberFormatter","getScale","axisLineWidth","groupbyLabels","formatValue","replace","axisTickLength","splitLineLength","titleOffsetFromTitle","detailOffsetFromTitle","columnsLabelMap","Map","transformedData","data_point","index","name","column","join","set","col","item","itemStyle","title","offsetCenter","titleFromCenter","detail","detailFontSize","selectedValues","opacity","SemiTransparent","show","setDataMask","onContextMenu","axisLabels","axisLabelLength","label","intervalBoundsAndColors","splitLineDistance","ticksFromLine","axisLabelDistance","axisTickDistance","progress","splitLine","distance","lineStyle","splitLineWidth","axisLine","axisLabel","formatter","axisTick","valueAnimation","tooltip","params","pointer","showAbove","series","type","radius","center","echartOptions","trigger","labelMap","Object","fromEntries"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  QueryFormMetric,\n  CategoricalColorNamespace,\n  CategoricalColorScale,\n  DataRecord,\n  getMetricLabel,\n  getColumnLabel,\n  getValueFormatter,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, GaugeSeriesOption } from 'echarts';\nimport { GaugeDataItemOption } from 'echarts/types/src/chart/gauge/GaugeSeries';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport range from 'lodash/range';\nimport { parseNumbersList } from '../utils/controls';\nimport {\n  DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA,\n  EchartsGaugeFormData,\n  AxisTickLineStyle,\n  GaugeChartTransformedProps,\n  EchartsGaugeChartProps,\n} from './types';\nimport {\n  defaultGaugeSeriesOption,\n  INTERVAL_GAUGE_SERIES_OPTION,\n  OFFSETS,\n  FONT_SIZE_MULTIPLIERS,\n} from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\nimport { getColtypesMapping } from '../utils/series';\n\nconst setIntervalBoundsAndColors = (\n  intervals: string,\n  intervalColorIndices: string,\n  colorFn: CategoricalColorScale,\n  normalizer: number,\n): Array<[number, string]> => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  } catch (error) {\n    intervalBoundsNonNormalized = [] as number[];\n    intervalColorIndicesArray = [] as number[];\n  }\n\n  const intervalBounds = intervalBoundsNonNormalized.map(\n    bound => bound / normalizer,\n  );\n  const intervalColors = intervalColorIndicesArray.map(\n    ind => colorFn.colors[(ind - 1) % colorFn.colors.length],\n  );\n\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\n\nconst calculateAxisLineWidth = (\n  data: DataRecord[],\n  fontSize: number,\n  overlap: boolean,\n): number => (overlap ? fontSize : data.length * fontSize);\n\nconst calculateMin = (data: GaugeDataItemOption[]) =>\n  2 * Math.min(...data.map(d => d.value as number).concat([0]));\n\nconst calculateMax = (data: GaugeDataItemOption[]) =>\n  2 * Math.max(...data.map(d => d.value as number).concat([0]));\n\nexport default function transformProps(\n  chartProps: EchartsGaugeChartProps,\n): GaugeChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    theme,\n    emitCrossFilters,\n    datasource,\n  } = chartProps;\n\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const {\n    verboseMap = {},\n    currencyFormats = {},\n    columnFormats = {},\n  } = datasource;\n  const {\n    groupby,\n    metric,\n    minVal,\n    maxVal,\n    colorScheme,\n    fontSize,\n    numberFormat,\n    animation,\n    showProgress,\n    overlap,\n    roundCap,\n    showAxisTick,\n    showSplitLine,\n    splitNumber,\n    startAngle,\n    endAngle,\n    showPointer,\n    intervals,\n    intervalColorIndices,\n    valueFormatter,\n    sliceId,\n  }: EchartsGaugeFormData = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs: Refs = {};\n  const data = (queriesData[0]?.data || []) as DataRecord[];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    numberFormat,\n  );\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value: number) =>\n    valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map<string, string[]>();\n\n  const transformedData: GaugeDataItemOption[] = data.map(\n    (data_point, index) => {\n      const name = groupbyLabels\n        .map(column => `${verboseMap[column] || column}: ${data_point[column]}`)\n        .join(', ');\n      columnsLabelMap.set(\n        name,\n        groupbyLabels.map(col => data_point[col] as string),\n      );\n      let item: GaugeDataItemOption = {\n        value: data_point[getMetricLabel(metric as QueryFormMetric)] as number,\n        name,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n        },\n        title: {\n          offsetCenter: [\n            '0%',\n            `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`,\n          ],\n          fontSize,\n        },\n        detail: {\n          offsetCenter: [\n            '0%',\n            `${\n              index * titleOffsetFromTitle +\n              OFFSETS.titleFromCenter +\n              detailOffsetFromTitle\n            }%`,\n          ],\n          fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize,\n        },\n      };\n      if (\n        filterState.selectedValues &&\n        !filterState.selectedValues.includes(name)\n      ) {\n        item = {\n          ...item,\n          itemStyle: {\n            color: colorFn(index, sliceId),\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          detail: {\n            show: false,\n          },\n          title: {\n            show: false,\n          },\n        };\n      }\n      return item;\n    },\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n\n  const min = minVal ?? calculateMin(transformedData);\n  const max = maxVal ?? calculateMax(transformedData);\n  const axisLabels = range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(\n    ...axisLabels.map(label => numberFormatter(label).length).concat([1]),\n  );\n  const normalizer = max;\n  const intervalBoundsAndColors = setIntervalBoundsAndColors(\n    intervals,\n    intervalColorIndices,\n    colorFn,\n    normalizer,\n  );\n  const splitLineDistance =\n    axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance =\n    FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n      fontSize *\n      FONT_SIZE_MULTIPLIERS.axisLabelLength *\n      axisLabelLength +\n    (showSplitLine ? splitLineLength : 0) +\n    (showAxisTick ? axisTickLength : 0) +\n    OFFSETS.ticksFromLine -\n    axisLineWidth;\n  const axisTickDistance =\n    axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize,\n  };\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: gaugeSeriesOptions.splitLine?.lineStyle?.color,\n    },\n  };\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: gaugeSeriesOptions.axisLine?.lineStyle?.color,\n    },\n  };\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: gaugeSeriesOptions.axisLabel?.color,\n  };\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: gaugeSeriesOptions.axisTick?.lineStyle as AxisTickLineStyle,\n  };\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value: number) => formatValue(value),\n    color: gaugeSeriesOptions.detail?.color,\n  };\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params: CallbackDataParams) => {\n      const { name, value } = params;\n      return `${name} : ${formatValue(value as number)}`;\n    },\n  };\n\n  let pointer;\n  if (intervalBoundsAndColors.length) {\n    splitLine.lineStyle.color =\n      INTERVAL_GAUGE_SERIES_OPTION.splitLine?.lineStyle?.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION?.axisTick?.lineStyle\n      ?.color as string;\n    axisLabel.color = INTERVAL_GAUGE_SERIES_OPTION.axisLabel?.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: INTERVAL_GAUGE_SERIES_OPTION.pointer?.itemStyle,\n    };\n  } else {\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n    };\n  }\n\n  const series: GaugeSeriesOption[] = [\n    {\n      type: 'gauge',\n      startAngle,\n      endAngle,\n      min,\n      max,\n      progress,\n      animation,\n      axisLine: axisLine as GaugeSeriesOption['axisLine'],\n      splitLine,\n      splitNumber,\n      axisLabel,\n      axisTick,\n      pointer,\n      detail,\n      // @ts-ignore\n      tooltip,\n      radius:\n        Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n      center: ['50%', '55%'],\n      data: transformedData,\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n    },\n    series,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}