{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { formatNumber } from '@superset-ui/core';\nfunction formatCellValue(i, cols, tdText, columnFormats, numberFormat, dateRegex, dateFormatter) {\n  const metric = cols[i];\n  const format = columnFormats[metric] || numberFormat || '.3s';\n  let textContent = tdText;\n  let sortAttributeValue = tdText;\n  if (parseFloat(tdText)) {\n    const parsedValue = parseFloat(tdText);\n    textContent = formatNumber(format, parsedValue);\n    sortAttributeValue = parsedValue;\n  } else\n  {\n    const regexMatch = dateRegex.exec(tdText);\n    if (regexMatch) {\n      const date = new Date(parseFloat(regexMatch[1]));\n      textContent = dateFormatter(date);\n      sortAttributeValue = date;\n    } else\n    if (tdText === 'null') {\n      textContent = '';\n      sortAttributeValue = Number.NEGATIVE_INFINITY;\n    }\n  }\n  return { textContent, sortAttributeValue };\n}\nfunction formatDateCellValue(text, verboseMap, dateRegex, dateFormatter) {\n  const regexMatch = dateRegex.exec(text);\n  let cellValue;\n  if (regexMatch) {\n    const date = new Date(parseFloat(regexMatch[1]));\n    cellValue = dateFormatter(date);\n  } else\n  {\n    cellValue = verboseMap[text] || text;\n  }\n  return cellValue;\n}\nexport { formatCellValue, formatDateCellValue };;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(formatCellValue, \"formatCellValue\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-pivot-table/src/utils/formatCells.ts\");reactHotLoader.register(formatDateCellValue, \"formatDateCellValue\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-pivot-table/src/utils/formatCells.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"wSAAA;;;;;;;;;;;;;;;;;;AAkBA,SAASA,YAAT,QAA6B,mBAA7B;AAEA,SAASC,eAAT,CACEC,CADF,EAEEC,IAFF,EAGEC,MAHF,EAIEC,aAJF,EAKEC,YALF,EAMEC,SANF,EAOEC,aAPF,EAOoB;EAElB,MAAMC,MAAM,GAAWN,IAAI,CAACD,CAAD,CAA3B;EACA,MAAMQ,MAAM,GAAWL,aAAa,CAACI,MAAD,CAAb,IAAyBH,YAAzB,IAAyC,KAAhE;EACA,IAAIK,WAAW,GAAWP,MAA1B;EACA,IAAIQ,kBAAkB,GAAQR,MAA9B;EAEA,IAAIS,UAAU,CAACT,MAAD,CAAd,EAAwB;IACtB,MAAMU,WAAW,GAAGD,UAAU,CAACT,MAAD,CAA9B;IACAO,WAAW,GAAGX,YAAY,CAACU,MAAD,EAASI,WAAT,CAA1B;IACAF,kBAAkB,GAAGE,WAArB;EACD,CAJD;EAIO;IACL,MAAMC,UAAU,GAAGR,SAAS,CAACS,IAAV,CAAeZ,MAAf,CAAnB;IACA,IAAIW,UAAJ,EAAgB;MACd,MAAME,IAAI,GAAG,IAAIC,IAAJ,CAASL,UAAU,CAACE,UAAU,CAAC,CAAD,CAAX,CAAnB,CAAb;MACAJ,WAAW,GAAGH,aAAa,CAACS,IAAD,CAA3B;MACAL,kBAAkB,GAAGK,IAArB;IACD,CAJD;IAIO,IAAIb,MAAM,KAAK,MAAf,EAAuB;MAC5BO,WAAW,GAAG,EAAd;MACAC,kBAAkB,GAAGO,MAAM,CAACC,iBAA5B;IACD;EACF;EAED,OAAO,EAAET,WAAF,EAAeC,kBAAf,EAAP;AACD;AAED,SAASS,mBAAT,CACEC,IADF,EAEEC,UAFF,EAGEhB,SAHF,EAIEC,aAJF,EAIoB;EAElB,MAAMO,UAAU,GAAGR,SAAS,CAACS,IAAV,CAAeM,IAAf,CAAnB;EACA,IAAIE,SAAJ;EACA,IAAIT,UAAJ,EAAgB;IACd,MAAME,IAAI,GAAG,IAAIC,IAAJ,CAASL,UAAU,CAACE,UAAU,CAAC,CAAD,CAAX,CAAnB,CAAb;IACAS,SAAS,GAAGhB,aAAa,CAACS,IAAD,CAAzB;EACD,CAHD;EAGO;IACLO,SAAS,GAAGD,UAAU,CAACD,IAAD,CAAV,IAAoBA,IAAhC;EACD;EACD,OAAOE,SAAP;AACD;AAED,SAASvB,eAAT,EAA0BoB,mBAA1B,G,iLAlDSpB,e,kLAiCAoB,mB","names":["formatNumber","formatCellValue","i","cols","tdText","columnFormats","numberFormat","dateRegex","dateFormatter","metric","format","textContent","sortAttributeValue","parseFloat","parsedValue","regexMatch","exec","date","Date","Number","NEGATIVE_INFINITY","formatDateCellValue","text","verboseMap","cellValue"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-plugin-chart-pivot-table/src/utils/formatCells.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { formatNumber } from '@superset-ui/core';\n\nfunction formatCellValue(\n  i: number,\n  cols: string[],\n  tdText: string,\n  columnFormats: any,\n  numberFormat: string,\n  dateRegex: RegExp,\n  dateFormatter: any,\n) {\n  const metric: string = cols[i];\n  const format: string = columnFormats[metric] || numberFormat || '.3s';\n  let textContent: string = tdText;\n  let sortAttributeValue: any = tdText;\n\n  if (parseFloat(tdText)) {\n    const parsedValue = parseFloat(tdText);\n    textContent = formatNumber(format, parsedValue);\n    sortAttributeValue = parsedValue;\n  } else {\n    const regexMatch = dateRegex.exec(tdText);\n    if (regexMatch) {\n      const date = new Date(parseFloat(regexMatch[1]));\n      textContent = dateFormatter(date);\n      sortAttributeValue = date;\n    } else if (tdText === 'null') {\n      textContent = '';\n      sortAttributeValue = Number.NEGATIVE_INFINITY;\n    }\n  }\n\n  return { textContent, sortAttributeValue };\n}\n\nfunction formatDateCellValue(\n  text: string,\n  verboseMap: any,\n  dateRegex: RegExp,\n  dateFormatter: any,\n) {\n  const regexMatch = dateRegex.exec(text);\n  let cellValue;\n  if (regexMatch) {\n    const date = new Date(parseFloat(regexMatch[1]));\n    cellValue = dateFormatter(date);\n  } else {\n    cellValue = verboseMap[text] || text;\n  }\n  return cellValue;\n}\n\nexport { formatCellValue, formatDateCellValue };\n"]},"metadata":{},"sourceType":"module"}