{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getTimeFormatter, getColumnLabel, getNumberFormatter } from '@superset-ui/core';\nimport React, { useCallback } from 'react';\nimport Echart from '../components/Echart';\nimport { NULL_STRING } from '../constants';\nimport { extractTreePathInfo } from './constants';\nimport { formatSeriesName } from '../utils/series';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nexport default function EchartsTreemap(_ref) {let { echartOptions, emitCrossFilters, groupby, height, labelMap, onContextMenu, refs, setDataMask, selectedValues, width, formData, coltypeMapping } = _ref;\n  const getCrossFilterDataMask = useCallback((data, treePathInfo) => {\n    if (data != null && data.children) {\n      return undefined;\n    }\n    const { treePath } = extractTreePathInfo(treePathInfo);\n    const name = treePath.join(',');\n    const selected = Object.values(selectedValues);\n    let values;\n    if (_includesInstanceProperty(selected).call(selected, name)) {\n      values = selected.filter((v) => v !== name);\n    } else\n    {\n      values = [name];\n    }\n    const groupbyValues = values.map((value) => labelMap[value]);\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length === 0 ?\n          [] :\n          groupby.map((col, idx) => {\n            const val = groupbyValues.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL' };\n\n            return {\n              col,\n              op: 'IN',\n              val: val };\n\n          }) },\n\n        filterState: {\n          value: groupbyValues.length ? groupbyValues : null,\n          selectedValues: values.length ? values : null } },\n\n\n      isCurrentValueSelected: _includesInstanceProperty(selected).call(selected, name) };\n\n  }, [groupby, labelMap, selectedValues]);\n  const handleChange = useCallback((data, treePathInfo) => {var _getCrossFilterDataMa;\n    if (!emitCrossFilters) {\n      return;\n    }\n    const dataMask = (_getCrossFilterDataMa = getCrossFilterDataMask(data, treePathInfo)) == null ? void 0 : _getCrossFilterDataMa.dataMask;\n    if (dataMask) {\n      setDataMask(dataMask);\n    }\n  }, [emitCrossFilters, getCrossFilterDataMask, setDataMask]);\n  const eventHandlers = {\n    click: (props) => {\n      const { data, treePathInfo } = props;\n      handleChange(data, treePathInfo);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { treePath } = extractTreePathInfo(treePathInfo);\n        if (treePath.length > 0) {\n          const pointerEvent = eventParams.event.event;\n          const drillToDetailFilters = [];\n          const drillByFilters = [];\n          treePath.forEach((path, i) => {\n            const val = path === 'null' ? NULL_STRING : path;\n            drillToDetailFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: path });\n\n            drillByFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: formatSeriesName(val, {\n                timeFormatter: getTimeFormatter(formData.dateFormat),\n                numberFormatter: getNumberFormatter(formData.numberFormat),\n                coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(groupby[i])] }) });\n\n\n          });\n          onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n            drillToDetail: drillToDetailFilters,\n            crossFilter: getCrossFilterDataMask(data, treePathInfo),\n            drillBy: { filters: drillByFilters, groupbyFieldName: 'groupby' } });\n\n        }\n      }\n    } };\n\n  return ___EmotionJSX(Echart, { refs: refs, height: height, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, selectedValues: selectedValues });\n}","map":{"version":3,"mappings":"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","names":["getTimeFormatter","getColumnLabel","getNumberFormatter","React","useCallback","Echart","NULL_STRING","extractTreePathInfo","formatSeriesName","EchartsTreemap","echartOptions","emitCrossFilters","groupby","height","labelMap","onContextMenu","refs","setDataMask","selectedValues","width","formData","coltypeMapping","getCrossFilterDataMask","data","treePathInfo","children","undefined","treePath","name","join","selected","Object","values","filter","v","groupbyValues","map","value","dataMask","extraFormData","filters","length","col","idx","val","op","filterState","isCurrentValueSelected","handleChange","eventHandlers","click","props","contextmenu","eventParams","event","stop","pointerEvent","drillToDetailFilters","drillByFilters","forEach","path","i","push","formattedVal","timeFormatter","dateFormat","numberFormatter","numberFormat","coltype","clientX","clientY","drillToDetail","crossFilter","drillBy","groupbyFieldName"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Treemap/EchartsTreemap.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DataRecordValue,\n  BinaryQueryObjectFilterClause,\n  getTimeFormatter,\n  getColumnLabel,\n  getNumberFormatter,\n} from '@superset-ui/core';\nimport React, { useCallback } from 'react';\nimport Echart from '../components/Echart';\nimport { NULL_STRING } from '../constants';\nimport { EventHandlers } from '../types';\nimport { extractTreePathInfo } from './constants';\nimport { TreemapTransformedProps } from './types';\nimport { formatSeriesName } from '../utils/series';\n\nexport default function EchartsTreemap({\n  echartOptions,\n  emitCrossFilters,\n  groupby,\n  height,\n  labelMap,\n  onContextMenu,\n  refs,\n  setDataMask,\n  selectedValues,\n  width,\n  formData,\n  coltypeMapping,\n}: TreemapTransformedProps) {\n  const getCrossFilterDataMask = useCallback(\n    (data, treePathInfo) => {\n      if (data?.children) {\n        return undefined;\n      }\n      const { treePath } = extractTreePathInfo(treePathInfo);\n      const name = treePath.join(',');\n      const selected = Object.values(selectedValues);\n      let values: string[];\n      if (selected.includes(name)) {\n        values = selected.filter(v => v !== name);\n      } else {\n        values = [name];\n      }\n\n      const groupbyValues = values.map(value => labelMap[value]);\n\n      return {\n        dataMask: {\n          extraFormData: {\n            filters:\n              values.length === 0\n                ? []\n                : groupby.map((col, idx) => {\n                    const val: DataRecordValue[] = groupbyValues.map(\n                      v => v[idx],\n                    );\n                    if (val === null || val === undefined)\n                      return {\n                        col,\n                        op: 'IS NULL' as const,\n                      };\n                    return {\n                      col,\n                      op: 'IN' as const,\n                      val: val as (string | number | boolean)[],\n                    };\n                  }),\n          },\n          filterState: {\n            value: groupbyValues.length ? groupbyValues : null,\n            selectedValues: values.length ? values : null,\n          },\n        },\n        isCurrentValueSelected: selected.includes(name),\n      };\n    },\n    [groupby, labelMap, selectedValues],\n  );\n\n  const handleChange = useCallback(\n    (data, treePathInfo) => {\n      if (!emitCrossFilters) {\n        return;\n      }\n\n      const dataMask = getCrossFilterDataMask(data, treePathInfo)?.dataMask;\n      if (dataMask) {\n        setDataMask(dataMask);\n      }\n    },\n    [emitCrossFilters, getCrossFilterDataMask, setDataMask],\n  );\n\n  const eventHandlers: EventHandlers = {\n    click: props => {\n      const { data, treePathInfo } = props;\n      handleChange(data, treePathInfo);\n    },\n    contextmenu: async eventParams => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { treePath } = extractTreePathInfo(treePathInfo);\n        if (treePath.length > 0) {\n          const pointerEvent = eventParams.event.event;\n          const drillToDetailFilters: BinaryQueryObjectFilterClause[] = [];\n          const drillByFilters: BinaryQueryObjectFilterClause[] = [];\n          treePath.forEach((path, i) => {\n            const val = path === 'null' ? NULL_STRING : path;\n            drillToDetailFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: path,\n            });\n            drillByFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: formatSeriesName(val, {\n                timeFormatter: getTimeFormatter(formData.dateFormat),\n                numberFormatter: getNumberFormatter(formData.numberFormat),\n                coltype: coltypeMapping?.[getColumnLabel(groupby[i])],\n              }),\n            });\n          });\n          onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n            drillToDetail: drillToDetailFilters,\n            crossFilter: getCrossFilterDataMask(data, treePathInfo),\n            drillBy: { filters: drillByFilters, groupbyFieldName: 'groupby' },\n          });\n        }\n      }\n    },\n  };\n\n  return (\n    <Echart\n      refs={refs}\n      height={height}\n      width={width}\n      echartOptions={echartOptions}\n      eventHandlers={eventHandlers}\n      selectedValues={selectedValues}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}