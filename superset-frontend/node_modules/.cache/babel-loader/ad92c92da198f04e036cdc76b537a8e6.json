{"ast":null,"code":"import _omit from \"lodash/omit\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { ensureIsArray, getChartControlPanelRegistry } from '@superset-ui/core';\nimport { getStandardizedControls, isStandardizedFormData } from '@superset-ui/chart-controls';\nimport { getControlsState } from 'src/explore/store';\nimport { getFormDataFromControls } from './getFormDataFromControls';\nexport const sharedMetricsKey = [\n'metric',\n'metrics',\n'metric_2',\n'size',\n'x',\n'y',\n'secondary_metric' // via sharedControls, scalar\n];\nexport const sharedColumnsKey = [\n'groupby',\n'columns',\n'groupbyColumns',\n'groupbyRows',\n'entity',\n'series',\n'series_columns' // via sharedControls, array\n];\nexport const publicControls = [\n// time section\n'granularity_sqla',\n'time_grain_sqla',\n'time_range',\n// filters\n'adhoc_filters',\n// subquery limit(series limit)\n'limit',\n// order by clause\n'timeseries_limit_metric',\n'series_limit_metric',\n// desc or asc in order by clause\n'order_desc',\n// outer query limit\n'row_limit',\n// x asxs column\n'x_axis',\n// advanced analytics - rolling window\n'rolling_type',\n'rolling_periods',\n'min_periods',\n// advanced analytics - time comparison\n'time_compare',\n'comparison_type',\n// advanced analytics - resample\n'resample_rule',\n'resample_method' // via sections.advancedAnalytics\n];\nexport class StandardizedFormData {\n\n  constructor(sourceFormData) {var _formData$standardize, _mfd$slice$0$;this.sfd = void 0;\n    /*\n     * Support form_data for smooth switching between different viz\n     * */\n    const formData = Object.freeze(sourceFormData);\n    // generates an ordered map, the key is viz_type and the value is form_data. the last item is current viz.\n    const mfd = formData == null ? void 0 : (_formData$standardize = formData.standardizedFormData) == null ? void 0 : _formData$standardize.memorizedFormData;\n    const vizType = formData.viz_type;\n    let memorizedFormData = new Map();\n    let controls;\n    if (Array.isArray(mfd) &&\n    mfd.length > 0 &&\n    formData.datasource === ((_mfd$slice$0$ = mfd.slice(-1)[0][1]) == null ? void 0 : _mfd$slice$0$.datasource)) {\n      memorizedFormData = new Map(formData.standardizedFormData.memorizedFormData);\n      if (memorizedFormData.has(vizType)) {\n        memorizedFormData.delete(vizType);\n      }\n      memorizedFormData.set(vizType, formData);\n      controls = StandardizedFormData.getStandardizedControls(formData);\n    } else\n    {\n      // reset the `memorizedFormData` if a request between different datasource.\n      const restFormData = _omit(formData, 'standardizedFormData');\n      memorizedFormData.set(vizType, restFormData);\n      controls = StandardizedFormData.getStandardizedControls(restFormData);\n    }\n    this.sfd = {\n      controls,\n      memorizedFormData };\n\n  }\n  static getStandardizedControls(formData) {\n    // 1. initial StandardizedControls\n    const controls = {\n      metrics: [],\n      columns: [] };\n\n    // 2. collect current sharedControls\n    Object.entries(formData).forEach((_ref) => {let [key, value] = _ref;\n      if (_includesInstanceProperty(sharedMetricsKey).call(sharedMetricsKey, key)) {\n        controls.metrics.push(...ensureIsArray(value));\n      }\n      if (_includesInstanceProperty(sharedColumnsKey).call(sharedColumnsKey, key)) {\n        controls.columns.push(...ensureIsArray(value));\n      }\n    });\n    // 3. append inherit sharedControls\n    if (isStandardizedFormData(formData)) {\n      const { metrics, columns } = formData.standardizedFormData.controls;\n      controls.metrics.push(...metrics);\n      controls.columns.push(...columns);\n    }\n    return controls;\n  }\n  getLatestFormData(vizType) {\n    if (this.has(vizType)) {\n      return this.get(vizType);\n    }\n    return this.memorizedFormData.slice(-1)[0][1];\n  }\n  get standardizedControls() {\n    return this.sfd.controls;\n  }\n  get memorizedFormData() {\n    return Array.from(this.sfd.memorizedFormData.entries());\n  }\n  serialize() {\n    return {\n      controls: this.standardizedControls,\n      memorizedFormData: this.memorizedFormData };\n\n  }\n  has(vizType) {\n    return this.sfd.memorizedFormData.has(vizType);\n  }\n  get(vizType) {\n    return this.sfd.memorizedFormData.get(vizType);\n  }\n  transform(targetVizType, exploreState) {\n    /*\n     * Transfrom form_data between different viz. Return new form_data and controlsState.\n     * 1. get memorized form_data by viz type or get previous form_data\n     * 2. collect public control values\n     * 3. generate initial targetControlsState\n     * 4. attach `standardizedFormData` to the initial form_data\n     * 5. call formDataOverrides to transform initial form_data if the plugin was defined\n     * 6. use final form_data to generate controlsState\n     * 7. to refresh validator message\n     * */\n    const latestFormData = this.getLatestFormData(targetVizType);\n    const publicFormData = {};\n    publicControls.forEach((key) => {\n      if (key in exploreState.form_data) {\n        publicFormData[key] = exploreState.form_data[key];\n      }\n    });\n    const targetControlsState = getControlsState(exploreState, {\n      ...latestFormData,\n      ...publicFormData,\n      viz_type: targetVizType });\n\n    const targetFormData = {\n      ...getFormDataFromControls(targetControlsState),\n      standardizedFormData: this.serialize() };\n\n    let rv = {\n      formData: targetFormData,\n      controlsState: targetControlsState };\n\n    const controlPanel = getChartControlPanelRegistry().get(targetVizType);\n    if (controlPanel != null && controlPanel.formDataOverrides) {\n      getStandardizedControls().setStandardizedControls(targetFormData);\n      const transformed = {\n        ...controlPanel.formDataOverrides(targetFormData),\n        standardizedFormData: {\n          controls: { ...getStandardizedControls().controls },\n          memorizedFormData: this.memorizedFormData } };\n\n\n      getStandardizedControls().clear();\n      rv = {\n        formData: transformed,\n        controlsState: getControlsState(exploreState, transformed) };\n\n    }\n    // refresh validator message\n    rv.controlsState = getControlsState({ ...exploreState, controls: rv.controlsState }, rv.formData);\n    return rv;\n  }}","map":{"version":3,"mappings":"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","names":["ensureIsArray","getChartControlPanelRegistry","getStandardizedControls","isStandardizedFormData","getControlsState","getFormDataFromControls","sharedMetricsKey","sharedColumnsKey","publicControls","StandardizedFormData","constructor","sourceFormData","sfd","formData","Object","freeze","mfd","standardizedFormData","memorizedFormData","vizType","viz_type","Map","controls","Array","isArray","length","datasource","slice","has","delete","set","restFormData","metrics","columns","entries","forEach","key","value","push","getLatestFormData","get","standardizedControls","from","serialize","transform","targetVizType","exploreState","latestFormData","publicFormData","form_data","targetControlsState","targetFormData","rv","controlsState","controlPanel","formDataOverrides","setStandardizedControls","transformed","clear"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/controlUtils/standardizedFormData.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { omit } from 'lodash';\nimport {\n  ensureIsArray,\n  getChartControlPanelRegistry,\n  QueryFormColumn,\n  QueryFormData,\n  QueryFormMetric,\n} from '@superset-ui/core';\nimport {\n  ControlStateMapping,\n  getStandardizedControls,\n  isStandardizedFormData,\n  StandardizedControls,\n  StandardizedFormDataInterface,\n} from '@superset-ui/chart-controls';\nimport { getControlsState } from 'src/explore/store';\nimport { getFormDataFromControls } from './getFormDataFromControls';\n\nexport const sharedMetricsKey = [\n  'metric', // via sharedControls, scalar\n  'metrics', // via sharedControls, array\n  'metric_2', // via sharedControls, scalar\n  'size', // via sharedControls, scalar\n  'x', // via sharedControls, scalar\n  'y', // via sharedControls, scalar\n  'secondary_metric', // via sharedControls, scalar\n];\nexport const sharedColumnsKey = [\n  'groupby', // via sharedControls, array\n  'columns', // via sharedControls, array\n  'groupbyColumns', // via pivot table v2, array\n  'groupbyRows', // via pivot table v2, array\n  'entity', // via sharedControls, scalar\n  'series', // via sharedControls, scalar\n  'series_columns', // via sharedControls, array\n];\n\nexport const publicControls = [\n  // time section\n  'granularity_sqla', // via sharedControls\n  'time_grain_sqla', // via sharedControls\n  'time_range', // via sharedControls\n  // filters\n  'adhoc_filters', // via sharedControls\n  // subquery limit(series limit)\n  'limit', // via sharedControls\n  // order by clause\n  'timeseries_limit_metric', // via sharedControls\n  'series_limit_metric', // via sharedControls\n  // desc or asc in order by clause\n  'order_desc', // via sharedControls\n  // outer query limit\n  'row_limit', // via sharedControls\n  // x asxs column\n  'x_axis', // via sharedControls\n  // advanced analytics - rolling window\n  'rolling_type', // via sections.advancedAnalytics\n  'rolling_periods', // via sections.advancedAnalytics\n  'min_periods', // via sections.advancedAnalytics\n  // advanced analytics - time comparison\n  'time_compare', // via sections.advancedAnalytics\n  'comparison_type', // via sections.advancedAnalytics\n  // advanced analytics - resample\n  'resample_rule', // via sections.advancedAnalytics\n  'resample_method', // via sections.advancedAnalytics\n];\n\nexport class StandardizedFormData {\n  private sfd: StandardizedFormDataInterface;\n\n  constructor(sourceFormData: QueryFormData) {\n    /*\n     * Support form_data for smooth switching between different viz\n     * */\n    const formData = Object.freeze(sourceFormData);\n\n    // generates an ordered map, the key is viz_type and the value is form_data. the last item is current viz.\n    const mfd = formData?.standardizedFormData?.memorizedFormData;\n    const vizType = formData.viz_type;\n    let memorizedFormData = new Map<string, QueryFormData>();\n    let controls: StandardizedControls;\n    if (\n      Array.isArray(mfd) &&\n      mfd.length > 0 &&\n      formData.datasource === mfd.slice(-1)[0][1]?.datasource\n    ) {\n      memorizedFormData = new Map(\n        formData.standardizedFormData.memorizedFormData,\n      );\n      if (memorizedFormData.has(vizType)) {\n        memorizedFormData.delete(vizType);\n      }\n      memorizedFormData.set(vizType, formData);\n      controls = StandardizedFormData.getStandardizedControls(formData);\n    } else {\n      // reset the `memorizedFormData` if a request between different datasource.\n      const restFormData = omit(\n        formData,\n        'standardizedFormData',\n      ) as QueryFormData;\n      memorizedFormData.set(vizType, restFormData);\n      controls = StandardizedFormData.getStandardizedControls(restFormData);\n    }\n\n    this.sfd = {\n      controls,\n      memorizedFormData,\n    };\n  }\n\n  static getStandardizedControls(\n    formData: QueryFormData,\n  ): StandardizedControls {\n    // 1. initial StandardizedControls\n    const controls: StandardizedControls = {\n      metrics: [],\n      columns: [],\n    };\n\n    // 2. collect current sharedControls\n    Object.entries(formData).forEach(([key, value]) => {\n      if (sharedMetricsKey.includes(key)) {\n        controls.metrics.push(...ensureIsArray<QueryFormMetric>(value));\n      }\n      if (sharedColumnsKey.includes(key)) {\n        controls.columns.push(...ensureIsArray<QueryFormColumn>(value));\n      }\n    });\n\n    // 3. append inherit sharedControls\n    if (isStandardizedFormData(formData)) {\n      const { metrics, columns } = formData.standardizedFormData.controls;\n      controls.metrics.push(...metrics);\n      controls.columns.push(...columns);\n    }\n\n    return controls;\n  }\n\n  private getLatestFormData(vizType: string): QueryFormData {\n    if (this.has(vizType)) {\n      return this.get(vizType);\n    }\n    return this.memorizedFormData.slice(-1)[0][1];\n  }\n\n  private get standardizedControls() {\n    return this.sfd.controls;\n  }\n\n  private get memorizedFormData() {\n    return Array.from(this.sfd.memorizedFormData.entries());\n  }\n\n  serialize() {\n    return {\n      controls: this.standardizedControls,\n      memorizedFormData: this.memorizedFormData,\n    };\n  }\n\n  has(vizType: string): boolean {\n    return this.sfd.memorizedFormData.has(vizType);\n  }\n\n  get(vizType: string): QueryFormData {\n    return this.sfd.memorizedFormData.get(vizType) as QueryFormData;\n  }\n\n  transform(\n    targetVizType: string,\n    exploreState: Record<string, any>,\n  ): {\n    formData: QueryFormData;\n    controlsState: ControlStateMapping;\n  } {\n    /*\n     * Transfrom form_data between different viz. Return new form_data and controlsState.\n     * 1. get memorized form_data by viz type or get previous form_data\n     * 2. collect public control values\n     * 3. generate initial targetControlsState\n     * 4. attach `standardizedFormData` to the initial form_data\n     * 5. call formDataOverrides to transform initial form_data if the plugin was defined\n     * 6. use final form_data to generate controlsState\n     * 7. to refresh validator message\n     * */\n    const latestFormData = this.getLatestFormData(targetVizType);\n    const publicFormData = {};\n    publicControls.forEach(key => {\n      if (key in exploreState.form_data) {\n        publicFormData[key] = exploreState.form_data[key];\n      }\n    });\n    const targetControlsState = getControlsState(exploreState, {\n      ...latestFormData,\n      ...publicFormData,\n      viz_type: targetVizType,\n    });\n    const targetFormData = {\n      ...getFormDataFromControls(targetControlsState),\n      standardizedFormData: this.serialize(),\n    };\n\n    let rv = {\n      formData: targetFormData,\n      controlsState: targetControlsState,\n    };\n\n    const controlPanel = getChartControlPanelRegistry().get(targetVizType);\n    if (controlPanel?.formDataOverrides) {\n      getStandardizedControls().setStandardizedControls(targetFormData);\n      const transformed = {\n        ...controlPanel.formDataOverrides(targetFormData),\n        standardizedFormData: {\n          controls: { ...getStandardizedControls().controls },\n          memorizedFormData: this.memorizedFormData,\n        },\n      };\n      getStandardizedControls().clear();\n      rv = {\n        formData: transformed,\n        controlsState: getControlsState(exploreState, transformed),\n      };\n    }\n\n    // refresh validator message\n    rv.controlsState = getControlsState(\n      { ...exploreState, controls: rv.controlsState },\n      rv.formData,\n    );\n    return rv;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}