{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ensureIsArray, t, useTheme, usePrevious } from '@superset-ui/core';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport Icons from 'src/components/Icons';\nimport {\nAddIconButton,\nAddControlLabel,\nHeaderContainer,\nLabelsContainer } from\n'src/explore/components/controls/OptionControls';\nimport columnType from './columnType';\nimport MetricDefinitionValue from './MetricDefinitionValue';\nimport AdhocMetric from './AdhocMetric';\nimport savedMetricType from './savedMetricType';\nimport adhocMetricType from './adhocMetricType';\nimport AdhocMetricPopoverTrigger from './AdhocMetricPopoverTrigger';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  name: PropTypes.string.isRequired,\n  onChange: PropTypes.func,\n  value: PropTypes.oneOfType([\n  PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, adhocMetricType])),\n  PropTypes.oneOfType([PropTypes.string, adhocMetricType])]),\n\n  columns: PropTypes.arrayOf(columnType),\n  savedMetrics: PropTypes.arrayOf(savedMetricType),\n  isLoading: PropTypes.bool,\n  multi: PropTypes.bool,\n  clearable: PropTypes.bool,\n  datasource: PropTypes.object };\n\n\nconst defaultProps = {\n  onChange: () => {},\n  clearable: true,\n  savedMetrics: [],\n  columns: [] };\n\n\nfunction getOptionsForSavedMetrics(\nsavedMetrics,\ncurrentMetricValues,\ncurrentMetric)\n{var _savedMetrics$filter;\n  return (_savedMetrics$filter =\n  savedMetrics == null ? void 0 : savedMetrics.filter((savedMetric) =>\n  Array.isArray(currentMetricValues) ?\n  !_includesInstanceProperty(currentMetricValues).call(currentMetricValues, savedMetric.metric_name) ||\n  savedMetric.metric_name === currentMetric :\n  savedMetric)) != null ? _savedMetrics$filter :\n  [];\n\n}\n\nfunction isDictionaryForAdhocMetric(value) {\n  return value && !(value instanceof AdhocMetric) && value.expressionType;\n}\n\n// adhoc metrics are stored as dictionaries in URL params. We convert them back into the\n// AdhocMetric class for typechecking, consistency and instance method access.\nfunction coerceAdhocMetrics(value) {\n  if (!value) {\n    return [];\n  }\n  if (!Array.isArray(value)) {\n    if (isDictionaryForAdhocMetric(value)) {\n      return [new AdhocMetric(value)];\n    }\n    return [value];\n  }\n  return value.map((val) => {\n    if (isDictionaryForAdhocMetric(val)) {\n      return new AdhocMetric(val);\n    }\n    return val;\n  });\n}\n\nconst emptySavedMetric = { metric_name: '', expression: '' };\n\n// TODO: use typeguards to distinguish saved metrics from adhoc metrics\nconst getMetricsMatchingCurrentDataset = (value, columns, savedMetrics) =>\nensureIsArray(value).filter((metric) => {\n  if (typeof metric === 'string' || metric.metric_name) {\n    return savedMetrics == null ? void 0 : savedMetrics.some(\n    (savedMetric) =>\n    savedMetric.metric_name === metric ||\n    savedMetric.metric_name === metric.metric_name);\n\n  }\n  return columns == null ? void 0 : columns.some(\n  (column) =>\n  !metric.column || metric.column.column_name === column.column_name);\n\n});\n\nconst MetricsControl = (_ref) =>\n\n\n\n\n\n\n\n{let { onChange, multi, value: propsValue, columns, savedMetrics, datasource, ...props } = _ref;\n  const [value, setValue] = useState(coerceAdhocMetrics(propsValue));\n  const theme = useTheme();\n  const prevColumns = usePrevious(columns);\n  const prevSavedMetrics = usePrevious(savedMetrics);\n\n  const handleChange = useCallback(\n  (opts) => {\n    // if clear out options\n    if (opts === null) {\n      onChange(null);\n      return;\n    }\n\n    const transformedOpts = ensureIsArray(opts);\n    const optionValues = transformedOpts.\n    map((option) => {\n      // pre-defined metric\n      if (option.metric_name) {\n        return option.metric_name;\n      }\n      return option;\n    }).\n    filter((option) => option);\n    onChange(multi ? optionValues : optionValues[0]);\n  },\n  [multi, onChange]);\n\n\n  const onNewMetric = useCallback(\n  (newMetric) => {\n    const newValue = [...value, newMetric];\n    setValue(newValue);\n    handleChange(newValue);\n  },\n  [handleChange, value]);\n\n\n  const onMetricEdit = useCallback(\n  (changedMetric, oldMetric) => {\n    const newValue = value.map((val) => {\n      if (\n      // compare saved metrics\n      val === oldMetric.metric_name ||\n      // compare adhoc metrics\n      typeof val.optionName !== 'undefined' ?\n      val.optionName === oldMetric.optionName :\n      false)\n      {\n        return changedMetric;\n      }\n      return val;\n    });\n    setValue(newValue);\n    handleChange(newValue);\n  },\n  [handleChange, value]);\n\n\n  const onRemoveMetric = useCallback(\n  (index) => {\n    if (!Array.isArray(value)) {\n      return;\n    }\n    const valuesCopy = [...value];\n    valuesCopy.splice(index, 1);\n    setValue(valuesCopy);\n    handleChange(valuesCopy);\n  },\n  [handleChange, value]);\n\n\n  const moveLabel = useCallback(\n  (dragIndex, hoverIndex) => {\n    const newValues = [...value];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValue(newValues);\n  },\n  [value]);\n\n\n  const isAddNewMetricDisabled = useCallback(\n  () => !multi && value.length > 0,\n  [multi, value.length]);\n\n\n  const savedMetricOptions = useMemo(\n  () => getOptionsForSavedMetrics(savedMetrics, propsValue, null),\n  [propsValue, savedMetrics]);\n\n\n  const newAdhocMetric = useMemo(() => new AdhocMetric({}), [value]);\n  const addNewMetricPopoverTrigger = useCallback(\n  (trigger) => {\n    if (isAddNewMetricDisabled()) {\n      return trigger;\n    }\n    return (\n      ___EmotionJSX(AdhocMetricPopoverTrigger, {\n        adhocMetric: newAdhocMetric,\n        onMetricEdit: onNewMetric,\n        columns: columns,\n        savedMetricsOptions: savedMetricOptions,\n        savedMetric: emptySavedMetric,\n        datasource: datasource,\n        isNew: true },\n\n      trigger));\n\n\n  },\n  [\n  columns,\n  datasource,\n  isAddNewMetricDisabled,\n  newAdhocMetric,\n  onNewMetric,\n  savedMetricOptions]);\n\n\n\n  useEffect(() => {\n    // Remove selected custom metrics that do not exist in the dataset anymore\n    // Remove selected adhoc metrics that use columns which do not exist in the dataset anymore\n    if (\n    propsValue && (\n    !_isEqual(prevColumns, columns) ||\n    !_isEqual(prevSavedMetrics, savedMetrics)))\n    {\n      const matchingMetrics = getMetricsMatchingCurrentDataset(\n      propsValue,\n      columns,\n      savedMetrics);\n\n      if (!_isEqual(matchingMetrics, propsValue)) {\n        handleChange(matchingMetrics);\n      }\n    }\n  }, [columns, handleChange, savedMetrics]);\n\n  useEffect(() => {\n    setValue(coerceAdhocMetrics(propsValue));\n  }, [propsValue]);\n\n  const onDropLabel = useCallback(\n  () => handleChange(value),\n  [handleChange, value]);\n\n\n  const valueRenderer = useCallback(\n  (option, index) =>\n  ___EmotionJSX(MetricDefinitionValue, {\n    key: index,\n    index: index,\n    option: option,\n    onMetricEdit: onMetricEdit,\n    onRemoveMetric: onRemoveMetric,\n    columns: columns,\n    datasource: datasource,\n    savedMetrics: savedMetrics,\n    savedMetricsOptions: getOptionsForSavedMetrics(\n    savedMetrics,\n    value,\n    value == null ? void 0 : value[index]),\n\n    onMoveLabel: moveLabel,\n    onDropLabel: onDropLabel,\n    multi: multi }),\n\n\n  [\n  columns,\n  datasource,\n  moveLabel,\n  multi,\n  onDropLabel,\n  onMetricEdit,\n  onRemoveMetric,\n  savedMetrics,\n  value]);\n\n\n\n  return (\n    ___EmotionJSX(\"div\", { className: \"metrics-select\" },\n    ___EmotionJSX(HeaderContainer, null,\n    ___EmotionJSX(ControlHeader, props),\n    addNewMetricPopoverTrigger(\n    ___EmotionJSX(AddIconButton, {\n      disabled: isAddNewMetricDisabled() },\n\n\n    ___EmotionJSX(Icons.PlusLarge, {\n      iconSize: \"s\",\n      iconColor: theme.colors.grayscale.light5 })))),\n\n\n\n\n    ___EmotionJSX(LabelsContainer, null,\n    value.length > 0 ?\n    value.map((value, index) => valueRenderer(value, index)) :\n    addNewMetricPopoverTrigger(\n    ___EmotionJSX(AddControlLabel, null,\n    ___EmotionJSX(Icons.PlusSmall, { iconColor: theme.colors.grayscale.light1 }),\n    t('Add metric'))))));\n\n\n\n\n\n};\n\nMetricsControl.propTypes = propTypes;\nMetricsControl.defaultProps = defaultProps;\n\nexport default MetricsControl;","map":{"version":3,"names":["React","useCallback","useEffect","useMemo","useState","PropTypes","ensureIsArray","t","useTheme","usePrevious","ControlHeader","Icons","AddIconButton","AddControlLabel","HeaderContainer","LabelsContainer","columnType","MetricDefinitionValue","AdhocMetric","savedMetricType","adhocMetricType","AdhocMetricPopoverTrigger","propTypes","name","string","isRequired","onChange","func","value","oneOfType","arrayOf","columns","savedMetrics","isLoading","bool","multi","clearable","datasource","object","defaultProps","getOptionsForSavedMetrics","currentMetricValues","currentMetric","filter","savedMetric","Array","isArray","metric_name","isDictionaryForAdhocMetric","expressionType","coerceAdhocMetrics","map","val","emptySavedMetric","expression","getMetricsMatchingCurrentDataset","metric","some","column","column_name","MetricsControl","propsValue","props","setValue","theme","prevColumns","prevSavedMetrics","handleChange","opts","transformedOpts","optionValues","option","onNewMetric","newMetric","newValue","onMetricEdit","changedMetric","oldMetric","optionName","onRemoveMetric","index","valuesCopy","splice","moveLabel","dragIndex","hoverIndex","newValues","isAddNewMetricDisabled","length","savedMetricOptions","newAdhocMetric","addNewMetricPopoverTrigger","trigger","matchingMetrics","onDropLabel","valueRenderer","colors","grayscale","light5","light1"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/explore/components/controls/MetricControl/MetricsControl.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ensureIsArray, t, useTheme, usePrevious } from '@superset-ui/core';\nimport { isEqual } from 'lodash';\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport Icons from 'src/components/Icons';\nimport {\n  AddIconButton,\n  AddControlLabel,\n  HeaderContainer,\n  LabelsContainer,\n} from 'src/explore/components/controls/OptionControls';\nimport columnType from './columnType';\nimport MetricDefinitionValue from './MetricDefinitionValue';\nimport AdhocMetric from './AdhocMetric';\nimport savedMetricType from './savedMetricType';\nimport adhocMetricType from './adhocMetricType';\nimport AdhocMetricPopoverTrigger from './AdhocMetricPopoverTrigger';\n\nconst propTypes = {\n  name: PropTypes.string.isRequired,\n  onChange: PropTypes.func,\n  value: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, adhocMetricType])),\n    PropTypes.oneOfType([PropTypes.string, adhocMetricType]),\n  ]),\n  columns: PropTypes.arrayOf(columnType),\n  savedMetrics: PropTypes.arrayOf(savedMetricType),\n  isLoading: PropTypes.bool,\n  multi: PropTypes.bool,\n  clearable: PropTypes.bool,\n  datasource: PropTypes.object,\n};\n\nconst defaultProps = {\n  onChange: () => {},\n  clearable: true,\n  savedMetrics: [],\n  columns: [],\n};\n\nfunction getOptionsForSavedMetrics(\n  savedMetrics,\n  currentMetricValues,\n  currentMetric,\n) {\n  return (\n    savedMetrics?.filter(savedMetric =>\n      Array.isArray(currentMetricValues)\n        ? !currentMetricValues.includes(savedMetric.metric_name) ||\n          savedMetric.metric_name === currentMetric\n        : savedMetric,\n    ) ?? []\n  );\n}\n\nfunction isDictionaryForAdhocMetric(value) {\n  return value && !(value instanceof AdhocMetric) && value.expressionType;\n}\n\n// adhoc metrics are stored as dictionaries in URL params. We convert them back into the\n// AdhocMetric class for typechecking, consistency and instance method access.\nfunction coerceAdhocMetrics(value) {\n  if (!value) {\n    return [];\n  }\n  if (!Array.isArray(value)) {\n    if (isDictionaryForAdhocMetric(value)) {\n      return [new AdhocMetric(value)];\n    }\n    return [value];\n  }\n  return value.map(val => {\n    if (isDictionaryForAdhocMetric(val)) {\n      return new AdhocMetric(val);\n    }\n    return val;\n  });\n}\n\nconst emptySavedMetric = { metric_name: '', expression: '' };\n\n// TODO: use typeguards to distinguish saved metrics from adhoc metrics\nconst getMetricsMatchingCurrentDataset = (value, columns, savedMetrics) =>\n  ensureIsArray(value).filter(metric => {\n    if (typeof metric === 'string' || metric.metric_name) {\n      return savedMetrics?.some(\n        savedMetric =>\n          savedMetric.metric_name === metric ||\n          savedMetric.metric_name === metric.metric_name,\n      );\n    }\n    return columns?.some(\n      column =>\n        !metric.column || metric.column.column_name === column.column_name,\n    );\n  });\n\nconst MetricsControl = ({\n  onChange,\n  multi,\n  value: propsValue,\n  columns,\n  savedMetrics,\n  datasource,\n  ...props\n}) => {\n  const [value, setValue] = useState(coerceAdhocMetrics(propsValue));\n  const theme = useTheme();\n  const prevColumns = usePrevious(columns);\n  const prevSavedMetrics = usePrevious(savedMetrics);\n\n  const handleChange = useCallback(\n    opts => {\n      // if clear out options\n      if (opts === null) {\n        onChange(null);\n        return;\n      }\n\n      const transformedOpts = ensureIsArray(opts);\n      const optionValues = transformedOpts\n        .map(option => {\n          // pre-defined metric\n          if (option.metric_name) {\n            return option.metric_name;\n          }\n          return option;\n        })\n        .filter(option => option);\n      onChange(multi ? optionValues : optionValues[0]);\n    },\n    [multi, onChange],\n  );\n\n  const onNewMetric = useCallback(\n    newMetric => {\n      const newValue = [...value, newMetric];\n      setValue(newValue);\n      handleChange(newValue);\n    },\n    [handleChange, value],\n  );\n\n  const onMetricEdit = useCallback(\n    (changedMetric, oldMetric) => {\n      const newValue = value.map(val => {\n        if (\n          // compare saved metrics\n          val === oldMetric.metric_name ||\n          // compare adhoc metrics\n          typeof val.optionName !== 'undefined'\n            ? val.optionName === oldMetric.optionName\n            : false\n        ) {\n          return changedMetric;\n        }\n        return val;\n      });\n      setValue(newValue);\n      handleChange(newValue);\n    },\n    [handleChange, value],\n  );\n\n  const onRemoveMetric = useCallback(\n    index => {\n      if (!Array.isArray(value)) {\n        return;\n      }\n      const valuesCopy = [...value];\n      valuesCopy.splice(index, 1);\n      setValue(valuesCopy);\n      handleChange(valuesCopy);\n    },\n    [handleChange, value],\n  );\n\n  const moveLabel = useCallback(\n    (dragIndex, hoverIndex) => {\n      const newValues = [...value];\n      [newValues[hoverIndex], newValues[dragIndex]] = [\n        newValues[dragIndex],\n        newValues[hoverIndex],\n      ];\n      setValue(newValues);\n    },\n    [value],\n  );\n\n  const isAddNewMetricDisabled = useCallback(\n    () => !multi && value.length > 0,\n    [multi, value.length],\n  );\n\n  const savedMetricOptions = useMemo(\n    () => getOptionsForSavedMetrics(savedMetrics, propsValue, null),\n    [propsValue, savedMetrics],\n  );\n\n  const newAdhocMetric = useMemo(() => new AdhocMetric({}), [value]);\n  const addNewMetricPopoverTrigger = useCallback(\n    trigger => {\n      if (isAddNewMetricDisabled()) {\n        return trigger;\n      }\n      return (\n        <AdhocMetricPopoverTrigger\n          adhocMetric={newAdhocMetric}\n          onMetricEdit={onNewMetric}\n          columns={columns}\n          savedMetricsOptions={savedMetricOptions}\n          savedMetric={emptySavedMetric}\n          datasource={datasource}\n          isNew\n        >\n          {trigger}\n        </AdhocMetricPopoverTrigger>\n      );\n    },\n    [\n      columns,\n      datasource,\n      isAddNewMetricDisabled,\n      newAdhocMetric,\n      onNewMetric,\n      savedMetricOptions,\n    ],\n  );\n\n  useEffect(() => {\n    // Remove selected custom metrics that do not exist in the dataset anymore\n    // Remove selected adhoc metrics that use columns which do not exist in the dataset anymore\n    if (\n      propsValue &&\n      (!isEqual(prevColumns, columns) ||\n        !isEqual(prevSavedMetrics, savedMetrics))\n    ) {\n      const matchingMetrics = getMetricsMatchingCurrentDataset(\n        propsValue,\n        columns,\n        savedMetrics,\n      );\n      if (!isEqual(matchingMetrics, propsValue)) {\n        handleChange(matchingMetrics);\n      }\n    }\n  }, [columns, handleChange, savedMetrics]);\n\n  useEffect(() => {\n    setValue(coerceAdhocMetrics(propsValue));\n  }, [propsValue]);\n\n  const onDropLabel = useCallback(\n    () => handleChange(value),\n    [handleChange, value],\n  );\n\n  const valueRenderer = useCallback(\n    (option, index) => (\n      <MetricDefinitionValue\n        key={index}\n        index={index}\n        option={option}\n        onMetricEdit={onMetricEdit}\n        onRemoveMetric={onRemoveMetric}\n        columns={columns}\n        datasource={datasource}\n        savedMetrics={savedMetrics}\n        savedMetricsOptions={getOptionsForSavedMetrics(\n          savedMetrics,\n          value,\n          value?.[index],\n        )}\n        onMoveLabel={moveLabel}\n        onDropLabel={onDropLabel}\n        multi={multi}\n      />\n    ),\n    [\n      columns,\n      datasource,\n      moveLabel,\n      multi,\n      onDropLabel,\n      onMetricEdit,\n      onRemoveMetric,\n      savedMetrics,\n      value,\n    ],\n  );\n\n  return (\n    <div className=\"metrics-select\">\n      <HeaderContainer>\n        <ControlHeader {...props} />\n        {addNewMetricPopoverTrigger(\n          <AddIconButton\n            disabled={isAddNewMetricDisabled()}\n            data-test=\"add-metric-button\"\n          >\n            <Icons.PlusLarge\n              iconSize=\"s\"\n              iconColor={theme.colors.grayscale.light5}\n            />\n          </AddIconButton>,\n        )}\n      </HeaderContainer>\n      <LabelsContainer>\n        {value.length > 0\n          ? value.map((value, index) => valueRenderer(value, index))\n          : addNewMetricPopoverTrigger(\n              <AddControlLabel>\n                <Icons.PlusSmall iconColor={theme.colors.grayscale.light1} />\n                {t('Add metric')}\n              </AddControlLabel>,\n            )}\n      </LabelsContainer>\n    </div>\n  );\n};\n\nMetricsControl.propTypes = propTypes;\nMetricsControl.defaultProps = defaultProps;\n\nexport default MetricsControl;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}