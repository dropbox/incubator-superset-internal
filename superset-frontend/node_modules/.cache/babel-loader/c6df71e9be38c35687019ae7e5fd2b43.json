{"ast":null,"code":"import _isEqual from \"lodash/isEqual\"; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport cloudLayout from 'd3-cloud';\nimport { createEncoderFactory } from 'encodable';\nimport { withTheme, seed } from '@superset-ui/core';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst seedRandom = seed('superset-ui');\nexport const ROTATION = {\n  flat: () => 0,\n  // this calculates a random rotation between -90 and 90 degrees.\n  random: () => Math.floor(seedRandom() * 6 - 3) * 30,\n  square: () => Math.floor(seedRandom() * 2) * 90 };\n\nconst defaultProps = {\n  encoding: {},\n  rotation: 'flat' };\n\nconst SCALE_FACTOR_STEP = 0.5;\nconst MAX_SCALE_FACTOR = 3;\n// Percentage of top results that will always be displayed.\n// Needed to avoid clutter when shrinking a chart with many records.\nconst TOP_RESULTS_PERCENTAGE = 0.1;\nclass WordCloud extends React.PureComponent {\n\n  // Cannot name it isMounted because of conflict\n  // with React's component function name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor(props) {\n    super(props);this.isComponentMounted = false;this.wordCloudEncoderFactory = createEncoderFactory({ channelTypes: { color: 'Color', fontFamily: 'Category', fontSize: 'Numeric', fontWeight: 'Category', text: 'Text' }, defaultEncoding: { color: { value: this.props.theme.colors.grayscale.dark2 }, fontFamily: { value: this.props.theme.typography.families.sansSerif }, fontSize: { value: 20 }, fontWeight: { value: 'bold' }, text: { value: '' } } });this.createEncoder = this.wordCloudEncoderFactory.createSelector();\n    this.state = {\n      words: [],\n      scaleFactor: 1 };\n\n    this.setWords = this.setWords.bind(this);\n  }\n  componentDidMount() {\n    this.isComponentMounted = true;\n    this.update();\n  }\n  componentDidUpdate(prevProps) {\n    const { data, encoding, width, height, rotation } = this.props;\n    if (!_isEqual(prevProps.data, data) ||\n    !_isEqual(prevProps.encoding, encoding) ||\n    prevProps.width !== width ||\n    prevProps.height !== height ||\n    prevProps.rotation !== rotation) {\n      this.update();\n    }\n  }\n  componentWillUnmount() {\n    this.isComponentMounted = false;\n  }\n  setWords(words) {\n    if (this.isComponentMounted) {\n      this.setState({ words });\n    }\n  }\n  update() {\n    const { data, encoding } = this.props;\n    const encoder = this.createEncoder(encoding);\n    encoder.setDomainFromDataset(data);\n    const sortedData = [...data].sort((a, b) => encoder.channels.fontSize.encodeDatum(b, 0) -\n    encoder.channels.fontSize.encodeDatum(a, 0));\n    const topResultsCount = Math.max(sortedData.length * TOP_RESULTS_PERCENTAGE, 10);\n    const topResults = sortedData.slice(0, topResultsCount);\n    // Ensure top results are always included in the final word cloud by scaling chart down if needed\n    this.generateCloud(encoder, 1, (words) => topResults.every((d) => words.find((_ref) => {let { text } = _ref;return encoder.channels.text.getValueFromDatum(d) === text;})));\n  }\n  generateCloud(encoder, scaleFactor, isValid) {\n    const { data, width, height, rotation } = this.props;\n    cloudLayout().\n    size([width * scaleFactor, height * scaleFactor])\n    // clone the data because cloudLayout mutates input\n    .words(data.map((d) => ({ ...d }))).\n    padding(5).\n    rotate(ROTATION[rotation] || ROTATION.flat).\n    text((d) => encoder.channels.text.getValueFromDatum(d)).\n    font((d) => encoder.channels.fontFamily.encodeDatum(d, this.props.theme.typography.families.sansSerif)).\n    fontWeight((d) => encoder.channels.fontWeight.encodeDatum(d, 'normal')).\n    fontSize((d) => encoder.channels.fontSize.encodeDatum(d, 0)).\n    on('end', (words) => {\n      if (isValid(words) || scaleFactor > MAX_SCALE_FACTOR) {\n        if (this.isComponentMounted) {\n          this.setState({ words, scaleFactor });\n        }\n      } else\n      {\n        this.generateCloud(encoder, scaleFactor + SCALE_FACTOR_STEP, isValid);\n      }\n    }).\n    start();\n  }\n  render() {\n    const { scaleFactor } = this.state;\n    const { width, height, encoding, sliceId } = this.props;\n    const { words } = this.state;\n    const encoder = this.createEncoder(encoding);\n    encoder.channels.color.setDomainFromDataset(words);\n    const { getValueFromDatum } = encoder.channels.color;\n    const colorFn = encoder.channels.color.scale;\n    const viewBoxWidth = width * scaleFactor;\n    const viewBoxHeight = height * scaleFactor;\n    return ___EmotionJSX(\"svg\", { width: width, height: height, viewBox: `-${viewBoxWidth / 2} -${viewBoxHeight / 2} ${viewBoxWidth} ${viewBoxHeight}` },\n    ___EmotionJSX(\"g\", null,\n    words.map((w) => ___EmotionJSX(\"text\", { key: w.text, fontSize: `${w.size}px`, fontWeight: w.weight, fontFamily: w.font, fill: colorFn(getValueFromDatum(w), sliceId), textAnchor: \"middle\", transform: `translate(${w.x}, ${w.y}) rotate(${w.rotate})` },\n    w.text))));\n\n\n\n  }}WordCloud.defaultProps = defaultProps;\n\nexport default withTheme(WordCloud);","map":{"version":3,"mappings":"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","names":["React","cloudLayout","createEncoderFactory","withTheme","seed","seedRandom","ROTATION","flat","random","Math","floor","square","defaultProps","encoding","rotation","SCALE_FACTOR_STEP","MAX_SCALE_FACTOR","TOP_RESULTS_PERCENTAGE","WordCloud","PureComponent","constructor","props","isComponentMounted","wordCloudEncoderFactory","channelTypes","color","fontFamily","fontSize","fontWeight","text","defaultEncoding","value","theme","colors","grayscale","dark2","typography","families","sansSerif","createEncoder","createSelector","state","words","scaleFactor","setWords","bind","componentDidMount","update","componentDidUpdate","prevProps","data","width","height","componentWillUnmount","setState","encoder","setDomainFromDataset","sortedData","sort","a","b","channels","encodeDatum","topResultsCount","max","length","topResults","slice","generateCloud","every","d","find","getValueFromDatum","isValid","size","map","padding","rotate","font","on","start","render","sliceId","colorFn","scale","viewBoxWidth","viewBoxHeight","w","weight","x","y"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-word-cloud/src/chart/WordCloud.tsx"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React from 'react';\nimport cloudLayout, { Word } from 'd3-cloud';\nimport {\n  PlainObject,\n  createEncoderFactory,\n  DeriveEncoding,\n  Encoder,\n} from 'encodable';\nimport {\n  SupersetThemeProps,\n  withTheme,\n  seed,\n  CategoricalColorScale,\n} from '@superset-ui/core';\nimport { isEqual } from 'lodash';\n\nconst seedRandom = seed('superset-ui');\nexport const ROTATION = {\n  flat: () => 0,\n  // this calculates a random rotation between -90 and 90 degrees.\n  random: () => Math.floor(seedRandom() * 6 - 3) * 30,\n  square: () => Math.floor(seedRandom() * 2) * 90,\n};\n\nexport type RotationType = keyof typeof ROTATION;\n\nexport type WordCloudEncoding = DeriveEncoding<WordCloudEncodingConfig>;\n\ntype WordCloudEncodingConfig = {\n  color: ['Color', string];\n  fontFamily: ['Category', string];\n  fontSize: ['Numeric', number];\n  fontWeight: ['Category', string | number];\n  text: ['Text', string];\n};\n\n/**\n * These props should be stored when saving the chart.\n */\nexport interface WordCloudVisualProps {\n  encoding?: Partial<WordCloudEncoding>;\n  rotation?: RotationType;\n}\n\nexport interface WordCloudProps extends WordCloudVisualProps {\n  data: PlainObject[];\n  height: number;\n  width: number;\n  sliceId: number;\n}\n\nexport interface WordCloudState {\n  words: Word[];\n  scaleFactor: number;\n}\n\nconst defaultProps: Required<WordCloudVisualProps> = {\n  encoding: {},\n  rotation: 'flat',\n};\n\ntype FullWordCloudProps = WordCloudProps &\n  typeof defaultProps &\n  SupersetThemeProps;\n\nconst SCALE_FACTOR_STEP = 0.5;\nconst MAX_SCALE_FACTOR = 3;\n// Percentage of top results that will always be displayed.\n// Needed to avoid clutter when shrinking a chart with many records.\nconst TOP_RESULTS_PERCENTAGE = 0.1;\n\nclass WordCloud extends React.PureComponent<\n  FullWordCloudProps,\n  WordCloudState\n> {\n  static defaultProps = defaultProps;\n\n  // Cannot name it isMounted because of conflict\n  // with React's component function name\n  isComponentMounted = false;\n\n  wordCloudEncoderFactory = createEncoderFactory<WordCloudEncodingConfig>({\n    channelTypes: {\n      color: 'Color',\n      fontFamily: 'Category',\n      fontSize: 'Numeric',\n      fontWeight: 'Category',\n      text: 'Text',\n    },\n    defaultEncoding: {\n      color: { value: this.props.theme.colors.grayscale.dark2 },\n      fontFamily: { value: this.props.theme.typography.families.sansSerif },\n      fontSize: { value: 20 },\n      fontWeight: { value: 'bold' },\n      text: { value: '' },\n    },\n  });\n\n  createEncoder = this.wordCloudEncoderFactory.createSelector();\n\n  constructor(props: FullWordCloudProps) {\n    super(props);\n    this.state = {\n      words: [],\n      scaleFactor: 1,\n    };\n    this.setWords = this.setWords.bind(this);\n  }\n\n  componentDidMount() {\n    this.isComponentMounted = true;\n    this.update();\n  }\n\n  componentDidUpdate(prevProps: WordCloudProps) {\n    const { data, encoding, width, height, rotation } = this.props;\n\n    if (\n      !isEqual(prevProps.data, data) ||\n      !isEqual(prevProps.encoding, encoding) ||\n      prevProps.width !== width ||\n      prevProps.height !== height ||\n      prevProps.rotation !== rotation\n    ) {\n      this.update();\n    }\n  }\n\n  componentWillUnmount() {\n    this.isComponentMounted = false;\n  }\n\n  setWords(words: Word[]) {\n    if (this.isComponentMounted) {\n      this.setState({ words });\n    }\n  }\n\n  update() {\n    const { data, encoding } = this.props;\n\n    const encoder = this.createEncoder(encoding);\n    encoder.setDomainFromDataset(data);\n\n    const sortedData = [...data].sort(\n      (a, b) =>\n        encoder.channels.fontSize.encodeDatum(b, 0) -\n        encoder.channels.fontSize.encodeDatum(a, 0),\n    );\n    const topResultsCount = Math.max(\n      sortedData.length * TOP_RESULTS_PERCENTAGE,\n      10,\n    );\n    const topResults = sortedData.slice(0, topResultsCount);\n\n    // Ensure top results are always included in the final word cloud by scaling chart down if needed\n    this.generateCloud(encoder, 1, (words: Word[]) =>\n      topResults.every((d: PlainObject) =>\n        words.find(\n          ({ text }) => encoder.channels.text.getValueFromDatum(d) === text,\n        ),\n      ),\n    );\n  }\n\n  generateCloud(\n    encoder: Encoder<WordCloudEncodingConfig>,\n    scaleFactor: number,\n    isValid: (word: Word[]) => boolean,\n  ) {\n    const { data, width, height, rotation } = this.props;\n\n    cloudLayout()\n      .size([width * scaleFactor, height * scaleFactor])\n      // clone the data because cloudLayout mutates input\n      .words(data.map(d => ({ ...d })))\n      .padding(5)\n      .rotate(ROTATION[rotation] || ROTATION.flat)\n      .text(d => encoder.channels.text.getValueFromDatum(d))\n      .font(d =>\n        encoder.channels.fontFamily.encodeDatum(\n          d,\n          this.props.theme.typography.families.sansSerif,\n        ),\n      )\n      .fontWeight(d => encoder.channels.fontWeight.encodeDatum(d, 'normal'))\n      .fontSize(d => encoder.channels.fontSize.encodeDatum(d, 0))\n      .on('end', (words: Word[]) => {\n        if (isValid(words) || scaleFactor > MAX_SCALE_FACTOR) {\n          if (this.isComponentMounted) {\n            this.setState({ words, scaleFactor });\n          }\n        } else {\n          this.generateCloud(encoder, scaleFactor + SCALE_FACTOR_STEP, isValid);\n        }\n      })\n      .start();\n  }\n\n  render() {\n    const { scaleFactor } = this.state;\n    const { width, height, encoding, sliceId } = this.props;\n    const { words } = this.state;\n\n    const encoder = this.createEncoder(encoding);\n    encoder.channels.color.setDomainFromDataset(words);\n\n    const { getValueFromDatum } = encoder.channels.color;\n    const colorFn = encoder.channels.color.scale as CategoricalColorScale;\n\n    const viewBoxWidth = width * scaleFactor;\n    const viewBoxHeight = height * scaleFactor;\n\n    return (\n      <svg\n        width={width}\n        height={height}\n        viewBox={`-${viewBoxWidth / 2} -${\n          viewBoxHeight / 2\n        } ${viewBoxWidth} ${viewBoxHeight}`}\n      >\n        <g>\n          {words.map(w => (\n            <text\n              key={w.text}\n              fontSize={`${w.size}px`}\n              fontWeight={w.weight}\n              fontFamily={w.font}\n              fill={colorFn(getValueFromDatum(w) as string, sliceId)}\n              textAnchor=\"middle\"\n              transform={`translate(${w.x}, ${w.y}) rotate(${w.rotate})`}\n            >\n              {w.text}\n            </text>\n          ))}\n        </g>\n      </svg>\n    );\n  }\n}\n\nexport default withTheme(WordCloud);\n"]},"metadata":{},"sourceType":"module"}