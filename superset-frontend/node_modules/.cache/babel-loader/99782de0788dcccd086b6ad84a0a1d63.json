{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AnnotationOpacity, getTimeFormatter, isTimeseriesAnnotationResult, smartDateDetailedFormatter, smartDateFormatter } from '@superset-ui/core';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum, LegendOrientation } from '../types';\nimport { evalFormula, extractRecordAnnotations, formatAnnotationLabel, parseAnnotationOpacity } from '../utils/annotation';\nimport { getChartPadding } from '../utils/series';\nimport { OpacityEnum, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (series, seriesType) => {var _context;\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value) => value != null ? value : 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta = i > 0 ?\n      getVal(series[j][i][1]) - getVal(series[j][i - 1][1]) :\n      getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n        i > 0 ?\n        getVal(series[k][i][1]) - getVal(series[k][i - 1][1]) :\n        getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else\n    {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all',\n    type: 'line',\n    lineStyle: {\n      opacity: 0 },\n\n    tooltip: {\n      show: false },\n\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0 },\n\n    step: _includesInstanceProperty(_context = [\n    EchartsTimeseriesSeriesType.Start,\n    EchartsTimeseriesSeriesType.Middle,\n    EchartsTimeseriesSeriesType.End]).call(_context,\n    seriesType) ?\n    seriesType :\n    undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth };\n\n};\nexport function transformSeries(series, colorScale, colorScaleKey, opts) {var _context2, _context3;\n  const { name } = series;\n  const { area, filterState, seriesContexts = {}, markerEnabled, markerSize, areaOpacity = 1, seriesType, stack, yAxisIndex = 0, showValue, onlyTotal, formatter, legendState, totalStackedValues = [], showValueIndexes = [], thresholdValues = [], richTooltip, sliceId, isHorizontal = false, queryIndex = 0 } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast = _includesInstanceProperty(contexts).call(contexts, ForecastSeriesEnum.ForecastTrend) ||\n  _includesInstanceProperty(contexts).call(contexts, ForecastSeriesEnum.ForecastLower) ||\n  _includesInstanceProperty(contexts).call(contexts, ForecastSeriesEnum.ForecastUpper);\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand = forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n  forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered = (filterState == null ? void 0 : filterState.selectedValues) && !(filterState != null && _includesInstanceProperty(_context2 = filterState.selectedValues).call(_context2, name));\n  const opacity = isFiltered ?\n  OpacityEnum.SemiTransparent :\n  OpacityEnum.NonTransparent;\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand)\n  return undefined;\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else\n  if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore we need to set something that is truthy.\n    stackId = 'obs';\n  } else\n  if (stack && isTrend) {\n    stackId = forecastSeries.type;\n  }\n  let plotType;\n  if (!isConfidenceBand && (\n  seriesType === 'scatter' || hasForecast && isObservation)) {\n    plotType = 'scatter';\n  } else\n  if (isConfidenceBand) {\n    plotType = 'line';\n  } else\n  {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  // forcing the colorScale to return a different color for same metrics across different queries\n  const itemStyle = {\n    color: colorScale(colorScaleKey, sliceId),\n    opacity };\n\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else\n    if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1 } };\n\n\n    } else\n    if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle = isConfidenceBand || stack === StackControlsValue.Stream && area ?\n  { ...opts.lineStyle, opacity: OpacityEnum.Transparent } :\n  { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: _includesInstanceProperty(_context3 = ['start', 'middle', 'end']).call(_context3, seriesType) ?\n    seriesType :\n    undefined,\n    stack: stackId,\n    stackStrategy: isConfidenceBand || stack === StackControlsValue.Stream ?\n    'all' :\n    'samesign',\n    lineStyle,\n    areaStyle: area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper ?\n    {\n      opacity: opacity * areaOpacity } :\n\n    undefined,\n    emphasis: {\n      // bold on hover as required since 5.3.0 to retain backwards feature parity:\n      // https://apache.github.io/echarts-handbook/en/basics/release-note/5-3-0/#removing-the-default-bolding-emphasis-effect-in-the-line-chart\n      // TODO: should consider only adding emphasis to currently hovered series\n      lineStyle: {\n        width: 'bolder' },\n\n      ...emphasis },\n\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params) => {\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (numericValue >= (\n          thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      } } };\n\n\n}\nexport function transformFormulaAnnotation(layer, data, xAxisCol, xAxisType, colorScale, sliceId) {\n  const { name, color, opacity, width, style } = layer;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId) },\n\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style,\n      width },\n\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType),\n    symbolSize: 0 };\n\n}\nexport function transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const intervalData = [\n    [\n    {\n      name: label,\n      xAxis: time },\n\n    {\n      xAxis: intervalEnd }]];\n\n\n\n    const intervalLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideTop',\n      verticalAlign: 'top',\n      fontWeight: 'bold',\n      // @ts-ignore\n      emphasis: {\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5 } } :\n\n\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      // @ts-ignore\n      emphasis: {\n        fontWeight: 'bold',\n        show: true,\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5 } };\n\n\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8 } },\n\n\n        label: intervalLabel,\n        data: intervalData } });\n\n\n  });\n  return series;\n}\nexport function transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const eventData = [\n    {\n      name: label,\n      xAxis: time }];\n\n\n    const lineStyle = {\n      width,\n      type: style,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1 } };\n\n\n    const eventLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      fontWeight: 'bold',\n      formatter: (params) => params.name,\n      // @ts-ignore\n      emphasis: {\n        backgroundColor: theme.colors.grayscale.light5 } } :\n\n\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      // @ts-ignore\n      emphasis: {\n        formatter: (params) => params.name,\n        fontWeight: 'bold',\n        show: true,\n        backgroundColor: theme.colors.grayscale.light5 } };\n\n\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData } });\n\n\n  });\n  return series;\n}\nexport function transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId) {\n  const series = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach((annotation) => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map((row) => [row.x, row.y]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId) } });\n\n\n    });\n  }\n  return series;\n}\nexport function getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, margin, addXAxisTitleOffset, yAxisTitlePosition, yAxisTitleMargin, xAxisTitleMargin) {\n  const yAxisOffset = addYAxisTitleOffset ?\n  TIMESERIES_CONSTANTS.yAxisLabelTopOffset :\n  0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  return getChartPadding(showLegend, legendOrientation, margin, {\n    top: yAxisTitlePosition && yAxisTitlePosition === 'Top' ?\n    TIMESERIES_CONSTANTS.gridOffsetTop + (Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetTop + yAxisOffset,\n    bottom: zoomable ?\n    TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset :\n    TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n    left: yAxisTitlePosition === 'Left' ?\n    TIMESERIES_CONSTANTS.gridOffsetLeft + (Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetLeft,\n    right: showLegend && legendOrientation === LegendOrientation.Right ?\n    0 :\n    TIMESERIES_CONSTANTS.gridOffsetRight });\n\n}\nexport function getTooltipTimeFormatter(format) {\n  if (format === smartDateFormatter.id) {\n    return smartDateDetailedFormatter;\n  }\n  if (format) {\n    return getTimeFormatter(format);\n  }\n  return String;\n}\nexport function getXAxisFormatter(format) {\n  if (format === smartDateFormatter.id || !format) {\n    return undefined;\n  }\n  if (format) {\n    return getTimeFormatter(format);\n  }\n  return String;\n}","map":{"version":3,"mappings":"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","names":["AnnotationOpacity","getTimeFormatter","isTimeseriesAnnotationResult","smartDateDetailedFormatter","smartDateFormatter","extractForecastSeriesContext","EchartsTimeseriesSeriesType","ForecastSeriesEnum","LegendOrientation","evalFormula","extractRecordAnnotations","formatAnnotationLabel","parseAnnotationOpacity","getChartPadding","OpacityEnum","StackControlsValue","TIMESERIES_CONSTANTS","getBaselineSeriesForStream","series","seriesType","seriesLength","length","baselineSeriesDelta","Array","fill","getVal","value","i","seriesSum","weightedSeriesSum","j","delta","deltaPrev","k","baselineSeries","reduce","acc","curr","push","data","name","stack","stackStrategy","type","lineStyle","opacity","tooltip","show","silent","showSymbol","areaStyle","step","Start","Middle","End","undefined","smooth","Smooth","transformSeries","colorScale","colorScaleKey","opts","area","filterState","seriesContexts","markerEnabled","markerSize","areaOpacity","yAxisIndex","showValue","onlyTotal","formatter","legendState","totalStackedValues","showValueIndexes","thresholdValues","richTooltip","sliceId","isHorizontal","queryIndex","contexts","hasForecast","ForecastTrend","ForecastLower","ForecastUpper","forecastSeries","isConfidenceBand","isFiltered","selectedValues","SemiTransparent","NonTransparent","isObservation","Observation","isTrend","stackId","plotType","itemStyle","color","emphasis","Stream","Transparent","triggerLineEvent","width","symbolSize","label","position","params","dataIndex","seriesIndex","seriesName","numericValue","isSelectedLegend","isAreaExpand","Expand","Number","MIN_SAFE_INTEGER","transformFormulaAnnotation","layer","xAxisCol","xAxisType","style","id","transformIntervalAnnotation","annotationData","theme","annotations","forEach","showLabel","descriptions","intervalEnd","time","title","annotation","intervalData","xAxis","intervalLabel","colors","grayscale","dark2","verticalAlign","fontWeight","backgroundColor","light5","animation","markArea","Medium","transformEventAnnotation","eventData","eventLabel","markLine","symbol","transformTimeseriesAnnotation","hideLine","showMarkers","result","key","values","map","row","x","y","getPadding","showLegend","legendOrientation","addYAxisTitleOffset","zoomable","margin","addXAxisTitleOffset","yAxisTitlePosition","yAxisTitleMargin","xAxisTitleMargin","yAxisOffset","yAxisLabelTopOffset","xAxisOffset","top","gridOffsetTop","bottom","gridOffsetBottomZoomable","gridOffsetBottom","left","gridOffsetLeft","right","Right","gridOffsetRight","getTooltipTimeFormatter","format","String","getXAxisFormatter"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AnnotationData,\n  AnnotationOpacity,\n  AxisType,\n  CategoricalColorScale,\n  EventAnnotationLayer,\n  FilterState,\n  FormulaAnnotationLayer,\n  getTimeFormatter,\n  IntervalAnnotationLayer,\n  isTimeseriesAnnotationResult,\n  LegendState,\n  smartDateDetailedFormatter,\n  smartDateFormatter,\n  SupersetTheme,\n  TimeFormatter,\n  TimeseriesAnnotationLayer,\n  TimeseriesDataRecord,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { SeriesOption } from 'echarts';\nimport {\n  CallbackDataParams,\n  DefaultStatesMixin,\n  ItemStyleOption,\n  LineStyleOption,\n  OptionName,\n  SeriesLabelOption,\n  SeriesLineLabelOption,\n  ZRLineType,\n} from 'echarts/types/src/util/types';\nimport {\n  MarkArea1DDataItemOption,\n  MarkArea2DDataItemOption,\n} from 'echarts/types/src/component/marker/MarkAreaModel';\nimport { MarkLine1DDataItemOption } from 'echarts/types/src/component/marker/MarkLineModel';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  LegendOrientation,\n  StackType,\n} from '../types';\n\nimport {\n  evalFormula,\n  extractRecordAnnotations,\n  formatAnnotationLabel,\n  parseAnnotationOpacity,\n} from '../utils/annotation';\nimport { getChartPadding } from '../utils/series';\nimport {\n  OpacityEnum,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\n\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (\n  series: [string | number, number][][],\n  seriesType: EchartsTimeseriesSeriesType,\n) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value: number | null) => value ?? 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta =\n        i > 0\n          ? getVal(series[j][i][1]) - getVal(series[j][i - 1][1])\n          : getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n          i > 0\n            ? getVal(series[k][i][1]) - getVal(series[k][i - 1][1])\n            : getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all' as const,\n    type: 'line' as const,\n    lineStyle: {\n      opacity: 0,\n    },\n    tooltip: {\n      show: false,\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0,\n    },\n    step: [\n      EchartsTimeseriesSeriesType.Start,\n      EchartsTimeseriesSeriesType.Middle,\n      EchartsTimeseriesSeriesType.End,\n    ].includes(seriesType)\n      ? (seriesType as\n          | EchartsTimeseriesSeriesType.Start\n          | EchartsTimeseriesSeriesType.Middle\n          | EchartsTimeseriesSeriesType.End)\n      : undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth,\n  };\n};\n\nexport function transformSeries(\n  series: SeriesOption,\n  colorScale: CategoricalColorScale,\n  colorScaleKey: string,\n  opts: {\n    area?: boolean;\n    filterState?: FilterState;\n    seriesContexts?: { [key: string]: ForecastSeriesEnum[] };\n    markerEnabled?: boolean;\n    markerSize?: number;\n    areaOpacity?: number;\n    seriesType?: EchartsTimeseriesSeriesType;\n    stack?: StackType;\n    yAxisIndex?: number;\n    showValue?: boolean;\n    onlyTotal?: boolean;\n    legendState?: LegendState;\n    formatter?: ValueFormatter;\n    totalStackedValues?: number[];\n    showValueIndexes?: number[];\n    thresholdValues?: number[];\n    richTooltip?: boolean;\n    seriesKey?: OptionName;\n    sliceId?: number;\n    isHorizontal?: boolean;\n    lineStyle?: LineStyleOption;\n    queryIndex?: number;\n  },\n): SeriesOption | undefined {\n  const { name } = series;\n  const {\n    area,\n    filterState,\n    seriesContexts = {},\n    markerEnabled,\n    markerSize,\n    areaOpacity = 1,\n    seriesType,\n    stack,\n    yAxisIndex = 0,\n    showValue,\n    onlyTotal,\n    formatter,\n    legendState,\n    totalStackedValues = [],\n    showValueIndexes = [],\n    thresholdValues = [],\n    richTooltip,\n    sliceId,\n    isHorizontal = false,\n    queryIndex = 0,\n  } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast =\n    contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n    contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n    contexts.includes(ForecastSeriesEnum.ForecastUpper);\n\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand =\n    forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n    forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered =\n    filterState?.selectedValues && !filterState?.selectedValues.includes(name);\n  const opacity = isFiltered\n    ? OpacityEnum.SemiTransparent\n    : OpacityEnum.NonTransparent;\n\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand) return undefined;\n\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore we need to set something that is truthy.\n    stackId = 'obs';\n  } else if (stack && isTrend) {\n    stackId = forecastSeries.type;\n  }\n  let plotType;\n  if (\n    !isConfidenceBand &&\n    (seriesType === 'scatter' || (hasForecast && isObservation))\n  ) {\n    plotType = 'scatter';\n  } else if (isConfidenceBand) {\n    plotType = 'line';\n  } else {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  // forcing the colorScale to return a different color for same metrics across different queries\n  const itemStyle = {\n    color: colorScale(colorScaleKey, sliceId),\n    opacity,\n  };\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1,\n        },\n      };\n    } else if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle =\n    isConfidenceBand || (stack === StackControlsValue.Stream && area)\n      ? { ...opts.lineStyle, opacity: OpacityEnum.Transparent }\n      : { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType as string)\n      ? seriesType\n      : undefined,\n    stack: stackId,\n    stackStrategy:\n      isConfidenceBand || stack === StackControlsValue.Stream\n        ? 'all'\n        : 'samesign',\n    lineStyle,\n    areaStyle:\n      area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper\n        ? {\n            opacity: opacity * areaOpacity,\n          }\n        : undefined,\n    emphasis: {\n      // bold on hover as required since 5.3.0 to retain backwards feature parity:\n      // https://apache.github.io/echarts-handbook/en/basics/release-note/5-3-0/#removing-the-default-bolding-emphasis-effect-in-the-line-chart\n      // TODO: should consider only adding emphasis to currently hovered series\n      lineStyle: {\n        width: 'bolder',\n      },\n      ...emphasis,\n    },\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params: any) => {\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (\n            numericValue >=\n            (thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)\n          ) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      },\n    },\n  };\n}\n\nexport function transformFormulaAnnotation(\n  layer: FormulaAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  xAxisCol: string,\n  xAxisType: AxisType,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n): SeriesOption {\n  const { name, color, opacity, width, style } = layer;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId),\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style as ZRLineType,\n      width,\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType),\n    symbolSize: 0,\n  };\n}\n\nexport function transformIntervalAnnotation(\n  layer: IntervalAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const intervalData: (\n      | MarkArea1DDataItemOption\n      | MarkArea2DDataItemOption\n    )[] = [\n      [\n        {\n          name: label,\n          xAxis: time,\n        },\n        {\n          xAxis: intervalEnd,\n        },\n      ],\n    ];\n    const intervalLabel: SeriesLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideTop',\n          verticalAlign: 'top',\n          fontWeight: 'bold',\n          // @ts-ignore\n          emphasis: {\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          // @ts-ignore\n          emphasis: {\n            fontWeight: 'bold',\n            show: true,\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8,\n          },\n        } as ItemStyleOption,\n        label: intervalLabel,\n        data: intervalData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformEventAnnotation(\n  layer: EventAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const eventData: MarkLine1DDataItemOption[] = [\n      {\n        name: label,\n        xAxis: time,\n      },\n    ];\n\n    const lineStyle: LineStyleOption & DefaultStatesMixin['emphasis'] = {\n      width,\n      type: style as ZRLineType,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1,\n      },\n    };\n\n    const eventLabel: SeriesLineLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          fontWeight: 'bold',\n          formatter: (params: CallbackDataParams) => params.name,\n          // @ts-ignore\n          emphasis: {\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          // @ts-ignore\n          emphasis: {\n            formatter: (params: CallbackDataParams) => params.name,\n            fontWeight: 'bold',\n            show: true,\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformTimeseriesAnnotation(\n  layer: TimeseriesAnnotationLayer,\n  markerSize: number,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach(annotation => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map(row => [row.x, row.y] as [OptionName, number]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style as ZRLineType,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId),\n        },\n      });\n    });\n  }\n  return series;\n}\n\nexport function getPadding(\n  showLegend: boolean,\n  legendOrientation: LegendOrientation,\n  addYAxisTitleOffset: boolean,\n  zoomable: boolean,\n  margin?: string | number | null,\n  addXAxisTitleOffset?: boolean,\n  yAxisTitlePosition?: string,\n  yAxisTitleMargin?: number,\n  xAxisTitleMargin?: number,\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  const yAxisOffset = addYAxisTitleOffset\n    ? TIMESERIES_CONSTANTS.yAxisLabelTopOffset\n    : 0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  return getChartPadding(showLegend, legendOrientation, margin, {\n    top:\n      yAxisTitlePosition && yAxisTitlePosition === 'Top'\n        ? TIMESERIES_CONSTANTS.gridOffsetTop + (Number(yAxisTitleMargin) || 0)\n        : TIMESERIES_CONSTANTS.gridOffsetTop + yAxisOffset,\n    bottom: zoomable\n      ? TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset\n      : TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n    left:\n      yAxisTitlePosition === 'Left'\n        ? TIMESERIES_CONSTANTS.gridOffsetLeft + (Number(yAxisTitleMargin) || 0)\n        : TIMESERIES_CONSTANTS.gridOffsetLeft,\n    right:\n      showLegend && legendOrientation === LegendOrientation.Right\n        ? 0\n        : TIMESERIES_CONSTANTS.gridOffsetRight,\n  });\n}\n\nexport function getTooltipTimeFormatter(\n  format?: string,\n): TimeFormatter | StringConstructor {\n  if (format === smartDateFormatter.id) {\n    return smartDateDetailedFormatter;\n  }\n  if (format) {\n    return getTimeFormatter(format);\n  }\n  return String;\n}\n\nexport function getXAxisFormatter(\n  format?: string,\n): TimeFormatter | StringConstructor | undefined {\n  if (format === smartDateFormatter.id || !format) {\n    return undefined;\n  }\n  if (format) {\n    return getTimeFormatter(format);\n  }\n  return String;\n}\n"]},"metadata":{},"sourceType":"module"}