{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useRef, useCallback, useImperativeHandle } from 'react';\nimport { ensureIsArray, t, usePrevious } from '@superset-ui/core';\nimport debounce from 'lodash/debounce';\n\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { FAST_DEBOUNCE, SLOW_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, hasCustomLabels, sortSelectedFirstHelper, sortComparatorWithSearchHelper, sortComparatorForNoSearchHelper, getSuffixIcon, dropDownRenderHelper, handleFilterOptionHelper, mapOptions } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledError, StyledErrorMessage, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { DEFAULT_PAGE_SIZE, EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Error = (_ref) => {let { error } = _ref;return ___EmotionJSX(StyledError, null,\n  ___EmotionJSX(Icons.ErrorSolid, null), \" \", ___EmotionJSX(StyledErrorMessage, null, error));};\n\nconst getQueryCacheKey = (value, page, pageSize) => `${value};${page};${pageSize}`;\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = /*#__PURE__*/forwardRef((_ref2, ref) => {let { allowClear, allowNewOptions = false, ariaLabel, autoClearSearchValue = false, fetchOnlyOnSearch, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onBlur, onError, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props } = _ref2;\n  const isSingleMode = mode === 'single';\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const selectValueRef = useRef(selectValue);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const allowFetch = !fetchOnlyOnSearch || inputValue;\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  useEffect(() => {\n    selectValueRef.current = selectValue;\n  }, [selectValue]);\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValueRef.current), []);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const sortComparatorForNoSearch = useCallback((a, b) => sortComparatorForNoSearchHelper(a, b, sortSelectedFirst, sortComparator), [sortComparator, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(EMPTY_OPTIONS);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    return missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n  }, [selectOptions, selectValue]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      setSelectValue(selectedItem);\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          return isLabeledValue(selectedItem) ?\n          result :\n          result;\n        }\n        return previousState;\n      });\n    }\n    fireOnChange();\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (isLabeledValue(value)) {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      }\n      // removes new option\n      if (option.isNewOption) {\n        setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const mergeData = useCallback((data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      // unique option values should always be case sensitive so don't lowercase\n      const dataValues = new Set(data.map((opt) => opt.value));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = prevOptions.\n        filter((previousOption) => !dataValues.has(previousOption.value)).\n        concat(data).\n        sort(sortComparatorForNoSearch);\n        return mergedData;\n      });\n    }\n    return mergedData;\n  }, [sortComparatorForNoSearch]);\n  const fetchPage = useMemo(() => (search, page) => {\n    setPage(page);\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      return;\n    }\n    const key = getQueryCacheKey(search, page, pageSize);\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount !== undefined) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(search, page, pageSize).\n    then((_ref3) => {let { data, totalCount } = _ref3;\n      const mergedData = mergeData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      search === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n    });\n  }, [\n  allValuesLoaded,\n  fetchOnlyOnSearch,\n  mergeData,\n  internalOnError,\n  options,\n  pageSize]);\n\n  const debouncedFetchPage = useMemo(() => debounce(fetchPage, SLOW_DEBOUNCE), [fetchPage]);\n  const handleOnSearch = debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true };\n\n      const cleanSelectOptions = fullSelectOptions.filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    if (!allValuesLoaded &&\n    loadingEnabled &&\n    !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))) {\n      // if fetch only on search but search value is empty, then should not be\n      // in loading state\n      setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n    }\n    setInputValue(search);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      fetchPage(inputValue, newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // loading is enabled when dropdown is open,\n    // disabled when dropdown is closed\n    if (loadingEnabled !== isDropdownVisible) {\n      setLoadingEnabled(isDropdownVisible);\n    }\n    // when closing dropdown, always reset loading state\n    if (!isDropdownVisible && isLoading) {\n      // delay is for the animation of closing the dropdown\n      // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n      // before closing.\n      setTimeout(() => {\n        setIsLoading(false);\n      }, 250);\n    }\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      const sortedOptions = selectOptions.\n      slice().\n      sort(sortComparatorForNoSearch);\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText, error ? ___EmotionJSX(Error, { error: error }) : undefined);\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n    fireOnChange();\n  };\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(selectValue, options[0]);\n      } else\n      {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]);\n\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    fetchedQueries.current.clear();\n    setAllValuesLoaded(false);\n    setSelectOptions(EMPTY_OPTIONS);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => {\n    debouncedFetchPage.cancel();\n  }, [debouncedFetchPage]);\n  useEffect(() => {\n    if (loadingEnabled && allowFetch) {\n      // trigger fetch every time inputValue changes\n      if (inputValue) {\n        debouncedFetchPage(inputValue, 0);\n      } else\n      {\n        fetchPage('', 0);\n      }\n    }\n  }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  const clearCache = () => fetchedQueries.current.clear();\n  useImperativeHandle(ref, () => ({\n    ...ref.current,\n    clearCache }),\n  [ref]);\n  const onPaste = (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      setSelectValue({ label: pastedText, value: pastedText });\n    } else\n    {\n      const token = tokenSeparators.find((token) => _includesInstanceProperty(pastedText).call(pastedText, token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      setSelectValue((previous) => [\n      ...(previous || []),\n      ...array.map((value) => ({\n        label: value,\n        value }))]);\n\n\n    }\n  };\n  const shouldRenderChildrenOptions = useMemo(() => hasCustomLabels(fullSelectOptions), [fullSelectOptions]);\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: true, maxTagCount: maxTagCount, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n    // @ts-ignore\n    , onPaste: onPaste, onPopupScroll: handlePagination, onSearch: showSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, placeholder: placeholder, showSearch: showSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, showSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  hasCustomLabels(fullSelectOptions) &&\n  renderSelectOptions(fullSelectOptions)));\n\n\n});\nexport default AsyncSelect;","map":{"version":3,"mappings":"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","names":["React","forwardRef","useEffect","useMemo","useState","useRef","useCallback","useImperativeHandle","ensureIsArray","t","usePrevious","debounce","Icons","getClientErrorObject","FAST_DEBOUNCE","SLOW_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","hasCustomLabels","sortSelectedFirstHelper","sortComparatorWithSearchHelper","sortComparatorForNoSearchHelper","getSuffixIcon","dropDownRenderHelper","handleFilterOptionHelper","mapOptions","StyledCheckOutlined","StyledContainer","StyledError","StyledErrorMessage","StyledHeader","StyledSelect","StyledStopOutlined","DEFAULT_PAGE_SIZE","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","Error","error","getQueryCacheKey","value","page","pageSize","AsyncSelect","ref","allowClear","allowNewOptions","ariaLabel","autoClearSearchValue","fetchOnlyOnSearch","filterOption","header","headerPosition","helperText","invertSelection","lazyLoading","loading","mode","name","notFoundContent","onBlur","onError","onChange","onClear","onDropdownVisibleChange","onDeselect","onSearch","onSelect","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","isSingleMode","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","setError","isDropdownVisible","setIsDropdownVisible","setPage","totalCount","setTotalCount","loadingEnabled","setLoadingEnabled","allValuesLoaded","setAllValuesLoaded","selectValueRef","fetchedQueries","Map","mappedMode","undefined","allowFetch","setMaxTagCount","onChangeCount","setOnChangeCount","previousChangeCount","fireOnChange","current","sortSelectedFirst","a","b","sortComparatorWithSearch","sortComparatorForNoSearch","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","length","concat","handleOnSelect","selectedItem","option","array","previousState","result","handleOnDeselect","Array","isArray","element","isNewOption","internalOnError","response","then","e","mergeData","data","mergedData","dataValues","Set","prevOptions","has","previousOption","sort","fetchPage","search","key","cachedCount","get","fetchOptions","set","catch","finally","debouncedFetchPage","handleOnSearch","searchValue","trim","newOption","cleanSelectOptions","newOptions","cancel","handlePagination","vScroll","currentTarget","thresholdReached","scrollTop","scrollHeight","offsetHeight","hasMoreData","newPage","handleFilterOption","handleOnDropdownVisibleChange","setTimeout","sortedOptions","slice","dropdownRender","originNode","handleClear","handleOnBlur","event","clear","clearCache","onPaste","pastedText","clipboardData","getData","token","find","split","previous","shouldRenderChildrenOptions","triggerNode","parentNode"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/components/Select/AsyncSelect.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  UIEvent,\n  useEffect,\n  useMemo,\n  useState,\n  useRef,\n  useCallback,\n  useImperativeHandle,\n  ClipboardEvent,\n} from 'react';\nimport { ensureIsArray, t, usePrevious } from '@superset-ui/core';\nimport { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport debounce from 'lodash/debounce';\nimport { isEqual, uniq } from 'lodash';\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { FAST_DEBOUNCE, SLOW_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  hasCustomLabels,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  sortComparatorForNoSearchHelper,\n  getSuffixIcon,\n  dropDownRenderHelper,\n  handleFilterOptionHelper,\n  mapOptions,\n} from './utils';\nimport {\n  AsyncSelectProps,\n  AsyncSelectRef,\n  SelectOptionsPagePromise,\n  SelectOptionsType,\n  SelectOptionsTypePage,\n  SelectProps,\n} from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledError,\n  StyledErrorMessage,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  DEFAULT_PAGE_SIZE,\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\nconst Error = ({ error }: { error: string }) => (\n  <StyledError>\n    <Icons.ErrorSolid /> <StyledErrorMessage>{error}</StyledErrorMessage>\n  </StyledError>\n);\n\nconst getQueryCacheKey = (value: string, page: number, pageSize: number) =>\n  `${value};${page};${pageSize}`;\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      ariaLabel,\n      autoClearSearchValue = false,\n      fetchOnlyOnSearch,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      lazyLoading = true,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onBlur,\n      onError,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      onDeselect,\n      onSearch,\n      onSelect,\n      optionFilterProps = ['label', 'value'],\n      options,\n      pageSize = DEFAULT_PAGE_SIZE,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators = TOKEN_SEPARATORS,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: AsyncSelectProps,\n    ref: RefObject<AsyncSelectRef>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [error, setError] = useState('');\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [page, setPage] = useState(0);\n    const [totalCount, setTotalCount] = useState(0);\n    const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n    const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n    const selectValueRef = useRef(selectValue);\n    const fetchedQueries = useRef(new Map<string, number>());\n    const mappedMode = isSingleMode ? undefined : 'multiple';\n    const allowFetch = !fetchOnlyOnSearch || inputValue;\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n    const [onChangeCount, setOnChangeCount] = useState(0);\n    const previousChangeCount = usePrevious(onChangeCount, 0);\n\n    const fireOnChange = useCallback(\n      () => setOnChangeCount(onChangeCount + 1),\n      [onChangeCount],\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    useEffect(() => {\n      selectValueRef.current = selectValue;\n    }, [selectValue]);\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValueRef.current),\n      [],\n    );\n\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const sortComparatorForNoSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorForNoSearchHelper(\n          a,\n          b,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [sortComparator, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(EMPTY_OPTIONS);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      return missingValues.length > 0\n        ? missingValues.concat(selectOptions)\n        : selectOptions;\n    }, [selectOptions, selectValue]);\n\n    const handleOnSelect: SelectProps['onSelect'] = (selectedItem, option) => {\n      if (isSingleMode) {\n        setSelectValue(selectedItem);\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            return isLabeledValue(selectedItem)\n              ? (result as AntdLabeledValue[])\n              : (result as (string | number)[]);\n          }\n          return previousState;\n        });\n      }\n      fireOnChange();\n      onSelect?.(selectedItem, option);\n    };\n\n    const handleOnDeselect: SelectProps['onDeselect'] = (value, option) => {\n      if (Array.isArray(selectValue)) {\n        if (isLabeledValue(value)) {\n          const array = selectValue as AntdLabeledValue[];\n          setSelectValue(\n            array.filter(element => element.value !== value.value),\n          );\n        } else {\n          const array = selectValue as (string | number)[];\n          setSelectValue(array.filter(element => element !== value));\n        }\n        // removes new option\n        if (option.isNewOption) {\n          setSelectOptions(\n            fullSelectOptions.filter(\n              option => getValue(option.value) !== getValue(value),\n            ),\n          );\n        }\n      }\n      fireOnChange();\n      onDeselect?.(value, option);\n    };\n\n    const internalOnError = useCallback(\n      (response: Response) =>\n        getClientErrorObject(response).then(e => {\n          const { error } = e;\n          setError(error);\n\n          if (onError) {\n            onError(error);\n          }\n        }),\n      [onError],\n    );\n\n    const mergeData = useCallback(\n      (data: SelectOptionsType) => {\n        let mergedData: SelectOptionsType = [];\n        if (data && Array.isArray(data) && data.length) {\n          // unique option values should always be case sensitive so don't lowercase\n          const dataValues = new Set(data.map(opt => opt.value));\n          // merges with existing and creates unique options\n          setSelectOptions(prevOptions => {\n            mergedData = prevOptions\n              .filter(previousOption => !dataValues.has(previousOption.value))\n              .concat(data)\n              .sort(sortComparatorForNoSearch);\n            return mergedData;\n          });\n        }\n        return mergedData;\n      },\n      [sortComparatorForNoSearch],\n    );\n\n    const fetchPage = useMemo(\n      () => (search: string, page: number) => {\n        setPage(page);\n        if (allValuesLoaded) {\n          setIsLoading(false);\n          return;\n        }\n        const key = getQueryCacheKey(search, page, pageSize);\n        const cachedCount = fetchedQueries.current.get(key);\n        if (cachedCount !== undefined) {\n          setTotalCount(cachedCount);\n          setIsLoading(false);\n          return;\n        }\n        setIsLoading(true);\n\n        const fetchOptions = options as SelectOptionsPagePromise;\n        fetchOptions(search, page, pageSize)\n          .then(({ data, totalCount }: SelectOptionsTypePage) => {\n            const mergedData = mergeData(data);\n            fetchedQueries.current.set(key, totalCount);\n            setTotalCount(totalCount);\n            if (\n              !fetchOnlyOnSearch &&\n              search === '' &&\n              mergedData.length >= totalCount\n            ) {\n              setAllValuesLoaded(true);\n            }\n          })\n          .catch(internalOnError)\n          .finally(() => {\n            setIsLoading(false);\n          });\n      },\n      [\n        allValuesLoaded,\n        fetchOnlyOnSearch,\n        mergeData,\n        internalOnError,\n        options,\n        pageSize,\n      ],\n    );\n\n    const debouncedFetchPage = useMemo(\n      () => debounce(fetchPage, SLOW_DEBOUNCE),\n      [fetchPage],\n    );\n\n    const handleOnSearch = debounce((search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = fullSelectOptions.filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      if (\n        !allValuesLoaded &&\n        loadingEnabled &&\n        !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))\n      ) {\n        // if fetch only on search but search value is empty, then should not be\n        // in loading state\n        setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n      }\n      setInputValue(search);\n      onSearch?.(searchValue);\n    }, FAST_DEBOUNCE);\n\n    useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n    const handlePagination = (e: UIEvent<HTMLElement>) => {\n      const vScroll = e.currentTarget;\n      const thresholdReached =\n        vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n      const hasMoreData = page * pageSize + pageSize < totalCount;\n\n      if (!isLoading && hasMoreData && thresholdReached) {\n        const newPage = page + 1;\n        fetchPage(inputValue, newPage);\n      }\n    };\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // loading is enabled when dropdown is open,\n      // disabled when dropdown is closed\n      if (loadingEnabled !== isDropdownVisible) {\n        setLoadingEnabled(isDropdownVisible);\n      }\n      // when closing dropdown, always reset loading state\n      if (!isDropdownVisible && isLoading) {\n        // delay is for the animation of closing the dropdown\n        // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n        // before closing.\n        setTimeout(() => {\n          setIsLoading(false);\n        }, 250);\n      }\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        const sortedOptions = selectOptions\n          .slice()\n          .sort(sortComparatorForNoSearch);\n        if (!isEqual(sortedOptions, selectOptions)) {\n          setSelectOptions(sortedOptions);\n        }\n      }\n\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n        error ? <Error error={error} /> : undefined,\n      );\n\n    const handleClear = () => {\n      setSelectValue(undefined);\n      if (onClear) {\n        onClear();\n      }\n      fireOnChange();\n    };\n\n    const handleOnBlur = (event: React.FocusEvent<HTMLElement>) => {\n      setInputValue('');\n      onBlur?.(event);\n    };\n\n    useEffect(() => {\n      if (onChangeCount !== previousChangeCount) {\n        const array = ensureIsArray(selectValue);\n        const set = new Set(array.map(getValue));\n        const options = mapOptions(\n          fullSelectOptions.filter(opt => set.has(opt.value)),\n        );\n        if (isSingleMode) {\n          // @ts-ignore\n          onChange?.(selectValue, options[0]);\n        } else {\n          // @ts-ignore\n          onChange?.(array, options);\n        }\n      }\n    }, [\n      fullSelectOptions,\n      isSingleMode,\n      onChange,\n      onChangeCount,\n      previousChangeCount,\n      selectValue,\n    ]);\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      fetchedQueries.current.clear();\n      setAllValuesLoaded(false);\n      setSelectOptions(EMPTY_OPTIONS);\n    }, [options]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    // Stop the invocation of the debounced function after unmounting\n    useEffect(\n      () => () => {\n        debouncedFetchPage.cancel();\n      },\n      [debouncedFetchPage],\n    );\n\n    useEffect(() => {\n      if (loadingEnabled && allowFetch) {\n        // trigger fetch every time inputValue changes\n        if (inputValue) {\n          debouncedFetchPage(inputValue, 0);\n        } else {\n          fetchPage('', 0);\n        }\n      }\n    }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    const clearCache = () => fetchedQueries.current.clear();\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        ...(ref.current as HTMLInputElement),\n        clearCache,\n      }),\n      [ref],\n    );\n\n    const onPaste = (e: ClipboardEvent<HTMLInputElement>) => {\n      const pastedText = e.clipboardData.getData('text');\n      if (isSingleMode) {\n        setSelectValue({ label: pastedText, value: pastedText });\n      } else {\n        const token = tokenSeparators.find(token => pastedText.includes(token));\n        const array = token ? uniq(pastedText.split(token)) : [pastedText];\n        setSelectValue(previous => [\n          ...((previous || []) as AntdLabeledValue[]),\n          ...array.map<AntdLabeledValue>(value => ({\n            label: value,\n            value,\n          })),\n        ]);\n      }\n    };\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => hasCustomLabels(fullSelectOptions),\n      [fullSelectOptions],\n    );\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={autoClearSearchValue}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue\n          maxTagCount={maxTagCount}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onBlur={handleOnBlur}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          // @ts-ignore\n          onPaste={onPaste}\n          onPopupScroll={handlePagination}\n          onSearch={showSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          options={shouldRenderChildrenOptions ? undefined : fullSelectOptions}\n          placeholder={placeholder}\n          showSearch={showSearch}\n          showArrow\n          tokenSeparators={tokenSeparators}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(isLoading, showSearch, isDropdownVisible)}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {hasCustomLabels(fullSelectOptions) &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default AsyncSelect;\n"]},"metadata":{},"sourceType":"module"}