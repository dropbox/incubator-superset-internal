{"ast":null,"code":"/* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extent } from 'd3-array';\nimport { scaleThreshold } from 'd3-scale';\nimport {\ngetSequentialSchemeRegistry,\nSequentialScheme } from\n'@superset-ui/core';\nimport { hexToRGB } from './utils/colors';\n\nconst DEFAULT_NUM_BUCKETS = 10;\n\nexport function getBreakPoints(_ref,\n\nfeatures,\naccessor)\n{let { break_points: formDataBreakPoints, num_buckets: formDataNumBuckets } = _ref;\n  if (!features) {\n    return [];\n  }\n  if (formDataBreakPoints === undefined || formDataBreakPoints.length === 0) {\n    // compute evenly distributed break points based on number of buckets\n    const numBuckets = formDataNumBuckets ?\n    parseInt(formDataNumBuckets, 10) :\n    DEFAULT_NUM_BUCKETS;\n    const [minValue, maxValue] = extent(features, accessor);\n    if (minValue === undefined) {\n      return [];\n    }\n    const delta = (maxValue - minValue) / numBuckets;\n    const precision =\n    delta === 0 ? 0 : Math.max(0, Math.ceil(Math.log10(1 / delta)));\n    const extraBucket = maxValue > maxValue.toFixed(precision) ? 1 : 0;\n    const startValue =\n    minValue < minValue.toFixed(precision) ? minValue - 1 : minValue;\n\n    return new Array(numBuckets + 1 + extraBucket).\n    fill().\n    map((_, i) => (startValue + i * delta).toFixed(precision));\n  }\n\n  return formDataBreakPoints.sort((a, b) => parseFloat(a) - parseFloat(b));\n}\n\nexport function getBreakPointColorScaler(_ref2,\n\n\n\n\n\n\nfeatures,\naccessor)\n{let { break_points: formDataBreakPoints, num_buckets: formDataNumBuckets, linear_color_scheme: linearColorScheme, opacity } = _ref2;\n  const breakPoints =\n  formDataBreakPoints || formDataNumBuckets ?\n  getBreakPoints(\n  {\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets },\n\n  features,\n  accessor) :\n\n  null;\n  const colorScheme = Array.isArray(linearColorScheme) ?\n  new SequentialScheme({\n    colors: linearColorScheme,\n    id: 'custom' }) :\n\n  getSequentialSchemeRegistry().get(linearColorScheme);\n\n  let scaler;\n  let maskPoint;\n  if (breakPoints !== null) {\n    // bucket colors into discrete colors\n    const n = breakPoints.length - 1;\n    const bucketedColors =\n    n > 1 ?\n    colorScheme.getColors(n) :\n    [colorScheme.colors[colorScheme.colors.length - 1]];\n\n    // repeat ends\n    const first = bucketedColors[0];\n    const last = bucketedColors[bucketedColors.length - 1];\n    bucketedColors.unshift(first);\n    bucketedColors.push(last);\n\n    const points = breakPoints.map((p) => parseFloat(p));\n    scaler = scaleThreshold().domain(points).range(bucketedColors);\n    maskPoint = (value) => value > breakPoints[n] || value < breakPoints[0];\n  } else {\n    // interpolate colors linearly\n    scaler = colorScheme.createLinearScale(extent(features, accessor));\n    maskPoint = () => false;\n  }\n\n  return (d) => {\n    const v = accessor(d);\n    const c = hexToRGB(scaler(v));\n    if (maskPoint(v)) {\n      c[3] = 0;\n    } else {\n      c[3] = opacity / 100 * 255;\n    }\n\n    return c;\n  };\n}\n\nexport function getBuckets(fd, features, accessor) {\n  const breakPoints = getBreakPoints(fd, features, accessor);\n  const colorScaler = getBreakPointColorScaler(fd, features, accessor);\n  const buckets = {};\n  breakPoints.slice(1).forEach((value, i) => {\n    const range = `${breakPoints[i]} - ${breakPoints[i + 1]}`;\n    const mid =\n    0.5 * (parseFloat(breakPoints[i]) + parseFloat(breakPoints[i + 1]));\n    // fix polygon doesn't show\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    buckets[range] = {\n      color: colorScaler({ [metricLabel || fd.metric]: mid }),\n      enabled: true };\n\n  });\n\n  return buckets;\n}","map":{"version":3,"names":["extent","scaleThreshold","getSequentialSchemeRegistry","SequentialScheme","hexToRGB","DEFAULT_NUM_BUCKETS","getBreakPoints","features","accessor","break_points","formDataBreakPoints","num_buckets","formDataNumBuckets","undefined","length","numBuckets","parseInt","minValue","maxValue","delta","precision","Math","max","ceil","log10","extraBucket","toFixed","startValue","Array","fill","map","_","i","sort","a","b","parseFloat","getBreakPointColorScaler","linear_color_scheme","linearColorScheme","opacity","breakPoints","colorScheme","isArray","colors","id","get","scaler","maskPoint","n","bucketedColors","getColors","first","last","unshift","push","points","p","domain","range","value","createLinearScale","d","v","c","getBuckets","fd","colorScaler","buckets","slice","forEach","mid","metricLabel","metric","label","color","enabled"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/legacy-preset-chart-deckgl/src/utils.js"],"sourcesContent":["/* eslint-disable no-negated-condition */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extent } from 'd3-array';\nimport { scaleThreshold } from 'd3-scale';\nimport {\n  getSequentialSchemeRegistry,\n  SequentialScheme,\n} from '@superset-ui/core';\nimport { hexToRGB } from './utils/colors';\n\nconst DEFAULT_NUM_BUCKETS = 10;\n\nexport function getBreakPoints(\n  { break_points: formDataBreakPoints, num_buckets: formDataNumBuckets },\n  features,\n  accessor,\n) {\n  if (!features) {\n    return [];\n  }\n  if (formDataBreakPoints === undefined || formDataBreakPoints.length === 0) {\n    // compute evenly distributed break points based on number of buckets\n    const numBuckets = formDataNumBuckets\n      ? parseInt(formDataNumBuckets, 10)\n      : DEFAULT_NUM_BUCKETS;\n    const [minValue, maxValue] = extent(features, accessor);\n    if (minValue === undefined) {\n      return [];\n    }\n    const delta = (maxValue - minValue) / numBuckets;\n    const precision =\n      delta === 0 ? 0 : Math.max(0, Math.ceil(Math.log10(1 / delta)));\n    const extraBucket = maxValue > maxValue.toFixed(precision) ? 1 : 0;\n    const startValue =\n      minValue < minValue.toFixed(precision) ? minValue - 1 : minValue;\n\n    return new Array(numBuckets + 1 + extraBucket)\n      .fill()\n      .map((_, i) => (startValue + i * delta).toFixed(precision));\n  }\n\n  return formDataBreakPoints.sort((a, b) => parseFloat(a) - parseFloat(b));\n}\n\nexport function getBreakPointColorScaler(\n  {\n    break_points: formDataBreakPoints,\n    num_buckets: formDataNumBuckets,\n    linear_color_scheme: linearColorScheme,\n    opacity,\n  },\n  features,\n  accessor,\n) {\n  const breakPoints =\n    formDataBreakPoints || formDataNumBuckets\n      ? getBreakPoints(\n          {\n            break_points: formDataBreakPoints,\n            num_buckets: formDataNumBuckets,\n          },\n          features,\n          accessor,\n        )\n      : null;\n  const colorScheme = Array.isArray(linearColorScheme)\n    ? new SequentialScheme({\n        colors: linearColorScheme,\n        id: 'custom',\n      })\n    : getSequentialSchemeRegistry().get(linearColorScheme);\n\n  let scaler;\n  let maskPoint;\n  if (breakPoints !== null) {\n    // bucket colors into discrete colors\n    const n = breakPoints.length - 1;\n    const bucketedColors =\n      n > 1\n        ? colorScheme.getColors(n)\n        : [colorScheme.colors[colorScheme.colors.length - 1]];\n\n    // repeat ends\n    const first = bucketedColors[0];\n    const last = bucketedColors[bucketedColors.length - 1];\n    bucketedColors.unshift(first);\n    bucketedColors.push(last);\n\n    const points = breakPoints.map(p => parseFloat(p));\n    scaler = scaleThreshold().domain(points).range(bucketedColors);\n    maskPoint = value => value > breakPoints[n] || value < breakPoints[0];\n  } else {\n    // interpolate colors linearly\n    scaler = colorScheme.createLinearScale(extent(features, accessor));\n    maskPoint = () => false;\n  }\n\n  return d => {\n    const v = accessor(d);\n    const c = hexToRGB(scaler(v));\n    if (maskPoint(v)) {\n      c[3] = 0;\n    } else {\n      c[3] = (opacity / 100) * 255;\n    }\n\n    return c;\n  };\n}\n\nexport function getBuckets(fd, features, accessor) {\n  const breakPoints = getBreakPoints(fd, features, accessor);\n  const colorScaler = getBreakPointColorScaler(fd, features, accessor);\n  const buckets = {};\n  breakPoints.slice(1).forEach((value, i) => {\n    const range = `${breakPoints[i]} - ${breakPoints[i + 1]}`;\n    const mid =\n      0.5 * (parseFloat(breakPoints[i]) + parseFloat(breakPoints[i + 1]));\n    // fix polygon doesn't show\n    const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;\n    buckets[range] = {\n      color: colorScaler({ [metricLabel || fd.metric]: mid }),\n      enabled: true,\n    };\n  });\n\n  return buckets;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,UAAvB;AACA,SAASC,cAAT,QAA+B,UAA/B;AACA;AACEC,2BADF;AAEEC,gBAFF;AAGO,mBAHP;AAIA,SAASC,QAAT,QAAyB,gBAAzB;;AAEA,MAAMC,mBAAmB,GAAG,EAA5B;;AAEA,OAAO,SAASC,cAAT;;AAELC,QAFK;AAGLC,QAHK;AAIL,KAHA,EAAEC,YAAY,EAAEC,mBAAhB,EAAqCC,WAAW,EAAEC,kBAAlD,EAGA;EACA,IAAI,CAACL,QAAL,EAAe;IACb,OAAO,EAAP;EACD;EACD,IAAIG,mBAAmB,KAAKG,SAAxB,IAAqCH,mBAAmB,CAACI,MAApB,KAA+B,CAAxE,EAA2E;IACzE;IACA,MAAMC,UAAU,GAAGH,kBAAkB;IACjCI,QAAQ,CAACJ,kBAAD,EAAqB,EAArB,CADyB;IAEjCP,mBAFJ;IAGA,MAAM,CAACY,QAAD,EAAWC,QAAX,IAAuBlB,MAAM,CAACO,QAAD,EAAWC,QAAX,CAAnC;IACA,IAAIS,QAAQ,KAAKJ,SAAjB,EAA4B;MAC1B,OAAO,EAAP;IACD;IACD,MAAMM,KAAK,GAAG,CAACD,QAAQ,GAAGD,QAAZ,IAAwBF,UAAtC;IACA,MAAMK,SAAS;IACbD,KAAK,KAAK,CAAV,GAAc,CAAd,GAAkBE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,IAAL,CAAUF,IAAI,CAACG,KAAL,CAAW,IAAIL,KAAf,CAAV,CAAZ,CADpB;IAEA,MAAMM,WAAW,GAAGP,QAAQ,GAAGA,QAAQ,CAACQ,OAAT,CAAiBN,SAAjB,CAAX,GAAyC,CAAzC,GAA6C,CAAjE;IACA,MAAMO,UAAU;IACdV,QAAQ,GAAGA,QAAQ,CAACS,OAAT,CAAiBN,SAAjB,CAAX,GAAyCH,QAAQ,GAAG,CAApD,GAAwDA,QAD1D;;IAGA,OAAO,IAAIW,KAAJ,CAAUb,UAAU,GAAG,CAAb,GAAiBU,WAA3B;IACJI,IADI;IAEJC,GAFI,CAEA,CAACC,CAAD,EAAIC,CAAJ,KAAU,CAACL,UAAU,GAAGK,CAAC,GAAGb,KAAlB,EAAyBO,OAAzB,CAAiCN,SAAjC,CAFV,CAAP;EAGD;;EAED,OAAOV,mBAAmB,CAACuB,IAApB,CAAyB,CAACC,CAAD,EAAIC,CAAJ,KAAUC,UAAU,CAACF,CAAD,CAAV,GAAgBE,UAAU,CAACD,CAAD,CAA7D,CAAP;AACD;;AAED,OAAO,SAASE,wBAAT;;;;;;;AAOL9B,QAPK;AAQLC,QARK;AASL,KARA,EACEC,YAAY,EAAEC,mBADhB,EAEEC,WAAW,EAAEC,kBAFf,EAGE0B,mBAAmB,EAAEC,iBAHvB,EAIEC,OAJF,EAQA;EACA,MAAMC,WAAW;EACf/B,mBAAmB,IAAIE,kBAAvB;EACIN,cAAc;EACZ;IACEG,YAAY,EAAEC,mBADhB;IAEEC,WAAW,EAAEC,kBAFf,EADY;;EAKZL,QALY;EAMZC,QANY,CADlB;;EASI,IAVN;EAWA,MAAMkC,WAAW,GAAGd,KAAK,CAACe,OAAN,CAAcJ,iBAAd;EAChB,IAAIpC,gBAAJ,CAAqB;IACnByC,MAAM,EAAEL,iBADW;IAEnBM,EAAE,EAAE,QAFe,EAArB,CADgB;;EAKhB3C,2BAA2B,GAAG4C,GAA9B,CAAkCP,iBAAlC,CALJ;;EAOA,IAAIQ,MAAJ;EACA,IAAIC,SAAJ;EACA,IAAIP,WAAW,KAAK,IAApB,EAA0B;IACxB;IACA,MAAMQ,CAAC,GAAGR,WAAW,CAAC3B,MAAZ,GAAqB,CAA/B;IACA,MAAMoC,cAAc;IAClBD,CAAC,GAAG,CAAJ;IACIP,WAAW,CAACS,SAAZ,CAAsBF,CAAtB,CADJ;IAEI,CAACP,WAAW,CAACE,MAAZ,CAAmBF,WAAW,CAACE,MAAZ,CAAmB9B,MAAnB,GAA4B,CAA/C,CAAD,CAHN;;IAKA;IACA,MAAMsC,KAAK,GAAGF,cAAc,CAAC,CAAD,CAA5B;IACA,MAAMG,IAAI,GAAGH,cAAc,CAACA,cAAc,CAACpC,MAAf,GAAwB,CAAzB,CAA3B;IACAoC,cAAc,CAACI,OAAf,CAAuBF,KAAvB;IACAF,cAAc,CAACK,IAAf,CAAoBF,IAApB;;IAEA,MAAMG,MAAM,GAAGf,WAAW,CAACX,GAAZ,CAAgB,CAAA2B,CAAC,KAAIrB,UAAU,CAACqB,CAAD,CAA/B,CAAf;IACAV,MAAM,GAAG9C,cAAc,GAAGyD,MAAjB,CAAwBF,MAAxB,EAAgCG,KAAhC,CAAsCT,cAAtC,CAAT;IACAF,SAAS,GAAG,CAAAY,KAAK,KAAIA,KAAK,GAAGnB,WAAW,CAACQ,CAAD,CAAnB,IAA0BW,KAAK,GAAGnB,WAAW,CAAC,CAAD,CAAlE;EACD,CAjBD,MAiBO;IACL;IACAM,MAAM,GAAGL,WAAW,CAACmB,iBAAZ,CAA8B7D,MAAM,CAACO,QAAD,EAAWC,QAAX,CAApC,CAAT;IACAwC,SAAS,GAAG,MAAM,KAAlB;EACD;;EAED,OAAO,CAAAc,CAAC,KAAI;IACV,MAAMC,CAAC,GAAGvD,QAAQ,CAACsD,CAAD,CAAlB;IACA,MAAME,CAAC,GAAG5D,QAAQ,CAAC2C,MAAM,CAACgB,CAAD,CAAP,CAAlB;IACA,IAAIf,SAAS,CAACe,CAAD,CAAb,EAAkB;MAChBC,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;IACD,CAFD,MAEO;MACLA,CAAC,CAAC,CAAD,CAAD,GAAQxB,OAAO,GAAG,GAAX,GAAkB,GAAzB;IACD;;IAED,OAAOwB,CAAP;EACD,CAVD;AAWD;;AAED,OAAO,SAASC,UAAT,CAAoBC,EAApB,EAAwB3D,QAAxB,EAAkCC,QAAlC,EAA4C;EACjD,MAAMiC,WAAW,GAAGnC,cAAc,CAAC4D,EAAD,EAAK3D,QAAL,EAAeC,QAAf,CAAlC;EACA,MAAM2D,WAAW,GAAG9B,wBAAwB,CAAC6B,EAAD,EAAK3D,QAAL,EAAeC,QAAf,CAA5C;EACA,MAAM4D,OAAO,GAAG,EAAhB;EACA3B,WAAW,CAAC4B,KAAZ,CAAkB,CAAlB,EAAqBC,OAArB,CAA6B,CAACV,KAAD,EAAQ5B,CAAR,KAAc;IACzC,MAAM2B,KAAK,GAAI,GAAElB,WAAW,CAACT,CAAD,CAAI,MAAKS,WAAW,CAACT,CAAC,GAAG,CAAL,CAAQ,EAAxD;IACA,MAAMuC,GAAG;IACP,OAAOnC,UAAU,CAACK,WAAW,CAACT,CAAD,CAAZ,CAAV,GAA6BI,UAAU,CAACK,WAAW,CAACT,CAAC,GAAG,CAAL,CAAZ,CAA9C,CADF;IAEA;IACA,MAAMwC,WAAW,GAAGN,EAAE,CAACO,MAAH,GAAYP,EAAE,CAACO,MAAH,CAAUC,KAAV,IAAmBR,EAAE,CAACO,MAAlC,GAA2C,IAA/D;IACAL,OAAO,CAACT,KAAD,CAAP,GAAiB;MACfgB,KAAK,EAAER,WAAW,CAAC,EAAE,CAACK,WAAW,IAAIN,EAAE,CAACO,MAAnB,GAA4BF,GAA9B,EAAD,CADH;MAEfK,OAAO,EAAE,IAFM,EAAjB;;EAID,CAVD;;EAYA,OAAOR,OAAP;AACD"},"metadata":{},"sourceType":"module"}