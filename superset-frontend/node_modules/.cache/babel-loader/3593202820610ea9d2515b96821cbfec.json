{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nconst modulePromises = {};\nconst withNamespace = (name) => `__superset__/${name}`;\n/**\n * Dependency management using global variables, because for the life of me\n * I can't figure out how to hook into UMD from a dynamically imported package.\n *\n * This defines a dynamically imported js module that can be used to import from\n * multiple different plugins.\n *\n * When importing a common module (such as react or lodash or superset-ui)\n * from a plugin, the plugin's build config will be able to\n * reference these globals instead of rebuilding them.\n *\n * @param name the module's name (should match name in package.json)\n * @param promise the promise resulting from a call to `import(name)`\n */\nexport async function defineSharedModule(name, fetchModule) {\n  // this field on window is used by dynamic plugins to reference the module\n  const moduleKey = withNamespace(name);\n  if (!window[moduleKey] && !modulePromises[name]) {\n    // if the module has not been loaded, load it\n    const modulePromise = fetchModule();\n    modulePromises[name] = modulePromise;\n    // wait for the module to load, and attach the result to window\n    // so that it can be referenced by plugins\n    window[moduleKey] = await modulePromise;\n  }\n  // we always return a reference to the promise.\n  // Multiple consumers can `.then()` or `await` the same promise,\n  // even long after it has completed,\n  // and it will always call back with the same reference.\n  return modulePromises[name];\n}\n/**\n * Define multiple shared modules at once, using a map of name -> `import(name)`\n *\n * @see defineSharedModule\n * @param moduleMap\n */\nexport async function defineSharedModules(moduleMap) {\n  return Promise.all(Object.entries(moduleMap).map((_ref) => {let [name, fetchModule] = _ref;return defineSharedModule(name, fetchModule);}));\n}\n// only exposed for tests\nexport function reset() {\n  Object.keys(modulePromises).forEach((key) => {\n    delete window[withNamespace(key)];\n    delete modulePromises[key];\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(modulePromises, \"modulePromises\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts\");reactHotLoader.register(withNamespace, \"withNamespace\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts\");reactHotLoader.register(defineSharedModule, \"defineSharedModule\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts\");reactHotLoader.register(defineSharedModules, \"defineSharedModules\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts\");reactHotLoader.register(reset, \"reset\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"wSAAA;;;;;;;;;;;;;;;;;;AAiCA,MAAMA,cAAc,GAAuC,EAA3D;AAEA,MAAMC,aAAa,GAAG,CAACC,IAAD,KAAkB,gBAAgBA,IAAI,EAA5D;AAEA;;;;;;;;;;;;;;AAcA,OAAO,eAAeC,kBAAf,CACLD,IADK,EAELE,WAFK,EAE6B;EAElC;EACA,MAAMC,SAAS,GAAGJ,aAAa,CAACC,IAAD,CAA/B;EAEA,IAAI,CAACI,MAAM,CAACD,SAAD,CAAP,IAAsB,CAACL,cAAc,CAACE,IAAD,CAAzC,EAAiD;IAC/C;IACA,MAAMK,aAAa,GAAGH,WAAW,EAAjC;IACAJ,cAAc,CAACE,IAAD,CAAd,GAAuBK,aAAvB;IACA;IACA;IACAD,MAAM,CAACD,SAAD,CAAN,GAAoB,MAAME,aAA1B;EACD;EAED;EACA;EACA;EACA;EACA,OAAOP,cAAc,CAACE,IAAD,CAArB;AACD;AAED;;;;;;AAMA,OAAO,eAAeM,mBAAf,CAAmCC,SAAnC,EAEN;EACC,OAAOC,OAAO,CAACC,GAAR,CACLC,MAAM,CAACC,OAAP,CAAeJ,SAAf,EAA0BK,GAA1B,CAA8B,eAAC,CAACZ,IAAD,EAAOE,WAAP,CAAD,eAC5BD,kBAAkB,CAACD,IAAD,EAAOE,WAAP,CADU,EAA9B,CADK,CAAP;AAKD;AAED;AACA,OAAM,SAAUW,KAAV,GAAe;EACnBH,MAAM,CAACI,IAAP,CAAYhB,cAAZ,EAA4BiB,OAA5B,CAAoC,IAAG,KAAG;IACxC,OAAOX,MAAM,CAACL,aAAa,CAACiB,GAAD,CAAd,CAAb;IACA,OAAOlB,cAAc,CAACkB,GAAD,CAArB;EACD,CAHD;AAID,C,iLA/DKlB,c,gLAEAC,a,+KAgBgBE,kB,oLA6BAK,mB,qLAWNO,K","names":["modulePromises","withNamespace","name","defineSharedModule","fetchModule","moduleKey","window","modulePromise","defineSharedModules","moduleMap","Promise","all","Object","entries","map","reset","keys","forEach","key"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/dynamic-plugins/shared-modules.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/** The type of an imported module. Don't fully understand this, yet. */\nexport type Module = any;\n\n/**\n * This is where packages are stored. We use window, because it plays well with Webpack.\n * To avoid\n * Have to amend the type of window, because window's usual type doesn't describe these fields.\n */\ninterface ModuleReferencer {\n  [packageKey: string]: Promise<Module>;\n}\n\ndeclare const window: Window & typeof globalThis & ModuleReferencer;\n\nconst modulePromises: { [key: string]: Promise<Module> } = {};\n\nconst withNamespace = (name: string) => `__superset__/${name}`;\n\n/**\n * Dependency management using global variables, because for the life of me\n * I can't figure out how to hook into UMD from a dynamically imported package.\n *\n * This defines a dynamically imported js module that can be used to import from\n * multiple different plugins.\n *\n * When importing a common module (such as react or lodash or superset-ui)\n * from a plugin, the plugin's build config will be able to\n * reference these globals instead of rebuilding them.\n *\n * @param name the module's name (should match name in package.json)\n * @param promise the promise resulting from a call to `import(name)`\n */\nexport async function defineSharedModule(\n  name: string,\n  fetchModule: () => Promise<Module>,\n) {\n  // this field on window is used by dynamic plugins to reference the module\n  const moduleKey = withNamespace(name);\n\n  if (!window[moduleKey] && !modulePromises[name]) {\n    // if the module has not been loaded, load it\n    const modulePromise = fetchModule();\n    modulePromises[name] = modulePromise;\n    // wait for the module to load, and attach the result to window\n    // so that it can be referenced by plugins\n    window[moduleKey] = await modulePromise;\n  }\n\n  // we always return a reference to the promise.\n  // Multiple consumers can `.then()` or `await` the same promise,\n  // even long after it has completed,\n  // and it will always call back with the same reference.\n  return modulePromises[name];\n}\n\n/**\n * Define multiple shared modules at once, using a map of name -> `import(name)`\n *\n * @see defineSharedModule\n * @param moduleMap\n */\nexport async function defineSharedModules(moduleMap: {\n  [key: string]: () => Promise<Module>;\n}) {\n  return Promise.all(\n    Object.entries(moduleMap).map(([name, fetchModule]) =>\n      defineSharedModule(name, fetchModule),\n    ),\n  );\n}\n\n// only exposed for tests\nexport function reset() {\n  Object.keys(modulePromises).forEach(key => {\n    delete window[withNamespace(key)];\n    delete modulePromises[key];\n  });\n}\n"]},"metadata":{},"sourceType":"module"}