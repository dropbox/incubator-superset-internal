{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";import _orderBy from \"lodash/orderBy\";import _minBy from \"lodash/minBy\";import _meanBy from \"lodash/meanBy\";import _maxBy from \"lodash/maxBy\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AxisType, DTTM_ALIAS, ensureIsArray, GenericDataType, NumberFormats, NumberFormatter, normalizeTimestamp } from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts';\n\nimport { NULL_STRING, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\nimport { LegendOrientation } from '../types';\nimport { defaultLegendPadding } from '../defaults';\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nexport function extractDataTotalValues(data, opts) {\n  const totalStackedValues = [];\n  const thresholdValues = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach((datum) => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + value;\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push((percentageThreshold || 0) / 100 * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues };\n\n}\nexport function extractShowValueIndexes(series, opts) {\n  const showValueIndexes = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      data.forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (!showValueIndexes[dataIndex] &&\n          datum[isHorizontal ? 0 : 1] !== null) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\nexport function sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending) {\n  const seriesNames = Object.keys(rows[0]).\n  filter((key) => key !== xAxis).\n  filter((key) => !_includesInstanceProperty(extraMetricLabels).call(extraMetricLabels, key));\n  let aggregator;\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = (name) => ({ name, value: _sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = (name) => {var _minBy2;return { name, value: (_minBy2 = _minBy(rows, name)) == null ? void 0 : _minBy2[name] };};\n      break;\n    case SortSeriesType.Max:\n      aggregator = (name) => {var _maxBy2;return { name, value: (_maxBy2 = _maxBy(rows, name)) == null ? void 0 : _maxBy2[name] };};\n      break;\n    case SortSeriesType.Avg:\n      aggregator = (name) => ({ name, value: _meanBy(rows, name) });\n      break;\n    default:\n      aggregator = (name) => ({ name, value: name.toLowerCase() });\n      break;}\n\n  const sortedValues = seriesNames.map(aggregator);\n  return _orderBy(sortedValues, ['value'], [sortSeriesAscending ? 'asc' : 'desc']).map((_ref) => {let { name } = _ref;return name;});\n}\nexport function sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey = '';\n    let aggregate;\n    let entries = 0;\n    Object.entries(row).forEach((_ref2) => {let [key, value] = _ref2;\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (xAxisSortSeries === SortSeriesType.Name ||\n      typeof value !== 'number') {\n        return;\n      }\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else\n          {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n          aggregate === undefined || isValueDefined && value < aggregate ?\n          value :\n          aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n          aggregate === undefined || isValueDefined && value > aggregate ?\n          value :\n          aggregate;\n          break;\n        default:\n          break;}\n\n    });\n    if (xAxisSortSeries === SortSeriesType.Avg &&\n    entries > 0 &&\n    aggregate !== undefined) {\n      aggregate /= entries;\n    }\n    const value = xAxisSortSeries === SortSeriesType.Name && typeof sortKey === 'string' ?\n    sortKey.toLowerCase() :\n    aggregate;\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx] };\n\n  });\n  return _orderBy(sortedRows, ['value'], [xAxisSortSeriesAscending ? 'asc' : 'desc']).map((_ref3) => {let { row, totalStackedValue } = _ref3;return { row, totalStackedValue };});\n}\nexport function extractSeries(data, opts) {if (opts === void 0) {opts = {};}\n  const { fillNeighborValue, xAxis = DTTM_ALIAS, extraMetricLabels = [], removeNulls = false, stack = false, totalStackedValues = [], isHorizontal = false, sortSeriesType, sortSeriesAscending, xAxisSortSeries, xAxisSortSeriesAscending } = opts;\n  if (data.length === 0)\n  return [[], [], undefined];\n  const rows = data.map((datum) => ({\n    ...datum,\n    [xAxis]: datum[xAxis] }));\n\n  const sortedSeries = sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending);\n  const sortedRows = isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending) ?\n  sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) :\n  rows.map((row, idx) => ({\n    row,\n    totalStackedValue: totalStackedValues[idx] }));\n\n  let minPositiveValue;\n  const finalSeries = sortedSeries.map((name) => ({\n    id: name,\n    name,\n    data: sortedRows.\n    map((_ref4, idx) => {var _rows, _rows2;let { row, totalStackedValue } = _ref4;\n      const currentValue = row[name];\n      if (typeof currentValue === 'number' &&\n      currentValue > 0 && (\n      minPositiveValue === undefined || minPositiveValue > currentValue)) {\n        minPositiveValue = currentValue;\n      }\n      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[name]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[name]);\n      const isFillNeighborValue = !isDefined(currentValue) &&\n      isNextToDefinedValue &&\n      fillNeighborValue !== undefined;\n      let value = currentValue;\n      if (isFillNeighborValue) {\n        value = fillNeighborValue;\n      } else\n      if (stack === StackControlsValue.Expand &&\n      totalStackedValue !== undefined) {\n        value = (value || 0) / totalStackedValue;\n      }\n      return [row[xAxis], value];\n    }).\n    filter((obs) => !removeNulls || obs[0] !== null && obs[1] !== null).\n    map((obs) => isHorizontal ? [obs[1], obs[0]] : obs) }));\n\n  return [\n  finalSeries,\n  sortedRows.map((_ref5) => {let { totalStackedValue } = _ref5;return totalStackedValue;}),\n  minPositiveValue];\n\n}\nexport function formatSeriesName(name, _temp) {let { numberFormatter, timeFormatter, coltype } = _temp === void 0 ? {} : _temp;\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.TEMPORAL) {\n    const normalizedName = typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d = normalizedName instanceof Date ?\n    normalizedName :\n    new Date(normalizedName);\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\nexport const getColtypesMapping = (_ref6) => {let { coltypes = [], colnames = [] } = _ref6;return colnames.reduce((accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }), {});};\nexport function extractGroupbyLabel(_ref7) {let { datum = {}, groupby, numberFormatter, timeFormatter, coltypeMapping = {} } = _ref7;\n  return ensureIsArray(groupby).\n  map((val) => formatSeriesName(datum[val], {\n    numberFormatter,\n    timeFormatter,\n    ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }) })).\n\n  join(', ');\n}\nexport function getLegendProps(type, orientation, show, theme, zoomable, legendState) {var _context;if (zoomable === void 0) {zoomable = false;}\n  const legend = {\n    orient: _includesInstanceProperty(_context = [LegendOrientation.Top, LegendOrientation.Bottom]).call(_context, orientation) ?\n    'horizontal' :\n    'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base } };\n\n\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;}\n\n  return legend;\n}\nexport function getChartPadding(show, orientation, margin, padding) {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else\n  if (margin === null ||\n  margin === undefined ||\n  typeof margin === 'string') {\n    legendMargin = defaultLegendPadding[orientation];\n  } else\n  {\n    legendMargin = margin;\n  }\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom: bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0) };\n\n}\nexport function dedupSeries(series) {\n  const counter = new Map();\n  return series.map((row) => {\n    let { id } = row;\n    if (id === undefined)\n    return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}` };\n\n  });\n}\nexport function sanitizeHtml(text) {\n  return format.encodeHTML(text);\n}\nexport function getAxisType(dataType) {\n  if (dataType === GenericDataType.TEMPORAL) {\n    return AxisType.time;\n  }\n  return AxisType.category;\n}\nexport function getOverMaxHiddenFormatter(config) {if (config === void 0) {config = {};}\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n  return new NumberFormatter({\n    formatFunc: (value) => `${shouldHideIfOverMax && value > max ?\n    '' :\n    (formatter == null ? void 0 : formatter.format(value)) || value}`,\n    id: NumberFormats.OVER_MAX_HIDDEN });\n\n}\nexport function calculateLowerLogTick(minPositiveValue) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}","map":{"version":3,"mappings":"iRAAA;AACA;;;;;;;;;;;;;;;;;;AAkBA,SACEA,QADF,EAKEC,UALF,EAMEC,aANF,EAOEC,eAPF,EAQEC,aARF,EASEC,eATF,EAYEC,kBAZF,QAeO,mBAfP;AAgBA,SAASC,cAAT,QAA+B,6BAA/B;AACA,SAASC,MAAT,QAA4D,SAA5D;;AAEA,SACEC,WADF,EAEEC,kBAFF,EAGEC,oBAHF,QAIO,cAJP;AAKA,SAASC,iBAAT,QAAyD,UAAzD;AACA,SAASC,oBAAT,QAAqC,aAArC;AAEA,SAASC,SAAT,CAAsBC,KAAtB,EAAiD;EAC/C,OAAOA,KAAK,KAAKC,SAAV,IAAuBD,KAAK,KAAK,IAAxC;AACD;AAED,OAAM,SAAUE,sBAAV,CACJC,IADI,EAEJC,IAFI,EAOH;EAKD,MAAMC,kBAAkB,GAAa,EAArC;EACA,MAAMC,eAAe,GAAa,EAAlC;EACA,MAAM,EAAEC,KAAF,EAASC,mBAAT,EAA8BC,QAA9B,EAAwCC,WAAxC,KAAwDN,IAA9D;EACA,IAAIG,KAAJ,EAAW;IACTJ,IAAI,CAACQ,OAAL,CAAa,MAAK,KAAG;MACnB,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYC,KAAZ,EAAmBC,MAAnB,CAA0B,CAACC,IAAD,EAAOC,IAAP,KAAe;QACtD,IAAIA,IAAI,KAAKT,QAAb,EAAuB;UACrB,OAAOQ,IAAP;QACD;QACD,IAAIP,WAAW,IAAI,CAACA,WAAW,CAACQ,IAAD,CAA/B,EAAuC;UACrC,OAAOD,IAAP;QACD;QACD,MAAMjB,KAAK,GAAGe,KAAK,CAACG,IAAD,CAAL,IAAe,CAA7B;QACA,OAAOD,IAAI,GAAIjB,KAAf;MACD,CATc,EASZ,CATY,CAAf;MAUAK,kBAAkB,CAACc,IAAnB,CAAwBP,MAAxB;MACAN,eAAe,CAACa,IAAhB,CAAsB,CAACX,mBAAmB,IAAI,CAAxB,IAA6B,GAA9B,GAAqCI,MAA1D;IACD,CAbD;EAcD;EACD,OAAO;IACLP,kBADK;IAELC,eAFK,EAAP;;AAID;AAED,OAAM,SAAUc,uBAAV,CACJC,MADI,EAEJjB,IAFI,EAOH;EAED,MAAMkB,gBAAgB,GAAa,EAAnC;EACA,MAAM,EAAEZ,WAAF,EAAeH,KAAf,EAAsBgB,YAAtB,EAAoCC,SAApC,KAAkDpB,IAAxD;EACA,IAAIG,KAAJ,EAAW;IACTc,MAAM,CAACV,OAAP,CAAe,CAACc,KAAD,EAAQC,WAAR,KAAuB;MACpC,MAAM,EAAEvB,IAAI,GAAG,EAAT,KAAgBsB,KAAtB;MACCtB,IAAwB,CAACQ,OAAzB,CAAiC,CAACI,KAAD,EAAQY,SAAR,KAAqB;QACrD,IAAIF,KAAK,CAACG,EAAN,IAAYlB,WAAZ,IAA2B,CAACA,WAAW,CAACe,KAAK,CAACG,EAAP,CAA3C,EAAuD;UACrD;QACD;QACD,IAAI,CAACJ,SAAD,IAAcT,KAAK,CAACQ,YAAY,GAAG,CAAH,GAAO,CAApB,CAAL,KAAgC,IAAlD,EAAwD;UACtDD,gBAAgB,CAACK,SAAD,CAAhB,GAA8BD,WAA9B;QACD;QACD,IAAIF,SAAJ,EAAe;UACb,IAAIT,KAAK,CAACQ,YAAY,GAAG,CAAH,GAAO,CAApB,CAAL,GAA8B,CAAlC,EAAqC;YACnCD,gBAAgB,CAACK,SAAD,CAAhB,GAA8BD,WAA9B;UACD;UACD,IACE,CAACJ,gBAAgB,CAACK,SAAD,CAAjB;UACAZ,KAAK,CAACQ,YAAY,GAAG,CAAH,GAAO,CAApB,CAAL,KAAgC,IAFlC,EAGE;YACAD,gBAAgB,CAACK,SAAD,CAAhB,GAA8BD,WAA9B;UACD;QACF;MACF,CAlBA;IAmBF,CArBD;EAsBD;EACD,OAAOJ,gBAAP;AACD;AAED,OAAM,SAAUO,mBAAV,CACJC,IADI,EAEJC,KAFI,EAGJC,iBAHI,EAIJC,cAJI,EAKJC,mBALI,EAKyB;EAE7B,MAAMC,WAAW,GAAGtB,MAAM,CAACC,IAAP,CAAYgB,IAAI,CAAC,CAAD,CAAhB;EACjBM,MADiB,CACV,IAAG,KAAIC,GAAG,KAAKN,KADL;EAEjBK,MAFiB,CAEV,IAAG,KAAI,CAAC,2CAAiB,MAAjB,kBAAiB,EAAUC,GAAV,CAFf,CAApB;EAIA,IAAIC,UAAJ;EAEA,QAAQL,cAAR;IACE,KAAKzC,cAAc,CAAC+C,GAApB;MACED,UAAU,GAAG,KAAI,MAAK,EAAEE,IAAF,EAAQxC,KAAK,EAAE,OAAM8B,IAAN,EAAYU,IAAZ,CAAf,EAAL,CAAjB;MACA;IACF,KAAKhD,cAAc,CAACiD,GAApB;MACEH,UAAU,GAAG,KAAI,yBAAK,EAAEE,IAAF,EAAQxC,KAAK,aAAE,OAAM8B,IAAN,EAAYU,IAAZ,CAAF,qBAAE,QAAoBA,IAApB,CAAf,EAAL,EAAjB;MACA;IACF,KAAKhD,cAAc,CAACkD,GAApB;MACEJ,UAAU,GAAG,KAAI,yBAAK,EAAEE,IAAF,EAAQxC,KAAK,aAAE,OAAM8B,IAAN,EAAYU,IAAZ,CAAF,qBAAE,QAAoBA,IAApB,CAAf,EAAL,EAAjB;MACA;IACF,KAAKhD,cAAc,CAACmD,GAApB;MACEL,UAAU,GAAG,KAAI,MAAK,EAAEE,IAAF,EAAQxC,KAAK,EAAE,QAAO8B,IAAP,EAAaU,IAAb,CAAf,EAAL,CAAjB;MACA;IACF;MACEF,UAAU,GAAG,KAAI,MAAK,EAAEE,IAAF,EAAQxC,KAAK,EAAEwC,IAAI,CAACI,WAAL,EAAf,EAAL,CAAjB;MACA,MAfJ;;EAkBA,MAAMC,YAAY,GAAGV,WAAW,CAACW,GAAZ,CAAgBR,UAAhB,CAArB;EAEA,OAAO,SACLO,YADK,EAEL,CAAC,OAAD,CAFK,EAGL,CAACX,mBAAmB,GAAG,KAAH,GAAW,MAA/B,CAHK,EAILY,GAJK,CAID,eAAC,EAAEN,IAAF,EAAD,eAAcA,IAAd,EAJC,CAAP;AAKD;AAED,OAAM,SAAUO,QAAV,CACJjB,IADI,EAEJzB,kBAFI,EAGJ0B,KAHI,EAIJiB,eAJI,EAKJC,wBALI,EAK6B;EAEjC,MAAMC,UAAU,GAAGpB,IAAI,CAACgB,GAAL,CAAS,CAACK,GAAD,EAAMC,GAAN,KAAa;IACvC,IAAIC,OAAO,GAAoB,EAA/B;IACA,IAAIC,SAAJ;IACA,IAAIC,OAAO,GAAG,CAAd;IACA1C,MAAM,CAAC0C,OAAP,CAAeJ,GAAf,EAAoBxC,OAApB,CAA4B,WAAiB,KAAhB,CAAC0B,GAAD,EAAMrC,KAAN,CAAgB;MAC3C,MAAMwD,cAAc,GAAGzD,SAAS,CAACC,KAAD,CAAhC;MACA,IAAIqC,GAAG,KAAKN,KAAZ,EAAmB;QACjBsB,OAAO,GAAGrD,KAAV;MACD;MACD,IACEgD,eAAe,KAAKxD,cAAc,CAACiE,IAAnC;MACA,OAAOzD,KAAP,KAAiB,QAFnB,EAGE;QACA;MACD;MAED,IAAI,EAAEgD,eAAe,KAAKxD,cAAc,CAACmD,GAAnC,IAA0C,CAACa,cAA7C,CAAJ,EAAkE;QAChED,OAAO,IAAI,CAAX;MACD;MAED,QAAQP,eAAR;QACE,KAAKxD,cAAc,CAACmD,GAApB;QACA,KAAKnD,cAAc,CAAC+C,GAApB;UACE,IAAIe,SAAS,KAAKrD,SAAlB,EAA6B;YAC3BqD,SAAS,GAAGtD,KAAZ;UACD,CAFD;UAEO;YACLsD,SAAS,IAAItD,KAAb;UACD;UACD;QACF,KAAKR,cAAc,CAACiD,GAApB;UACEa,SAAS;UACPA,SAAS,KAAKrD,SAAd,IAA4BuD,cAAc,IAAIxD,KAAK,GAAGsD,SAAtD;UACItD,KADJ;UAEIsD,SAHN;UAIA;QACF,KAAK9D,cAAc,CAACkD,GAApB;UACEY,SAAS;UACPA,SAAS,KAAKrD,SAAd,IAA4BuD,cAAc,IAAIxD,KAAK,GAAGsD,SAAtD;UACItD,KADJ;UAEIsD,SAHN;UAIA;QACF;UACE,MAtBJ;;IAwBD,CAxCD;IAyCA,IACEN,eAAe,KAAKxD,cAAc,CAACmD,GAAnC;IACAY,OAAO,GAAG,CADV;IAEAD,SAAS,KAAKrD,SAHhB,EAIE;MACAqD,SAAS,IAAIC,OAAb;IACD;IAED,MAAMvD,KAAK,GACTgD,eAAe,KAAKxD,cAAc,CAACiE,IAAnC,IAA2C,OAAOJ,OAAP,KAAmB,QAA9D;IACIA,OAAO,CAACT,WAAR,EADJ;IAEIU,SAHN;IAKA,OAAO;MACLjB,GAAG,EAAEgB,OADA;MAELrD,KAFK;MAGLmD,GAHK;MAILO,iBAAiB,EAAErD,kBAAkB,CAAC+C,GAAD,CAJhC,EAAP;;EAMD,CAhEkB,CAAnB;EAkEA,OAAO,SACLF,UADK,EAEL,CAAC,OAAD,CAFK,EAGL,CAACD,wBAAwB,GAAG,KAAH,GAAW,MAApC,CAHK,EAILH,GAJK,CAID,gBAAC,EAAEK,GAAF,EAAOO,iBAAP,EAAD,gBAAiC,EAAEP,GAAF,EAAOO,iBAAP,EAAjC,EAJC,CAAP;AAKD;AAED,OAAM,SAAUC,aAAV,CACJxD,IADI,EAEJC,IAFI,EAcE,KAZNA,IAYM,cAZNA,IAYM,GAAF,EAAE;EAEN,MAAM,EACJwD,iBADI,EAEJ7B,KAAK,GAAG7C,UAFJ,EAGJ8C,iBAAiB,GAAG,EAHhB,EAIJ6B,WAAW,GAAG,KAJV,EAKJtD,KAAK,GAAG,KALJ,EAMJF,kBAAkB,GAAG,EANjB,EAOJkB,YAAY,GAAG,KAPX,EAQJU,cARI,EASJC,mBATI,EAUJc,eAVI,EAWJC,wBAXI,KAYF7C,IAZJ;EAaA,IAAID,IAAI,CAAC2D,MAAL,KAAgB,CAApB;EAAuB,OAAO,CAAC,EAAD,EAAK,EAAL,EAAS7D,SAAT,CAAP;EACvB,MAAM6B,IAAI,GAAiB3B,IAAI,CAAC2C,GAAL,CAAS,MAAK,MAAK;IAC5C,GAAG/B,KADyC;IAE5C,CAACgB,KAAD,GAAShB,KAAK,CAACgB,KAAD,CAF8B,EAAL,CAAd,CAA3B;;EAIA,MAAMgC,YAAY,GAAGlC,mBAAmB,CACtCC,IADsC,EAEtCC,KAFsC,EAGtCC,iBAHsC,EAItCC,cAJsC,EAKtCC,mBALsC,CAAxC;EAOA,MAAMgB,UAAU,GACdnD,SAAS,CAACiD,eAAD,CAAT,IAA8BjD,SAAS,CAACkD,wBAAD,CAAvC;EACIF,QAAQ,CACNjB,IADM,EAENzB,kBAFM,EAGN0B,KAHM,EAINiB,eAJM,EAKNC,wBALM,CADZ;EAQInB,IAAI,CAACgB,GAAL,CAAS,CAACK,GAAD,EAAMC,GAAN,MAAe;IACtBD,GADsB;IAEtBO,iBAAiB,EAAErD,kBAAkB,CAAC+C,GAAD,CAFf,EAAf,CAAT,CATN;;EAcA,IAAIY,gBAAJ;EACA,MAAMC,WAAW,GAAGF,YAAY,CAACjB,GAAb,CAAiB,KAAI,MAAK;IAC5ClB,EAAE,EAAEY,IADwC;IAE5CA,IAF4C;IAG5CrC,IAAI,EAAE+C,UAAU;IACbJ,GADG,CACC,QAA6BM,GAA7B,KAAoC,uBAAnC,EAAED,GAAF,EAAOO,iBAAP,EAAmC;MACvC,MAAMQ,YAAY,GAAGf,GAAG,CAACX,IAAD,CAAxB;MACA,IACE,OAAO0B,YAAP,KAAwB,QAAxB;MACAA,YAAY,GAAG,CADf;MAECF,gBAAgB,KAAK/D,SAArB,IAAkC+D,gBAAgB,GAAGE,YAFtD,CADF,EAIE;QACAF,gBAAgB,GAAGE,YAAnB;MACD;MACD,MAAMC,oBAAoB,GACxBpE,SAAS,UAAC+B,IAAI,CAACsB,GAAG,GAAG,CAAP,CAAL,qBAAC,MAAgBZ,IAAhB,CAAD,CAAT,IAAoCzC,SAAS,WAAC+B,IAAI,CAACsB,GAAG,GAAG,CAAP,CAAL,qBAAC,OAAgBZ,IAAhB,CAAD,CAD/C;MAEA,MAAM4B,mBAAmB,GACvB,CAACrE,SAAS,CAACmE,YAAD,CAAV;MACAC,oBADA;MAEAP,iBAAiB,KAAK3D,SAHxB;MAIA,IAAID,KAAK,GAAgCkE,YAAzC;MACA,IAAIE,mBAAJ,EAAyB;QACvBpE,KAAK,GAAG4D,iBAAR;MACD,CAFD;MAEO,IACLrD,KAAK,KAAKZ,kBAAkB,CAAC0E,MAA7B;MACAX,iBAAiB,KAAKzD,SAFjB,EAGL;QACAD,KAAK,GAAI,CAACA,KAAK,IAAI,CAAV,IAA0B0D,iBAAnC;MACD;MACD,OAAO,CAACP,GAAG,CAACpB,KAAD,CAAJ,EAAa/B,KAAb,CAAP;IACD,CA1BG;IA2BHoC,MA3BG,CA2BI,IAAG,KAAI,CAACyB,WAAD,IAAiBS,GAAG,CAAC,CAAD,CAAH,KAAW,IAAX,IAAmBA,GAAG,CAAC,CAAD,CAAH,KAAW,IA3B1D;IA4BHxB,GA5BG,CA4BC,IAAG,KAAKvB,YAAY,GAAG,CAAC+C,GAAG,CAAC,CAAD,CAAJ,EAASA,GAAG,CAAC,CAAD,CAAZ,CAAH,GAAsBA,GA5B3C,CAHsC,EAAL,CAArB,CAApB;;EAiCA,OAAO;EACLL,WADK;EAELf,UAAU,CAACJ,GAAX,CAAe,gBAAC,EAAEY,iBAAF,EAAD,gBAA2BA,iBAA3B,EAAf,CAFK;EAGLM,gBAHK,CAAP;;AAKD;AAED,OAAM,SAAUO,gBAAV,CACJ/B,IADI,SAUE,KARN,EACEgC,eADF,EAEEC,aAFF,EAGEC,OAHF,EAQM,sBAAF,EAAE;EAEN,IAAIlC,IAAI,KAAKvC,SAAT,IAAsBuC,IAAI,KAAK,IAAnC,EAAyC;IACvC,OAAO9C,WAAP;EACD;EACD,IAAI,OAAO8C,IAAP,KAAgB,SAApB,EAA+B;IAC7B,OAAOA,IAAI,CAACmC,QAAL,EAAP;EACD;EACD,IAAInC,IAAI,YAAYoC,IAAhB,IAAwBF,OAAO,KAAKtF,eAAe,CAACyF,QAAxD,EAAkE;IAChE,MAAMC,cAAc,GAClB,OAAOtC,IAAP,KAAgB,QAAhB,GAA2BjD,kBAAkB,CAACiD,IAAD,CAA7C,GAAsDA,IADxD;IAEA,MAAMuC,CAAC,GACLD,cAAc,YAAYF,IAA1B;IACIE,cADJ;IAEI,IAAIF,IAAJ,CAASE,cAAT,CAHN;IAKA,OAAOL,aAAa,GAAGA,aAAa,CAACM,CAAD,CAAhB,GAAsBA,CAAC,CAACC,WAAF,EAA1C;EACD;EACD,IAAI,OAAOxC,IAAP,KAAgB,QAApB,EAA8B;IAC5B,OAAOgC,eAAe,GAAGA,eAAe,CAAChC,IAAD,CAAlB,GAA2BA,IAAI,CAACmC,QAAL,EAAjD;EACD;EACD,OAAOnC,IAAP;AACD;AAED,OAAO,MAAMyC,kBAAkB,GAAG,gBAAC,EACjCC,QAAQ,GAAG,EADsB,EAEjCC,QAAQ,GAAG,EAFsB,EAAD,gBAOhCA,QAAQ,CAACnE,MAAT,CACE,CAACoE,WAAD,EAAcC,IAAd,EAAoBC,KAApB,MAA+B,EAAE,GAAGF,WAAL,EAAkB,CAACC,IAAD,GAAQH,QAAQ,CAACI,KAAD,CAAlC,EAA/B,CADF,EAEE,EAFF,CAPgC,EAA3B;AAYP,OAAM,SAAUC,mBAAV,QAYL,KAZmC,EAClCxE,KAAK,GAAG,EAD0B,EAElCyE,OAFkC,EAGlChB,eAHkC,EAIlCC,aAJkC,EAKlCgB,cAAc,GAAG,EALiB,EAYnC;EACC,OAAOtG,aAAa,CAACqG,OAAD,CAAb;EACJ1C,GADI,CACA,IAAG,KACNyB,gBAAgB,CAACxD,KAAK,CAAC2E,GAAD,CAAN,EAAa;IAC3BlB,eAD2B;IAE3BC,aAF2B;IAG3B,IAAIgB,cAAc,CAACC,GAAD,CAAd,IAAuB,EAAEhB,OAAO,EAAEe,cAAc,CAACC,GAAD,CAAzB,EAA3B,CAH2B,EAAb,CAFb;;EAQJC,IARI,CAQC,IARD,CAAP;AASD;AAED,OAAM,SAAUC,cAAV,CACJC,IADI,EAEJC,WAFI,EAGJC,IAHI,EAIJC,KAJI,EAKJC,QALI,EAMJvF,WANI,EAMqB,kBADzBuF,QACyB,cADzBA,QACyB,GADd,KACc;EAEzB,MAAMC,MAAM,GAAoD;IAC9DC,MAAM,EAAE,sCAACtG,iBAAiB,CAACuG,GAAnB,EAAwBvG,iBAAiB,CAACwG,MAA1C,kBACNP,WADM;IAGJ,YAHI;IAIJ,UAL0D;IAM9DC,IAN8D;IAO9DF,IAP8D;IAQ9DS,QAAQ,EAAE5F,WARoD;IAS9D6F,QAAQ,EAAE,CAAC,KAAD,EAAQ,SAAR,CAToD;IAU9DC,aAAa,EAAE;MACbC,UAAU,EAAET,KAAK,CAACU,UAAN,CAAiBC,QAAjB,CAA0BC,SADzB;MAEbC,QAAQ,EAAEb,KAAK,CAACU,UAAN,CAAiBI,KAAjB,CAAuBC,CAFpB;MAGbC,KAAK,EAAEhB,KAAK,CAACiB,MAAN,CAAaC,SAAb,CAAuBC,IAHjB;MAIbC,WAAW,EAAEpB,KAAK,CAACiB,MAAN,CAAaC,SAAb,CAAuBC,IAJvB,EAV+C,EAAhE;;;EAiBA,QAAQrB,WAAR;IACE,KAAKjG,iBAAiB,CAACwH,IAAvB;MACEnB,MAAM,CAACoB,IAAP,GAAc,CAAd;MACA;IACF,KAAKzH,iBAAiB,CAAC0H,KAAvB;MACErB,MAAM,CAACsB,KAAP,GAAe,CAAf;MACAtB,MAAM,CAACuB,GAAP,GAAaxB,QAAQ,GAAGrG,oBAAoB,CAAC8H,oBAAxB,GAA+C,CAApE;MACA;IACF,KAAK7H,iBAAiB,CAACwG,MAAvB;MACEH,MAAM,CAACyB,MAAP,GAAgB,CAAhB;MACA;IACF,KAAK9H,iBAAiB,CAACuG,GAAvB;IACA;MACEF,MAAM,CAACuB,GAAP,GAAa,CAAb;MACAvB,MAAM,CAACsB,KAAP,GAAevB,QAAQ,GAAGrG,oBAAoB,CAACgI,oBAAxB,GAA+C,CAAtE;MACA,MAfJ;;EAiBA,OAAO1B,MAAP;AACD;AAED,OAAM,SAAU2B,eAAV,CACJ9B,IADI,EAEJD,WAFI,EAGJgC,MAHI,EAIJC,OAJI,EAIsE;EAO1E,IAAIC,YAAJ;EACA,IAAI,CAACjC,IAAL,EAAW;IACTiC,YAAY,GAAG,CAAf;EACD,CAFD;EAEO,IACLF,MAAM,KAAK,IAAX;EACAA,MAAM,KAAK7H,SADX;EAEA,OAAO6H,MAAP,KAAkB,QAHb,EAIL;IACAE,YAAY,GAAGlI,oBAAoB,CAACgG,WAAD,CAAnC;EACD,CANM;EAMA;IACLkC,YAAY,GAAGF,MAAf;EACD;EAED,MAAM,EAAEH,MAAM,GAAG,CAAX,EAAcL,IAAI,GAAG,CAArB,EAAwBE,KAAK,GAAG,CAAhC,EAAmCC,GAAG,GAAG,CAAzC,KAA+CM,OAAO,IAAI,EAAhE;EACA,OAAO;IACLT,IAAI,EAAEA,IAAI,IAAIxB,WAAW,KAAKjG,iBAAiB,CAACwH,IAAlC,GAAyCW,YAAzC,GAAwD,CAA5D,CADL;IAELR,KAAK,EAAEA,KAAK,IAAI1B,WAAW,KAAKjG,iBAAiB,CAAC0H,KAAlC,GAA0CS,YAA1C,GAAyD,CAA7D,CAFP;IAGLP,GAAG,EAAEA,GAAG,IAAI3B,WAAW,KAAKjG,iBAAiB,CAACuG,GAAlC,GAAwC4B,YAAxC,GAAuD,CAA3D,CAHH;IAILL,MAAM,EACJA,MAAM,IAAI7B,WAAW,KAAKjG,iBAAiB,CAACwG,MAAlC,GAA2C2B,YAA3C,GAA0D,CAA9D,CALH,EAAP;;AAOD;AAED,OAAM,SAAUC,WAAV,CAAsB5G,MAAtB,EAA4C;EAChD,MAAM6G,OAAO,GAAG,IAAIC,GAAJ,EAAhB;EACA,OAAO9G,MAAM,CAACyB,GAAP,CAAW,IAAG,KAAG;IACtB,IAAI,EAAElB,EAAF,KAASuB,GAAb;IACA,IAAIvB,EAAE,KAAK3B,SAAX;IAAsB,OAAOkD,GAAP;IACtBvB,EAAE,GAAGwG,MAAM,CAACxG,EAAD,CAAX;IACA,MAAMyG,KAAK,GAAGH,OAAO,CAACI,GAAR,CAAY1G,EAAZ,KAAmB,CAAjC;IACA,MAAM2G,MAAM,GAAGF,KAAK,GAAG,CAAR,GAAY,KAAKA,KAAK,GAAtB,GAA4B,EAA3C;IACAH,OAAO,CAACM,GAAR,CAAY5G,EAAZ,EAAgByG,KAAK,GAAG,CAAxB;IACA,OAAO;MACL,GAAGlF,GADE;MAELvB,EAAE,EAAE,GAAGA,EAAE,GAAG2G,MAAM,EAFb,EAAP;;EAID,CAXM,CAAP;AAYD;AAED,OAAM,SAAUE,YAAV,CAAuBC,IAAvB,EAAmC;EACvC,OAAOjJ,MAAM,CAACkJ,UAAP,CAAkBD,IAAlB,CAAP;AACD;AAED,OAAM,SAAUE,WAAV,CAAsBC,QAAtB,EAAgD;EACpD,IAAIA,QAAQ,KAAKzJ,eAAe,CAACyF,QAAjC,EAA2C;IACzC,OAAO5F,QAAQ,CAAC6J,IAAhB;EACD;EACD,OAAO7J,QAAQ,CAAC8J,QAAhB;AACD;AAED,OAAM,SAAUC,yBAAV,CACJC,MADI,EAIE,KAHNA,MAGM,cAHNA,MAGM,GAAF,EAAE;EAEN,MAAM,EAAEC,GAAF,EAAOC,SAAP,KAAqBF,MAA3B;EACA;EACA,MAAMG,mBAAmB,GAAG,CAAC,CAACF,GAAF,IAASA,GAAG,KAAK,CAA7C;EAEA,OAAO,IAAI5J,eAAJ,CAAoB;IACzB+J,UAAU,EAAE,MAAK,KACf,GACED,mBAAmB,IAAIpJ,KAAK,GAAGkJ,GAA/B;IACI,EADJ;IAEI,UAAS,QAAT,qBAAS,CAAEzJ,MAAX,CAAkBO,KAAlB,MAA4BA,KAClC,EANuB;IAOzB4B,EAAE,EAAEvC,aAAa,CAACiK,eAPO,EAApB,CAAP;;AASD;AAED,OAAM,SAAUC,qBAAV,CAAgCvF,gBAAhC,EAAwD;EAC5D,MAAMwF,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,KAAL,CAAW3F,gBAAX,CAAX,CAAlB;EACA,OAAOyF,IAAI,CAACG,GAAL,CAAS,EAAT,EAAaJ,SAAb,CAAP;AACD","names":["AxisType","DTTM_ALIAS","ensureIsArray","GenericDataType","NumberFormats","NumberFormatter","normalizeTimestamp","SortSeriesType","format","NULL_STRING","StackControlsValue","TIMESERIES_CONSTANTS","LegendOrientation","defaultLegendPadding","isDefined","value","undefined","extractDataTotalValues","data","opts","totalStackedValues","thresholdValues","stack","percentageThreshold","xAxisCol","legendState","forEach","values","Object","keys","datum","reduce","prev","curr","push","extractShowValueIndexes","series","showValueIndexes","isHorizontal","onlyTotal","entry","seriesIndex","dataIndex","id","sortAndFilterSeries","rows","xAxis","extraMetricLabels","sortSeriesType","sortSeriesAscending","seriesNames","filter","key","aggregator","Sum","name","Min","Max","Avg","toLowerCase","sortedValues","map","sortRows","xAxisSortSeries","xAxisSortSeriesAscending","sortedRows","row","idx","sortKey","aggregate","entries","isValueDefined","Name","totalStackedValue","extractSeries","fillNeighborValue","removeNulls","length","sortedSeries","minPositiveValue","finalSeries","currentValue","isNextToDefinedValue","isFillNeighborValue","Expand","obs","formatSeriesName","numberFormatter","timeFormatter","coltype","toString","Date","TEMPORAL","normalizedName","d","toISOString","getColtypesMapping","coltypes","colnames","accumulator","item","index","extractGroupbyLabel","groupby","coltypeMapping","val","join","getLegendProps","type","orientation","show","theme","zoomable","legend","orient","Top","Bottom","selected","selector","selectorLabel","fontFamily","typography","families","sansSerif","fontSize","sizes","s","color","colors","grayscale","base","borderColor","Left","left","Right","right","top","legendRightTopOffset","bottom","legendTopRightOffset","getChartPadding","margin","padding","legendMargin","dedupSeries","counter","Map","String","count","get","suffix","set","sanitizeHtml","text","encodeHTML","getAxisType","dataType","time","category","getOverMaxHiddenFormatter","config","max","formatter","shouldHideIfOverMax","formatFunc","OVER_MAX_HIDDEN","calculateLowerLogTick","logBase10","Math","floor","log10","pow"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AxisType,\n  ChartDataResponseResult,\n  DataRecord,\n  DataRecordValue,\n  DTTM_ALIAS,\n  ensureIsArray,\n  GenericDataType,\n  NumberFormats,\n  NumberFormatter,\n  TimeFormatter,\n  SupersetTheme,\n  normalizeTimestamp,\n  LegendState,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format, LegendComponentOption, SeriesOption } from 'echarts';\nimport { maxBy, meanBy, minBy, orderBy, sumBy } from 'lodash';\nimport {\n  NULL_STRING,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport { LegendOrientation, LegendType, StackType } from '../types';\nimport { defaultLegendPadding } from '../defaults';\n\nfunction isDefined<T>(value: T | undefined | null): boolean {\n  return value !== undefined && value !== null;\n}\n\nexport function extractDataTotalValues(\n  data: DataRecord[],\n  opts: {\n    stack: StackType;\n    percentageThreshold: number;\n    xAxisCol: string;\n    legendState?: LegendState;\n  },\n): {\n  totalStackedValues: number[];\n  thresholdValues: number[];\n} {\n  const totalStackedValues: number[] = [];\n  const thresholdValues: number[] = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach(datum => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + (value as number);\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push(((percentageThreshold || 0) / 100) * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues,\n  };\n}\n\nexport function extractShowValueIndexes(\n  series: SeriesOption[],\n  opts: {\n    stack: StackType;\n    onlyTotal?: boolean;\n    isHorizontal?: boolean;\n    legendState?: LegendState;\n  },\n): number[] {\n  const showValueIndexes: number[] = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      (data as [any, number][]).forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (\n            !showValueIndexes[dataIndex] &&\n            datum[isHorizontal ? 0 : 1] !== null\n          ) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\n\nexport function sortAndFilterSeries(\n  rows: DataRecord[],\n  xAxis: string,\n  extraMetricLabels: any[],\n  sortSeriesType?: SortSeriesType,\n  sortSeriesAscending?: boolean,\n): string[] {\n  const seriesNames = Object.keys(rows[0])\n    .filter(key => key !== xAxis)\n    .filter(key => !extraMetricLabels.includes(key));\n\n  let aggregator: (name: string) => { name: string; value: any };\n\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = name => ({ name, value: sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = name => ({ name, value: minBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Max:\n      aggregator = name => ({ name, value: maxBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Avg:\n      aggregator = name => ({ name, value: meanBy(rows, name) });\n      break;\n    default:\n      aggregator = name => ({ name, value: name.toLowerCase() });\n      break;\n  }\n\n  const sortedValues = seriesNames.map(aggregator);\n\n  return orderBy(\n    sortedValues,\n    ['value'],\n    [sortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ name }) => name);\n}\n\nexport function sortRows(\n  rows: DataRecord[],\n  totalStackedValues: number[],\n  xAxis: string,\n  xAxisSortSeries: SortSeriesType,\n  xAxisSortSeriesAscending: boolean,\n) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey: DataRecordValue = '';\n    let aggregate: number | undefined;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (\n        xAxisSortSeries === SortSeriesType.Name ||\n        typeof value !== 'number'\n      ) {\n        return;\n      }\n\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value < aggregate)\n              ? value\n              : aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value > aggregate)\n              ? value\n              : aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (\n      xAxisSortSeries === SortSeriesType.Avg &&\n      entries > 0 &&\n      aggregate !== undefined\n    ) {\n      aggregate /= entries;\n    }\n\n    const value =\n      xAxisSortSeries === SortSeriesType.Name && typeof sortKey === 'string'\n        ? sortKey.toLowerCase()\n        : aggregate;\n\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx],\n    };\n  });\n\n  return orderBy(\n    sortedRows,\n    ['value'],\n    [xAxisSortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\n\nexport function extractSeries(\n  data: DataRecord[],\n  opts: {\n    fillNeighborValue?: number;\n    xAxis?: string;\n    extraMetricLabels?: string[];\n    removeNulls?: boolean;\n    stack?: StackType;\n    totalStackedValues?: number[];\n    isHorizontal?: boolean;\n    sortSeriesType?: SortSeriesType;\n    sortSeriesAscending?: boolean;\n    xAxisSortSeries?: SortSeriesType;\n    xAxisSortSeriesAscending?: boolean;\n  } = {},\n): [SeriesOption[], number[], number | undefined] {\n  const {\n    fillNeighborValue,\n    xAxis = DTTM_ALIAS,\n    extraMetricLabels = [],\n    removeNulls = false,\n    stack = false,\n    totalStackedValues = [],\n    isHorizontal = false,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n  } = opts;\n  if (data.length === 0) return [[], [], undefined];\n  const rows: DataRecord[] = data.map(datum => ({\n    ...datum,\n    [xAxis]: datum[xAxis],\n  }));\n  const sortedSeries = sortAndFilterSeries(\n    rows,\n    xAxis,\n    extraMetricLabels,\n    sortSeriesType,\n    sortSeriesAscending,\n  );\n  const sortedRows =\n    isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending)\n      ? sortRows(\n          rows,\n          totalStackedValues,\n          xAxis,\n          xAxisSortSeries!,\n          xAxisSortSeriesAscending!,\n        )\n      : rows.map((row, idx) => ({\n          row,\n          totalStackedValue: totalStackedValues[idx],\n        }));\n\n  let minPositiveValue: number | undefined;\n  const finalSeries = sortedSeries.map(name => ({\n    id: name,\n    name,\n    data: sortedRows\n      .map(({ row, totalStackedValue }, idx) => {\n        const currentValue = row[name];\n        if (\n          typeof currentValue === 'number' &&\n          currentValue > 0 &&\n          (minPositiveValue === undefined || minPositiveValue > currentValue)\n        ) {\n          minPositiveValue = currentValue;\n        }\n        const isNextToDefinedValue =\n          isDefined(rows[idx - 1]?.[name]) || isDefined(rows[idx + 1]?.[name]);\n        const isFillNeighborValue =\n          !isDefined(currentValue) &&\n          isNextToDefinedValue &&\n          fillNeighborValue !== undefined;\n        let value: DataRecordValue | undefined = currentValue;\n        if (isFillNeighborValue) {\n          value = fillNeighborValue;\n        } else if (\n          stack === StackControlsValue.Expand &&\n          totalStackedValue !== undefined\n        ) {\n          value = ((value || 0) as number) / totalStackedValue;\n        }\n        return [row[xAxis], value];\n      })\n      .filter(obs => !removeNulls || (obs[0] !== null && obs[1] !== null))\n      .map(obs => (isHorizontal ? [obs[1], obs[0]] : obs)),\n  }));\n  return [\n    finalSeries,\n    sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n    minPositiveValue,\n  ];\n}\n\nexport function formatSeriesName(\n  name: DataRecordValue | undefined,\n  {\n    numberFormatter,\n    timeFormatter,\n    coltype,\n  }: {\n    numberFormatter?: ValueFormatter;\n    timeFormatter?: TimeFormatter;\n    coltype?: GenericDataType;\n  } = {},\n): string {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.TEMPORAL) {\n    const normalizedName =\n      typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d =\n      normalizedName instanceof Date\n        ? normalizedName\n        : new Date(normalizedName);\n\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\n\nexport const getColtypesMapping = ({\n  coltypes = [],\n  colnames = [],\n}: Pick<ChartDataResponseResult, 'coltypes' | 'colnames'>): Record<\n  string,\n  GenericDataType\n> =>\n  colnames.reduce(\n    (accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }),\n    {},\n  );\n\nexport function extractGroupbyLabel({\n  datum = {},\n  groupby,\n  numberFormatter,\n  timeFormatter,\n  coltypeMapping = {},\n}: {\n  datum?: DataRecord;\n  groupby?: string[] | null;\n  numberFormatter?: NumberFormatter;\n  timeFormatter?: TimeFormatter;\n  coltypeMapping?: Record<string, GenericDataType>;\n}): string {\n  return ensureIsArray(groupby)\n    .map(val =>\n      formatSeriesName(datum[val], {\n        numberFormatter,\n        timeFormatter,\n        ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }),\n      }),\n    )\n    .join(', ');\n}\n\nexport function getLegendProps(\n  type: LegendType,\n  orientation: LegendOrientation,\n  show: boolean,\n  theme: SupersetTheme,\n  zoomable = false,\n  legendState?: LegendState,\n): LegendComponentOption | LegendComponentOption[] {\n  const legend: LegendComponentOption | LegendComponentOption[] = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(\n      orientation,\n    )\n      ? 'horizontal'\n      : 'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base,\n    },\n  };\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\n\nexport function getChartPadding(\n  show: boolean,\n  orientation: LegendOrientation,\n  margin?: string | number | null,\n  padding?: { top?: number; bottom?: number; left?: number; right?: number },\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else if (\n    margin === null ||\n    margin === undefined ||\n    typeof margin === 'string'\n  ) {\n    legendMargin = defaultLegendPadding[orientation];\n  } else {\n    legendMargin = margin;\n  }\n\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom:\n      bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n  };\n}\n\nexport function dedupSeries(series: SeriesOption[]): SeriesOption[] {\n  const counter = new Map<string, number>();\n  return series.map(row => {\n    let { id } = row;\n    if (id === undefined) return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`,\n    };\n  });\n}\n\nexport function sanitizeHtml(text: string): string {\n  return format.encodeHTML(text);\n}\n\nexport function getAxisType(dataType?: GenericDataType): AxisType {\n  if (dataType === GenericDataType.TEMPORAL) {\n    return AxisType.time;\n  }\n  return AxisType.category;\n}\n\nexport function getOverMaxHiddenFormatter(\n  config: {\n    max?: number;\n    formatter?: ValueFormatter;\n  } = {},\n) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n\n  return new NumberFormatter({\n    formatFunc: value =>\n      `${\n        shouldHideIfOverMax && value > max\n          ? ''\n          : formatter?.format(value) || value\n      }`,\n    id: NumberFormats.OVER_MAX_HIDDEN,\n  });\n}\n\nexport function calculateLowerLogTick(minPositiveValue: number) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\n"]},"metadata":{},"sourceType":"module"}