{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport { extractGroupbyLabel, getColtypesMapping, sanitizeHtml } from '../utils/series';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding } from '../Timeseries/transformers';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, filterState, queriesData, inContextMenu, emitCrossFilters } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby = [], metrics = [], numberFormat, dateFormat, xTicksLayout, legendOrientation = 'top', xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId } = formData;\n  const refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const transformedData = data.\n  map((datum) => {\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat) });\n\n    return metricLabels.map((metric) => {var _context;\n      const name = metricLabels.length === 1 ?\n      groupbyLabel :\n      `${groupbyLabel}, ${metric}`;\n      const isFiltered = filterState.selectedValues &&\n      !_includesInstanceProperty(_context = filterState.selectedValues).call(_context, name);\n      return {\n        name,\n        value: [\n        datum[`${metric}__min`],\n        datum[`${metric}__q1`],\n        datum[`${metric}__median`],\n        datum[`${metric}__q3`],\n        datum[`${metric}__max`],\n        datum[`${metric}__mean`],\n        datum[`${metric}__count`],\n        datum[`${metric}__outliers`]],\n\n        itemStyle: {\n          color: colorFn(groupbyLabel, sliceId),\n          opacity: isFiltered ? OpacityEnum.SemiTransparent : 0.6,\n          borderColor: colorFn(groupbyLabel, sliceId) } };\n\n\n    });\n  }).\n  flatMap((row) => row);\n  const outlierData = data.\n  map((datum) => metricLabels.map((metric) => {var _context2;\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat) });\n\n    const name = metricLabels.length === 1 ?\n    groupbyLabel :\n    `${groupbyLabel}, ${metric}`;\n    // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)\n    const outlierDatum = datum[`${metric}__outliers`] || [];\n    const isFiltered = filterState.selectedValues &&\n    !_includesInstanceProperty(_context2 = filterState.selectedValues).call(_context2, name);\n    return {\n      name: 'outlier',\n      type: 'scatter',\n      data: outlierDatum.map((val) => [name, val]),\n      tooltip: {\n        ...getDefaultTooltip(refs),\n        formatter: (param) => {\n          const [outlierName, stats] = param.data;\n          const headline = groupbyLabels.length ?\n          `<p><strong>${sanitizeHtml(outlierName)}</strong></p>` :\n          '';\n          return `${headline}${numberFormatter(stats)}`;\n        } },\n\n      itemStyle: {\n        color: colorFn(groupbyLabel, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent } };\n\n\n  })).\n  flat(2);\n  const labelMap = data.reduce((acc, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat) });\n\n    return {\n      ...acc,\n      [label]: groupbyLabels.map((col) => datum[col]) };\n\n  }, {});\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex((_ref) => {let { name } = _ref;return name === selectedValue;});\n    return {\n      ...acc,\n      [index]: selectedValue };\n\n  }, {});\n  let axisLabel;\n  if (xTicksLayout === '45°')\n  axisLabel = { rotate: -45 };else\n  if (xTicksLayout === '90°')\n  axisLabel = { rotate: -90 };else\n  if (xTicksLayout === 'flat')\n  axisLabel = { rotate: 0 };else\n  if (xTicksLayout === 'staggered')\n  axisLabel = { rotate: -45 };else\n\n  axisLabel = { show: true };\n  const series = [\n  {\n    name: 'boxplot',\n    type: 'boxplot',\n    data: transformedData,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (param) => {\n        // @ts-ignore\n        const { value, name } = param;\n        const headline = name ?\n        `<p><strong>${sanitizeHtml(name)}</strong></p>` :\n        '';\n        const stats = [\n        `Max: ${numberFormatter(value[5])}`,\n        `3rd Quartile: ${numberFormatter(value[4])}`,\n        `Mean: ${numberFormatter(value[6])}`,\n        `Median: ${numberFormatter(value[3])}`,\n        `1st Quartile: ${numberFormatter(value[2])}`,\n        `Min: ${numberFormatter(value[1])}`,\n        `# Observations: ${numberFormatter(value[7])}`];\n\n        if (value[8].length > 0) {\n          stats.push(`# Outliers: ${numberFormatter(value[8].length)}`);\n        }\n        return headline + stats.join('<br/>');\n      } } },\n\n\n  // @ts-ignore\n  ...outlierData];\n\n  const addYAxisTitleOffset = !!yAxisTitle;\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(true, legendOrientation, addYAxisTitleOffset, false, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const echartOptions = {\n    grid: {\n      ...defaultGrid,\n      ...chartPadding },\n\n    xAxis: {\n      type: 'category',\n      data: transformedData.map((row) => row.name),\n      axisLabel,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle' },\n\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      axisLabel: { formatter: numberFormatter },\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end' },\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow' } },\n\n\n    series };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n}","map":{"version":3,"mappings":"iGAAA;;;;;;;;;;;;;;;;;;AAkBA,SACEA,yBADF,EAEEC,cAFF,EAGEC,cAHF,EAIEC,kBAJF,EAKEC,gBALF,QAMO,mBANP;AAcA,SACEC,mBADF,EAEEC,kBAFF,EAGEC,YAHF,QAIO,iBAJP;AAKA,SAASC,cAAT,QAA+B,yBAA/B;AACA,SAASC,WAAT,EAAsBC,YAAtB,QAA0C,aAA1C;AACA,SAASC,UAAT,QAA2B,4BAA3B;AACA,SAASC,WAAT,QAA4B,cAA5B;AACA,SAASC,iBAAT,QAAkC,kBAAlC;AAGA,eAAc,SAAUC,cAAV,CACZC,UADY,EACwB;EAEpC,MAAM,EACJC,KADI,EAEJC,MAFI,EAGJC,QAHI,EAIJC,KAJI,EAKJC,WALI,EAMJC,WANI,EAOJC,aAPI,EAQJC,gBARI,KASFR,UATJ;EAUA,MAAM,EAAES,IAAI,GAAG,EAAT,KAAgBH,WAAW,CAAC,CAAD,CAAjC;EACA,MAAM,EAAEI,WAAW,GAAG,MAAK,CAAG,CAAxB,EAA0BC,aAA1B,KAA4CP,KAAlD;EACA,MAAMQ,cAAc,GAAGrB,kBAAkB,CAACe,WAAW,CAAC,CAAD,CAAZ,CAAzC;EACA,MAAM,EACJO,WADI,EAEJC,OAAO,GAAG,EAFN,EAGJC,OAAO,GAAG,EAHN,EAIJC,YAJI,EAKJC,UALI,EAMJC,YANI,EAOJC,iBAAiB,GAAG,KAPhB,EAQJC,UARI,EASJC,UATI,EAUJC,gBAVI,EAWJC,gBAXI,EAYJC,kBAZI,EAaJC,OAbI,KAcFtB,QAdJ;EAeA,MAAMuB,IAAI,GAAS,EAAnB;EACA,MAAMC,OAAO,GAAG1C,yBAAyB,CAAC2C,QAA1B,CAAmCf,WAAnC,CAAhB;EACA,MAAMgB,eAAe,GAAGzC,kBAAkB,CAAC4B,YAAD,CAA1C;EACA,MAAMc,YAAY,GAAGf,OAAO,CAACgB,GAAR,CAAY5C,cAAZ,CAArB;EACA,MAAM6C,aAAa,GAAGlB,OAAO,CAACiB,GAAR,CAAY7C,cAAZ,CAAtB;EAEA,MAAM+C,eAAe,GAAGxB,IAAI;EACzBsB,GADqB,CACjB,CAACG,KAAD,KAAe;IAClB,MAAMC,YAAY,GAAG7C,mBAAmB,CAAC;MACvC4C,KADuC;MAEvCpB,OAAO,EAAEkB,aAF8B;MAGvCpB,cAHuC;MAIvCwB,aAAa,EAAE/C,gBAAgB,CAAC4B,UAAD,CAJQ,EAAD,CAAxC;;IAMA,OAAOa,YAAY,CAACC,GAAb,CAAiB,OAAM,KAAG;MAC/B,MAAMM,IAAI,GACRP,YAAY,CAACQ,MAAb,KAAwB,CAAxB;MACIH,YADJ;MAEI,GAAGA,YAAY,KAAKI,MAAM,EAHhC;MAIA,MAAMC,UAAU,GACdnC,WAAW,CAACoC,cAAZ;MACA,CAAC,gDAAW,CAACA,cAAZ,iBAAoCJ,IAApC,CAFH;MAGA,OAAO;QACLA,IADK;QAELK,KAAK,EAAE;QACLR,KAAK,CAAC,GAAGK,MAAM,OAAV,CADA;QAELL,KAAK,CAAC,GAAGK,MAAM,MAAV,CAFA;QAGLL,KAAK,CAAC,GAAGK,MAAM,UAAV,CAHA;QAILL,KAAK,CAAC,GAAGK,MAAM,MAAV,CAJA;QAKLL,KAAK,CAAC,GAAGK,MAAM,OAAV,CALA;QAMLL,KAAK,CAAC,GAAGK,MAAM,QAAV,CANA;QAOLL,KAAK,CAAC,GAAGK,MAAM,SAAV,CAPA;QAQLL,KAAK,CAAC,GAAGK,MAAM,YAAV,CARA,CAFF;;QAYLI,SAAS,EAAE;UACTC,KAAK,EAAEjB,OAAO,CAACQ,YAAD,EAAeV,OAAf,CADL;UAEToB,OAAO,EAAEL,UAAU,GAAG3C,WAAW,CAACiD,eAAf,GAAiC,GAF3C;UAGTC,WAAW,EAAEpB,OAAO,CAACQ,YAAD,EAAeV,OAAf,CAHX,EAZN,EAAP;;;IAkBD,CA1BM,CAAP;EA2BD,CAnCqB;EAoCrBuB,OApCqB,CAoCb,IAAG,KAAIC,GApCM,CAAxB;EAqCA,MAAMC,WAAW,GAAGzC,IAAI;EACrBsB,GADiB,CACb,MAAK,KACRD,YAAY,CAACC,GAAb,CAAiB,OAAM,KAAG;IACxB,MAAMI,YAAY,GAAG7C,mBAAmB,CAAC;MACvC4C,KADuC;MAEvCpB,OAAO,EAAEkB,aAF8B;MAGvCpB,cAHuC;MAIvCwB,aAAa,EAAE/C,gBAAgB,CAAC4B,UAAD,CAJQ,EAAD,CAAxC;;IAMA,MAAMoB,IAAI,GACRP,YAAY,CAACQ,MAAb,KAAwB,CAAxB;IACIH,YADJ;IAEI,GAAGA,YAAY,KAAKI,MAAM,EAHhC;IAIA;IACA,MAAMY,YAAY,GAAIjB,KAAK,CAAC,GAAGK,MAAM,YAAV,CAAL,IAAgC,EAAtD;IACA,MAAMC,UAAU,GACdnC,WAAW,CAACoC,cAAZ;IACA,CAAC,iDAAW,CAACA,cAAZ,kBAAoCJ,IAApC,CAFH;IAGA,OAAO;MACLA,IAAI,EAAE,SADD;MAELe,IAAI,EAAE,SAFD;MAGL3C,IAAI,EAAE0C,YAAY,CAACpB,GAAb,CAAiB,IAAG,KAAI,CAACM,IAAD,EAAOgB,GAAP,CAAxB,CAHD;MAILC,OAAO,EAAE;QACP,GAAGxD,iBAAiB,CAAC4B,IAAD,CADb;QAEP6B,SAAS,EAAE,CAACC,KAAD,KAAsC;UAC/C,MAAM,CAACC,WAAD,EAAcC,KAAd,IAAuBF,KAAK,CAAC/C,IAAnC;UACA,MAAMkD,QAAQ,GAAG3B,aAAa,CAACM,MAAd;UACb,cAAc9C,YAAY,CAACiE,WAAD,CAAa,eAD1B;UAEb,EAFJ;UAGA,OAAO,GAAGE,QAAQ,GAAG9B,eAAe,CAAC6B,KAAD,CAAO,EAA3C;QACD,CARM,EAJJ;;MAcLf,SAAS,EAAE;QACTC,KAAK,EAAEjB,OAAO,CAACQ,YAAD,EAAeV,OAAf,CADL;QAEToB,OAAO,EAAEL,UAAU;QACf3C,WAAW,CAACiD,eADG;QAEfjD,WAAW,CAAC+D,cAJP,EAdN,EAAP;;;EAqBD,CArCD,CAFgB;EAyCjBC,IAzCiB,CAyCZ,CAzCY,CAApB;EA2CA,MAAMC,QAAQ,GAAGrD,IAAI,CAACsD,MAAL,CAAY,CAACC,GAAD,EAAgC9B,KAAhC,KAAyC;IACpE,MAAM+B,KAAK,GAAG3E,mBAAmB,CAAC;MAChC4C,KADgC;MAEhCpB,OAAO,EAAEkB,aAFuB;MAGhCpB,cAHgC;MAIhCwB,aAAa,EAAE/C,gBAAgB,CAAC4B,UAAD,CAJC,EAAD,CAAjC;;IAMA,OAAO;MACL,GAAG+C,GADE;MAEL,CAACC,KAAD,GAASjC,aAAa,CAACD,GAAd,CAAkB,IAAG,KAAIG,KAAK,CAACgC,GAAD,CAA9B,CAFJ,EAAP;;EAID,CAXgB,EAWd,EAXc,CAAjB;EAaA,MAAMzB,cAAc,GAAG,CAACpC,WAAW,CAACoC,cAAZ,IAA8B,EAA/B,EAAmCsB,MAAnC,CACrB,CAACC,GAAD,EAA8BG,aAA9B,KAAuD;IACrD,MAAMC,KAAK,GAAGnC,eAAe,CAACoC,SAAhB,CACZ,eAAC,EAAEhC,IAAF,EAAD,eAAcA,IAAI,KAAK8B,aAAvB,EADY,CAAd;IAGA,OAAO;MACL,GAAGH,GADE;MAEL,CAACI,KAAD,GAASD,aAFJ,EAAP;;EAID,CAToB,EAUrB,EAVqB,CAAvB;EAaA,IAAIG,SAAJ;EACA,IAAIpD,YAAY,KAAK,KAArB;EAA4BoD,SAAS,GAAG,EAAEC,MAAM,EAAE,CAAC,EAAX,EAAZ,CAA5B;EACK,IAAIrD,YAAY,KAAK,KAArB;EAA4BoD,SAAS,GAAG,EAAEC,MAAM,EAAE,CAAC,EAAX,EAAZ,CAA5B;EACA,IAAIrD,YAAY,KAAK,MAArB;EAA6BoD,SAAS,GAAG,EAAEC,MAAM,EAAE,CAAV,EAAZ,CAA7B;EACA,IAAIrD,YAAY,KAAK,WAArB;EAAkCoD,SAAS,GAAG,EAAEC,MAAM,EAAE,CAAC,EAAX,EAAZ,CAAlC;;EACAD,SAAS,GAAG,EAAEE,IAAI,EAAE,IAAR,EAAZ;EAEL,MAAMC,MAAM,GAA0B;EACpC;IACEpC,IAAI,EAAE,SADR;IAEEe,IAAI,EAAE,SAFR;IAGE3C,IAAI,EAAEwB,eAHR;IAIEqB,OAAO,EAAE;MACP,GAAGxD,iBAAiB,CAAC4B,IAAD,CADb;MAEP6B,SAAS,EAAE,CAACC,KAAD,KAA8B;QACvC;QACA,MAAM,EACJd,KADI,EAEJL,IAFI,KAgBFmB,KAhBJ;QAiBA,MAAMG,QAAQ,GAAGtB,IAAI;QACjB,cAAc7C,YAAY,CAAC6C,IAAD,CAAM,eADf;QAEjB,EAFJ;QAGA,MAAMqB,KAAK,GAAG;QACZ,QAAQ7B,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EADrB;QAEZ,iBAAiBb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EAF9B;QAGZ,SAASb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EAHtB;QAIZ,WAAWb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EAJxB;QAKZ,iBAAiBb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EAL9B;QAMZ,QAAQb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EANrB;QAOZ,mBAAmBb,eAAe,CAACa,KAAK,CAAC,CAAD,CAAN,CAAU,EAPhC,CAAd;;QASA,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASJ,MAAT,GAAkB,CAAtB,EAAyB;UACvBoB,KAAK,CAACgB,IAAN,CAAW,eAAe7C,eAAe,CAACa,KAAK,CAAC,CAAD,CAAL,CAASJ,MAAV,CAAiB,EAA1D;QACD;QACD,OAAOqB,QAAQ,GAAGD,KAAK,CAACiB,IAAN,CAAW,OAAX,CAAlB;MACD,CArCM,EAJX,EADoC;;;EA6CpC;EACA,GAAGzB,WA9CiC,CAAtC;;EAgDA,MAAM0B,mBAAmB,GAAG,CAAC,CAACvD,UAA9B;EACA,MAAMwD,mBAAmB,GAAG,CAAC,CAACzD,UAA9B;EACA,MAAM0D,YAAY,GAAGlF,UAAU,CAC7B,IAD6B,EAE7BuB,iBAF6B,EAG7ByD,mBAH6B,EAI7B,KAJ6B,EAK7B,IAL6B,EAM7BC,mBAN6B,EAO7BrD,kBAP6B,EAQ7B/B,cAAc,CAAC8B,gBAAD,CARe,EAS7B9B,cAAc,CAAC6B,gBAAD,CATe,CAA/B;EAWA,MAAMyD,aAAa,GAAsB;IACvCC,IAAI,EAAE;MACJ,GAAGtF,WADC;MAEJ,GAAGoF,YAFC,EADiC;;IAKvCG,KAAK,EAAE;MACL7B,IAAI,EAAE,UADD;MAEL3C,IAAI,EAAEwB,eAAe,CAACF,GAAhB,CAAoB,IAAG,KAAIkB,GAAG,CAACZ,IAA/B,CAFD;MAGLiC,SAHK;MAILjC,IAAI,EAAEjB,UAJD;MAKL8D,OAAO,EAAEzF,cAAc,CAAC6B,gBAAD,CALlB;MAML6D,YAAY,EAAE,QANT,EALgC;;IAavCC,KAAK,EAAE;MACL,GAAGzF,YADE;MAELyD,IAAI,EAAE,OAFD;MAGLkB,SAAS,EAAE,EAAEf,SAAS,EAAE1B,eAAb,EAHN;MAILQ,IAAI,EAAEhB,UAJD;MAKL6D,OAAO,EAAEzF,cAAc,CAAC8B,gBAAD,CALlB;MAML4D,YAAY,EAAE3D,kBAAkB,KAAK,MAAvB,GAAgC,QAAhC,GAA2C,KANpD,EAbgC;;IAqBvC8B,OAAO,EAAE;MACP,GAAGxD,iBAAiB,CAAC4B,IAAD,CADb;MAEP8C,IAAI,EAAE,CAACjE,aAFA;MAGP8E,OAAO,EAAE,MAHF;MAIPC,WAAW,EAAE;QACXlC,IAAI,EAAE,QADK,EAJN,EArB8B;;;IA6BvCqB,MA7BuC,EAAzC;;EAgCA,OAAO;IACLtE,QADK;IAELF,KAFK;IAGLC,MAHK;IAIL6E,aAJK;IAKLrE,WALK;IAMLF,gBANK;IAOLsD,QAPK;IAQLhD,OARK;IASL2B,cATK;IAUL9B,aAVK;IAWLe,IAXK;IAYLd,cAZK,EAAP;;AAcD","names":["CategoricalColorNamespace","getColumnLabel","getMetricLabel","getNumberFormatter","getTimeFormatter","extractGroupbyLabel","getColtypesMapping","sanitizeHtml","convertInteger","defaultGrid","defaultYAxis","getPadding","OpacityEnum","getDefaultTooltip","transformProps","chartProps","width","height","formData","hooks","filterState","queriesData","inContextMenu","emitCrossFilters","data","setDataMask","onContextMenu","coltypeMapping","colorScheme","groupby","metrics","numberFormat","dateFormat","xTicksLayout","legendOrientation","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","refs","colorFn","getScale","numberFormatter","metricLabels","map","groupbyLabels","transformedData","datum","groupbyLabel","timeFormatter","name","length","metric","isFiltered","selectedValues","value","itemStyle","color","opacity","SemiTransparent","borderColor","flatMap","row","outlierData","outlierDatum","type","val","tooltip","formatter","param","outlierName","stats","headline","NonTransparent","flat","labelMap","reduce","acc","label","col","selectedValue","index","findIndex","axisLabel","rotate","show","series","push","join","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","echartOptions","grid","xAxis","nameGap","nameLocation","yAxis","trigger","axisPointer"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/BoxPlot/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getTimeFormatter,\n} from '@superset-ui/core';\nimport { EChartsCoreOption, BoxplotSeriesOption } from 'echarts';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport {\n  BoxPlotChartTransformedProps,\n  BoxPlotQueryFormData,\n  EchartsBoxPlotChartProps,\n} from './types';\nimport {\n  extractGroupbyLabel,\n  getColtypesMapping,\n  sanitizeHtml,\n} from '../utils/series';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding } from '../Timeseries/transformers';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\n\nexport default function transformProps(\n  chartProps: EchartsBoxPlotChartProps,\n): BoxPlotChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    hooks,\n    filterState,\n    queriesData,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    colorScheme,\n    groupby = [],\n    metrics = [],\n    numberFormat,\n    dateFormat,\n    xTicksLayout,\n    legendOrientation = 'top',\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n  } = formData as BoxPlotQueryFormData;\n  const refs: Refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n\n  const transformedData = data\n    .map((datum: any) => {\n      const groupbyLabel = extractGroupbyLabel({\n        datum,\n        groupby: groupbyLabels,\n        coltypeMapping,\n        timeFormatter: getTimeFormatter(dateFormat),\n      });\n      return metricLabels.map(metric => {\n        const name =\n          metricLabels.length === 1\n            ? groupbyLabel\n            : `${groupbyLabel}, ${metric}`;\n        const isFiltered =\n          filterState.selectedValues &&\n          !filterState.selectedValues.includes(name);\n        return {\n          name,\n          value: [\n            datum[`${metric}__min`],\n            datum[`${metric}__q1`],\n            datum[`${metric}__median`],\n            datum[`${metric}__q3`],\n            datum[`${metric}__max`],\n            datum[`${metric}__mean`],\n            datum[`${metric}__count`],\n            datum[`${metric}__outliers`],\n          ],\n          itemStyle: {\n            color: colorFn(groupbyLabel, sliceId),\n            opacity: isFiltered ? OpacityEnum.SemiTransparent : 0.6,\n            borderColor: colorFn(groupbyLabel, sliceId),\n          },\n        };\n      });\n    })\n    .flatMap(row => row);\n  const outlierData = data\n    .map(datum =>\n      metricLabels.map(metric => {\n        const groupbyLabel = extractGroupbyLabel({\n          datum,\n          groupby: groupbyLabels,\n          coltypeMapping,\n          timeFormatter: getTimeFormatter(dateFormat),\n        });\n        const name =\n          metricLabels.length === 1\n            ? groupbyLabel\n            : `${groupbyLabel}, ${metric}`;\n        // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)\n        const outlierDatum = (datum[`${metric}__outliers`] || []) as number[];\n        const isFiltered =\n          filterState.selectedValues &&\n          !filterState.selectedValues.includes(name);\n        return {\n          name: 'outlier',\n          type: 'scatter',\n          data: outlierDatum.map(val => [name, val]),\n          tooltip: {\n            ...getDefaultTooltip(refs),\n            formatter: (param: { data: [string, number] }) => {\n              const [outlierName, stats] = param.data;\n              const headline = groupbyLabels.length\n                ? `<p><strong>${sanitizeHtml(outlierName)}</strong></p>`\n                : '';\n              return `${headline}${numberFormatter(stats)}`;\n            },\n          },\n          itemStyle: {\n            color: colorFn(groupbyLabel, sliceId),\n            opacity: isFiltered\n              ? OpacityEnum.SemiTransparent\n              : OpacityEnum.NonTransparent,\n          },\n        };\n      }),\n    )\n    .flat(2);\n\n  const labelMap = data.reduce((acc: Record<string, string[]>, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat),\n    });\n    return {\n      ...acc,\n      [label]: groupbyLabels.map(col => datum[col] as string),\n    };\n  }, {});\n\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = transformedData.findIndex(\n        ({ name }) => name === selectedValue,\n      );\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  let axisLabel;\n  if (xTicksLayout === '45°') axisLabel = { rotate: -45 };\n  else if (xTicksLayout === '90°') axisLabel = { rotate: -90 };\n  else if (xTicksLayout === 'flat') axisLabel = { rotate: 0 };\n  else if (xTicksLayout === 'staggered') axisLabel = { rotate: -45 };\n  else axisLabel = { show: true };\n\n  const series: BoxplotSeriesOption[] = [\n    {\n      name: 'boxplot',\n      type: 'boxplot',\n      data: transformedData,\n      tooltip: {\n        ...getDefaultTooltip(refs),\n        formatter: (param: CallbackDataParams) => {\n          // @ts-ignore\n          const {\n            value,\n            name,\n          }: {\n            value: [\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number,\n              number[],\n            ];\n            name: string;\n          } = param;\n          const headline = name\n            ? `<p><strong>${sanitizeHtml(name)}</strong></p>`\n            : '';\n          const stats = [\n            `Max: ${numberFormatter(value[5])}`,\n            `3rd Quartile: ${numberFormatter(value[4])}`,\n            `Mean: ${numberFormatter(value[6])}`,\n            `Median: ${numberFormatter(value[3])}`,\n            `1st Quartile: ${numberFormatter(value[2])}`,\n            `Min: ${numberFormatter(value[1])}`,\n            `# Observations: ${numberFormatter(value[7])}`,\n          ];\n          if (value[8].length > 0) {\n            stats.push(`# Outliers: ${numberFormatter(value[8].length)}`);\n          }\n          return headline + stats.join('<br/>');\n        },\n      },\n    },\n    // @ts-ignore\n    ...outlierData,\n  ];\n  const addYAxisTitleOffset = !!yAxisTitle;\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(\n    true,\n    legendOrientation,\n    addYAxisTitleOffset,\n    false,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: 'category',\n      data: transformedData.map(row => row.name),\n      axisLabel,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      axisLabel: { formatter: numberFormatter },\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow',\n      },\n    },\n    series,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}