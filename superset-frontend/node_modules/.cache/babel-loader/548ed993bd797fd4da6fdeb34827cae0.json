{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array };\n\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels' };\n\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height }).\n    fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom } };\n\n\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds } =\n    this.props;\n    const { viewport } = this.state;\n    const isDragging =\n    viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = width * 0.5 / 100;\n    const offsetVertical = height * 0.5 / 100;\n    const bbox = [\n    bounds[0][0] - offsetHorizontal,\n    bounds[0][1] - offsetVertical,\n    bounds[1][0] + offsetHorizontal,\n    bounds[1][1] + offsetVertical];\n\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      ___EmotionJSX(MapGL, _extends({},\n      viewport, {\n        mapStyle: mapStyle,\n        width: width,\n        height: height,\n        mapboxApiAccessToken: mapboxApiKey,\n        onViewportChange: this.handleViewportChange,\n        preserveDrawingBuffer: true }),\n\n      ___EmotionJSX(ScatterPlotGlowOverlay, _extends({},\n      viewport, {\n        isDragging: isDragging,\n        locations: clusters,\n        dotRadius: pointRadius,\n        pointRadiusUnit: pointRadiusUnit,\n        rgb: rgb,\n        globalOpacity: globalOpacity,\n        compositeOperation: \"screen\",\n        renderWhileDragging: renderWhileDragging,\n        aggregation: hasCustomMetric ? aggregatorName : null,\n        lngLatAccessor: (location) => {\n          const { coordinates } = location.geometry;\n\n          return [coordinates[0], coordinates[1]];\n        } }))));\n\n\n\n  }}\n\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;","map":{"version":3,"names":["React","PropTypes","MapGL","ViewportMercator","ScatterPlotGlowOverlay","NOOP","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","propTypes","width","number","height","aggregatorName","string","clusterer","object","globalOpacity","hasCustomMetric","bool","mapStyle","mapboxApiKey","isRequired","onViewportChange","func","pointRadius","pointRadiusUnit","renderWhileDragging","rgb","array","bounds","defaultProps","MapBox","Component","constructor","props","mercator","fitBounds","latitude","longitude","zoom","state","viewport","handleViewportChange","bind","setState","render","isDragging","undefined","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","Math","round","location","coordinates","geometry"],"sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/legacy-plugin-chart-map-box/src/MapBox.jsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}