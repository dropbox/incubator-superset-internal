{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { AnnotationOpacity, AnnotationType, evalExpression, isRecordAnnotationResult, isTableAnnotationLayer, isTimeseriesAnnotationResult } from '@superset-ui/core';\nexport function evalFormula(formula, data, xAxis, xAxisType) {\n  const { value: expression } = formula;\n  return data.map((row) => {\n    let value = row[xAxis];\n    if (xAxisType === 'time') {\n      value = new Date(value).getTime();\n    }\n    return [value, evalExpression(expression, value || 0)];\n  });\n}\nexport function parseAnnotationOpacity(opacity) {\n  switch (opacity) {\n    case AnnotationOpacity.Low:\n      return 0.2;\n    case AnnotationOpacity.Medium:\n      return 0.5;\n    case AnnotationOpacity.High:\n      return 0.8;\n    default:\n      return 1;}\n\n}\nconst NATIVE_COLUMN_NAMES = {\n  descriptionColumns: ['long_descr'],\n  intervalEndColumn: 'end_dttm',\n  timeColumn: 'start_dttm',\n  titleColumn: 'short_descr' };\n\nexport function extractRecordAnnotations(annotationLayer, annotationData) {\n  const { name } = annotationLayer;\n  const result = annotationData[name];\n  if (isRecordAnnotationResult(result)) {\n    const { records } = result;\n    const { descriptionColumns = [], intervalEndColumn = '', timeColumn = '', titleColumn = '' } = isTableAnnotationLayer(annotationLayer) ?\n    annotationLayer :\n    NATIVE_COLUMN_NAMES;\n    return records.map((record) => ({\n      descriptions: descriptionColumns.map((column) => record[column] || ''),\n      intervalEnd: record[intervalEndColumn] || '',\n      time: record[timeColumn] || '',\n      title: record[titleColumn] || '' }));\n\n  }\n  throw new Error('Please rerun the query.');\n}\nexport function formatAnnotationLabel(name, title, descriptions) {if (descriptions === void 0) {descriptions = [];}\n  const labels = [];\n  const titleLabels = [];\n  const filteredDescriptions = descriptions.filter((description) => !!description);\n  if (name)\n  titleLabels.push(name);\n  if (title)\n  titleLabels.push(title);\n  if (titleLabels.length > 0)\n  labels.push(titleLabels.join(' - '));\n  if (filteredDescriptions.length > 0)\n  labels.push(filteredDescriptions.join('\\n'));\n  return labels.join('\\n\\n');\n}\nexport function extractAnnotationLabels(layers, data) {\n  const formulaAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Formula && anno.show).\n  map((anno) => anno.name);\n  const timeseriesAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Timeseries && anno.show).\n  flatMap((anno) => {\n    const result = data[anno.name];\n    return isTimeseriesAnnotationResult(result) ?\n    result.map((annoSeries) => annoSeries.key) :\n    [];\n  });\n  return formulaAnnotationLabels.concat(timeseriesAnnotationLabels);\n}\nexport function getAnnotationData(chartProps) {var _chartProps$queriesDa;\n  const data = chartProps == null ? void 0 : (_chartProps$queriesDa = chartProps.queriesData[0]) == null ? void 0 : _chartProps$queriesDa.annotation_data;\n  if (!_isEmpty(data)) {\n    return data;\n  }\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(evalFormula, \"evalFormula\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(parseAnnotationOpacity, \"parseAnnotationOpacity\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(NATIVE_COLUMN_NAMES, \"NATIVE_COLUMN_NAMES\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(extractRecordAnnotations, \"extractRecordAnnotations\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(formatAnnotationLabel, \"formatAnnotationLabel\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(extractAnnotationLabels, \"extractAnnotationLabels\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");reactHotLoader.register(getAnnotationData, \"getAnnotationData\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["AnnotationOpacity","AnnotationType","evalExpression","isRecordAnnotationResult","isTableAnnotationLayer","isTimeseriesAnnotationResult","evalFormula","formula","data","xAxis","xAxisType","value","expression","map","row","Date","getTime","parseAnnotationOpacity","opacity","Low","Medium","High","NATIVE_COLUMN_NAMES","descriptionColumns","intervalEndColumn","timeColumn","titleColumn","extractRecordAnnotations","annotationLayer","annotationData","name","result","records","descriptions","record","column","intervalEnd","time","title","Error","formatAnnotationLabel","labels","titleLabels","filteredDescriptions","filter","description","push","length","join","extractAnnotationLabels","layers","formulaAnnotationLabels","anno","annotationType","Formula","show","timeseriesAnnotationLabels","Timeseries","flatMap","annoSeries","key","concat","getAnnotationData","chartProps","queriesData","annotation_data"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/annotation.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isEmpty } from 'lodash';\n\nimport {\n  Annotation,\n  AnnotationData,\n  AnnotationLayer,\n  AnnotationOpacity,\n  AnnotationType,\n  DataRecord,\n  evalExpression,\n  FormulaAnnotationLayer,\n  isRecordAnnotationResult,\n  isTableAnnotationLayer,\n  isTimeseriesAnnotationResult,\n  AxisType,\n} from '@superset-ui/core';\nimport { EchartsTimeseriesChartProps } from '../types';\nimport { EchartsMixedTimeseriesProps } from '../MixedTimeseries/types';\n\nexport function evalFormula(\n  formula: FormulaAnnotationLayer,\n  data: DataRecord[],\n  xAxis: string,\n  xAxisType: AxisType,\n): [any, number][] {\n  const { value: expression } = formula;\n\n  return data.map(row => {\n    let value = row[xAxis];\n    if (xAxisType === 'time') {\n      value = new Date(value as string).getTime();\n    }\n    return [value, evalExpression(expression, (value || 0) as number)];\n  });\n}\n\nexport function parseAnnotationOpacity(opacity?: AnnotationOpacity): number {\n  switch (opacity) {\n    case AnnotationOpacity.Low:\n      return 0.2;\n    case AnnotationOpacity.Medium:\n      return 0.5;\n    case AnnotationOpacity.High:\n      return 0.8;\n    default:\n      return 1;\n  }\n}\n\nconst NATIVE_COLUMN_NAMES = {\n  descriptionColumns: ['long_descr'],\n  intervalEndColumn: 'end_dttm',\n  timeColumn: 'start_dttm',\n  titleColumn: 'short_descr',\n};\n\nexport function extractRecordAnnotations(\n  annotationLayer: AnnotationLayer,\n  annotationData: AnnotationData,\n): Annotation[] {\n  const { name } = annotationLayer;\n  const result = annotationData[name];\n  if (isRecordAnnotationResult(result)) {\n    const { records } = result;\n    const {\n      descriptionColumns = [],\n      intervalEndColumn = '',\n      timeColumn = '',\n      titleColumn = '',\n    } = isTableAnnotationLayer(annotationLayer)\n      ? annotationLayer\n      : NATIVE_COLUMN_NAMES;\n\n    return records.map(record => ({\n      descriptions: descriptionColumns.map(\n        column => (record[column] || '') as string,\n      ) as string[],\n      intervalEnd: (record[intervalEndColumn] || '') as string,\n      time: (record[timeColumn] || '') as string,\n      title: (record[titleColumn] || '') as string,\n    }));\n  }\n  throw new Error('Please rerun the query.');\n}\n\nexport function formatAnnotationLabel(\n  name?: string,\n  title?: string,\n  descriptions: string[] = [],\n): string {\n  const labels: string[] = [];\n  const titleLabels: string[] = [];\n  const filteredDescriptions = descriptions.filter(\n    description => !!description,\n  );\n  if (name) titleLabels.push(name);\n  if (title) titleLabels.push(title);\n  if (titleLabels.length > 0) labels.push(titleLabels.join(' - '));\n  if (filteredDescriptions.length > 0)\n    labels.push(filteredDescriptions.join('\\n'));\n  return labels.join('\\n\\n');\n}\n\nexport function extractAnnotationLabels(\n  layers: AnnotationLayer[],\n  data: AnnotationData,\n): string[] {\n  const formulaAnnotationLabels = layers\n    .filter(anno => anno.annotationType === AnnotationType.Formula && anno.show)\n    .map(anno => anno.name);\n  const timeseriesAnnotationLabels = layers\n    .filter(\n      anno => anno.annotationType === AnnotationType.Timeseries && anno.show,\n    )\n    .flatMap(anno => {\n      const result = data[anno.name];\n      return isTimeseriesAnnotationResult(result)\n        ? result.map(annoSeries => annoSeries.key)\n        : [];\n    });\n\n  return formulaAnnotationLabels.concat(timeseriesAnnotationLabels);\n}\n\nexport function getAnnotationData(\n  chartProps: EchartsTimeseriesChartProps | EchartsMixedTimeseriesProps,\n): AnnotationData {\n  const data = chartProps?.queriesData[0]?.annotation_data as AnnotationData;\n  if (!isEmpty(data)) {\n    return data;\n  }\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}