{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\nimport { useSchemas } from './schemas';\nconst tableApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    tables: builder.query({\n      providesTags: ['Tables'],\n      query: (_ref) => {let { dbId, schema, forceRefresh } = _ref;return {\n          endpoint: `/api/v1/database/${dbId != null ? dbId : 'undefined'}/tables/`,\n          // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n          urlParams: {\n            force: forceRefresh,\n            schema_name: schema ? encodeURIComponent(schema) : '' },\n\n          transformResponse: (_ref2) => {let { json } = _ref2;return {\n              options: json.result,\n              hasMore: json.count > json.result.length };} };},\n\n\n      serializeQueryArgs: (_ref3) => {let { queryArgs: { dbId, schema } } = _ref3;return {\n          dbId,\n          schema };} }),\n\n\n    tableMetadata: builder.query({\n      query: (_ref4) => {let { dbId, schema, table } = _ref4;return {\n          endpoint: `/api/v1/database/${dbId}/table/${encodeURIComponent(table)}/${encodeURIComponent(schema)}/`,\n          transformResponse: (_ref5) => {let { json } = _ref5;return json;} };} }),\n\n\n    tableExtendedMetadata: builder.query({\n      query: (_ref6) => {let { dbId, schema, table } = _ref6;return {\n          endpoint: `/api/v1/database/${dbId}/table_extra/${encodeURIComponent(table)}/${encodeURIComponent(schema)}/`,\n          transformResponse: (_ref7) => {let { json } = _ref7;return json;} };} }) }) });\n\n\n\n\nexport const { useLazyTablesQuery, useTablesQuery, useTableMetadataQuery, useTableExtendedMetadataQuery, endpoints: tableEndpoints, util: tableApiUtil } = tableApi;\nexport function useTables(options) {\n  const isMountedRef = useRef(false);\n  const { data: schemaOptions, isFetching } = useSchemas({\n    dbId: options.dbId });\n\n  const schemaOptionsMap = useMemo(() => new Set(schemaOptions == null ? void 0 : schemaOptions.map((_ref8) => {let { value } = _ref8;return value;})), [schemaOptions]);\n  const { dbId, schema, onSuccess, onError } = options || {};\n  const enabled = Boolean(dbId && schema && !isFetching && schemaOptionsMap.has(schema));\n  const result = useTablesQuery({ dbId, schema, forceRefresh: false }, {\n    skip: !enabled });\n\n  const [trigger] = useLazyTablesQuery();\n  const handleOnSuccess = useEffectEvent((data, isRefetched) => {\n    onSuccess == null ? void 0 : onSuccess(data, isRefetched);\n  });\n  const handleOnError = useEffectEvent((error) => {\n    onError == null ? void 0 : onError(error);\n  });\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, schema, forceRefresh: true }).then((_ref9) => {let { isSuccess, isError, data, error } = _ref9;\n        if (isSuccess && data) {\n          handleOnSuccess(data, true);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      });\n    }\n  }, [dbId, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, data, error, originalArgs } = result;\n      if (!(originalArgs != null && originalArgs.forceRefresh) && requestId && !isFetching) {\n        if (isSuccess && data) {\n          handleOnSuccess(data, false);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      }\n    } else\n    {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n  return {\n    ...result,\n    refetch };\n\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useEffect","useRef","useEffectEvent","api","useSchemas","tableApi","injectEndpoints","endpoints","tables","builder","query","providesTags","dbId","schema","forceRefresh","endpoint","urlParams","force","schema_name","encodeURIComponent","transformResponse","json","options","result","hasMore","count","length","serializeQueryArgs","queryArgs","tableMetadata","table","tableExtendedMetadata","useLazyTablesQuery","useTablesQuery","useTableMetadataQuery","useTableExtendedMetadataQuery","tableEndpoints","util","tableApiUtil","useTables","isMountedRef","data","schemaOptions","isFetching","schemaOptionsMap","Set","map","value","onSuccess","onError","enabled","Boolean","has","skip","trigger","handleOnSuccess","isRefetched","handleOnError","error","refetch","then","isSuccess","isError","current","requestId","originalArgs"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/src/hooks/apiResources/tables.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api, JsonResponse } from './queryApi';\n\nimport { useSchemas } from './schemas';\n\nexport interface Table {\n  label: string;\n  value: string;\n  type: string;\n  extra?: {\n    certification?: {\n      certified_by: string;\n      details: string;\n    };\n    warning_markdown?: string;\n  };\n}\n\ntype QueryResponse = {\n  json: {\n    count: number;\n    result: Table[];\n  };\n  response: Response;\n};\n\nexport type Data = {\n  options: Table[];\n  hasMore: boolean;\n};\n\nexport type FetchTablesQueryParams = {\n  dbId?: string | number;\n  schema?: string;\n  forceRefresh?: boolean;\n  onSuccess?: (data: Data, isRefetched: boolean) => void;\n  onError?: (error: Response) => void;\n};\n\nexport type FetchTableMetadataQueryParams = {\n  dbId: string | number;\n  schema: string;\n  table: string;\n};\n\ntype ColumnKeyTypeType = 'pk' | 'fk' | 'index';\ninterface Column {\n  name: string;\n  keys?: { type: ColumnKeyTypeType }[];\n  type: string;\n}\n\nexport type TableMetaData = {\n  name: string;\n  partitions?: {\n    partitionQuery: string;\n    latest: object[];\n  };\n  metadata?: Record<string, string>;\n  indexes?: object[];\n  selectStar?: string;\n  view?: string;\n  columns: Column[];\n};\n\ntype TableMetadataReponse = {\n  json: TableMetaData;\n  response: Response;\n};\n\nexport type TableExtendedMetadata = Record<string, string>;\n\ntype Params = Omit<FetchTablesQueryParams, 'forceRefresh'>;\n\nconst tableApi = api.injectEndpoints({\n  endpoints: builder => ({\n    tables: builder.query<Data, FetchTablesQueryParams>({\n      providesTags: ['Tables'],\n      query: ({ dbId, schema, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId ?? 'undefined'}/tables/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          schema_name: schema ? encodeURIComponent(schema) : '',\n        },\n        transformResponse: ({ json }: QueryResponse) => ({\n          options: json.result,\n          hasMore: json.count > json.result.length,\n        }),\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, schema } }) => ({\n        dbId,\n        schema,\n      }),\n    }),\n    tableMetadata: builder.query<TableMetaData, FetchTableMetadataQueryParams>({\n      query: ({ dbId, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table/${encodeURIComponent(\n          table,\n        )}/${encodeURIComponent(schema)}/`,\n        transformResponse: ({ json }: TableMetadataReponse) => json,\n      }),\n    }),\n    tableExtendedMetadata: builder.query<\n      TableExtendedMetadata,\n      FetchTableMetadataQueryParams\n    >({\n      query: ({ dbId, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_extra/${encodeURIComponent(\n          table,\n        )}/${encodeURIComponent(schema)}/`,\n        transformResponse: ({ json }: JsonResponse) => json,\n      }),\n    }),\n  }),\n});\n\nexport const {\n  useLazyTablesQuery,\n  useTablesQuery,\n  useTableMetadataQuery,\n  useTableExtendedMetadataQuery,\n  endpoints: tableEndpoints,\n  util: tableApiUtil,\n} = tableApi;\n\nexport function useTables(options: Params) {\n  const isMountedRef = useRef(false);\n  const { data: schemaOptions, isFetching } = useSchemas({\n    dbId: options.dbId,\n  });\n  const schemaOptionsMap = useMemo(\n    () => new Set(schemaOptions?.map(({ value }) => value)),\n    [schemaOptions],\n  );\n  const { dbId, schema, onSuccess, onError } = options || {};\n\n  const enabled = Boolean(\n    dbId && schema && !isFetching && schemaOptionsMap.has(schema),\n  );\n\n  const result = useTablesQuery(\n    { dbId, schema, forceRefresh: false },\n    {\n      skip: !enabled,\n    },\n  );\n  const [trigger] = useLazyTablesQuery();\n\n  const handleOnSuccess = useEffectEvent((data: Data, isRefetched: boolean) => {\n    onSuccess?.(data, isRefetched);\n  });\n\n  const handleOnError = useEffectEvent((error: Response) => {\n    onError?.(error);\n  });\n\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, schema, forceRefresh: true }).then(\n        ({ isSuccess, isError, data, error }) => {\n          if (isSuccess && data) {\n            handleOnSuccess(data, true);\n          }\n          if (isError) {\n            handleOnError(error as Response);\n          }\n        },\n      );\n    }\n  }, [dbId, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const {\n        requestId,\n        isSuccess,\n        isError,\n        isFetching,\n        data,\n        error,\n        originalArgs,\n      } = result;\n      if (!originalArgs?.forceRefresh && requestId && !isFetching) {\n        if (isSuccess && data) {\n          handleOnSuccess(data, false);\n        }\n        if (isError) {\n          handleOnError(error as Response);\n        }\n      }\n    } else {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n\n  return {\n    ...result,\n    refetch,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}