{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t } from '@superset-ui/core';\nimport { ErrorTypeEnum } from 'src/components/ErrorMessage/types';\nimport COMMON_ERR_MESSAGES from './errorMessages';\nexport function parseErrorJson(responseObject) {\n  let error = { ...responseObject };\n  // Backwards compatibility for old error renderers with the new error object\n  if (error.errors && error.errors.length > 0) {var _error$errors$, _error$errors$$extra;\n    error.error = error.description = error.errors[0].message;\n    error.link = (_error$errors$ = error.errors[0]) == null ? void 0 : (_error$errors$$extra = _error$errors$.extra) == null ? void 0 : _error$errors$$extra.link;\n  }\n  // Marshmallow field validation returns the error message in the format\n  // of { message: { field1: [msg1, msg2], field2: [msg], } }\n  if (!error.error && error.message) {\n    if (typeof error.message === 'object') {var _Object$values$;\n      error.error =\n      ((_Object$values$ = Object.values(error.message)[0]) == null ? void 0 : _Object$values$[0]) ||\n      t('Invalid input');\n    }\n    if (typeof error.message === 'string') {\n      error.error = error.message;\n    }\n  }\n  if (error.stack) {\n    error = {\n      ...error,\n      error: t('Unexpected error: ') + (\n      error.description || t('(no description, click to see stack trace)')),\n      stacktrace: error.stack };\n\n  } else\n  if (error.responseText && error.responseText.indexOf('CSRF') >= 0) {\n    error = {\n      ...error,\n      error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT) };\n\n  }\n  return { ...error, error: error.error }; // explicit ClientErrorObject\n}\n/*\n * Utility to get standardized error text for generic update failures\n */\nexport async function getErrorText(errorObject, source) {\n  const { error, message } = await getClientErrorObject(errorObject);\n  let errorText = t('Sorry, an unknown error occurred.');\n  if (error) {\n    errorText = t('Sorry, there was an error saving this %s: %s', source, error);\n  }\n  if (typeof message === 'string' && message === 'Forbidden') {\n    errorText = t('You do not have permission to edit this %s', source);\n  }\n  return errorText;\n}\nexport function getClientErrorObject(response) {\n  // takes a SupersetClientResponse as input, attempts to read response as Json if possible,\n  // and returns a Promise that resolves to a plain object with error key and text value.\n  return new Promise((resolve) => {\n    if (typeof response === 'string') {\n      resolve({ error: response });\n      return;\n    }\n    if (response instanceof TypeError &&\n    response.message === 'Failed to fetch') {\n      resolve({\n        error: t('Network error') });\n\n      return;\n    }\n    if ('timeout' in response &&\n    'statusText' in response &&\n    response.statusText === 'timeout') {\n      resolve({\n        ...response,\n        error: t('Request timed out'),\n        errors: [\n        {\n          error_type: ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR,\n          extra: {\n            timeout: response.timeout / 1000,\n            issue_codes: [\n            {\n              code: 1000,\n              message: t('Issue 1000 - The dataset is too large to query.') },\n\n            {\n              code: 1001,\n              message: t('Issue 1001 - The database is under an unusual load.') }] },\n\n\n\n          level: 'error',\n          message: 'Request timed out' }] });\n\n\n\n      return;\n    }\n    const responseObject = response instanceof Response ? response : response.response;\n    if (responseObject && !responseObject.bodyUsed) {\n      // attempt to read the body as json, and fallback to text. we must clone the\n      // response in order to fallback to .text() because Response is single-read\n      responseObject.\n      clone().\n      json().\n      then((errorJson) => {\n        const error = { ...responseObject, ...errorJson };\n        resolve(parseErrorJson(error));\n      }).\n      catch(() => {\n        // fall back to reading as text\n        responseObject.text().then((errorText) => {\n          resolve({ ...responseObject, error: errorText });\n        });\n      });\n      return;\n    }\n    // fall back to Response.statusText or generic error of we cannot read the response\n    let error = response.statusText || response.message;\n    if (!error) {\n      // eslint-disable-next-line no-console\n      console.error('non-standard error:', response);\n      error = t('An error occurred');\n    }\n    resolve({\n      ...responseObject,\n      error });\n\n  });\n}\nexport function getClientErrorMessage(message, clientError) {\n  let finalMessage = message;\n  const errorMessage = (clientError == null ? void 0 : clientError.message) || (clientError == null ? void 0 : clientError.error);\n  if (errorMessage) {\n    finalMessage = `${finalMessage}:\\n${errorMessage}`;\n  }\n  return finalMessage;\n}","map":{"version":3,"mappings":"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","names":["t","ErrorTypeEnum","COMMON_ERR_MESSAGES","parseErrorJson","responseObject","error","errors","length","description","message","link","extra","values","stack","stacktrace","responseText","indexOf","SESSION_TIMED_OUT","getErrorText","errorObject","source","getClientErrorObject","errorText","response","Promise","resolve","TypeError","statusText","error_type","FRONTEND_TIMEOUT_ERROR","timeout","issue_codes","code","level","Response","bodyUsed","clone","json","then","errorJson","catch","text","console","getClientErrorMessage","clientError","finalMessage","errorMessage"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/utils/getClientErrorObject.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { JsonObject, SupersetClientResponse, t } from '@superset-ui/core';\nimport {\n  SupersetError,\n  ErrorTypeEnum,\n} from 'src/components/ErrorMessage/types';\nimport COMMON_ERR_MESSAGES from './errorMessages';\n\n// The response always contains an error attribute, can contain anything from the\n// SupersetClientResponse object, and can contain a spread JSON blob\nexport type ClientErrorObject = {\n  error: string;\n  errors?: SupersetError[];\n  link?: string;\n  message?: string;\n  severity?: string;\n  stacktrace?: string;\n  statusText?: string;\n} & Partial<SupersetClientResponse>;\n\n// see rejectAfterTimeout.ts\ninterface TimeoutError {\n  statusText: 'timeout';\n  timeout: number;\n}\n\ntype ErrorType =\n  | SupersetClientResponse\n  | TimeoutError\n  | { response: Response }\n  | string;\n\ntype ErrorTextSource = 'dashboard' | 'chart' | 'query' | 'dataset' | 'database';\n\nexport function parseErrorJson(responseObject: JsonObject): ClientErrorObject {\n  let error = { ...responseObject };\n  // Backwards compatibility for old error renderers with the new error object\n  if (error.errors && error.errors.length > 0) {\n    error.error = error.description = error.errors[0].message;\n    error.link = error.errors[0]?.extra?.link;\n  }\n  // Marshmallow field validation returns the error message in the format\n  // of { message: { field1: [msg1, msg2], field2: [msg], } }\n  if (!error.error && error.message) {\n    if (typeof error.message === 'object') {\n      error.error =\n        Object.values(error.message as Record<string, string[]>)[0]?.[0] ||\n        t('Invalid input');\n    }\n    if (typeof error.message === 'string') {\n      error.error = error.message;\n    }\n  }\n  if (error.stack) {\n    error = {\n      ...error,\n      error:\n        t('Unexpected error: ') +\n        (error.description || t('(no description, click to see stack trace)')),\n      stacktrace: error.stack,\n    };\n  } else if (error.responseText && error.responseText.indexOf('CSRF') >= 0) {\n    error = {\n      ...error,\n      error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT),\n    };\n  }\n\n  return { ...error, error: error.error }; // explicit ClientErrorObject\n}\n\n/*\n * Utility to get standardized error text for generic update failures\n */\nexport async function getErrorText(\n  errorObject: ErrorType,\n  source: ErrorTextSource,\n) {\n  const { error, message } = await getClientErrorObject(errorObject);\n  let errorText = t('Sorry, an unknown error occurred.');\n\n  if (error) {\n    errorText = t(\n      'Sorry, there was an error saving this %s: %s',\n      source,\n      error,\n    );\n  }\n  if (typeof message === 'string' && message === 'Forbidden') {\n    errorText = t('You do not have permission to edit this %s', source);\n  }\n  return errorText;\n}\n\nexport function getClientErrorObject(\n  response:\n    | SupersetClientResponse\n    | TimeoutError\n    | { response: Response }\n    | string,\n): Promise<ClientErrorObject> {\n  // takes a SupersetClientResponse as input, attempts to read response as Json if possible,\n  // and returns a Promise that resolves to a plain object with error key and text value.\n  return new Promise(resolve => {\n    if (typeof response === 'string') {\n      resolve({ error: response });\n      return;\n    }\n\n    if (\n      response instanceof TypeError &&\n      response.message === 'Failed to fetch'\n    ) {\n      resolve({\n        error: t('Network error'),\n      });\n      return;\n    }\n\n    if (\n      'timeout' in response &&\n      'statusText' in response &&\n      response.statusText === 'timeout'\n    ) {\n      resolve({\n        ...response,\n        error: t('Request timed out'),\n        errors: [\n          {\n            error_type: ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR,\n            extra: {\n              timeout: response.timeout / 1000,\n              issue_codes: [\n                {\n                  code: 1000,\n                  message: t('Issue 1000 - The dataset is too large to query.'),\n                },\n                {\n                  code: 1001,\n                  message: t(\n                    'Issue 1001 - The database is under an unusual load.',\n                  ),\n                },\n              ],\n            },\n            level: 'error',\n            message: 'Request timed out',\n          },\n        ],\n      });\n      return;\n    }\n\n    const responseObject =\n      response instanceof Response ? response : response.response;\n    if (responseObject && !responseObject.bodyUsed) {\n      // attempt to read the body as json, and fallback to text. we must clone the\n      // response in order to fallback to .text() because Response is single-read\n      responseObject\n        .clone()\n        .json()\n        .then(errorJson => {\n          const error = { ...responseObject, ...errorJson };\n          resolve(parseErrorJson(error));\n        })\n        .catch(() => {\n          // fall back to reading as text\n          responseObject.text().then((errorText: any) => {\n            resolve({ ...responseObject, error: errorText });\n          });\n        });\n      return;\n    }\n\n    // fall back to Response.statusText or generic error of we cannot read the response\n    let error = (response as any).statusText || (response as any).message;\n    if (!error) {\n      // eslint-disable-next-line no-console\n      console.error('non-standard error:', response);\n      error = t('An error occurred');\n    }\n    resolve({\n      ...responseObject,\n      error,\n    });\n  });\n}\n\nexport function getClientErrorMessage(\n  message: string,\n  clientError?: ClientErrorObject,\n) {\n  let finalMessage = message;\n  const errorMessage = clientError?.message || clientError?.error;\n  if (errorMessage) {\n    finalMessage = `${finalMessage}:\\n${errorMessage}`;\n  }\n  return finalMessage;\n}\n"]},"metadata":{},"sourceType":"module"}