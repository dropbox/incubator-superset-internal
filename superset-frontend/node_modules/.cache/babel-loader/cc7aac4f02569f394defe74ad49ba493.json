{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { addAlpha } from '@superset-ui/core';\nimport { COMPARATOR, MULTIPLE_VALUE_COMPARATORS } from '../types';\nexport const round = function (num, precision) {if (precision === void 0) {precision = 0;}return Number(`${Math.round(Number(`${num}e+${precision}`))}e-${precision}`);};\nconst MIN_OPACITY_BOUNDED = 0.05;\nconst MIN_OPACITY_UNBOUNDED = 0;\nconst MAX_OPACITY = 1;\nexport const getOpacity = function (value, cutoffPoint, extremeValue, minOpacity, maxOpacity) {if (minOpacity === void 0) {minOpacity = MIN_OPACITY_BOUNDED;}if (maxOpacity === void 0) {maxOpacity = MAX_OPACITY;}\n  if (extremeValue === cutoffPoint) {\n    return maxOpacity;\n  }\n  return Math.min(maxOpacity, round(Math.abs((maxOpacity - minOpacity) / (extremeValue - cutoffPoint) * (\n  value - cutoffPoint)) + minOpacity, 2));\n};\nexport const getColorFunction = (_ref, columnValues, alpha) => {let { operator, targetValue, targetValueLeft, targetValueRight, colorScheme } = _ref;\n  let minOpacity = MIN_OPACITY_BOUNDED;\n  const maxOpacity = MAX_OPACITY;\n  let comparatorFunction;\n  if (operator === undefined || colorScheme === undefined) {\n    return () => undefined;\n  }\n  if (_includesInstanceProperty(MULTIPLE_VALUE_COMPARATORS).call(MULTIPLE_VALUE_COMPARATORS, operator) && (\n  targetValueLeft === undefined || targetValueRight === undefined)) {\n    return () => undefined;\n  }\n  if (operator !== COMPARATOR.NONE &&\n  !_includesInstanceProperty(MULTIPLE_VALUE_COMPARATORS).call(MULTIPLE_VALUE_COMPARATORS, operator) &&\n  targetValue === undefined) {\n    return () => undefined;\n  }\n  switch (operator) {\n    case COMPARATOR.NONE:\n      minOpacity = MIN_OPACITY_UNBOUNDED;\n      comparatorFunction = (value, allValues) => {\n        const cutoffValue = Math.min(...allValues);\n        const extremeValue = Math.max(...allValues);\n        return value >= cutoffValue && value <= extremeValue ?\n        { cutoffValue, extremeValue } :\n        false;\n      };\n      break;\n    case COMPARATOR.GREATER_THAN:\n      comparatorFunction = (value, allValues) => value > targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case COMPARATOR.LESS_THAN:\n      comparatorFunction = (value, allValues) => value < targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case COMPARATOR.GREATER_OR_EQUAL:\n      comparatorFunction = (value, allValues) => value >= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case COMPARATOR.LESS_OR_EQUAL:\n      comparatorFunction = (value, allValues) => value <= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case COMPARATOR.EQUAL:\n      comparatorFunction = (value) => value === targetValue ?\n      { cutoffValue: targetValue, extremeValue: targetValue } :\n      false;\n      break;\n    case COMPARATOR.NOT_EQUAL:\n      comparatorFunction = (value, allValues) => {\n        if (value === targetValue) {\n          return false;\n        }\n        const max = Math.max(...allValues);\n        const min = Math.min(...allValues);\n        return {\n          cutoffValue: targetValue,\n          extremeValue: Math.abs(targetValue - min) > Math.abs(max - targetValue) ?\n          min :\n          max };\n\n      };\n      break;\n    case COMPARATOR.BETWEEN:\n      comparatorFunction = (value) => value > targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case COMPARATOR.BETWEEN_OR_EQUAL:\n      comparatorFunction = (value) => value >= targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case COMPARATOR.BETWEEN_OR_LEFT_EQUAL:\n      comparatorFunction = (value) => value >= targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case COMPARATOR.BETWEEN_OR_RIGHT_EQUAL:\n      comparatorFunction = (value) => value > targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    default:\n      comparatorFunction = () => false;\n      break;}\n\n  return (value) => {\n    const compareResult = comparatorFunction(value, columnValues);\n    if (compareResult === false)\n    return undefined;\n    const { cutoffValue, extremeValue } = compareResult;\n    if (alpha === undefined || alpha) {\n      return addAlpha(colorScheme, getOpacity(value, cutoffValue, extremeValue, minOpacity, maxOpacity));\n    }\n    return colorScheme;\n  };\n};\nexport const getColorFormatters = memoizeOne((columnConfig, data, alpha) => {var _columnConfig$reduce;return (_columnConfig$reduce = columnConfig == null ? void 0 : columnConfig.reduce((acc, config) => {\n    if ((config == null ? void 0 : config.column) !== undefined && (\n    (config == null ? void 0 : config.operator) === COMPARATOR.NONE ||\n    (config == null ? void 0 : config.operator) !== undefined && (\n    _includesInstanceProperty(MULTIPLE_VALUE_COMPARATORS).call(MULTIPLE_VALUE_COMPARATORS, config == null ? void 0 : config.operator) ?\n    (config == null ? void 0 : config.targetValueLeft) !== undefined &&\n    (config == null ? void 0 : config.targetValueRight) !== undefined :\n    (config == null ? void 0 : config.targetValue) !== undefined))) {\n      acc.push({\n        column: config == null ? void 0 : config.column,\n        getColorFromValue: getColorFunction(config, data.map((row) => row[config.column]), alpha) });\n\n    }\n    return acc;\n  }, [])) != null ? _columnConfig$reduce : [];});;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(round, \"round\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MIN_OPACITY_BOUNDED, \"MIN_OPACITY_BOUNDED\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MIN_OPACITY_UNBOUNDED, \"MIN_OPACITY_UNBOUNDED\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(MAX_OPACITY, \"MAX_OPACITY\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getOpacity, \"getOpacity\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getColorFunction, \"getColorFunction\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");reactHotLoader.register(getColorFormatters, \"getColorFormatters\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["memoizeOne","addAlpha","COMPARATOR","MULTIPLE_VALUE_COMPARATORS","round","num","precision","Number","Math","MIN_OPACITY_BOUNDED","MIN_OPACITY_UNBOUNDED","MAX_OPACITY","getOpacity","value","cutoffPoint","extremeValue","minOpacity","maxOpacity","min","abs","getColorFunction","columnValues","alpha","operator","targetValue","targetValueLeft","targetValueRight","colorScheme","comparatorFunction","undefined","NONE","allValues","cutoffValue","max","GREATER_THAN","LESS_THAN","GREATER_OR_EQUAL","LESS_OR_EQUAL","EQUAL","NOT_EQUAL","BETWEEN","BETWEEN_OR_EQUAL","BETWEEN_OR_LEFT_EQUAL","BETWEEN_OR_RIGHT_EQUAL","compareResult","getColorFormatters","columnConfig","data","reduce","acc","config","column","push","getColorFromValue","map","row"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-chart-controls/src/utils/getColorFormatters.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { addAlpha, DataRecord } from '@superset-ui/core';\nimport {\n  ColorFormatters,\n  COMPARATOR,\n  ConditionalFormattingConfig,\n  MULTIPLE_VALUE_COMPARATORS,\n} from '../types';\n\nexport const round = (num: number, precision = 0) =>\n  Number(`${Math.round(Number(`${num}e+${precision}`))}e-${precision}`);\n\nconst MIN_OPACITY_BOUNDED = 0.05;\nconst MIN_OPACITY_UNBOUNDED = 0;\nconst MAX_OPACITY = 1;\nexport const getOpacity = (\n  value: number,\n  cutoffPoint: number,\n  extremeValue: number,\n  minOpacity = MIN_OPACITY_BOUNDED,\n  maxOpacity = MAX_OPACITY,\n) => {\n  if (extremeValue === cutoffPoint) {\n    return maxOpacity;\n  }\n  return Math.min(\n    maxOpacity,\n    round(\n      Math.abs(\n        ((maxOpacity - minOpacity) / (extremeValue - cutoffPoint)) *\n          (value - cutoffPoint),\n      ) + minOpacity,\n      2,\n    ),\n  );\n};\n\nexport const getColorFunction = (\n  {\n    operator,\n    targetValue,\n    targetValueLeft,\n    targetValueRight,\n    colorScheme,\n  }: ConditionalFormattingConfig,\n  columnValues: number[],\n  alpha?: boolean,\n) => {\n  let minOpacity = MIN_OPACITY_BOUNDED;\n  const maxOpacity = MAX_OPACITY;\n\n  let comparatorFunction: (\n    value: number,\n    allValues: number[],\n  ) => false | { cutoffValue: number; extremeValue: number };\n  if (operator === undefined || colorScheme === undefined) {\n    return () => undefined;\n  }\n  if (\n    MULTIPLE_VALUE_COMPARATORS.includes(operator) &&\n    (targetValueLeft === undefined || targetValueRight === undefined)\n  ) {\n    return () => undefined;\n  }\n  if (\n    operator !== COMPARATOR.NONE &&\n    !MULTIPLE_VALUE_COMPARATORS.includes(operator) &&\n    targetValue === undefined\n  ) {\n    return () => undefined;\n  }\n  switch (operator) {\n    case COMPARATOR.NONE:\n      minOpacity = MIN_OPACITY_UNBOUNDED;\n      comparatorFunction = (value: number, allValues: number[]) => {\n        const cutoffValue = Math.min(...allValues);\n        const extremeValue = Math.max(...allValues);\n        return value >= cutoffValue && value <= extremeValue\n          ? { cutoffValue, extremeValue }\n          : false;\n      };\n      break;\n    case COMPARATOR.GREATER_THAN:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value > targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.max(...allValues) }\n          : false;\n      break;\n    case COMPARATOR.LESS_THAN:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value < targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.min(...allValues) }\n          : false;\n      break;\n    case COMPARATOR.GREATER_OR_EQUAL:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value >= targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.max(...allValues) }\n          : false;\n      break;\n    case COMPARATOR.LESS_OR_EQUAL:\n      comparatorFunction = (value: number, allValues: number[]) =>\n        value <= targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: Math.min(...allValues) }\n          : false;\n      break;\n    case COMPARATOR.EQUAL:\n      comparatorFunction = (value: number) =>\n        value === targetValue!\n          ? { cutoffValue: targetValue!, extremeValue: targetValue! }\n          : false;\n      break;\n    case COMPARATOR.NOT_EQUAL:\n      comparatorFunction = (value: number, allValues: number[]) => {\n        if (value === targetValue!) {\n          return false;\n        }\n        const max = Math.max(...allValues);\n        const min = Math.min(...allValues);\n        return {\n          cutoffValue: targetValue!,\n          extremeValue:\n            Math.abs(targetValue! - min) > Math.abs(max - targetValue!)\n              ? min\n              : max,\n        };\n      };\n      break;\n    case COMPARATOR.BETWEEN:\n      comparatorFunction = (value: number) =>\n        value > targetValueLeft! && value < targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case COMPARATOR.BETWEEN_OR_EQUAL:\n      comparatorFunction = (value: number) =>\n        value >= targetValueLeft! && value <= targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case COMPARATOR.BETWEEN_OR_LEFT_EQUAL:\n      comparatorFunction = (value: number) =>\n        value >= targetValueLeft! && value < targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    case COMPARATOR.BETWEEN_OR_RIGHT_EQUAL:\n      comparatorFunction = (value: number) =>\n        value > targetValueLeft! && value <= targetValueRight!\n          ? { cutoffValue: targetValueLeft!, extremeValue: targetValueRight! }\n          : false;\n      break;\n    default:\n      comparatorFunction = () => false;\n      break;\n  }\n\n  return (value: number) => {\n    const compareResult = comparatorFunction(value, columnValues);\n    if (compareResult === false) return undefined;\n    const { cutoffValue, extremeValue } = compareResult;\n    if (alpha === undefined || alpha) {\n      return addAlpha(\n        colorScheme,\n        getOpacity(value, cutoffValue, extremeValue, minOpacity, maxOpacity),\n      );\n    }\n    return colorScheme;\n  };\n};\n\nexport const getColorFormatters = memoizeOne(\n  (\n    columnConfig: ConditionalFormattingConfig[] | undefined,\n    data: DataRecord[],\n    alpha?: boolean,\n  ) =>\n    columnConfig?.reduce(\n      (acc: ColorFormatters, config: ConditionalFormattingConfig) => {\n        if (\n          config?.column !== undefined &&\n          (config?.operator === COMPARATOR.NONE ||\n            (config?.operator !== undefined &&\n              (MULTIPLE_VALUE_COMPARATORS.includes(config?.operator)\n                ? config?.targetValueLeft !== undefined &&\n                  config?.targetValueRight !== undefined\n                : config?.targetValue !== undefined)))\n        ) {\n          acc.push({\n            column: config?.column,\n            getColorFromValue: getColorFunction(\n              config,\n              data.map(row => row[config.column!] as number),\n              alpha,\n            ),\n          });\n        }\n        return acc;\n      },\n      [],\n    ) ?? [],\n);\n"]},"metadata":{},"sourceType":"module"}