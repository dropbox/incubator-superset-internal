{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope(_ref) {let { tabs = [], tabsInScope = [] } = _ref;\n  const chartsNotInScope = [];\n  tabs.forEach((_ref2) => {let { value: tab, children: tabChildren } = _ref2;\n    if (tabChildren && !_includesInstanceProperty(tabsInScope).call(tabsInScope, tab)) {\n      tabChildren.forEach((_ref3) => {let { value: subTab, children: subTabChildren } = _ref3;\n        if (subTabChildren && !_includesInstanceProperty(tabsInScope).call(tabsInScope, subTab)) {\n          chartsNotInScope.push(\n          ...subTabChildren.filter((_ref4) => {let { type } = _ref4;return type === CHART_TYPE;}));\n\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map((_ref5) => {let { value } = _ref5;return value;});\n}\nfunction getTabChildrenScope(_ref6)\n\n\n\n\n\n\n{let { tabScopes, parentNodeValue, forceAggregate = false, hasChartSiblings = false, tabChildren = [], immuneChartSiblings = [] } = _ref6;\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n  (_ref7) => {let [key, { scope }] = _ref7;return scope && scope.length && key === scope[0];}))\n\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope =\n    getImmuneChartIdsFromTabsNotInScope({\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, (_ref8) => {let { scope } = _ref8;return scope;}) });\n\n    const immuneChartIdsFromTabsInScope = _flatMap(\n    Object.values(tabScopes),\n    (_ref9) => {let { immune } = _ref9;return immune;});\n\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope])];\n\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts };\n\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n  (_ref10) => {let { scope } = _ref10;return scope && scope.length;});\n\n  return {\n    scope: _flatMap(componentsInScope, (_ref11) => {let { scope } = _ref11;return scope;}),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, (_ref12) => {let { immune } = _ref12;return immune;}) :\n    _flatMap(Object.values(tabScopes), (_ref13) => {let { immune } = _ref13;return immune;}).concat(\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse(_ref14) {let { currentNode = {}, filterId, checkedChartIds = [] } = _ref14;\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter((_ref15) => {let { type } = _ref15;return type === CHART_TYPE;});\n  const tabChildren = children.filter((_ref16) => {let { type } = _ref16;return type === TAB_TYPE;});\n\n  const chartsImmune = chartChildren.\n  filter(\n  (_ref17) => {let { value } = _ref17;return filterId !== value && !_includesInstanceProperty(checkedChartIds).call(checkedChartIds, value);}).\n\n  map((_ref18) => {let { value } = _ref18;return value;});\n  const tabScopes = _flow(\n  _keyBy((child) => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some((_ref19) => {let { value } = _ref19;return _includesInstanceProperty(checkedChartIds).call(checkedChartIds, value);}))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren });\n\n    return {\n      scope,\n      immune: chartsImmune.concat(immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree(_ref20)\n\n\n\n{let { filterKey, nodes = [], checkedChartIds = [] } = _ref20;\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n}","map":{"version":3,"names":["CHART_TYPE","TAB_TYPE","getChartIdAndColumnFromFilterKey","getImmuneChartIdsFromTabsNotInScope","tabs","tabsInScope","chartsNotInScope","forEach","value","tab","children","tabChildren","subTab","subTabChildren","push","filter","type","map","getTabChildrenScope","tabScopes","parentNodeValue","forceAggregate","hasChartSiblings","immuneChartSiblings","Object","entries","every","key","scope","length","immuneChartIdsFromTabsNotInScope","immuneChartIdsFromTabsInScope","values","immune","immuneCharts","Set","componentsInScope","concat","traverse","currentNode","filterId","checkedChartIds","currentValue","chartChildren","chartsImmune","child","some","getFilterScopeFromNodesTree","filterKey","nodes","chartId"],"sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE),\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope =\n      getImmuneChartIdsFromTabsNotInScope({\n        tabs: tabChildren,\n        tabsInScope: flatMap(tabScopes, ({ scope }) => scope),\n      });\n    const immuneChartIdsFromTabsInScope = flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune,\n    );\n    const immuneCharts = [\n      ...new Set([\n        ...immuneChartIdsFromTabsNotInScope,\n        ...immuneChartIdsFromTabsInScope,\n      ]),\n    ];\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts,\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}