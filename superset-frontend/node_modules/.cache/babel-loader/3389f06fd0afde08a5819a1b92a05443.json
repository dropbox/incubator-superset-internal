{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport callApiAndParseWithTimeout from './callApi/callApiAndParseWithTimeout';\nimport { DEFAULT_FETCH_RETRY_OPTIONS, DEFAULT_BASE_URL } from './constants';\nconst defaultUnauthorizedHandler = () => {\n  if (!window.location.pathname.startsWith('/login')) {\n    window.location.href = `/login?next=${window.location.href}`;\n  }\n};\nexport default class SupersetClientClass {\n\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor(_temp) {let { baseUrl = DEFAULT_BASE_URL, host, protocol, headers = {}, fetchRetryOptions = {}, mode = 'same-origin', timeout, credentials = undefined, csrfToken = undefined, guestToken = undefined, guestTokenHeaderName = 'X-GuestToken', unauthorizedHandler = defaultUnauthorizedHandler } = _temp === void 0 ? {} : _temp;this.credentials = void 0;this.csrfToken = void 0;this.csrfPromise = void 0;this.guestToken = void 0;this.guestTokenHeaderName = void 0;this.fetchRetryOptions = void 0;this.baseUrl = void 0;this.protocol = void 0;this.host = void 0;this.headers = void 0;this.mode = void 0;this.timeout = void 0;this.handleUnauthorized = void 0;\n    const url = new URL(host || protocol ?\n    `${protocol || 'https:'}//${host || 'localhost'}` :\n    baseUrl,\n    // baseUrl for API could also be relative, so we provide current location.href\n    // as the base of baseUrl\n    window.location.href);\n    this.baseUrl = url.href.replace(/\\/+$/, ''); // always strip trailing slash\n    this.host = url.host;\n    this.protocol = url.protocol;\n    this.headers = { Accept: 'application/json', ...headers }; // defaulting accept to json\n    this.mode = mode;\n    this.timeout = timeout;\n    this.credentials = credentials;\n    this.csrfToken = csrfToken;\n    this.guestToken = guestToken;\n    this.guestTokenHeaderName = guestTokenHeaderName;\n    this.fetchRetryOptions = {\n      ...DEFAULT_FETCH_RETRY_OPTIONS,\n      ...fetchRetryOptions };\n\n    if (typeof this.csrfToken === 'string') {\n      this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n      this.csrfPromise = Promise.resolve(this.csrfToken);\n    }\n    if (guestToken) {\n      this.headers[guestTokenHeaderName] = guestToken;\n    }\n    this.handleUnauthorized = unauthorizedHandler;\n  }\n  async init(force) {if (force === void 0) {force = false;}\n    if (this.isAuthenticated() && !force) {\n      return this.csrfPromise;\n    }\n    return this.getCSRFToken();\n  }\n  async postForm(url, payload, target) {if (target === void 0) {target = '_blank';}\n    if (url) {\n      await this.ensureAuth();\n      const hiddenForm = document.createElement('form');\n      hiddenForm.action = url;\n      hiddenForm.method = 'POST';\n      hiddenForm.target = target;\n      const payloadWithToken = {\n        ...payload,\n        csrf_token: this.csrfToken };\n\n      if (this.guestToken) {\n        payloadWithToken.guest_token = this.guestToken;\n      }\n      Object.entries(payloadWithToken).forEach((_ref) => {let [key, value] = _ref;\n        const data = document.createElement('input');\n        data.type = 'hidden';\n        data.name = key;\n        data.value = value;\n        hiddenForm.appendChild(data);\n      });\n      document.body.appendChild(hiddenForm);\n      hiddenForm.submit();\n      document.body.removeChild(hiddenForm);\n    }\n  }\n  async reAuthenticate() {\n    return this.init(true);\n  }\n  isAuthenticated() {\n    // if CSRF protection is disabled in the Superset app, the token may be an empty string\n    return this.csrfToken !== null && this.csrfToken !== undefined;\n  }\n  getGuestToken() {\n    return this.guestToken;\n  }\n  async get(requestConfig) {\n    return this.request({ ...requestConfig, method: 'GET' });\n  }\n  async delete(requestConfig) {\n    return this.request({ ...requestConfig, method: 'DELETE' });\n  }\n  async put(requestConfig) {\n    return this.request({ ...requestConfig, method: 'PUT' });\n  }\n  async post(requestConfig) {\n    return this.request({ ...requestConfig, method: 'POST' });\n  }\n  async request(_ref2) {let { credentials, mode, endpoint, host, url, headers, timeout, fetchRetryOptions, ignoreUnauthorized = false, ...rest } = _ref2;\n    await this.ensureAuth();\n    return callApiAndParseWithTimeout({\n      ...rest,\n      credentials: credentials != null ? credentials : this.credentials,\n      mode: mode != null ? mode : this.mode,\n      url: this.getUrl({ endpoint, host, url }),\n      headers: { ...this.headers, ...headers },\n      timeout: timeout != null ? timeout : this.timeout,\n      fetchRetryOptions: fetchRetryOptions != null ? fetchRetryOptions : this.fetchRetryOptions }).\n    catch((res) => {\n      if ((res == null ? void 0 : res.status) === 401 && !ignoreUnauthorized) {\n        this.handleUnauthorized();\n      }\n      return Promise.reject(res);\n    });\n  }\n  async ensureAuth() {var _this$csrfPromise;\n    return (_this$csrfPromise = this.csrfPromise) != null ? _this$csrfPromise :\n    // eslint-disable-next-line prefer-promise-reject-errors\n    Promise.reject({\n      error: `SupersetClient has not been provided a CSRF token, ensure it is\n        initialized with \\`client.getCSRFToken()\\` or try logging in at\n        ${this.getUrl({ endpoint: '/login' })}` });\n\n  }\n  async getCSRFToken() {\n    this.csrfToken = undefined;\n    // If we can request this resource successfully, it means that the user has\n    // authenticated. If not we throw an error prompting to authenticate.\n    this.csrfPromise = callApiAndParseWithTimeout({\n      credentials: this.credentials,\n      headers: {\n        ...this.headers },\n\n      method: 'GET',\n      mode: this.mode,\n      timeout: this.timeout,\n      url: this.getUrl({ endpoint: 'api/v1/security/csrf_token/' }),\n      parseMethod: 'json' }).\n    then((_ref3) => {let { json } = _ref3;\n      if (typeof json === 'object') {\n        this.csrfToken = json.result;\n        if (typeof this.csrfToken === 'string') {\n          this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n        }\n      }\n      if (this.isAuthenticated()) {\n        return this.csrfToken;\n      }\n      // eslint-disable-next-line prefer-promise-reject-errors\n      return Promise.reject({ error: 'Failed to fetch CSRF token' });\n    });\n    return this.csrfPromise;\n  }\n  getUrl(_temp2) {let { host: inputHost, endpoint = '', url } = _temp2 === void 0 ? {} : _temp2;\n    if (typeof url === 'string')\n    return url;\n    const host = inputHost != null ? inputHost : this.host;\n    const cleanHost = host.slice(-1) === '/' ? host.slice(0, -1) : host; // no backslash\n    return `${this.protocol}//${cleanHost}/${endpoint[0] === '/' ? endpoint.slice(1) : endpoint}`;\n  }}","map":{"version":3,"mappings":"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","names":["callApiAndParseWithTimeout","DEFAULT_FETCH_RETRY_OPTIONS","DEFAULT_BASE_URL","defaultUnauthorizedHandler","window","location","pathname","startsWith","href","SupersetClientClass","constructor","baseUrl","host","protocol","headers","fetchRetryOptions","mode","timeout","credentials","undefined","csrfToken","guestToken","guestTokenHeaderName","unauthorizedHandler","csrfPromise","handleUnauthorized","url","URL","replace","Accept","Promise","resolve","init","force","isAuthenticated","getCSRFToken","postForm","payload","target","ensureAuth","hiddenForm","document","createElement","action","method","payloadWithToken","csrf_token","guest_token","Object","entries","forEach","key","value","data","type","name","appendChild","body","submit","removeChild","reAuthenticate","getGuestToken","get","requestConfig","request","delete","put","post","endpoint","ignoreUnauthorized","rest","getUrl","catch","status","reject","res","error","parseMethod","then","json","result","inputHost","cleanHost","slice"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/packages/superset-ui-core/src/connection/SupersetClientClass.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport callApiAndParseWithTimeout from './callApi/callApiAndParseWithTimeout';\nimport {\n  ClientConfig,\n  ClientTimeout,\n  Credentials,\n  CsrfPromise,\n  CsrfToken,\n  FetchRetryOptions,\n  Headers,\n  Host,\n  Mode,\n  Protocol,\n  RequestConfig,\n  ParseMethod,\n} from './types';\nimport { DEFAULT_FETCH_RETRY_OPTIONS, DEFAULT_BASE_URL } from './constants';\n\nconst defaultUnauthorizedHandler = () => {\n  if (!window.location.pathname.startsWith('/login')) {\n    window.location.href = `/login?next=${window.location.href}`;\n  }\n};\n\nexport default class SupersetClientClass {\n  credentials: Credentials;\n\n  csrfToken?: CsrfToken;\n\n  csrfPromise?: CsrfPromise;\n\n  guestToken?: string;\n\n  guestTokenHeaderName: string;\n\n  fetchRetryOptions?: FetchRetryOptions;\n\n  baseUrl: string;\n\n  protocol: Protocol;\n\n  host: Host;\n\n  headers: Headers;\n\n  mode: Mode;\n\n  timeout: ClientTimeout;\n\n  handleUnauthorized: () => void;\n\n  constructor({\n    baseUrl = DEFAULT_BASE_URL,\n    host,\n    protocol,\n    headers = {},\n    fetchRetryOptions = {},\n    mode = 'same-origin',\n    timeout,\n    credentials = undefined,\n    csrfToken = undefined,\n    guestToken = undefined,\n    guestTokenHeaderName = 'X-GuestToken',\n    unauthorizedHandler = defaultUnauthorizedHandler,\n  }: ClientConfig = {}) {\n    const url = new URL(\n      host || protocol\n        ? `${protocol || 'https:'}//${host || 'localhost'}`\n        : baseUrl,\n      // baseUrl for API could also be relative, so we provide current location.href\n      // as the base of baseUrl\n      window.location.href,\n    );\n    this.baseUrl = url.href.replace(/\\/+$/, ''); // always strip trailing slash\n    this.host = url.host;\n    this.protocol = url.protocol as Protocol;\n    this.headers = { Accept: 'application/json', ...headers }; // defaulting accept to json\n    this.mode = mode;\n    this.timeout = timeout;\n    this.credentials = credentials;\n    this.csrfToken = csrfToken;\n    this.guestToken = guestToken;\n    this.guestTokenHeaderName = guestTokenHeaderName;\n    this.fetchRetryOptions = {\n      ...DEFAULT_FETCH_RETRY_OPTIONS,\n      ...fetchRetryOptions,\n    };\n    if (typeof this.csrfToken === 'string') {\n      this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n      this.csrfPromise = Promise.resolve(this.csrfToken);\n    }\n    if (guestToken) {\n      this.headers[guestTokenHeaderName] = guestToken;\n    }\n    this.handleUnauthorized = unauthorizedHandler;\n  }\n\n  async init(force = false): CsrfPromise {\n    if (this.isAuthenticated() && !force) {\n      return this.csrfPromise as CsrfPromise;\n    }\n    return this.getCSRFToken();\n  }\n\n  async postForm(url: string, payload: Record<string, any>, target = '_blank') {\n    if (url) {\n      await this.ensureAuth();\n      const hiddenForm = document.createElement('form');\n      hiddenForm.action = url;\n      hiddenForm.method = 'POST';\n      hiddenForm.target = target;\n      const payloadWithToken: Record<string, any> = {\n        ...payload,\n        csrf_token: this.csrfToken!,\n      };\n\n      if (this.guestToken) {\n        payloadWithToken.guest_token = this.guestToken;\n      }\n\n      Object.entries(payloadWithToken).forEach(([key, value]) => {\n        const data = document.createElement('input');\n        data.type = 'hidden';\n        data.name = key;\n        data.value = value;\n        hiddenForm.appendChild(data);\n      });\n\n      document.body.appendChild(hiddenForm);\n      hiddenForm.submit();\n      document.body.removeChild(hiddenForm);\n    }\n  }\n\n  async reAuthenticate() {\n    return this.init(true);\n  }\n\n  isAuthenticated(): boolean {\n    // if CSRF protection is disabled in the Superset app, the token may be an empty string\n    return this.csrfToken !== null && this.csrfToken !== undefined;\n  }\n\n  getGuestToken() {\n    return this.guestToken;\n  }\n\n  async get<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'GET' });\n  }\n\n  async delete<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'DELETE' });\n  }\n\n  async put<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'PUT' });\n  }\n\n  async post<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'POST' });\n  }\n\n  async request<T extends ParseMethod = 'json'>({\n    credentials,\n    mode,\n    endpoint,\n    host,\n    url,\n    headers,\n    timeout,\n    fetchRetryOptions,\n    ignoreUnauthorized = false,\n    ...rest\n  }: RequestConfig & { parseMethod?: T }) {\n    await this.ensureAuth();\n    return callApiAndParseWithTimeout({\n      ...rest,\n      credentials: credentials ?? this.credentials,\n      mode: mode ?? this.mode,\n      url: this.getUrl({ endpoint, host, url }),\n      headers: { ...this.headers, ...headers },\n      timeout: timeout ?? this.timeout,\n      fetchRetryOptions: fetchRetryOptions ?? this.fetchRetryOptions,\n    }).catch(res => {\n      if (res?.status === 401 && !ignoreUnauthorized) {\n        this.handleUnauthorized();\n      }\n      return Promise.reject(res);\n    });\n  }\n\n  async ensureAuth(): CsrfPromise {\n    return (\n      this.csrfPromise ??\n      // eslint-disable-next-line prefer-promise-reject-errors\n      Promise.reject({\n        error: `SupersetClient has not been provided a CSRF token, ensure it is\n        initialized with \\`client.getCSRFToken()\\` or try logging in at\n        ${this.getUrl({ endpoint: '/login' })}`,\n      })\n    );\n  }\n\n  async getCSRFToken() {\n    this.csrfToken = undefined;\n    // If we can request this resource successfully, it means that the user has\n    // authenticated. If not we throw an error prompting to authenticate.\n    this.csrfPromise = callApiAndParseWithTimeout({\n      credentials: this.credentials,\n      headers: {\n        ...this.headers,\n      },\n      method: 'GET',\n      mode: this.mode,\n      timeout: this.timeout,\n      url: this.getUrl({ endpoint: 'api/v1/security/csrf_token/' }),\n      parseMethod: 'json',\n    }).then(({ json }) => {\n      if (typeof json === 'object') {\n        this.csrfToken = json.result as string;\n        if (typeof this.csrfToken === 'string') {\n          this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n        }\n      }\n      if (this.isAuthenticated()) {\n        return this.csrfToken;\n      }\n      // eslint-disable-next-line prefer-promise-reject-errors\n      return Promise.reject({ error: 'Failed to fetch CSRF token' });\n    });\n    return this.csrfPromise;\n  }\n\n  getUrl({\n    host: inputHost,\n    endpoint = '',\n    url,\n  }: {\n    endpoint?: string;\n    host?: Host;\n    url?: string;\n  } = {}) {\n    if (typeof url === 'string') return url;\n\n    const host = inputHost ?? this.host;\n    const cleanHost = host.slice(-1) === '/' ? host.slice(0, -1) : host; // no backslash\n\n    return `${this.protocol}//${cleanHost}/${\n      endpoint[0] === '/' ? endpoint.slice(1) : endpoint\n    }`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}