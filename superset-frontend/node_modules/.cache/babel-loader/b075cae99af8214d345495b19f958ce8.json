{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport mexp from 'math-expression-evaluator';\nconst REPLACE_OPERATORS = [\n[new RegExp(/==/g), 'Eq'],\n[new RegExp(/>=/g), 'Gte'],\n[new RegExp(/<=/g), 'Lte'],\n[new RegExp(/>/g), 'Gt'],\n[new RegExp(/</g), 'Lt']];\n\nconst TOKENS = [\n{\n  type: 3,\n  token: 'x',\n  show: 'x',\n  value: 'x' },\n\n{\n  type: 2,\n  token: '&',\n  show: '&',\n  value: (a, b) => a & b },\n\n{\n  type: 2,\n  token: '|',\n  show: '|',\n  value: (a, b) => a | b },\n\n{\n  type: 2,\n  token: 'and',\n  show: 'and',\n  value: (a, b) => a && b },\n\n{\n  type: 2,\n  token: 'xor',\n  show: 'xor',\n  value: (a, b) => a ^ b },\n\n{\n  type: 2,\n  token: 'or',\n  show: 'or',\n  value: (a, b) => Number(a || b) },\n\n{\n  type: 2,\n  token: 'Eq',\n  show: 'Eq',\n  value: (a, b) => Number(a === b) },\n\n{\n  type: 2,\n  token: 'Lt',\n  show: 'Lt',\n  value: (a, b) => Number(a < b) },\n\n{\n  type: 2,\n  token: 'Lte',\n  show: 'Lte',\n  value: (a, b) => Number(a <= b) },\n\n{\n  type: 2,\n  token: 'Gt',\n  show: 'Gt',\n  value: (a, b) => Number(a > b) },\n\n{\n  type: 2,\n  token: 'Gte',\n  show: 'Gte',\n  value: (a, b) => Number(a >= b) }];\n\n\nexport function evalExpression(expression, value) {var _subExpressions$;\n  let parsedExpression = expression;\n  // replace `<` with `Lt` (and others) to avoid clashes with builtin function operators\n  // that are not needed in Superset.\n  REPLACE_OPERATORS.forEach((_ref) => {let [key, value] = _ref;\n    parsedExpression = parsedExpression.replace(key, value);\n  });\n  const subExpressions = String(parsedExpression).split('=');\n  parsedExpression = (_subExpressions$ = subExpressions[1]) != null ? _subExpressions$ : subExpressions[0];\n  // we can ignore the type requirement on `TOKENS`, as value is always `number`\n  // and doesn't need to consider `number | undefined`.\n  // @ts-ignore\n  return Number(mexp.eval(parsedExpression, TOKENS, { x: value }));\n}\nexport function isValidExpression(expression) {\n  try {\n    evalExpression(expression, 0);\n  }\n  catch (err) {\n    return false;\n  }\n  return true;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(REPLACE_OPERATORS, \"REPLACE_OPERATORS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/math-expression/index.ts\");reactHotLoader.register(TOKENS, \"TOKENS\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/math-expression/index.ts\");reactHotLoader.register(evalExpression, \"evalExpression\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/math-expression/index.ts\");reactHotLoader.register(isValidExpression, \"isValidExpression\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/math-expression/index.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["mexp","REPLACE_OPERATORS","RegExp","TOKENS","type","token","show","value","a","b","Number","evalExpression","expression","parsedExpression","forEach","key","replace","subExpressions","String","split","eval","x","isValidExpression","err"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/packages/superset-ui-core/src/math-expression/index.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport mexp from 'math-expression-evaluator';\n\nconst REPLACE_OPERATORS: [RegExp, string][] = [\n  [new RegExp(/==/g), 'Eq'],\n  [new RegExp(/>=/g), 'Gte'],\n  [new RegExp(/<=/g), 'Lte'],\n  [new RegExp(/>/g), 'Gt'],\n  [new RegExp(/</g), 'Lt'],\n];\n\nconst TOKENS = [\n  {\n    type: 3,\n    token: 'x',\n    show: 'x',\n    value: 'x',\n  },\n  {\n    type: 2,\n    token: '&',\n    show: '&',\n    value: (a: number, b: number): number => a & b,\n  },\n  {\n    type: 2,\n    token: '|',\n    show: '|',\n    value: (a: number, b: number): number => a | b,\n  },\n  {\n    type: 2,\n    token: 'and',\n    show: 'and',\n    value: (a: number, b: number): number => a && b,\n  },\n  {\n    type: 2,\n    token: 'xor',\n    show: 'xor',\n    value: (a: number, b: number): number => a ^ b,\n  },\n  {\n    type: 2,\n    token: 'or',\n    show: 'or',\n    value: (a: number, b: number): number => Number(a || b),\n  },\n  {\n    type: 2,\n    token: 'Eq',\n    show: 'Eq',\n    value: (a: number, b: number): number => Number(a === b),\n  },\n  {\n    type: 2,\n    token: 'Lt',\n    show: 'Lt',\n    value: (a: number, b: number): number => Number(a < b),\n  },\n  {\n    type: 2,\n    token: 'Lte',\n    show: 'Lte',\n    value: (a: number, b: number): number => Number(a <= b),\n  },\n  {\n    type: 2,\n    token: 'Gt',\n    show: 'Gt',\n    value: (a: number, b: number): number => Number(a > b),\n  },\n  {\n    type: 2,\n    token: 'Gte',\n    show: 'Gte',\n    value: (a: number, b: number): number => Number(a >= b),\n  },\n];\n\nexport function evalExpression(expression: string, value: number): number {\n  let parsedExpression = expression;\n  // replace `<` with `Lt` (and others) to avoid clashes with builtin function operators\n  // that are not needed in Superset.\n  REPLACE_OPERATORS.forEach(([key, value]) => {\n    parsedExpression = parsedExpression.replace(key, value);\n  });\n  const subExpressions = String(parsedExpression).split('=');\n  parsedExpression = subExpressions[1] ?? subExpressions[0];\n  // we can ignore the type requirement on `TOKENS`, as value is always `number`\n  // and doesn't need to consider `number | undefined`.\n  // @ts-ignore\n  return Number(mexp.eval(parsedExpression, TOKENS, { x: value }));\n}\n\nexport function isValidExpression(expression: string): boolean {\n  try {\n    evalExpression(expression, 0);\n  } catch (err) {\n    return false;\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}