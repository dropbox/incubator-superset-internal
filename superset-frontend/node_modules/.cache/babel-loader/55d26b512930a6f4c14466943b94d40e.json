{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEqual from \"lodash/isEqual\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { forwardRef, useEffect, useMemo, useState, useRef, useCallback, useImperativeHandle } from 'react';\nimport { ensureIsArray, t } from '@superset-ui/core';\nimport debounce from 'lodash/debounce';\n\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { SLOW_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, hasCustomLabels, sortSelectedFirstHelper, sortComparatorWithSearchHelper, sortComparatorForNoSearchHelper, getSuffixIcon, dropDownRenderHelper, handleFilterOptionHelper } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledError, StyledErrorMessage, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { DEFAULT_PAGE_SIZE, EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Error = (_ref) => {let { error } = _ref;return ___EmotionJSX(StyledError, null,\n  ___EmotionJSX(Icons.ErrorSolid, null), \" \", ___EmotionJSX(StyledErrorMessage, null, error));};\n\nconst getQueryCacheKey = (value, page, pageSize) => `${value};${page};${pageSize}`;\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = /*#__PURE__*/forwardRef(__signature__((_ref2, ref) => {let { allowClear, allowNewOptions = false, ariaLabel, fetchOnlyOnSearch, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onError, onChange, onClear, onDropdownVisibleChange, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props } = _ref2;\n  const isSingleMode = mode === 'single';\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const selectValueRef = useRef(selectValue);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ?\n  undefined :\n  allowNewOptions ?\n  'tags' :\n  'multiple';\n  const allowFetch = !fetchOnlyOnSearch || inputValue;\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  useEffect(() => {\n    selectValueRef.current = selectValue;\n  }, [selectValue]);\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValueRef.current), []);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const sortComparatorForNoSearch = useCallback((a, b) => sortComparatorForNoSearchHelper(a, b, sortSelectedFirst, sortComparator), [sortComparator, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(EMPTY_OPTIONS);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    return missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n  }, [selectOptions, selectValue]);\n  const handleOnSelect = (selectedItem) => {\n    if (isSingleMode) {\n      setSelectValue(selectedItem);\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          return isLabeledValue(selectedItem) ?\n          result :\n          result;\n        }\n        return previousState;\n      });\n    }\n    setInputValue('');\n  };\n  const handleOnDeselect = (value) => {\n    if (Array.isArray(selectValue)) {\n      if (isLabeledValue(value)) {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      }\n    }\n    setInputValue('');\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const mergeData = useCallback((data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      // unique option values should always be case sensitive so don't lowercase\n      const dataValues = new Set(data.map((opt) => opt.value));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = prevOptions.\n        filter((previousOption) => !dataValues.has(previousOption.value)).\n        concat(data).\n        sort(sortComparatorForNoSearch);\n        return mergedData;\n      });\n    }\n    return mergedData;\n  }, [sortComparatorForNoSearch]);\n  const fetchPage = useMemo(() => (search, page) => {\n    setPage(page);\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      return;\n    }\n    const key = getQueryCacheKey(search, page, pageSize);\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount !== undefined) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(search, page, pageSize).\n    then((_ref3) => {let { data, totalCount } = _ref3;\n      const mergedData = mergeData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      search === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n    });\n  }, [\n  allValuesLoaded,\n  fetchOnlyOnSearch,\n  mergeData,\n  internalOnError,\n  options,\n  pageSize]);\n\n  const debouncedFetchPage = useMemo(() => debounce(fetchPage, SLOW_DEBOUNCE), [fetchPage]);\n  const handleOnSearch = (search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions && isSingleMode) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true };\n\n      const cleanSelectOptions = fullSelectOptions.filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    if (!allValuesLoaded &&\n    loadingEnabled &&\n    !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))) {\n      // if fetch only on search but search value is empty, then should not be\n      // in loading state\n      setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n    }\n    setInputValue(search);\n  };\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      fetchPage(inputValue, newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // loading is enabled when dropdown is open,\n    // disabled when dropdown is closed\n    if (loadingEnabled !== isDropdownVisible) {\n      setLoadingEnabled(isDropdownVisible);\n    }\n    // when closing dropdown, always reset loading state\n    if (!isDropdownVisible && isLoading) {\n      // delay is for the animation of closing the dropdown\n      // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n      // before closing.\n      setTimeout(() => {\n        setIsLoading(false);\n      }, 250);\n    }\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      const sortedOptions = selectOptions.\n      slice().\n      sort(sortComparatorForNoSearch);\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText, error ? ___EmotionJSX(Error, { error: error }) : undefined);\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    fetchedQueries.current.clear();\n    setAllValuesLoaded(false);\n    setSelectOptions(EMPTY_OPTIONS);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => {\n    debouncedFetchPage.cancel();\n  }, [debouncedFetchPage]);\n  useEffect(() => {\n    if (loadingEnabled && allowFetch) {\n      // trigger fetch every time inputValue changes\n      if (inputValue) {\n        debouncedFetchPage(inputValue, 0);\n      } else\n      {\n        fetchPage('', 0);\n      }\n    }\n  }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  const clearCache = () => fetchedQueries.current.clear();\n  useImperativeHandle(ref, () => ({\n    ...ref.current,\n    clearCache }),\n  [ref]);\n  return ___EmotionJSX(StyledContainer, { headerPosition: headerPosition },\n  header && ___EmotionJSX(StyledHeader, { headerPosition: headerPosition }, header),\n  ___EmotionJSX(StyledSelect, _extends({ allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: false, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: true, maxTagCount: maxTagCount, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange, onPopupScroll: handlePagination, onSearch: showSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, onChange: onChange, options: hasCustomLabels(fullSelectOptions) ? undefined : fullSelectOptions, placeholder: placeholder, showSearch: showSearch, showArrow: true, tokenSeparators: tokenSeparators || TOKEN_SEPARATORS, value: selectValue, suffixIcon: getSuffixIcon(isLoading, showSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), oneLine: oneLine, tagRender: customTagRender }, props, { ref: ref }),\n  hasCustomLabels(fullSelectOptions) &&\n  renderSelectOptions(fullSelectOptions)));\n\n\n}, \"useState{[selectValue, setSelectValue](value)}\\nuseState{[inputValue, setInputValue]('')}\\nuseState{[isLoading, setIsLoading](loading)}\\nuseState{[error, setError]('')}\\nuseState{[isDropdownVisible, setIsDropdownVisible](false)}\\nuseState{[page, setPage](0)}\\nuseState{[totalCount, setTotalCount](0)}\\nuseState{[loadingEnabled, setLoadingEnabled](!lazyLoading)}\\nuseState{[allValuesLoaded, setAllValuesLoaded](false)}\\nuseRef{selectValueRef}\\nuseRef{fetchedQueries}\\nuseState{[maxTagCount, setMaxTagCount](propsMaxTagCount ?? MAX_TAG_COUNT)}\\nuseEffect{}\\nuseEffect{}\\nuseCallback{sortSelectedFirst}\\nuseCallback{sortComparatorWithSearch}\\nuseCallback{sortComparatorForNoSearch}\\nuseState{[selectOptions, setSelectOptions](EMPTY_OPTIONS)}\\nuseMemo{fullSelectOptions}\\nuseCallback{internalOnError}\\nuseCallback{mergeData}\\nuseMemo{fetchPage}\\nuseMemo{debouncedFetchPage}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseImperativeHandle{}\", () => [useImperativeHandle]));const _default =\nAsyncSelect;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Error, \"Error\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(getQueryCacheKey, \"getQueryCacheKey\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(AsyncSelect, \"AsyncSelect\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/AsyncSelect.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"mappings":"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","names":["React","forwardRef","useEffect","useMemo","useState","useRef","useCallback","useImperativeHandle","ensureIsArray","t","debounce","Icons","getClientErrorObject","SLOW_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","hasCustomLabels","sortSelectedFirstHelper","sortComparatorWithSearchHelper","sortComparatorForNoSearchHelper","getSuffixIcon","dropDownRenderHelper","handleFilterOptionHelper","StyledCheckOutlined","StyledContainer","StyledError","StyledErrorMessage","StyledHeader","StyledSelect","StyledStopOutlined","DEFAULT_PAGE_SIZE","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","Error","error","getQueryCacheKey","value","page","pageSize","AsyncSelect","ref","allowClear","allowNewOptions","ariaLabel","fetchOnlyOnSearch","filterOption","header","headerPosition","helperText","invertSelection","lazyLoading","loading","mode","name","notFoundContent","onError","onChange","onClear","onDropdownVisibleChange","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","isSingleMode","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","setError","isDropdownVisible","setIsDropdownVisible","setPage","totalCount","setTotalCount","loadingEnabled","setLoadingEnabled","allValuesLoaded","setAllValuesLoaded","selectValueRef","fetchedQueries","Map","mappedMode","undefined","allowFetch","setMaxTagCount","current","sortSelectedFirst","a","b","sortComparatorWithSearch","sortComparatorForNoSearch","selectOptions","setSelectOptions","fullSelectOptions","missingValues","filter","opt","map","label","String","length","concat","handleOnSelect","selectedItem","array","previousState","result","handleOnDeselect","Array","isArray","element","internalOnError","response","then","e","mergeData","data","mergedData","dataValues","Set","prevOptions","has","previousOption","sort","fetchPage","search","key","cachedCount","get","fetchOptions","set","catch","finally","debouncedFetchPage","handleOnSearch","searchValue","trim","newOption","isNewOption","cleanSelectOptions","newOptions","handlePagination","vScroll","currentTarget","thresholdReached","scrollTop","scrollHeight","offsetHeight","hasMoreData","newPage","handleFilterOption","option","handleOnDropdownVisibleChange","setTimeout","sortedOptions","slice","dropdownRender","originNode","handleClear","clear","cancel","clearCache","triggerNode","parentNode"],"sourceRoot":"","sources":["/Users/bogdankyryliuk/code/opensource/superset/superset-frontend/src/components/Select/AsyncSelect.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, {\n  forwardRef,\n  ReactElement,\n  RefObject,\n  UIEvent,\n  useEffect,\n  useMemo,\n  useState,\n  useRef,\n  useCallback,\n  useImperativeHandle,\n} from 'react';\nimport { ensureIsArray, t } from '@superset-ui/core';\nimport { LabeledValue as AntdLabeledValue } from 'antd/lib/select';\nimport debounce from 'lodash/debounce';\nimport { isEqual } from 'lodash';\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { SLOW_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  hasCustomLabels,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  sortComparatorForNoSearchHelper,\n  getSuffixIcon,\n  dropDownRenderHelper,\n  handleFilterOptionHelper,\n} from './utils';\nimport {\n  AsyncSelectProps,\n  AsyncSelectRef,\n  SelectOptionsPagePromise,\n  SelectOptionsType,\n  SelectOptionsTypePage,\n} from './types';\nimport {\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledError,\n  StyledErrorMessage,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  DEFAULT_PAGE_SIZE,\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\n\nconst Error = ({ error }: { error: string }) => (\n  <StyledError>\n    <Icons.ErrorSolid /> <StyledErrorMessage>{error}</StyledErrorMessage>\n  </StyledError>\n);\n\nconst getQueryCacheKey = (value: string, page: number, pageSize: number) =>\n  `${value};${page};${pageSize}`;\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * The aim of the component was to combine all the instances of select components throughout the\n * project under one and to remove the react-select component entirely.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = forwardRef(\n  (\n    {\n      allowClear,\n      allowNewOptions = false,\n      ariaLabel,\n      fetchOnlyOnSearch,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      lazyLoading = true,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onError,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      optionFilterProps = ['label', 'value'],\n      options,\n      pageSize = DEFAULT_PAGE_SIZE,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n      ...props\n    }: AsyncSelectProps,\n    ref: RefObject<AsyncSelectRef>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [error, setError] = useState('');\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [page, setPage] = useState(0);\n    const [totalCount, setTotalCount] = useState(0);\n    const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n    const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n    const selectValueRef = useRef(selectValue);\n    const fetchedQueries = useRef(new Map<string, number>());\n    const mappedMode = isSingleMode\n      ? undefined\n      : allowNewOptions\n      ? 'tags'\n      : 'multiple';\n    const allowFetch = !fetchOnlyOnSearch || inputValue;\n\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    useEffect(() => {\n      selectValueRef.current = selectValue;\n    }, [selectValue]);\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValueRef.current),\n      [],\n    );\n\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const sortComparatorForNoSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorForNoSearchHelper(\n          a,\n          b,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [sortComparator, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(EMPTY_OPTIONS);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(opt => !hasOption(getValue(opt), selectOptions))\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      return missingValues.length > 0\n        ? missingValues.concat(selectOptions)\n        : selectOptions;\n    }, [selectOptions, selectValue]);\n\n    const handleOnSelect = (\n      selectedItem: string | number | AntdLabeledValue | undefined,\n    ) => {\n      if (isSingleMode) {\n        setSelectValue(selectedItem);\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          // Tokenized values can contain duplicated values\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            return isLabeledValue(selectedItem)\n              ? (result as AntdLabeledValue[])\n              : (result as (string | number)[]);\n          }\n          return previousState;\n        });\n      }\n      setInputValue('');\n    };\n\n    const handleOnDeselect = (\n      value: string | number | AntdLabeledValue | undefined,\n    ) => {\n      if (Array.isArray(selectValue)) {\n        if (isLabeledValue(value)) {\n          const array = selectValue as AntdLabeledValue[];\n          setSelectValue(\n            array.filter(element => element.value !== value.value),\n          );\n        } else {\n          const array = selectValue as (string | number)[];\n          setSelectValue(array.filter(element => element !== value));\n        }\n      }\n      setInputValue('');\n    };\n\n    const internalOnError = useCallback(\n      (response: Response) =>\n        getClientErrorObject(response).then(e => {\n          const { error } = e;\n          setError(error);\n\n          if (onError) {\n            onError(error);\n          }\n        }),\n      [onError],\n    );\n\n    const mergeData = useCallback(\n      (data: SelectOptionsType) => {\n        let mergedData: SelectOptionsType = [];\n        if (data && Array.isArray(data) && data.length) {\n          // unique option values should always be case sensitive so don't lowercase\n          const dataValues = new Set(data.map(opt => opt.value));\n          // merges with existing and creates unique options\n          setSelectOptions(prevOptions => {\n            mergedData = prevOptions\n              .filter(previousOption => !dataValues.has(previousOption.value))\n              .concat(data)\n              .sort(sortComparatorForNoSearch);\n            return mergedData;\n          });\n        }\n        return mergedData;\n      },\n      [sortComparatorForNoSearch],\n    );\n\n    const fetchPage = useMemo(\n      () => (search: string, page: number) => {\n        setPage(page);\n        if (allValuesLoaded) {\n          setIsLoading(false);\n          return;\n        }\n        const key = getQueryCacheKey(search, page, pageSize);\n        const cachedCount = fetchedQueries.current.get(key);\n        if (cachedCount !== undefined) {\n          setTotalCount(cachedCount);\n          setIsLoading(false);\n          return;\n        }\n        setIsLoading(true);\n\n        const fetchOptions = options as SelectOptionsPagePromise;\n        fetchOptions(search, page, pageSize)\n          .then(({ data, totalCount }: SelectOptionsTypePage) => {\n            const mergedData = mergeData(data);\n            fetchedQueries.current.set(key, totalCount);\n            setTotalCount(totalCount);\n            if (\n              !fetchOnlyOnSearch &&\n              search === '' &&\n              mergedData.length >= totalCount\n            ) {\n              setAllValuesLoaded(true);\n            }\n          })\n          .catch(internalOnError)\n          .finally(() => {\n            setIsLoading(false);\n          });\n      },\n      [\n        allValuesLoaded,\n        fetchOnlyOnSearch,\n        mergeData,\n        internalOnError,\n        options,\n        pageSize,\n      ],\n    );\n\n    const debouncedFetchPage = useMemo(\n      () => debounce(fetchPage, SLOW_DEBOUNCE),\n      [fetchPage],\n    );\n\n    const handleOnSearch = (search: string) => {\n      const searchValue = search.trim();\n      if (allowNewOptions && isSingleMode) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = fullSelectOptions.filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        const newOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(newOptions);\n      }\n      if (\n        !allValuesLoaded &&\n        loadingEnabled &&\n        !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))\n      ) {\n        // if fetch only on search but search value is empty, then should not be\n        // in loading state\n        setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n      }\n      setInputValue(search);\n    };\n\n    const handlePagination = (e: UIEvent<HTMLElement>) => {\n      const vScroll = e.currentTarget;\n      const thresholdReached =\n        vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n      const hasMoreData = page * pageSize + pageSize < totalCount;\n\n      if (!isLoading && hasMoreData && thresholdReached) {\n        const newPage = page + 1;\n        fetchPage(inputValue, newPage);\n      }\n    };\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      // loading is enabled when dropdown is open,\n      // disabled when dropdown is closed\n      if (loadingEnabled !== isDropdownVisible) {\n        setLoadingEnabled(isDropdownVisible);\n      }\n      // when closing dropdown, always reset loading state\n      if (!isDropdownVisible && isLoading) {\n        // delay is for the animation of closing the dropdown\n        // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n        // before closing.\n        setTimeout(() => {\n          setIsLoading(false);\n        }, 250);\n      }\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        const sortedOptions = selectOptions\n          .slice()\n          .sort(sortComparatorForNoSearch);\n        if (!isEqual(sortedOptions, selectOptions)) {\n          setSelectOptions(sortedOptions);\n        }\n      }\n\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n        error ? <Error error={error} /> : undefined,\n      );\n\n    const handleClear = () => {\n      setSelectValue(undefined);\n      if (onClear) {\n        onClear();\n      }\n    };\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      fetchedQueries.current.clear();\n      setAllValuesLoaded(false);\n      setSelectOptions(EMPTY_OPTIONS);\n    }, [options]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    // Stop the invocation of the debounced function after unmounting\n    useEffect(\n      () => () => {\n        debouncedFetchPage.cancel();\n      },\n      [debouncedFetchPage],\n    );\n\n    useEffect(() => {\n      if (loadingEnabled && allowFetch) {\n        // trigger fetch every time inputValue changes\n        if (inputValue) {\n          debouncedFetchPage(inputValue, 0);\n        } else {\n          fetchPage('', 0);\n        }\n      }\n    }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    const clearCache = () => fetchedQueries.current.clear();\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        ...(ref.current as HTMLInputElement),\n        clearCache,\n      }),\n      [ref],\n    );\n\n    return (\n      <StyledContainer headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel || name}\n          autoClearSearchValue={false}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue\n          maxTagCount={maxTagCount}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          onPopupScroll={handlePagination}\n          onSearch={showSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          onChange={onChange}\n          options={\n            hasCustomLabels(fullSelectOptions) ? undefined : fullSelectOptions\n          }\n          placeholder={placeholder}\n          showSearch={showSearch}\n          showArrow\n          tokenSeparators={tokenSeparators || TOKEN_SEPARATORS}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(isLoading, showSearch, isDropdownVisible)}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {hasCustomLabels(fullSelectOptions) &&\n            renderSelectOptions(fullSelectOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default AsyncSelect;\n"]},"metadata":{},"sourceType":"module"}