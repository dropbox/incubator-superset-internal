{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getMetricLabel } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA, DEFAULT_TREE_SERIES_OPTION } from './constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function formatTooltip(_ref) {let { params, metricLabel } = _ref;\n  const { value, treeAncestors } = params;\n  const treePath = (treeAncestors != null ? treeAncestors : []).\n  map((pathInfo) => (pathInfo == null ? void 0 : pathInfo.name) || '').\n  filter((path) => path !== '');\n  return [\n  `<div>${treePath.join(' ▸ ')}</div>`,\n  value ? `${metricLabel}: ${value}` : ''].\n  join('');\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, queriesData } = chartProps;\n  const refs = {};\n  const data = queriesData[0].data || [];\n  const { id, parent, name, metric = '', rootNodeId, layout, orient, symbol, symbolSize, roam, nodeLabelPosition, childLabelPosition, emphasis } = { ...DEFAULT_FORM_DATA, ...formData };\n  const metricLabel = getMetricLabel(metric);\n  const nameColumn = name || id;\n  function findNodeName(rootNodeId) {\n    let nodeName = '';\n    data.some((node) => {\n      if (node[id].toString() === rootNodeId) {\n        nodeName = node[nameColumn];\n        return true;\n      }\n      return false;\n    });\n    return nodeName;\n  }\n  function getTotalChildren(tree) {\n    let totalChildren = 0;\n    function traverse(tree) {\n      tree.children.forEach((node) => {\n        traverse(node);\n      });\n      totalChildren += 1;\n    }\n    traverse(tree);\n    return totalChildren;\n  }\n  function createTree(rootNodeId) {\n    const rootNodeName = findNodeName(rootNodeId);\n    const tree = { name: rootNodeName, children: [] };\n    const children = [];\n    const indexMap = {};\n    if (!rootNodeName) {\n      return tree;\n    }\n    // index indexMap with node ids\n    for (let i = 0; i < data.length; i += 1) {\n      const nodeId = data[i][id];\n      indexMap[nodeId] = i;\n      children[i] = [];\n    }\n    // generate tree\n    for (let i = 0; i < data.length; i += 1) {var _node$parent;\n      const node = data[i];\n      if (((_node$parent = node[parent]) == null ? void 0 : _node$parent.toString()) === rootNodeId) {var _tree$children;\n        (_tree$children = tree.children) == null ? void 0 : _tree$children.push({\n          name: node[nameColumn],\n          children: children[i],\n          value: node[metricLabel] });\n\n      } else\n      {\n        const parentId = node[parent];\n        if (data[indexMap[parentId]]) {\n          const parentIndex = indexMap[parentId];\n          children[parentIndex].push({\n            name: node[nameColumn],\n            children: children[i],\n            value: node[metricLabel] });\n\n        }\n      }\n    }\n    return tree;\n  }\n  let finalTree = {};\n  if (rootNodeId) {\n    finalTree = createTree(rootNodeId);\n  } else\n  {\n    /*\n      to select root node,\n      1.find parent nodes with only 1 child.\n      2.build tree for each such child nodes as root\n      3.select tree with most children\n    */\n    // create map of parent:children\n    const parentChildMap = {};\n    data.forEach((node) => {\n      const parentId = node[parent];\n      if (parentId in parentChildMap) {\n        parentChildMap[parentId].push({ id: node[id] });\n      } else\n      {\n        parentChildMap[parentId] = [{ id: node[id] }];\n      }\n    });\n    // for each parent node which has only 1 child,find tree and select node with max number of children.\n    let maxChildren = 0;\n    Object.keys(parentChildMap).forEach((key) => {\n      if (parentChildMap[key].length === 1) {\n        const tree = createTree(parentChildMap[key][0].id);\n        const totalChildren = getTotalChildren(tree);\n        if (totalChildren > maxChildren) {\n          maxChildren = totalChildren;\n          finalTree = tree;\n        }\n      }\n    });\n  }\n  const series = [\n  {\n    type: 'tree',\n    data: [finalTree],\n    label: {\n      ...DEFAULT_TREE_SERIES_OPTION.label,\n      position: nodeLabelPosition },\n\n    emphasis: { focus: emphasis },\n    animation: DEFAULT_TREE_SERIES_OPTION.animation,\n    layout,\n    orient,\n    symbol,\n    roam,\n    symbolSize,\n    lineStyle: DEFAULT_TREE_SERIES_OPTION.lineStyle,\n    select: DEFAULT_TREE_SERIES_OPTION.select,\n    leaves: { label: { position: childLabelPosition } } }];\n\n\n  const echartOptions = {\n    animationDuration: DEFAULT_TREE_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_TREE_SERIES_OPTION.animationEasing,\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: (params) => formatTooltip({\n        params,\n        metricLabel }) } };\n\n\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    refs };\n\n}","map":{"version":3,"mappings":"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","names":["getMetricLabel","DEFAULT_FORM_DATA","DEFAULT_TREE_SERIES_OPTION","getDefaultTooltip","formatTooltip","params","metricLabel","value","treeAncestors","treePath","map","name","filter","path","join","transformProps","chartProps","width","height","formData","queriesData","refs","data","id","parent","metric","rootNodeId","layout","orient","symbol","symbolSize","roam","nodeLabelPosition","childLabelPosition","emphasis","nameColumn","findNodeName","nodeName","some","node","toString","getTotalChildren","tree","totalChildren","traverse","children","forEach","createTree","rootNodeName","indexMap","i","length","nodeId","push","parentId","parentIndex","finalTree","parentChildMap","maxChildren","Object","keys","key","series","type","label","position","focus","animation","lineStyle","select","leaves","echartOptions","animationDuration","animationEasing","tooltip","trigger","triggerOn","formatter"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Tree/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getMetricLabel, DataRecordValue } from '@superset-ui/core';\nimport { EChartsCoreOption, TreeSeriesOption } from 'echarts';\nimport {\n  TreeSeriesCallbackDataParams,\n  TreeSeriesNodeItemOption,\n} from 'echarts/types/src/chart/tree/TreeSeries';\nimport { OptionName } from 'echarts/types/src/util/types';\nimport {\n  EchartsTreeChartProps,\n  EchartsTreeFormData,\n  TreeDataRecord,\n  TreeTransformedProps,\n} from './types';\nimport { DEFAULT_FORM_DATA, DEFAULT_TREE_SERIES_OPTION } from './constants';\nimport { Refs } from '../types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function formatTooltip({\n  params,\n  metricLabel,\n}: {\n  params: TreeSeriesCallbackDataParams;\n  metricLabel: string;\n}): string {\n  const { value, treeAncestors } = params;\n  const treePath = (treeAncestors ?? [])\n    .map(pathInfo => pathInfo?.name || '')\n    .filter(path => path !== '');\n\n  return [\n    `<div>${treePath.join(' ▸ ')}</div>`,\n    value ? `${metricLabel}: ${value}` : '',\n  ].join('');\n}\n\nexport default function transformProps(\n  chartProps: EchartsTreeChartProps,\n): TreeTransformedProps {\n  const { width, height, formData, queriesData } = chartProps;\n  const refs: Refs = {};\n  const data: TreeDataRecord[] = queriesData[0].data || [];\n\n  const {\n    id,\n    parent,\n    name,\n    metric = '',\n    rootNodeId,\n    layout,\n    orient,\n    symbol,\n    symbolSize,\n    roam,\n    nodeLabelPosition,\n    childLabelPosition,\n    emphasis,\n  }: EchartsTreeFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const metricLabel = getMetricLabel(metric);\n\n  const nameColumn = name || id;\n\n  function findNodeName(rootNodeId: DataRecordValue): OptionName {\n    let nodeName: DataRecordValue = '';\n    data.some(node => {\n      if (node[id]!.toString() === rootNodeId) {\n        nodeName = node[nameColumn];\n        return true;\n      }\n      return false;\n    });\n    return nodeName;\n  }\n\n  function getTotalChildren(tree: TreeSeriesNodeItemOption) {\n    let totalChildren = 0;\n\n    function traverse(tree: TreeSeriesNodeItemOption) {\n      tree.children!.forEach(node => {\n        traverse(node);\n      });\n      totalChildren += 1;\n    }\n    traverse(tree);\n    return totalChildren;\n  }\n\n  function createTree(rootNodeId: DataRecordValue): TreeSeriesNodeItemOption {\n    const rootNodeName = findNodeName(rootNodeId);\n    const tree: TreeSeriesNodeItemOption = { name: rootNodeName, children: [] };\n    const children: TreeSeriesNodeItemOption[][] = [];\n    const indexMap: { [name: string]: number } = {};\n\n    if (!rootNodeName) {\n      return tree;\n    }\n\n    // index indexMap with node ids\n    for (let i = 0; i < data.length; i += 1) {\n      const nodeId = data[i][id] as number;\n      indexMap[nodeId] = i;\n      children[i] = [];\n    }\n\n    // generate tree\n    for (let i = 0; i < data.length; i += 1) {\n      const node = data[i];\n      if (node[parent]?.toString() === rootNodeId) {\n        tree.children?.push({\n          name: node[nameColumn],\n          children: children[i],\n          value: node[metricLabel],\n        });\n      } else {\n        const parentId = node[parent];\n        if (data[indexMap[parentId]]) {\n          const parentIndex = indexMap[parentId];\n          children[parentIndex].push({\n            name: node[nameColumn],\n            children: children[i],\n            value: node[metricLabel],\n          });\n        }\n      }\n    }\n\n    return tree;\n  }\n\n  let finalTree = {};\n\n  if (rootNodeId) {\n    finalTree = createTree(rootNodeId);\n  } else {\n    /*\n      to select root node,\n      1.find parent nodes with only 1 child.\n      2.build tree for each such child nodes as root\n      3.select tree with most children\n    */\n    // create map of parent:children\n    const parentChildMap: { [name: string]: { [name: string]: any } } = {};\n    data.forEach(node => {\n      const parentId = node[parent] as string;\n      if (parentId in parentChildMap) {\n        parentChildMap[parentId].push({ id: node[id] });\n      } else {\n        parentChildMap[parentId] = [{ id: node[id] }];\n      }\n    });\n\n    // for each parent node which has only 1 child,find tree and select node with max number of children.\n    let maxChildren = 0;\n    Object.keys(parentChildMap).forEach(key => {\n      if (parentChildMap[key].length === 1) {\n        const tree = createTree(parentChildMap[key][0].id);\n        const totalChildren = getTotalChildren(tree);\n        if (totalChildren > maxChildren) {\n          maxChildren = totalChildren;\n          finalTree = tree;\n        }\n      }\n    });\n  }\n\n  const series: TreeSeriesOption[] = [\n    {\n      type: 'tree',\n      data: [finalTree],\n      label: {\n        ...DEFAULT_TREE_SERIES_OPTION.label,\n        position: nodeLabelPosition,\n      },\n      emphasis: { focus: emphasis },\n      animation: DEFAULT_TREE_SERIES_OPTION.animation,\n      layout,\n      orient,\n      symbol,\n      roam,\n      symbolSize,\n      lineStyle: DEFAULT_TREE_SERIES_OPTION.lineStyle,\n      select: DEFAULT_TREE_SERIES_OPTION.select,\n      leaves: { label: { position: childLabelPosition } },\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    animationDuration: DEFAULT_TREE_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_TREE_SERIES_OPTION.animationEasing,\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          metricLabel,\n        }),\n    },\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    refs,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}