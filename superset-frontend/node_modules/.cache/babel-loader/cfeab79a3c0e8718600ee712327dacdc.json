{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, NumberFormats, t } from '@superset-ui/core';\nimport { OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder } from '../utils/treeBuilder';\nimport { EchartsSunburstLabelType } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function getLinearDomain(treeData, callback) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree) {\n    tree.forEach((treeNode) => {var _treeNode$children;\n      if ((_treeNode$children = treeNode.children) != null && _treeNode$children.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp)\n        min = temp;\n        if (max < temp)\n        max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\nexport function formatLabel(_ref) {let { params, labelType, numberFormatter } = _ref;\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;}\n\n}\nexport function formatTooltip(_ref2) {let { params, primaryValueFormatter, secondaryValueFormatter, colorByCategory, totalValue, metricLabel, secondaryMetricLabel, theme } = _ref2;\n  const { data, treePathInfo = [] } = params;\n  const node = data;\n  const formattedValue = primaryValueFormatter(node.value);\n  const formattedSecondaryValue = secondaryValueFormatter == null ? void 0 : secondaryValueFormatter(node.secondaryValue);\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(node.secondaryValue / node.value);\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode = treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n  const result = [\n  `<div style=\"\n      font-size: ${theme.typography.sizes.m}px;\n      color: ${theme.colors.grayscale.base}\"\n     >`,\n  `<div style=\"font-weight: ${theme.typography.weights.bold}\">\n      ${node.name}\n     </div>`,\n  `<div\">\n      ${absolutePercentage} of total\n     </div>`];\n\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(node.value / parentNode.value);\n    result.push(`\n    <div>\n      ${conditionalPercentage} of ${parentNode.name}\n    </div>`);\n  }\n  result.push(`<div>\n    ${metricLabel}: ${formattedValue}${colorByCategory ?\n  '' :\n  `, ${secondaryMetricLabel}: ${formattedSecondaryValue}`}\n     </div>`, colorByCategory ?\n  '' :\n  `<div>${metricLabel}/${secondaryMetricLabel}: ${compareValuePercentage}</div>`);\n  result.push('</div>');\n  return result.join('\\n');\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters, datasource } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { groupby = [], columns = [], metric = '', secondaryMetric = '', colorScheme, linearColorScheme, labelType, numberFormat, dateFormat, showLabels, showLabelsThreshold, showTotal, sliceId } = formData;\n  const { currencyFormats = {}, columnFormats = {} } = datasource;\n  const refs = {};\n  const primaryValueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat);\n  const secondaryValueFormatter = secondaryMetric ?\n  getValueFormatter(secondaryMetric, currencyFormats, columnFormats, numberFormat) :\n  undefined;\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter: primaryValueFormatter,\n    labelType });\n\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit };\n\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric ?\n  getMetricLabel(secondaryMetric) :\n  undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(data, columnLabels, metricLabel, secondaryMetricLabel);\n  const totalValue = treeData.reduce((result, treeNode) => result + treeNode.value, 0);\n  const totalSecondaryValue = treeData.reduce((result, treeNode) => result + treeNode.secondaryValue, 0);\n  const categoricalColorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let linearColorScale;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {var _getSequentialSchemeR, _getSequentialSchemeR2;\n    const domain = getLinearDomain(treeData, (node) => node.secondaryValue / node.value);\n    colorByCategory = false;\n    linearColorScale = (_getSequentialSchemeR = getSequentialSchemeRegistry()) == null ? void 0 : (_getSequentialSchemeR2 = _getSequentialSchemeR.\n    get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR2.\n    createLinearScale(domain);\n  }\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else\n  {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n  const traverse = (treeNodes, path, pathRecords) => treeNodes.map((treeNode) => {var _treeNode$children2, _filterState$selected, _filterState$selected2;\n    const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n    const records = [...(pathRecords || []), nodeName];\n    let name = formatSeriesName(nodeName, {\n      numberFormatter,\n      timeFormatter: getTimeFormatter(dateFormat),\n      ...(coltypeMapping[groupBy] && {\n        coltype: coltypeMapping[groupBy] }) });\n\n\n    const newPath = path.concat(name);\n    let item = {\n      records,\n      name,\n      value,\n      secondaryValue,\n      itemStyle: {\n        color: colorByCategory ?\n        categoricalColorScale(name, sliceId) :\n        linearColorScale(secondaryValue / value) } };\n\n\n    if ((_treeNode$children2 = treeNode.children) != null && _treeNode$children2.length) {\n      item.children = traverse(treeNode.children, newPath, records);\n    } else\n    {\n      name = newPath.join(',');\n    }\n    columnsLabelMap.set(name, newPath);\n    if (((_filterState$selected = filterState.selectedValues) == null ? void 0 : (_filterState$selected2 = _filterState$selected[0]) == null ? void 0 : _includesInstanceProperty(_filterState$selected2).call(_filterState$selected2, name)) === false) {\n      item = {\n        ...item,\n        itemStyle: {\n          ...item.itemStyle,\n          opacity: OpacityEnum.SemiTransparent },\n\n        label: {\n          color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})` } };\n\n\n    }\n    return item;\n  });\n  const echartOptions = {\n    grid: {\n      ...defaultGrid },\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => formatTooltip({\n        params,\n        primaryValueFormatter,\n        secondaryValueFormatter,\n        colorByCategory,\n        totalValue,\n        metricLabel,\n        secondaryMetricLabel,\n        theme }) },\n\n\n    series: [\n    {\n      type: 'sunburst',\n      ...padding,\n      nodeClick: false,\n      emphasis: {\n        focus: 'ancestor',\n        label: {\n          show: showLabels } },\n\n\n      label: {\n        width: radius * 0.6 / (columns.length || 1),\n        show: showLabels,\n        formatter,\n        color: theme.colors.grayscale.dark2,\n        minAngle: minShowLabelAngle,\n        overflow: 'breakAll' },\n\n      radius: [radius * 0.3, radius],\n      data: traverse(treeData, []) }],\n\n\n    graphic: showTotal ?\n    {\n      type: 'text',\n      top: 'center',\n      left: 'center',\n      style: {\n        text: t('Total: %s', primaryValueFormatter(totalValue)),\n        fontSize: 16,\n        fontWeight: 'bold' },\n\n      z: 10 } :\n\n    null };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping };\n\n}","map":{"version":3,"mappings":"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","names":["CategoricalColorNamespace","getColumnLabel","getMetricLabel","getNumberFormatter","getSequentialSchemeRegistry","getTimeFormatter","getValueFormatter","NumberFormats","t","OpacityEnum","defaultGrid","formatSeriesName","getColtypesMapping","treeBuilder","EchartsSunburstLabelType","getDefaultTooltip","getLinearDomain","treeData","callback","min","max","temp","traverse","tree","forEach","treeNode","children","length","formatLabel","params","labelType","numberFormatter","name","value","formattedValue","Key","Value","KeyValue","formatTooltip","primaryValueFormatter","secondaryValueFormatter","colorByCategory","totalValue","metricLabel","secondaryMetricLabel","theme","data","treePathInfo","node","formattedSecondaryValue","secondaryValue","percentFormatter","PERCENT_2_POINT","compareValuePercentage","absolutePercentage","parentNode","undefined","result","typography","sizes","m","colors","grayscale","base","weights","bold","conditionalPercentage","push","join","transformProps","chartProps","formData","height","hooks","filterState","queriesData","width","inContextMenu","emitCrossFilters","datasource","coltypeMapping","groupby","columns","metric","secondaryMetric","colorScheme","linearColorScheme","numberFormat","dateFormat","showLabels","showLabelsThreshold","showTotal","sliceId","currencyFormats","columnFormats","refs","formatter","minShowLabelAngle","padding","top","gridUnit","right","bottom","left","containerWidth","containerHeight","visWidth","visHeight","radius","Math","setDataMask","onContextMenu","columnsLabelMap","Map","columnLabels","map","reduce","totalSecondaryValue","categoricalColorScale","getScale","linearColorScale","domain","get","createLinearScale","treeNodes","path","pathRecords","nodeName","groupBy","records","timeFormatter","coltype","newPath","concat","item","itemStyle","color","set","selectedValues","opacity","SemiTransparent","label","echartOptions","grid","tooltip","show","trigger","series","type","nodeClick","emphasis","focus","dark2","minAngle","overflow","graphic","style","text","fontSize","fontWeight","z","labelMap","Object","fromEntries"],"sourceRoot":"","sources":["/Users/zhaorui/src/incubator-superset-internal/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  DataRecordValue,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getSequentialSchemeRegistry,\n  getTimeFormatter,\n  getValueFormatter,\n  NumberFormats,\n  SupersetTheme,\n  t,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { EChartsCoreOption } from 'echarts';\nimport { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { Refs } from '../types';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder, TreeNode } from '../utils/treeBuilder';\nimport {\n  EchartsSunburstChartProps,\n  EchartsSunburstLabelType,\n  NodeItemOption,\n  SunburstTransformedProps,\n} from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function getLinearDomain(\n  treeData: TreeNode[],\n  callback: (treeNode: TreeNode) => number,\n) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree: TreeNode[]) {\n    tree.forEach(treeNode => {\n      if (treeNode.children?.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp) min = temp;\n        if (max < temp) max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\n\nexport function formatLabel({\n  params,\n  labelType,\n  numberFormatter,\n}: {\n  params: CallbackDataParams;\n  labelType: EchartsSunburstLabelType;\n  numberFormatter: ValueFormatter;\n}): string {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value as number);\n\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\n\nexport function formatTooltip({\n  params,\n  primaryValueFormatter,\n  secondaryValueFormatter,\n  colorByCategory,\n  totalValue,\n  metricLabel,\n  secondaryMetricLabel,\n  theme,\n}: {\n  params: CallbackDataParams & {\n    treePathInfo: {\n      name: string;\n      dataIndex: number;\n      value: number;\n    }[];\n  };\n  primaryValueFormatter: ValueFormatter;\n  secondaryValueFormatter: ValueFormatter | undefined;\n  colorByCategory: boolean;\n  totalValue: number;\n  metricLabel: string;\n  secondaryMetricLabel?: string;\n  theme: SupersetTheme;\n}): string {\n  const { data, treePathInfo = [] } = params;\n  const node = data as TreeNode;\n  const formattedValue = primaryValueFormatter(node.value);\n  const formattedSecondaryValue = secondaryValueFormatter?.(\n    node.secondaryValue,\n  );\n\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(\n    node.secondaryValue / node.value,\n  );\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode =\n    treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n\n  const result = [\n    `<div style=\"\n      font-size: ${theme.typography.sizes.m}px;\n      color: ${theme.colors.grayscale.base}\"\n     >`,\n    `<div style=\"font-weight: ${theme.typography.weights.bold}\">\n      ${node.name}\n     </div>`,\n    `<div\">\n      ${absolutePercentage} of total\n     </div>`,\n  ];\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(\n      node.value / parentNode.value,\n    );\n    result.push(`\n    <div>\n      ${conditionalPercentage} of ${parentNode.name}\n    </div>`);\n  }\n  result.push(\n    `<div>\n    ${metricLabel}: ${formattedValue}${\n      colorByCategory\n        ? ''\n        : `, ${secondaryMetricLabel}: ${formattedSecondaryValue}`\n    }\n     </div>`,\n    colorByCategory\n      ? ''\n      : `<div>${metricLabel}/${secondaryMetricLabel}: ${compareValuePercentage}</div>`,\n  );\n  result.push('</div>');\n  return result.join('\\n');\n}\n\nexport default function transformProps(\n  chartProps: EchartsSunburstChartProps,\n): SunburstTransformedProps {\n  const {\n    formData,\n    height,\n    hooks,\n    filterState,\n    queriesData,\n    width,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n    datasource,\n  } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    groupby = [],\n    columns = [],\n    metric = '',\n    secondaryMetric = '',\n    colorScheme,\n    linearColorScheme,\n    labelType,\n    numberFormat,\n    dateFormat,\n    showLabels,\n    showLabelsThreshold,\n    showTotal,\n    sliceId,\n  } = formData;\n  const { currencyFormats = {}, columnFormats = {} } = datasource;\n  const refs: Refs = {};\n  const primaryValueFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    numberFormat,\n  );\n  const secondaryValueFormatter = secondaryMetric\n    ? getValueFormatter(\n        secondaryMetric,\n        currencyFormats,\n        columnFormats,\n        numberFormat,\n      )\n    : undefined;\n\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params: CallbackDataParams) =>\n    formatLabel({\n      params,\n      numberFormatter: primaryValueFormatter,\n      labelType,\n    });\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit,\n  };\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map<string, string[]>();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric\n    ? getMetricLabel(secondaryMetric)\n    : undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(\n    data,\n    columnLabels,\n    metricLabel,\n    secondaryMetricLabel,\n  );\n  const totalValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.value,\n    0,\n  );\n  const totalSecondaryValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.secondaryValue,\n    0,\n  );\n\n  const categoricalColorScale = CategoricalColorNamespace.getScale(\n    colorScheme as string,\n  );\n  let linearColorScale: any;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {\n    const domain = getLinearDomain(\n      treeData,\n      node => node.secondaryValue / node.value,\n    );\n    colorByCategory = false;\n    linearColorScale = getSequentialSchemeRegistry()\n      ?.get(linearColorScheme)\n      ?.createLinearScale(domain);\n  }\n\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n\n  const traverse = (\n    treeNodes: TreeNode[],\n    path: string[],\n    pathRecords?: DataRecordValue[],\n  ) =>\n    treeNodes.map(treeNode => {\n      const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n      const records = [...(pathRecords || []), nodeName];\n      let name = formatSeriesName(nodeName, {\n        numberFormatter,\n        timeFormatter: getTimeFormatter(dateFormat),\n        ...(coltypeMapping[groupBy] && {\n          coltype: coltypeMapping[groupBy],\n        }),\n      });\n      const newPath = path.concat(name);\n      let item: NodeItemOption = {\n        records,\n        name,\n        value,\n        secondaryValue,\n        itemStyle: {\n          color: colorByCategory\n            ? categoricalColorScale(name, sliceId)\n            : linearColorScale(secondaryValue / value),\n        },\n      };\n      if (treeNode.children?.length) {\n        item.children = traverse(treeNode.children, newPath, records);\n      } else {\n        name = newPath.join(',');\n      }\n      columnsLabelMap.set(name, newPath);\n      if (filterState.selectedValues?.[0]?.includes(name) === false) {\n        item = {\n          ...item,\n          itemStyle: {\n            ...item.itemStyle,\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          label: {\n            color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`,\n          },\n        };\n      }\n      return item;\n    });\n\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          primaryValueFormatter,\n          secondaryValueFormatter,\n          colorByCategory,\n          totalValue,\n          metricLabel,\n          secondaryMetricLabel,\n          theme,\n        }),\n    },\n    series: [\n      {\n        type: 'sunburst',\n        ...padding,\n        nodeClick: false,\n        emphasis: {\n          focus: 'ancestor',\n          label: {\n            show: showLabels,\n          },\n        },\n        label: {\n          width: (radius * 0.6) / (columns.length || 1),\n          show: showLabels,\n          formatter,\n          color: theme.colors.grayscale.dark2,\n          minAngle: minShowLabelAngle,\n          overflow: 'breakAll',\n        },\n        radius: [radius * 0.3, radius],\n        data: traverse(treeData, []),\n      },\n    ],\n    graphic: showTotal\n      ? {\n          type: 'text',\n          top: 'center',\n          left: 'center',\n          style: {\n            text: t('Total: %s', primaryValueFormatter(totalValue)),\n            fontSize: 16,\n            fontWeight: 'bold',\n          },\n          z: 10,\n        }\n      : null,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}