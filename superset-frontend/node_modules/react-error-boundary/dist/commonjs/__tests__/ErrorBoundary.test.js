'use strict';

var _enzyme = require('enzyme');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ErrorBoundary = require('../ErrorBoundary');

var _ErrorBoundary2 = _interopRequireDefault(_ErrorBoundary);

var _ErrorBoundaryFallbackComponent = require('../ErrorBoundaryFallbackComponent');

var _ErrorBoundaryFallbackComponent2 = _interopRequireDefault(_ErrorBoundaryFallbackComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('ErrorBoundary', function () {
  var consoleErrorSpy = void 0;
  var mockError = void 0;

  var Spell = void 0;
  var Wand = void 0;

  beforeAll(function () {
    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(function () {
      // React error boundaries print the error to `console.error` stream even when it’s caught by our
      // `ErrorBoundary` component. We suppress `console.error` to keep our test console output clean.
      // @see #11098 Allow suppressing error boundary logs from intentionally thrown/caught errors
      // https://github.com/facebook/react/issues/11098
    });

    mockError = new Error('You cast an unforgivable curse! You’ve earned a one-way ticket to Azkaban.');
    Spell = function Spell(_ref) {
      var incantation = _ref.incantation;

      switch (incantation) {
        case 'Avada Kedavra':
        case 'Crucio':
        case 'Imperio':
          throw mockError;

        default:
          return _react2.default.createElement(
            'p',
            null,
            'You cast the ' + incantation + ' spell!'
          );
      }
    };

    Wand = function Wand(_ref2) {
      var name = _ref2.name,
          incantation = _ref2.incantation;
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'p',
          null,
          'Casting spell with the ' + name + ' wand'
        ),
        _react2.default.createElement(Spell, { incantation: incantation })
      );
    };
  });

  afterAll(function () {
    consoleErrorSpy.mockRestore();
  });

  it('Renders the child component if there is no error', function () {
    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(
      _ErrorBoundary2.default,
      null,
      _react2.default.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' })
    ));

    var WandWithErrorBoundary = (0, _ErrorBoundary.withErrorBoundary)(Wand);
    var wrapperWithErrorBoundary = (0, _enzyme.mount)(_react2.default.createElement(WandWithErrorBoundary, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }));

    expect(wrapper.state().error).toBe(null);
    expect(wrapper.state().info).toBe(null);
    expect(wrapper.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(false);
    expect(wrapper.contains(_react2.default.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }))).toBe(true);

    // Note: We use `….instance().state …` instead of `….state() …` here because…
    // > ReactWrapper::state() can only be called on the root
    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.error).toBe(null);
    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.info).toBe(null);
    expect(wrapperWithErrorBoundary.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(false);
    expect(wrapperWithErrorBoundary.contains(_react2.default.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }))).toBe(true);
  });

  it('Sets its state to an error state and renders the default fallback component', function () {
    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(
      _ErrorBoundary2.default,
      null,
      _react2.default.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Avada Kedavra' })
    ));

    var WandWithErrorBoundary = (0, _ErrorBoundary.withErrorBoundary)(Wand);
    var wrapperWithErrorBoundary = (0, _enzyme.mount)(_react2.default.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Avada Kedavra' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapper.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(true);

    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapperWithErrorBoundary.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(true);
  });

  it('Sets its state to an error state and renders a custom fallback component', function () {
    var MockFallbackComponent = function MockFallbackComponent(_ref3) {
      var error = _ref3.error,
          componentStack = _ref3.componentStack;
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'p',
          null,
          _react2.default.createElement(
            'strong',
            null,
            'Wand unable to perform magic!'
          ),
          'Please contact Ollivanders in Diagon Alley for repairs.'
        ),
        _react2.default.createElement(
          'p',
          null,
          _react2.default.createElement(
            'strong',
            null,
            'Error:'
          ),
          ' ',
          error.toString()
        ),
        _react2.default.createElement(
          'p',
          null,
          _react2.default.createElement(
            'strong',
            null,
            'Stacktrace:'
          ),
          _react2.default.createElement(
            'pre',
            null,
            componentStack
          )
        )
      );
    };

    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(
      _ErrorBoundary2.default,
      { FallbackComponent: MockFallbackComponent },
      _react2.default.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Crucio' })
    ));

    var WandWithErrorBoundary = (0, _ErrorBoundary.withErrorBoundary)(Wand, MockFallbackComponent);
    var wrapperWithErrorBoundary = (0, _enzyme.mount)(_react2.default.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Crucio' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapper.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(false);
    expect(wrapper.containsMatchingElement(_react2.default.createElement(MockFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);

    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapperWithErrorBoundary.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, null))).toBe(false);
    expect(wrapperWithErrorBoundary.containsMatchingElement(_react2.default.createElement(MockFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);
  });

  it('Sets its state to an error state and invokes the onError callback prop', function () {
    var mockOnError = jest.fn().mockImplementation(function (error, // eslint-disable-line no-unused-vars
    info) // eslint-disable-line no-unused-vars
    {});

    var mockOnErrorWithErrorBoundary = jest.fn().mockImplementation(function (error, // eslint-disable-line no-unused-vars
    info) // eslint-disable-line no-unused-vars
    {});

    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(
      _ErrorBoundary2.default,
      { onError: mockOnError },
      _react2.default.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Imperio' })
    ));
    var WandWithErrorBoundary = (0, _ErrorBoundary.withErrorBoundary)(Wand, _ErrorBoundaryFallbackComponent2.default, mockOnErrorWithErrorBoundary);
    var wrapperWithErrorBoundary = (0, _enzyme.mount)(_react2.default.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Imperio' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(mockOnError).toHaveBeenCalledWith(mockError, expect.any(String));
    expect(wrapper.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);

    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(_ErrorBoundary2.default).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(mockOnErrorWithErrorBoundary).toHaveBeenCalledWith(mockError, expect.any(String));
    expect(wrapperWithErrorBoundary.containsMatchingElement(_react2.default.createElement(_ErrorBoundaryFallbackComponent2.default, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);
  });

  it('sets the correct displayName for wrapped components', function () {
    function NormalComponent() {
      return null;
    }
    expect((0, _ErrorBoundary.withErrorBoundary)(NormalComponent).displayName).toBe('WithErrorBoundary(NormalComponent)');

    function ComponentWithDisplayNameOverride() {
      return null;
    }
    ComponentWithDisplayNameOverride.displayName = 'Override';

    expect((0, _ErrorBoundary.withErrorBoundary)(ComponentWithDisplayNameOverride).displayName).toBe('WithErrorBoundary(Override)');
    expect((0, _ErrorBoundary.withErrorBoundary)(function () {
      return null;
    }).displayName).toBe('WithErrorBoundary');
  });
});