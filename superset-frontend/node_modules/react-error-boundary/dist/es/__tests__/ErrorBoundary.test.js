import { mount } from 'enzyme';
import React from 'react';

import ErrorBoundary, { withErrorBoundary } from '../ErrorBoundary';
import ErrorBoundaryFallbackComponent from '../ErrorBoundaryFallbackComponent';

describe('ErrorBoundary', function () {
  var consoleErrorSpy = void 0;
  var mockError = void 0;

  var Spell = void 0;
  var Wand = void 0;

  beforeAll(function () {
    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(function () {
      // React error boundaries print the error to `console.error` stream even when it’s caught by our
      // `ErrorBoundary` component. We suppress `console.error` to keep our test console output clean.
      // @see #11098 Allow suppressing error boundary logs from intentionally thrown/caught errors
      // https://github.com/facebook/react/issues/11098
    });

    mockError = new Error('You cast an unforgivable curse! You’ve earned a one-way ticket to Azkaban.');
    Spell = function Spell(_ref) {
      var incantation = _ref.incantation;

      switch (incantation) {
        case 'Avada Kedavra':
        case 'Crucio':
        case 'Imperio':
          throw mockError;

        default:
          return React.createElement(
            'p',
            null,
            'You cast the ' + incantation + ' spell!'
          );
      }
    };

    Wand = function Wand(_ref2) {
      var name = _ref2.name,
          incantation = _ref2.incantation;
      return React.createElement(
        'div',
        null,
        React.createElement(
          'p',
          null,
          'Casting spell with the ' + name + ' wand'
        ),
        React.createElement(Spell, { incantation: incantation })
      );
    };
  });

  afterAll(function () {
    consoleErrorSpy.mockRestore();
  });

  it('Renders the child component if there is no error', function () {
    var wrapper = mount(React.createElement(
      ErrorBoundary,
      null,
      React.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' })
    ));

    var WandWithErrorBoundary = withErrorBoundary(Wand);
    var wrapperWithErrorBoundary = mount(React.createElement(WandWithErrorBoundary, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }));

    expect(wrapper.state().error).toBe(null);
    expect(wrapper.state().info).toBe(null);
    expect(wrapper.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(false);
    expect(wrapper.contains(React.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }))).toBe(true);

    // Note: We use `….instance().state …` instead of `….state() …` here because…
    // > ReactWrapper::state() can only be called on the root
    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.error).toBe(null);
    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.info).toBe(null);
    expect(wrapperWithErrorBoundary.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(false);
    expect(wrapperWithErrorBoundary.contains(React.createElement(Wand, { name: 'Harry\u2019s', incantation: 'Expelliarmus' }))).toBe(true);
  });

  it('Sets its state to an error state and renders the default fallback component', function () {
    var wrapper = mount(React.createElement(
      ErrorBoundary,
      null,
      React.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Avada Kedavra' })
    ));

    var WandWithErrorBoundary = withErrorBoundary(Wand);
    var wrapperWithErrorBoundary = mount(React.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Avada Kedavra' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapper.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(true);

    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapperWithErrorBoundary.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(true);
  });

  it('Sets its state to an error state and renders a custom fallback component', function () {
    var MockFallbackComponent = function MockFallbackComponent(_ref3) {
      var error = _ref3.error,
          componentStack = _ref3.componentStack;
      return React.createElement(
        'div',
        null,
        React.createElement(
          'p',
          null,
          React.createElement(
            'strong',
            null,
            'Wand unable to perform magic!'
          ),
          'Please contact Ollivanders in Diagon Alley for repairs.'
        ),
        React.createElement(
          'p',
          null,
          React.createElement(
            'strong',
            null,
            'Error:'
          ),
          ' ',
          error.toString()
        ),
        React.createElement(
          'p',
          null,
          React.createElement(
            'strong',
            null,
            'Stacktrace:'
          ),
          React.createElement(
            'pre',
            null,
            componentStack
          )
        )
      );
    };

    var wrapper = mount(React.createElement(
      ErrorBoundary,
      { FallbackComponent: MockFallbackComponent },
      React.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Crucio' })
    ));

    var WandWithErrorBoundary = withErrorBoundary(Wand, MockFallbackComponent);
    var wrapperWithErrorBoundary = mount(React.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Crucio' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapper.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(false);
    expect(wrapper.containsMatchingElement(React.createElement(MockFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);

    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(wrapperWithErrorBoundary.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, null))).toBe(false);
    expect(wrapperWithErrorBoundary.containsMatchingElement(React.createElement(MockFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);
  });

  it('Sets its state to an error state and invokes the onError callback prop', function () {
    var mockOnError = jest.fn().mockImplementation(function (error, // eslint-disable-line no-unused-vars
    info) // eslint-disable-line no-unused-vars
    {});

    var mockOnErrorWithErrorBoundary = jest.fn().mockImplementation(function (error, // eslint-disable-line no-unused-vars
    info) // eslint-disable-line no-unused-vars
    {});

    var wrapper = mount(React.createElement(
      ErrorBoundary,
      { onError: mockOnError },
      React.createElement(Wand, { name: 'Voldemort\u2019s', incantation: 'Imperio' })
    ));
    var WandWithErrorBoundary = withErrorBoundary(Wand, ErrorBoundaryFallbackComponent, mockOnErrorWithErrorBoundary);
    var wrapperWithErrorBoundary = mount(React.createElement(WandWithErrorBoundary, { name: 'Voldemort\u2019s', incantation: 'Imperio' }));

    expect(wrapper.state().error).toEqual(expect.objectContaining(mockError));
    expect(wrapper.state().info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(mockOnError).toHaveBeenCalledWith(mockError, expect.any(String));
    expect(wrapper.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);

    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.error).toEqual(expect.objectContaining(mockError));
    expect(wrapperWithErrorBoundary.find(ErrorBoundary).instance().state.info).toEqual(expect.objectContaining({
      componentStack: expect.any(String)
    }));
    expect(mockOnErrorWithErrorBoundary).toHaveBeenCalledWith(mockError, expect.any(String));
    expect(wrapperWithErrorBoundary.containsMatchingElement(React.createElement(ErrorBoundaryFallbackComponent, {
      error: mockError /* componentStack="ignored" */
    }))).toBe(true);
  });

  it('sets the correct displayName for wrapped components', function () {
    function NormalComponent() {
      return null;
    }
    expect(withErrorBoundary(NormalComponent).displayName).toBe('WithErrorBoundary(NormalComponent)');

    function ComponentWithDisplayNameOverride() {
      return null;
    }
    ComponentWithDisplayNameOverride.displayName = 'Override';

    expect(withErrorBoundary(ComponentWithDisplayNameOverride).displayName).toBe('WithErrorBoundary(Override)');
    expect(withErrorBoundary(function () {
      return null;
    }).displayName).toBe('WithErrorBoundary');
  });
});