'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const core = require('@babel/core');

function extractTypeProperties(node, types) {
  const properties = [];

  const mapToPropertySignature = data => {
    data.forEach(prop => {
      if (core.types.isTSPropertySignature(prop)) {
        properties.push(prop);
      }
    });
  }; // Props


  if (core.types.isIdentifier(node)) {
    if (types[node.name]) {
      properties.push(...types[node.name]);
    } // Props

  } else if (core.types.isTSTypeReference(node)) {
    properties.push(...extractTypeProperties(node.typeName, types)); // interface {}
  } else if (core.types.isTSInterfaceDeclaration(node)) {
    var _node$extends;

    ((_node$extends = node.extends) !== null && _node$extends !== void 0 ? _node$extends : []).forEach(ext => {
      properties.push(...extractTypeProperties(ext.expression, types));
    });
    mapToPropertySignature(node.body.body); // type = {}
  } else if (core.types.isTSTypeAliasDeclaration(node)) {
    properties.push(...extractTypeProperties(node.typeAnnotation, types)); // {}
  } else if (core.types.isTSTypeLiteral(node)) {
    mapToPropertySignature(node.members); // Props & {}, Props | {}
  } else if (core.types.isTSIntersectionType(node) || core.types.isTSUnionType(node)) {
    node.types.forEach(intType => {
      properties.push(...extractTypeProperties(intType, types));
    });
  }

  return properties;
}

exports.extractTypeProperties = extractTypeProperties;
//# sourceMappingURL=extractTypeProperties.js.map
