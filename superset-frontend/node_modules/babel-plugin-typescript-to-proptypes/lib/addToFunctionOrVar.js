'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const core = require('@babel/core');

const convertBabelToPropTypes = require('./convertBabelToPropTypes.js');

const extractGenericTypeNames = require('./extractGenericTypeNames.js');

const propTypes = require('./propTypes.js');

function findStaticProperty(path, funcName, name) {
  const expr = path.getAllNextSiblings().find(sibPath => core.types.isExpressionStatement(sibPath.node) && core.types.isAssignmentExpression(sibPath.node.expression, {
    operator: '='
  }) && core.types.isMemberExpression(sibPath.node.expression.left) && core.types.isObjectExpression(sibPath.node.expression.right) && core.types.isIdentifier(sibPath.node.expression.left.object, {
    name: funcName
  }) && core.types.isIdentifier(sibPath.node.expression.left.property, {
    name
  })); // @ts-expect-error Allow unknown access

  return expr === null || expr === void 0 ? void 0 : expr.node.expression;
}

function addToFunctionOrVar(path, name, propsType, state) {
  const rootPath = core.types.isExportNamedDeclaration(path.parent) || core.types.isExportDefaultDeclaration(path.parent) ? path.parentPath : path;
  const defaultProps = findStaticProperty(rootPath, name, 'defaultProps');
  const defaultPropsKeyList = [];

  if (defaultProps && core.types.isAssignmentExpression(defaultProps) && core.types.isObjectExpression(defaultProps.right)) {
    defaultProps.right.properties.forEach(prop => {
      if (core.types.isProperty(prop) && core.types.isIdentifier(prop.key)) {
        defaultPropsKeyList.push(prop.key.name);
      }
    });
  }

  const typeNames = extractGenericTypeNames.extractGenericTypeNames(propsType);
  const propTypesList = convertBabelToPropTypes.convertToPropTypes(state.componentTypes, typeNames, state, defaultPropsKeyList);

  if (typeNames.length === 0 || propTypesList.length === 0) {
    return;
  }

  const propTypes$1 = findStaticProperty(rootPath, name, 'propTypes');

  if (propTypes$1) {
    propTypes$1.right = propTypes.mergePropTypes(propTypes$1.right, propTypesList, state);
  } else {
    rootPath.insertAfter(core.types.expressionStatement(core.types.assignmentExpression('=', core.types.memberExpression(core.types.identifier(name), core.types.identifier('propTypes')), propTypes.createPropTypesObject(propTypesList, state))));
  }
}

exports.addToFunctionOrVar = addToFunctionOrVar;
//# sourceMappingURL=addToFunctionOrVar.js.map
