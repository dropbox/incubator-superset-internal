'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const core = require('@babel/core');

const convertBabelToPropTypes = require('./convertBabelToPropTypes.js');

const extractGenericTypeNames = require('./extractGenericTypeNames.js');

const propTypes = require('./propTypes.js');

function findStaticProperty(node, name) {
  return node.body.body.find(property => core.types.isClassProperty(property, {
    static: true
  }) && core.types.isIdentifier(property.key, {
    name
  }) && (core.types.isObjectExpression(property.value) || core.types.isCallExpression(property.value)));
}

function addToClass(node, state) {
  if (!node.superTypeParameters || node.superTypeParameters.params.length <= 0) {
    return;
  }

  const defaultProps = findStaticProperty(node, 'defaultProps');
  const defaultPropsKeyList = [];

  if (defaultProps && core.types.isClassProperty(defaultProps) && core.types.isObjectExpression(defaultProps.value)) {
    defaultProps.value.properties.forEach(prop => {
      if (core.types.isProperty(prop) && core.types.isIdentifier(prop.key)) {
        defaultPropsKeyList.push(prop.key.name);
      }
    });
  }

  const typeNames = extractGenericTypeNames.extractGenericTypeNames(node.superTypeParameters.params[0]);
  const propTypesList = convertBabelToPropTypes.convertToPropTypes(state.componentTypes, typeNames, state, defaultPropsKeyList);

  if (typeNames.length === 0 || propTypesList.length === 0) {
    return;
  }

  const propTypes$1 = findStaticProperty(node, 'propTypes');

  if (propTypes$1) {
    if (core.types.isClassProperty(propTypes$1)) {
      propTypes$1.value = propTypes.mergePropTypes(propTypes$1.value, propTypesList, state);
    }
  } else {
    const staticProperty = core.types.classProperty(core.types.identifier('propTypes'), propTypes.createPropTypesObject(propTypesList, state));
    staticProperty.static = true;
    node.body.body.unshift(staticProperty);
  }
}

exports.addToClass = addToClass;
//# sourceMappingURL=addToClass.js.map
