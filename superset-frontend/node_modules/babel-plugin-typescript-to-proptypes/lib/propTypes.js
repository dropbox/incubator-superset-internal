'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const core = require('@babel/core');

function hasCustomPropTypeSuffix(name, suffixes) {
  return !!suffixes && suffixes.some(suffix => name.endsWith(suffix));
}

function isReactTypeMatch(name, type, reactImportedName) {
  return name === type || name === `React.${type}` || name === `${reactImportedName}.${type}`;
}

function wrapIsRequired(propType, optional) {
  return optional ? propType : core.types.memberExpression(propType, core.types.identifier('isRequired'));
}

function createMember(value, propTypesImportedName) {
  return core.types.memberExpression(core.types.identifier(propTypesImportedName), value);
}

function createCall(value, args, propTypesImportedName) {
  return core.types.callExpression(createMember(value, propTypesImportedName), args);
}

function createPropTypesObject(propTypes, state) {
  const object = core.types.objectExpression(propTypes); // Wrap with forbid

  return state.options.forbidExtraProps ? core.types.callExpression(core.types.identifier(state.airbnbPropTypes.forbidImport), [object]) : object;
}

function mergePropTypes(expr, propTypes, state, wrapForbid = true) {
  if (!expr) {
    return undefined;
  }

  if (core.types.isCallExpression(expr)) {
    if (core.types.isIdentifier(expr.callee, {
      name: 'forbidExtraProps'
    })) {
      expr.arguments.forEach((arg, index) => {
        expr.arguments[index] = mergePropTypes(arg, propTypes, state, false);
      });
    }

    return expr;
  }

  if (!core.types.isObjectExpression(expr)) {
    return undefined;
  }

  const properties = expr.properties;
  const existingProps = {}; // Extract existing props so that we don't duplicate

  properties.forEach(property => {
    if (core.types.isObjectProperty(property) && core.types.isIdentifier(property.key)) {
      existingProps[property.key.name] = true;
    }
  }); // Add to the beginning of the array so existing/custom prop types aren't overwritten

  propTypes.forEach(propType => {
    if (core.types.isIdentifier(propType.key) && !existingProps[propType.key.name]) {
      properties.unshift(propType);
    }
  }); // Wrap with forbid

  if (wrapForbid && state.options.forbidExtraProps) {
    return core.types.callExpression(core.types.identifier(state.airbnbPropTypes.forbidImport), [expr]);
  }

  return expr;
}

let installedVersion = 0;

function getInstalledPropTypesVersion() {
  if (installedVersion) {
    return installedVersion;
  }

  try {
    installedVersion = Number.parseFloat( // eslint-disable-next-line import/no-extraneous-dependencies
    require('prop-types/package.json').version);
  } catch {// Swallow
  }

  return installedVersion;
}

exports.createCall = createCall;
exports.createMember = createMember;
exports.createPropTypesObject = createPropTypesObject;
exports.getInstalledPropTypesVersion = getInstalledPropTypesVersion;
exports.hasCustomPropTypeSuffix = hasCustomPropTypeSuffix;
exports.isReactTypeMatch = isReactTypeMatch;
exports.mergePropTypes = mergePropTypes;
exports.wrapIsRequired = wrapIsRequired;
//# sourceMappingURL=propTypes.js.map
