// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: lib
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperties(exports, {
  __esModule: {
    value: true
  },
  [Symbol.toStringTag]: {
    value: 'Module'
  }
});

const Matcher = require('./bundle-8478b3b4.js');

const React = require('react');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const React__default = /*#__PURE__*/_interopDefault(React);

const TOKEN_LOCATIONS = ['no tokens', '{token}', ' {token} ', '{token} pattern at beginning', 'pattern at end {token}', 'pattern in {token} middle', '{token} pattern at beginning and end {token}', '{token} pattern on {token} all sides {token}', 'pattern {token} used {token} multiple {token} times', 'tokens next {token} {token} {token} to each other', 'token next to {token}, a comma', 'token by a period {token}.', 'token after a colon: {token}', 'token after a\n{token} new line', 'token before a {token}\n new line', 'token surrounded by ({token}) parenthesis' // 'tokens without {token}{token}{token} spaces',
];
const SOURCE_PROP = {
  compact: false,
  locale: 'en',
  version: '0.0.0'
};
const VALID_EMOJIS = [['1F621', '😡', ':rage:', '>:/'], ['1F468-200D-1F469-200D-1F467-200D-1F466', '👨‍👩‍👧‍👦', ':family_mwgb:'], ['1F1FA-1F1F8', '🇺🇸', ':flag_us:'], ['1F63A', '😺', ':grinning_cat:'], ['1F3EF', '🏯', ':japanese_castle:'], ['1F681', '🚁', ':helicopter:'], ['1F469-200D-2764-FE0F-200D-1F468', '👩‍❤️‍👨', ':couple_with_heart_mw:'], ['1F1E7-1F1F4', '🇧🇴', ':bolivia:'], ['1F468-200D-1F468-200D-1F466', '👨‍👨‍👦', ':family_mmb:'], ['1F3C0', '🏀', ':basketball:']];

function createExpectedToken(value, factory, index, join = false) {
  if (index === 0) {
    return TOKEN_LOCATIONS[0];
  }

  let count = -1;
  const tokens = TOKEN_LOCATIONS[index].split(/({token})/).map(row => {
    if (row === '{token}') {
      count += 1;
      return factory(value, count);
    }

    return row;
  }).filter(Boolean);
  return join ? tokens.join('') : tokens;
}

const MOCK_MARKUP = `<main role="main">
  Main content
  <div>
    <a href="#">Link</a>
    <span class="foo">String</span>
  </div>
</main>
<aside id="sidebar">
  Sidebar content
</aside>`;
const MOCK_INVALID_MARKUP = `<div bgcolor="black">
  <font color="red">Outdated font.</font>
  <script type="text/javascript"></script>
  <p align="center">More text <strike>with outdated stuff</strike>.</p>
</div>`;
const parentConfig = {
  children: [],
  content: 0,
  invalid: [],
  parent: [],
  self: true,
  tagName: 'div',
  type: 0,
  void: false,
  ...Matcher.TAGS.div
};

function matchCodeTag(string, tag) {
  const matches = string.match(new RegExp(`\\[${tag}\\]`));

  if (!matches) {
    return null;
  }

  return {
    children: tag,
    customProp: 'foo',
    index: matches.index,
    length: matches[0].length,
    match: matches[0],
    valid: true,
    void: false
  };
}

class CodeTagMatcher extends Matcher.Matcher {
  constructor(tag, key = '') {
    super(tag, {});

    _defineProperty(this, "tag", void 0);

    _defineProperty(this, "key", void 0);

    this.tag = tag;
    this.key = key;
  }

  replaceWith(match, props = {}) {
    const {
      children
    } = props;

    if (this.key) {
      // eslint-disable-next-line no-param-reassign
      props.key = this.key;
    }

    return /*#__PURE__*/React__default.default.createElement(Matcher.Element, Matcher._extends({
      tagName: "span"
    }, props), children.toUpperCase());
  }

  asTag() {
    return 'span';
  }

  match(string) {
    return matchCodeTag(string, this.tag);
  }

}

class MarkdownBoldMatcher extends Matcher.Matcher {
  replaceWith(children, props) {
    return /*#__PURE__*/React__default.default.createElement("b", props, children);
  }

  asTag() {
    return 'b';
  }

  match(value) {
    return this.doMatch(value, /\*\*([^*]+)\*\*/u, matches => ({
      match: matches[1]
    }));
  }

}

class MarkdownItalicMatcher extends Matcher.Matcher {
  replaceWith(children, props) {
    return /*#__PURE__*/React__default.default.createElement("i", props, children);
  }

  asTag() {
    return 'i';
  }

  match(value) {
    return this.doMatch(value, /_([^_]+)_/u, matches => ({
      match: matches[1]
    }));
  }

}

class MockMatcher extends Matcher.Matcher {
  replaceWith(children, props) {
    return /*#__PURE__*/React__default.default.createElement("div", props, children);
  }

  asTag() {
    return 'div';
  }

  match() {
    return null;
  }

}

class LinkFilter extends Matcher.Filter {
  attribute(name, value) {
    if (name === 'href') {
      return value.replace('foo.com', 'bar.net');
    }

    return value;
  }

  node(name, node) {
    if (name === 'a') {
      node.setAttribute('target', '_blank');
    } else if (name === 'link') {
      return null;
    }

    return node;
  }

}

class MockFilter extends Matcher.Filter {}

exports.CodeTagMatcher = CodeTagMatcher;
exports.LinkFilter = LinkFilter;
exports.MOCK_INVALID_MARKUP = MOCK_INVALID_MARKUP;
exports.MOCK_MARKUP = MOCK_MARKUP;
exports.MarkdownBoldMatcher = MarkdownBoldMatcher;
exports.MarkdownItalicMatcher = MarkdownItalicMatcher;
exports.MockFilter = MockFilter;
exports.MockMatcher = MockMatcher;
exports.SOURCE_PROP = SOURCE_PROP;
exports.TOKEN_LOCATIONS = TOKEN_LOCATIONS;
exports.VALID_EMOJIS = VALID_EMOJIS;
exports.createExpectedToken = createExpectedToken;
exports.matchCodeTag = matchCodeTag;
exports.parentConfig = parentConfig;
//# sourceMappingURL=test.js.map
