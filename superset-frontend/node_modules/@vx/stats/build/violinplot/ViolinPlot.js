'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = ViolinPlot;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _group = require('@vx/group');

var _scale = require('@vx/scale');

var _d3Shape = require('d3-shape');

var _additionalProps = require('../util/additionalProps');

var _additionalProps2 = _interopRequireDefault(_additionalProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function ViolinPlot(_ref) {
  var _ref$left = _ref.left,
      left = _ref$left === undefined ? 0 : _ref$left,
      _ref$top = _ref.top,
      top = _ref$top === undefined ? 0 : _ref$top,
      className = _ref.className,
      binData = _ref.binData,
      _ref$stroke = _ref.stroke,
      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,
      _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,
      opacity = _ref.opacity,
      strokeWidth = _ref.strokeWidth,
      width = _ref.width,
      valueScale = _ref.valueScale,
      strokeDasharray = _ref.strokeDasharray,
      horizontal = _ref.horizontal,
      restProps = _objectWithoutProperties(_ref, ['left', 'top', 'className', 'binData', 'stroke', 'fill', 'opacity', 'strokeWidth', 'width', 'valueScale', 'strokeDasharray', 'horizontal']);

  var center = (horizontal ? top : left) + width / 2;
  var binCounts = binData.map(function (bin) {
    return bin.count;
  });
  var widthScale = (0, _scale.scaleLinear)({
    rangeRound: [0, width / 2],
    domain: [0, Math.max.apply(Math, _toConsumableArray(binCounts))]
  });

  var path = '';
  if (horizontal) {
    var topCurve = (0, _d3Shape.line)().x(function (d) {
      return valueScale(d.value);
    }).y(function (d) {
      return center - widthScale(d.count);
    }).curve(_d3Shape.curveCardinal);

    var bottomCurve = (0, _d3Shape.line)().x(function (d) {
      return valueScale(d.value);
    }).y(function (d) {
      return center + widthScale(d.count);
    }).curve(_d3Shape.curveCardinal);

    var topCurvePath = topCurve(binData);
    var bottomCurvePath = bottomCurve([].concat(_toConsumableArray(binData)).reverse());
    path = topCurvePath + ' ' + bottomCurvePath.replace('M', 'L') + ' Z';
  } else {
    var rightCurve = (0, _d3Shape.line)().x(function (d) {
      return center + widthScale(d.count);
    }).y(function (d) {
      return valueScale(d.value);
    }).curve(_d3Shape.curveCardinal);

    var leftCurve = (0, _d3Shape.line)().x(function (d) {
      return center - widthScale(d.count);
    }).y(function (d) {
      return valueScale(d.value);
    }).curve(_d3Shape.curveCardinal);

    var rightCurvePath = rightCurve(binData);
    var leftCurvePath = leftCurve([].concat(_toConsumableArray(binData)).reverse());
    path = rightCurvePath + ' ' + leftCurvePath.replace('M', 'L') + ' Z';
  }
  return _react2.default.createElement(
    _group.Group,
    { className: (0, _classnames2.default)('vx-violin', className) },
    _react2.default.createElement('path', _extends({
      d: path,
      stroke: stroke,
      strokeWidth: strokeWidth,
      strokeDasharray: strokeDasharray,
      fill: fill,
      fillOpacity: opacity
    }, (0, _additionalProps2.default)(restProps, binData)))
  );
}