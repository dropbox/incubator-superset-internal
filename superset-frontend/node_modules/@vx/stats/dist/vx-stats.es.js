import React from 'react';
import classnames from 'classnames';
import { Group } from '@vx/group';
import { scaleLinear } from '@vx/scale';
import { line, curveCardinal } from 'd3-shape';

function callOrValue(maybeFn, data) {
  if (typeof maybeFn === 'function') {
    return maybeFn(data);
  }
  return maybeFn;
}

function additionalProps(restProps, data) {
  return Object.keys(restProps).reduce(function (ret, cur) {
    ret[cur] = callOrValue(restProps[cur], data);
    return ret;
  }, {});
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function verticalToHorizontal(_ref) {
  var _ref2 = slicedToArray(_ref, 4),
      x1 = _ref2[0],
      y1 = _ref2[1],
      x2 = _ref2[2],
      y2 = _ref2[3];

  return [y1, x1, y2, x2];
}

function BoxPlot(_ref3) {
  var _ref3$left = _ref3.left,
      left = _ref3$left === undefined ? 0 : _ref3$left,
      _ref3$top = _ref3.top,
      top = _ref3$top === undefined ? 0 : _ref3$top,
      className = _ref3.className,
      data = _ref3.data,
      max = _ref3.max,
      min = _ref3.min,
      firstQuartile = _ref3.firstQuartile,
      thirdQuartile = _ref3.thirdQuartile,
      median = _ref3.median,
      boxWidth = _ref3.boxWidth,
      fill = _ref3.fill,
      fillOpacity = _ref3.fillOpacity,
      stroke = _ref3.stroke,
      strokeWidth = _ref3.strokeWidth,
      _ref3$rx = _ref3.rx,
      rx = _ref3$rx === undefined ? 2 : _ref3$rx,
      _ref3$ry = _ref3.ry,
      ry = _ref3$ry === undefined ? 2 : _ref3$ry,
      valueScale = _ref3.valueScale,
      outliers = _ref3.outliers,
      horizontal = _ref3.horizontal,
      _ref3$medianProps = _ref3.medianProps,
      medianProps = _ref3$medianProps === undefined ? {} : _ref3$medianProps,
      _ref3$maxProps = _ref3.maxProps,
      maxProps = _ref3$maxProps === undefined ? {} : _ref3$maxProps,
      _ref3$minProps = _ref3.minProps,
      minProps = _ref3$minProps === undefined ? {} : _ref3$minProps,
      _ref3$boxProps = _ref3.boxProps,
      boxProps = _ref3$boxProps === undefined ? {} : _ref3$boxProps,
      _ref3$outlierProps = _ref3.outlierProps,
      outlierProps = _ref3$outlierProps === undefined ? {} : _ref3$outlierProps,
      _ref3$container = _ref3.container,
      container = _ref3$container === undefined ? false : _ref3$container,
      _ref3$containerProps = _ref3.containerProps,
      containerProps = _ref3$containerProps === undefined ? {} : _ref3$containerProps,
      restProps = objectWithoutProperties(_ref3, ['left', 'top', 'className', 'data', 'max', 'min', 'firstQuartile', 'thirdQuartile', 'median', 'boxWidth', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'rx', 'ry', 'valueScale', 'outliers', 'horizontal', 'medianProps', 'maxProps', 'minProps', 'boxProps', 'outlierProps', 'container', 'containerProps']);

  var offset = horizontal ? top : left;
  var center = offset + boxWidth / 2;

  var maxLinePos = Array(4).fill(0);
  var maxToBoxLinePos = Array(4).fill(0);
  var boxPos = Array(4).fill(0);
  var medianLinePos = Array(4).fill(0);
  var minToBoxLinePos = Array(4).fill(0);
  var minLinePos = Array(4).fill(0);
  var containerPos = Array(4).fill(0);

  // all of these are [x0, y0, x1, y1]
  maxLinePos[0] = center - boxWidth / 4;
  maxLinePos[1] = valueScale(max);
  maxLinePos[2] = center + boxWidth / 4;
  maxLinePos[3] = valueScale(max);

  maxToBoxLinePos[0] = center;
  maxToBoxLinePos[1] = valueScale(max);
  maxToBoxLinePos[2] = center;
  maxToBoxLinePos[3] = valueScale(thirdQuartile);

  boxPos[0] = offset;
  boxPos[1] = valueScale(thirdQuartile);
  boxPos[2] = boxWidth;
  boxPos[3] = Math.abs(valueScale(thirdQuartile) - valueScale(firstQuartile));

  medianLinePos[0] = offset;
  medianLinePos[1] = valueScale(median);
  medianLinePos[2] = offset + boxWidth;
  medianLinePos[3] = valueScale(median);

  minToBoxLinePos[0] = center;
  minToBoxLinePos[1] = valueScale(firstQuartile);
  minToBoxLinePos[2] = center;
  minToBoxLinePos[3] = valueScale(min);

  minLinePos[0] = center - boxWidth / 4;
  minLinePos[1] = valueScale(min);
  minLinePos[2] = center + boxWidth / 4;
  minLinePos[3] = valueScale(min);

  var valueRange = valueScale.range();
  containerPos[0] = boxPos[0];
  containerPos[1] = Math.min.apply(Math, toConsumableArray(valueRange));
  containerPos[2] = boxPos[2];
  containerPos[3] = Math.abs(valueRange[0] - valueRange[1]);

  if (horizontal) {
    maxLinePos = verticalToHorizontal(maxLinePos);
    maxToBoxLinePos = verticalToHorizontal(maxToBoxLinePos);
    boxPos = verticalToHorizontal(boxPos);
    boxPos[0] = valueScale(firstQuartile);
    medianLinePos = verticalToHorizontal(medianLinePos);
    minToBoxLinePos = verticalToHorizontal(minToBoxLinePos);
    minLinePos = verticalToHorizontal(minLinePos);
    containerPos = verticalToHorizontal(containerPos);
    containerPos[0] = Math.min.apply(Math, toConsumableArray(valueRange));
  }
  return React.createElement(
    Group,
    { className: classnames('vx-boxplot', className) },
    outliers.map(function (d, i) {
      var cx = horizontal ? valueScale(d) : center;
      var cy = horizontal ? center : valueScale(d);
      return React.createElement('circle', _extends({
        key: i,
        className: 'vx-boxplot-outlier',
        cx: cx,
        cy: cy,
        stroke: stroke,
        strokeWidth: 1,
        fill: fill,
        fillOpacity: fillOpacity,
        r: '4'
      }, additionalProps(outlierProps, {
        data: d,
        cx: cx,
        cy: cy
      })));
    }),
    React.createElement('line', _extends({
      className: 'vx-boxplot-max',
      x1: maxLinePos[0],
      y1: maxLinePos[1],
      x2: maxLinePos[2],
      y2: maxLinePos[3],
      stroke: stroke,
      strokeWidth: strokeWidth
    }, additionalProps(maxProps, {
      data: data,
      max: max,
      x1: maxLinePos[0],
      x2: maxLinePos[2],
      y1: maxLinePos[1],
      y2: maxLinePos[3]
    }))),
    React.createElement('line', {
      x1: maxToBoxLinePos[0],
      y1: maxToBoxLinePos[1],
      x2: maxToBoxLinePos[2],
      y2: maxToBoxLinePos[3],
      stroke: stroke,
      strokeWidth: strokeWidth
    }),
    React.createElement('rect', _extends({
      className: 'vx-boxplot-box',
      x: boxPos[0],
      y: boxPos[1],
      width: boxPos[2],
      height: boxPos[3],
      stroke: stroke,
      strokeWidth: strokeWidth,
      fill: fill,
      fillOpacity: fillOpacity,
      rx: rx,
      ry: ry
    }, additionalProps(boxProps, {
      data: data,
      height: boxPos[3],
      median: median,
      firstQuartile: firstQuartile,
      thirdQuartile: thirdQuartile,
      min: min,
      max: max,
      x1: boxPos[0],
      x2: boxPos[0] + boxPos[2],
      y1: boxPos[1],
      y2: boxPos[1] + boxPos[3]
    }))),
    React.createElement('line', _extends({
      className: 'vx-boxplot-median',
      x1: medianLinePos[0],
      y1: medianLinePos[1],
      x2: medianLinePos[2],
      y2: medianLinePos[3],
      stroke: stroke,
      strokeWidth: strokeWidth
    }, additionalProps(medianProps, {
      data: data,
      median: median,
      x1: medianLinePos[0],
      x2: medianLinePos[2],
      y1: medianLinePos[1],
      y2: medianLinePos[3]
    }))),
    React.createElement('line', {
      x1: minToBoxLinePos[0],
      y1: minToBoxLinePos[1],
      x2: minToBoxLinePos[2],
      y2: minToBoxLinePos[3],
      stroke: stroke,
      strokeWidth: strokeWidth
    }),
    React.createElement('line', _extends({
      className: 'vx-boxplot-min',
      x1: minLinePos[0],
      y1: minLinePos[1],
      x2: minLinePos[2],
      y2: minLinePos[3],
      stroke: stroke,
      strokeWidth: strokeWidth
    }, additionalProps(minProps, {
      data: data,
      min: min,
      x1: minLinePos[0],
      x2: minLinePos[2],
      y1: minLinePos[1],
      y2: minLinePos[3]
    }))),
    container && React.createElement('rect', _extends({
      x: containerPos[0],
      y: containerPos[1],
      width: containerPos[2],
      height: containerPos[3],
      fillOpacity: '0'
    }, additionalProps(containerProps, {
      data: data,
      x1: containerPos[0],
      x2: containerPos[0] + containerPos[2],
      y1: containerPos[1],
      y2: containerPos[1] + containerPos[3],
      median: median,
      max: max,
      min: min,
      thirdQuartile: thirdQuartile,
      firstQuartile: firstQuartile
    })))
  );
}

function ViolinPlot(_ref) {
  var _ref$left = _ref.left,
      left = _ref$left === undefined ? 0 : _ref$left,
      _ref$top = _ref.top,
      top = _ref$top === undefined ? 0 : _ref$top,
      className = _ref.className,
      binData = _ref.binData,
      _ref$stroke = _ref.stroke,
      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,
      _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,
      opacity = _ref.opacity,
      strokeWidth = _ref.strokeWidth,
      width = _ref.width,
      valueScale = _ref.valueScale,
      strokeDasharray = _ref.strokeDasharray,
      horizontal = _ref.horizontal,
      restProps = objectWithoutProperties(_ref, ['left', 'top', 'className', 'binData', 'stroke', 'fill', 'opacity', 'strokeWidth', 'width', 'valueScale', 'strokeDasharray', 'horizontal']);

  var center = (horizontal ? top : left) + width / 2;
  var binCounts = binData.map(function (bin) {
    return bin.count;
  });
  var widthScale = scaleLinear({
    rangeRound: [0, width / 2],
    domain: [0, Math.max.apply(Math, toConsumableArray(binCounts))]
  });

  var path = '';
  if (horizontal) {
    var topCurve = line().x(function (d) {
      return valueScale(d.value);
    }).y(function (d) {
      return center - widthScale(d.count);
    }).curve(curveCardinal);

    var bottomCurve = line().x(function (d) {
      return valueScale(d.value);
    }).y(function (d) {
      return center + widthScale(d.count);
    }).curve(curveCardinal);

    var topCurvePath = topCurve(binData);
    var bottomCurvePath = bottomCurve([].concat(toConsumableArray(binData)).reverse());
    path = topCurvePath + ' ' + bottomCurvePath.replace('M', 'L') + ' Z';
  } else {
    var rightCurve = line().x(function (d) {
      return center + widthScale(d.count);
    }).y(function (d) {
      return valueScale(d.value);
    }).curve(curveCardinal);

    var leftCurve = line().x(function (d) {
      return center - widthScale(d.count);
    }).y(function (d) {
      return valueScale(d.value);
    }).curve(curveCardinal);

    var rightCurvePath = rightCurve(binData);
    var leftCurvePath = leftCurve([].concat(toConsumableArray(binData)).reverse());
    path = rightCurvePath + ' ' + leftCurvePath.replace('M', 'L') + ' Z';
  }
  return React.createElement(
    Group,
    { className: classnames('vx-violin', className) },
    React.createElement('path', _extends({
      d: path,
      stroke: stroke,
      strokeWidth: strokeWidth,
      strokeDasharray: strokeDasharray,
      fill: fill,
      fillOpacity: opacity
    }, additionalProps(restProps, binData)))
  );
}

function computeStats (numericalArray) {
  var points = [].concat(toConsumableArray(numericalArray)).sort(function (a, b) {
    return a - b;
  });
  var sampleSize = points.length;
  var firstQuartile = points[Math.round(sampleSize / 4)];
  var thirdQuartile = points[Math.round(3 * sampleSize / 4)];
  var IQR = thirdQuartile - firstQuartile;

  var min = firstQuartile - 1.5 * IQR;
  var max = thirdQuartile + 1.5 * IQR;

  var outliers = points.filter(function (p) {
    return p < min || p > max;
  });
  var binWidth = 2 * IQR * Math.pow(sampleSize - outliers.length, -1 / 3);
  var binNum = Math.round((max - min) / binWidth);
  var actualBinWidth = (max - min) / binNum;

  var bins = Array(binNum + 2).fill(0);
  var values = Array(binNum + 2).fill(min);

  for (var i = 1; i <= binNum; i += 1) {
    values[i] += actualBinWidth * (i - 0.5);
  }

  values[values.length - 1] = max;

  points.filter(function (p) {
    return p >= min && p <= max;
  }).forEach(function (p) {
    bins[Math.floor((p - min) / actualBinWidth) + 1] += 1;
  });

  var binData = values.map(function (v, i) {
    return {
      value: v,
      count: bins[i]
    };
  });

  var boxPlot = {
    min: min,
    firstQuartile: firstQuartile,
    median: points[Math.round(sampleSize / 2)],
    thirdQuartile: thirdQuartile,
    max: max,
    outliers: outliers
  };

  return {
    boxPlot: boxPlot,
    binData: binData
  };
}

export { BoxPlot, ViolinPlot, computeStats };
