{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["toRadians","WGS84_RADIUS_X","qualityFactor","Math","PI","lodJudge","tile","frameState","viewport","metersPerPixel","mbsLat","header","mbs","mbsLon","mbsZ","mbsR","height","width","latitude","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","sqrt","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","lodMetricValue","screenSize","getI3ScreenSize","children","projectVertexToSphere","x","y","z","azim","incl","radius","radCosInc","cos","sin","observer","center","observerLon","observerLat","observerZ","centerLon","centerLat","centerZ","projectedCenter","projectedObserver","dx","dy","dz","cameraPositionCartographic","unprojectPosition","cameraPosition","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","getTanOfHalfVFAngle","projectionMatrix","t"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer: number[], center: number[]) {\n  const [observerLon, observerLat, observerZ = 0.0] = observer;\n  const [centerLon, centerLat, centerZ = 0.0] = center;\n\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  // There is a formula there to calculate projected radius:\n  // return 1.0 / Math.tan(fov) * r / Math.sqrt(d * d - r * r); // Right\n  // Hack: 300 is a Magic number to get the correct LoD. Possibly, d and r are calculated in a wrong way.\n  const screenSizeFactor =\n    ((getTanOfHalfVFAngle(frameState) * mbsRNormalized) / Math.sqrt(d)) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  const {projectionMatrix} = frameState.viewport;\n  const t = projectionMatrix[5];\n  return t;\n}\n"],"file":"i3s-lod.js"}