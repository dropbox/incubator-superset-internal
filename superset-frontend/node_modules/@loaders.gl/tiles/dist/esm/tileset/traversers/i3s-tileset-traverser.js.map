{"version":3,"sources":["../../../../src/tileset/traversers/i3s-tileset-traverser.ts"],"names":["load","TilesetTraverser","lodJudge","TileHeader","I3STileManager","I3STilesetTraverser","constructor","options","_tileManager","shouldRefine","tile","frameState","_lodJudge","updateChildTiles","children","header","childTiles","tileset","child","extendedId","id","viewport","childTile","find","t","request","_loadTile","cachedRequest","nodePages","nodePagesTile","formTileFromNodePages","add","_onTileLoad","update","updateTile","nodeId","loader","nodeUrl","getTileUrl","url","loadOptions","i3s","isTileHeader","loadContent","push","_frameNumber","frameNumber","executeTraversal"],"mappings":"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","sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {lodJudge} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    // TODO refactor loaJudge\n    tile._lodJudge = lodJudge(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init TileHeader instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {TileHeader} tile - the parent TileHeader instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"],"file":"i3s-tileset-traverser.js"}