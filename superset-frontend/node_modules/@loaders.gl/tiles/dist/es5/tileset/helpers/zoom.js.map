{"version":3,"sources":["../../../../src/tileset/helpers/zoom.ts"],"names":["WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","Vector3","getZoomFromBoundingVolume","boundingVolume","halfAxes","radius","width","height","obbSize","getObbSize","Math","log2","zoomX","zoomY","getColumn","axeY","axeZ","farthestVertex","add","size","len"],"mappings":";;;;;;;AAAA;;AAEA,IAAMA,cAAc,GAAG,SAAvB;AACA,IAAMC,cAAc,GAAG,SAAvB;AACA,IAAMC,cAAc,GAAG,kBAAvB;AAEA,IAAMC,aAAa,GAAG,IAAIC,aAAJ,EAAtB;;AAOO,SAASC,yBAAT,CAAmCC,cAAnC,EAAmD;AACxD,MAAOC,QAAP,GAA0CD,cAA1C,CAAOC,QAAP;AAAA,MAAiBC,MAAjB,GAA0CF,cAA1C,CAAiBE,MAAjB;AAAA,MAAyBC,KAAzB,GAA0CH,cAA1C,CAAyBG,KAAzB;AAAA,MAAgCC,MAAhC,GAA0CJ,cAA1C,CAAgCI,MAAhC;;AAEA,MAAIH,QAAJ,EAAc;AAEZ,QAAMI,OAAO,GAAGC,UAAU,CAACL,QAAD,CAA1B;AAEA,WAAOM,IAAI,CAACC,IAAL,CAAUZ,cAAc,GAAGS,OAA3B,CAAP;AACD,GALD,MAKO,IAAIH,MAAJ,EAAY;AAEjB,WAAOK,IAAI,CAACC,IAAL,CAAUZ,cAAc,GAAGM,MAA3B,CAAP;AACD,GAHM,MAGA,IAAIE,MAAM,IAAID,KAAd,EAAqB;AAE1B,QAAMM,KAAK,GAAGF,IAAI,CAACC,IAAL,CAAUd,cAAc,GAAGS,KAA3B,CAAd;AACA,QAAMO,KAAK,GAAGH,IAAI,CAACC,IAAL,CAAUb,cAAc,GAAGS,MAA3B,CAAd;AAEA,WAAO,CAACK,KAAK,GAAGC,KAAT,IAAkB,CAAzB;AACD;;AAED,SAAO,CAAP;AACD;;AAED,SAASJ,UAAT,CAAoBL,QAApB,EAA8B;AAC5BA,EAAAA,QAAQ,CAACU,SAAT,CAAmB,CAAnB,EAAsBd,aAAtB;AACA,MAAMe,IAAI,GAAGX,QAAQ,CAACU,SAAT,CAAmB,CAAnB,CAAb;AACA,MAAME,IAAI,GAAGZ,QAAQ,CAACU,SAAT,CAAmB,CAAnB,CAAb;AACA,MAAMG,cAAc,GAAGjB,aAAa,CAACkB,GAAd,CAAkBH,IAAlB,EAAwBG,GAAxB,CAA4BF,IAA5B,CAAvB;AACA,MAAMG,IAAI,GAAGF,cAAc,CAACG,GAAf,EAAb;AACA,SAAOD,IAAP;AACD","sourcesContent":["import {Vector3} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param {BoundingSphere, OrientedBoundingBox} boundingVolume - the instance of bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume) {\n  const {halfAxes, radius, width, height} = boundingVolume;\n\n  if (halfAxes) {\n    // OrientedBoundingBox\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    return Math.log2(WGS84_RADIUS_Z / obbSize);\n  } else if (radius) {\n    // BoundingSphere\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    // BoundingRectangle\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n"],"file":"zoom.js"}