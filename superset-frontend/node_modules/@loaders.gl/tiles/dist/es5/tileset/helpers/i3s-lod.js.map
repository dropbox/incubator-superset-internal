{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["WGS84_RADIUS_X","qualityFactor","Math","PI","lodJudge","tile","frameState","viewport","metersPerPixel","mbsLat","header","mbs","mbsLon","mbsZ","mbsR","height","width","latitude","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","sqrt","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","lodMetricValue","screenSize","getI3ScreenSize","children","projectVertexToSphere","x","y","z","azim","incl","radius","radCosInc","cos","sin","observer","center","observerLon","observerLat","observerZ","centerLon","centerLat","centerZ","projectedCenter","projectedObserver","dx","dy","dz","cameraPositionCartographic","unprojectPosition","cameraPosition","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","getTanOfHalfVFAngle","projectionMatrix","t"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(observer: number[], center: number[]) {\n  const [observerLon, observerLat, observerZ = 0.0] = observer;\n  const [centerLon, centerLat, centerZ = 0.0] = center;\n\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  // There is a formula there to calculate projected radius:\n  // return 1.0 / Math.tan(fov) * r / Math.sqrt(d * d - r * r); // Right\n  // Hack: 300 is a Magic number to get the correct LoD. Possibly, d and r are calculated in a wrong way.\n  const screenSizeFactor =\n    ((getTanOfHalfVFAngle(frameState) * mbsRNormalized) / Math.sqrt(d)) * 300;\n  return screenSizeFactor;\n}\n\nfunction getTanOfHalfVFAngle(frameState) {\n  const {projectionMatrix} = frameState.viewport;\n  const t = projectionMatrix[5];\n  return t;\n}\n"],"file":"i3s-lod.js"}