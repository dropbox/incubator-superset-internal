{"version":3,"sources":["../../../../src/lib/worker-api/create-worker.ts"],"names":["requestId","inputBatches","options","createWorker","process","processInBatches","self","context","processOnMainThread","WorkerBody","onmessage","type","payload","Error","input","result","postMessage","AsyncQueue","resultIterator","batch","push","close","message","error","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"],"file":"create-worker.js"}