import WorkerFarm from '../worker-farm/worker-farm';
import { removeNontransferableOptions } from '../worker-utils/remove-nontransferable-options';
import { getWorkerURL, getWorkerName } from './get-worker-url';
export function canProcessOnWorker(worker, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
export async function processOnWorker(worker, data, options = {}, context = {}) {
  const name = getWorkerName(worker);
  const url = getWorkerURL(worker, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
  const transferableOptions = removeNontransferableOptions(options);
  job.postMessage('process', {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}

async function onMessage(context, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;

    case 'error':
      job.error(payload.error);
      break;

    case 'process':
      const {
        id,
        input,
        options
      } = payload;

      try {
        if (!context.process) {
          job.postMessage('error', {
            id,
            error: 'Worker not set up to process on main thread'
          });
          return;
        }

        const result = await context.process(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }

      break;

    default:
      console.warn(`process-on-worker: unknown message ${type}`);
  }
}
//# sourceMappingURL=process-on-worker.js.map