{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lib/schema/index.ts","webpack:///./src/lib/table/row-table-batch-aggregator.ts","webpack:///./src/lib/utils/row-utils.ts","webpack:///./src/lib/table/columnar-table-batch-aggregator.ts","webpack:///./src/bundle.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/index.ts","webpack:///./src/lib/table/table-batch-builder.ts","webpack:///./src/lib/table/base-table-batch-aggregator.ts","webpack:///./src/category/mesh/mesh-utils.ts","webpack:///./src/lib/schema/impl/schema.ts","webpack:///./src/lib/utils/assert.ts","webpack:///./src/lib/schema/impl/field.ts","webpack:///./src/lib/schema/impl/type.ts","webpack:///./src/lib/schema/impl/enum.ts","webpack:///./src/lib/schema-utils/deduce-table-schema.ts","webpack:///./src/lib/schema-utils/get-type-info.ts","webpack:///./src/lib/schema-utils/type-utils.ts","webpack:///./src/lib/utils/async-queue.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RowTableBatchAggregator","schema","options","this","Array","isArray","_headers","index","length","row","cursor","Number","isFinite","shape","rowObject","convertToObjectRow","addObjectRow","arrayRows","rowArray","convertToArrayRow","addArrayRow","objectRows","rows","slice","batchType","data","arrayRow","headers","Error","objectRow","ColumnarTableBatchAggregator","_reallocateColumns","fieldName","columns","_pruneColumns","field","allocated","ArrayType","type","Float32Array","oldColumn","ArrayBuffer","isView","typedArray","set","entries","columnName","column","moduleExports","require","_global","window","global","loaders","assign","g","Function","e","DEFAULT_OPTIONS","batchSize","batchDebounceMs","limit","_limitMB","TableBatchBuilder","Date","now","Boolean","totalLength","totalBytes","limitReached","rowBytes","_estimateRowMB","aggregator","TableBatchType","_getTableBatchType","chunk","bytesUsed","byteLength","isChunkComplete","_isFull","_getBatch","keys","rowCount","lastBatchEmittedMs","normalizedBatch","getBatch","count","batchCount","BaseTableBatchAggregator","ArrowBatch","attributes","size","attributeName","attribute","BYTES_PER_ELEMENT","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","POSITION","len","x","y","z","Schema","fields","metadata","assert","usedNames","console","warn","checkNames","Map","other","compareTo","nameMap","columnNames","selectedFields","filter","columnIndices","map","schemaOrFields","otherSchema","mergeMaps","fieldMap","values","m1","m2","condition","message","Field","nullable","typeId","DataType","Type","NONE","Null","Int","Float","Binary","Utf8","Bool","Decimal","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Dictionary","isSigned","bitWidth","Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Precision","precision","Float16","Float32","Float64","DateUnit","DAY","MILLISECOND","unit","DateDay","DateMillisecond","TimeUnit","SECOND","MICROSECOND","NANOSECOND","TimeSecond","TimeMillisecond","timezone","TimestampSecond","TimestampMillisecond","TimestampMicrosecond","TimestampNanosecond","IntervalUnit","DAY_TIME","YEAR_MONTH","IntervalDayTime","IntervalYearMonth","listSize","child","children","valueType","deduceTypeFromValue","String","table","deducedSchema","rowTable","deduceSchemaForRowTable","columnarTable","constructor","deduceSchemaForColumnarTable","arrowTypeLike","typeName","toString","typeEnumName","getTypeKey","ReverseType","typeKey","array","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float64Array","ArrayQueue","push","shift","asyncIterator","AsyncQueue","_values","_settlers","_closed","dequeue","resolve","done","settler","reject","enqueue","Promise","asyncIterable","result","iterator","next"],"mappings":"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","file":"dist.es5.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/*\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  TimeMicrosecond,\n  TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from 'apache-arrow';\n*/\nexport {default as Schema} from './impl/schema';\nexport {default as Field} from './impl/field';\nexport {Type} from './impl/type';\nexport {\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  // TimeMicrosecond,\n  // TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './impl/type';\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n","/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n","import type {Schema} from '../schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// COMMON CATEGORY\nexport type {TypedArray, NumberArray, AnyArray} from './types';\n\nexport type {Batch} from './category/common';\n\n// TABLE CATEGORY TYPES\n\nexport type {\n  Table,\n  ArrayRowTable,\n  ObjectRowTable,\n  ColumnarTable,\n  ArrowTable\n} from './category/table';\nexport type {\n  TableBatch,\n  RowArrayTableBatch,\n  RowObjectTableBatch,\n  ColumnarTableBatch,\n  ArrowTableBatch\n} from './category/table';\n\n// TABLE CATEGORY UTILS\nexport {default as TableBatchBuilder} from './lib/table/table-batch-builder';\nexport type {TableBatchAggregator} from './lib/table/table-batch-aggregator';\nexport {default as RowTableBatchAggregator} from './lib/table/row-table-batch-aggregator';\nexport {default as ColumnarTableBatchAggregator} from './lib/table/columnar-table-batch-aggregator';\n\nexport {convertToObjectRow, convertToArrayRow} from './lib/utils/row-utils';\n\n// MESH CATEGORY\nexport type {MeshTable, MeshArrowTable, Mesh, MeshAttribute} from './category/mesh';\n\n// MESH CATEGORY UTILS\nexport type {Attributes as _Attributes} from './category/mesh/mesh-utils';\nexport {getMeshSize, getMeshBoundingBox} from './category/mesh/mesh-utils';\n\n// TYPES\n// GIS CATEGORY - GEOJSON\nexport type {GeoJSON, Feature, Geometry, Position, GeoJsonProperties} from './category/gis';\nexport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from './category/gis';\n\n// GIS CATEGORY - BINARY\nexport type {\n  BinaryGeometryType,\n  BinaryGeometry,\n  BinaryPointGeometry,\n  BinaryLineGeometry,\n  BinaryPolygonGeometry,\n  BinaryAttribute\n} from './category/gis';\nexport type {\n  BinaryFeatures,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures\n} from './category/gis';\n\n// SCHEMA\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Binary,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeMillisecond,\n  TimeSecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './lib/schema';\n\n// SCHEMA UTILS\nexport {deduceTableSchema} from './lib/schema-utils/deduce-table-schema';\nexport {getTypeInfo} from './lib/schema-utils/get-type-info';\nexport {getArrowTypeFromTypedArray} from './lib/schema-utils/type-utils';\n\n// EXPERIMENTAL APIs\nexport {default as AsyncQueue} from './lib/utils/async-queue';\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: number;\n  readonly bitWidth: number;\n\n  constructor(unit, bitWidth) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n","// Type deduction\nimport {\n  Schema\n  // Int,\n  // Int8,\n  // Int16,\n  // Int32,\n  // Uint8,\n  // Uint16,\n  // Uint32,\n  // Float32,\n  // Float64\n  // Bool,\n  // Utf8,\n  // TimestampMillisecond,\n  // Null\n} from '../schema';\n\n// const TYPED_ARRAY_TO_TYPE = {\n//   Int8Array: new Int8(),\n//   Int16Array: new Int16(),\n//   Int32Array: new Int32(),\n//   Uint8Array: new Uint8(),\n//   Uint8ClampedArray: new Uint8(),\n//   Uint16Array: new Uint16(),\n//   Uint32Array: new Uint32(),\n//   Float32Array: new Float32(),\n//   Float64Array: new Float64()\n// };\n\n// if (typeof BigInt64Array !== 'undefined') {\n//   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n//   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n// }\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table, schema?: Schema) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n","import {Type} from '../schema';\nimport {AnyArray} from '../../types';\n\n/**\n * Gets type information from an Arrow type object or \"mock\" Arrow type object\n * @param arrowTypeLike Arrow Type or type object of similar shape\n */\nexport function getTypeInfo(arrowTypeLike: any): {\n  typeId: Type;\n  ArrayType: AnyArray;\n  typeName: string;\n  typeEnumName?: string;\n  precision?: number;\n} {\n  return {\n    typeId: arrowTypeLike.typeId,\n    ArrayType: arrowTypeLike.ArrayType,\n    typeName: arrowTypeLike.toString(),\n    typeEnumName: getTypeKey(arrowTypeLike.typeId),\n    precision: arrowTypeLike.precision\n  };\n}\n\nlet ReverseType: {[key: string]: string} | null = null;\n\nfunction getTypeKey(typeKey) {\n  if (!ReverseType) {\n    ReverseType = {};\n    for (const key in Type) {\n      ReverseType[Type[key]] = key;\n    }\n  }\n\n  return ReverseType[typeKey];\n}\n","import type {TypedArray} from '../../types';\nimport {DataType, Float32, Float64, Int16, Int32, Int8, Uint16, Uint32, Uint8} from '../schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T>;\n  private _settlers: ArrayQueue<{resolve; reject}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{resolve; reject}>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n"],"sourceRoot":""}