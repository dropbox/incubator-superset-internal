{"version":3,"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"names":["ImageLoader","parseJSON","sliceArrayBuffer","assert","resolveUrl","getTypedArrayForBufferView","decodeExtensions","normalizeGLTFV1","postProcessGLTF","parseGLBSync","isGLB","isGLTF","arrayBuffer","options","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalize","promises","loadBuffers","json","buffers","loadImages","promise","push","Promise","all","postProcess","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","response","loadImage","image","index","parse","Number","isFinite","bufferView","array","parsedImage"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLB} from '../types/glb-types';\nimport type {GLBParseOptions} from './parse-glb';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {decodeExtensions} from '../extensions/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  excludeExtensions?: string[];\n  decompressMeshes?: boolean;\n  normalize?: boolean;\n  loadBuffers?: boolean;\n  loadImages?: boolean;\n  postProcess?: boolean;\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: {\n    gltf?: GLTFParseOptions;\n    glb?: GLBParseOptions;\n  },\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context: LoaderContext) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context: LoaderContext) {\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, index: number, options, context: LoaderContext) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[index] = parsedImage;\n}\n"],"file":"parse-gltf.js"}