import GLTFScenegraph from '../api/gltf-scenegraph';
import { EXT_MESHOPT_COMPRESSION } from '../gltf-utils/gltf-constants';
import { isMeshoptSupported, meshoptDecodeGltfBuffer } from '../../meshopt/meshopt-decoder';
const DEFAULT_MESHOPT_OPTIONS = {
  byteOffset: 0,
  filter: 'NONE'
};
export async function decode(gltfData, options) {
  var _options$gltf;

  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) || !isMeshoptSupported()) {
    return;
  }

  const promises = [];

  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(gltfData.json, bufferViewIndex));
  }

  await Promise.all(promises);
  const scenegraph = new GLTFScenegraph(gltfData);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}

async function decodeMeshoptBufferView(json, index) {
  const bufferView = json.bufferViews[index];
  const meshoptExtension = bufferView.extensions && bufferView.extensions[EXT_MESHOPT_COMPRESSION];

  if (meshoptExtension) {
    const buffer = json.buffers[meshoptExtension.buffer];
    const {
      byteOffset = 0,
      byteLength = 0,
      byteStride,
      count,
      mode,
      filter = 'NONE'
    } = meshoptExtension;
    const source = new Uint8Array(buffer, byteOffset, byteLength);
    const result = new ArrayBuffer(count * byteStride);
    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);
    return result;
  }

  return null;
}
//# sourceMappingURL=EXT_meshopt_compression.js.map