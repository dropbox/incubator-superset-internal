{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../worker-utils/src/lib/env-utils/assert.ts","webpack:///./src/lib/gltf-utils/gltf-constants.ts","webpack:///../loader-utils/src/index.ts","webpack:///./src/lib/utils/assert.js","webpack:///./src/lib/api/gltf-scenegraph.ts","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/lib/utils/version.js","webpack:///../images/src/lib/utils/assert.js","webpack:////home/user/apps/loaders.gl/node_modules/process/browser.js","webpack:///../images/src/lib/category-api/parsed-image-api.ts","webpack:///../worker-utils/src/lib/env-utils/version.ts","webpack:///../images/src/lib/utils/globals.ts","webpack:///../images/src/lib/category-api/binary-image-api.ts","webpack:///../worker-utils/src/index.ts","webpack:///../worker-utils/src/lib/env-utils/globals.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-thread.ts","webpack:///../worker-utils/src/lib/worker-utils/get-transfer-list.ts","webpack:///../schema/src/lib/schema/index.ts","webpack:///./src/lib/gltf-utils/gltf-utils.ts","webpack:///../images/src/index.ts","webpack:///../images/src/lib/utils/version.ts","webpack:///../images/src/lib/parsers/parse-image.ts","webpack:///../images/src/lib/category-api/image-type.ts","webpack:///../images/src/lib/parsers/parse-to-image.ts","webpack:///../images/src/lib/parsers/svg-utils.ts","webpack:///../loader-utils/src/lib/env-utils/assert.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-job.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-farm.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-pool.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-body.ts","webpack:///../worker-utils/src/lib/worker-api/get-worker-url.ts","webpack:///../worker-utils/src/lib/async-queue/async-queue.ts","webpack:///../loader-utils/src/lib/binary-utils/get-first-characters.ts","webpack:///../loader-utils/src/lib/binary-utils/array-buffer-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/memory-copy-utils.ts","webpack:///../draco/src/lib/utils/version.ts","webpack:///../schema/src/index.ts","webpack:///../schema/src/lib/table/row-table-batch-aggregator.ts","webpack:///../schema/src/lib/utils/row-utils.ts","webpack:///../schema/src/lib/table/columnar-table-batch-aggregator.ts","webpack:///../draco/src/lib/draco-module-loader.ts","webpack:///./src/lib/api/post-process-gltf.js","webpack:///./src/lib/parsers/parse-glb.ts","webpack:///./src/lib/encoders/encode-glb.js","webpack:///./src/bundle.ts","webpack:///./src/index.ts","webpack:///./src/gltf-loader.ts","webpack:///./src/lib/parsers/parse-gltf.ts","webpack:///../images/src/image-loader.ts","webpack:///../images/src/lib/parsers/parse-to-image-bitmap.ts","webpack:///../images/src/lib/parsers/parse-to-node-image.ts","webpack:///../images/src/image-writer.ts","webpack:///../images/src/lib/encoders/encode-image.ts","webpack:///../images/src/lib/texture-api/load-image.ts","webpack:///../images/src/lib/texture-api/generate-url.ts","webpack:///../loader-utils/src/lib/env-utils/globals.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/create-loader-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/get-loadable-worker-url.ts","webpack:///../worker-utils/src/lib/worker-api/process-on-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/remove-nontransferable-options.ts","webpack:///../worker-utils/src/lib/worker-api/create-worker.ts","webpack:///../worker-utils/src/lib/worker-api/validate-worker-version.ts","webpack:///../worker-utils/src/lib/library-utils/library-utils.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/parse-with-worker.ts","webpack:///../loader-utils/src/lib/parser-utils/parse-json.ts","webpack:///../loader-utils/src/lib/binary-utils/binary-copy-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/encode-utils.ts","webpack:///../loader-utils/src/lib/iterators/text-iterators.ts","webpack:///../loader-utils/src/lib/iterators/async-iteration.ts","webpack:///../loader-utils/src/lib/request-utils/request-scheduler.ts","webpack:///../loader-utils/src/lib/path-utils/path.ts","webpack:///../loader-utils/src/lib/path-utils/file-aliases.ts","webpack:///../loader-utils/src/lib/binary-utils/buffer-utils.ts","webpack:///../loader-utils/src/json-loader.ts","webpack:///../images/src/lib/texture-api/deep-load.ts","webpack:///../images/src/lib/texture-api/async-deep-map.ts","webpack:///./src/lib/gltf-utils/resolve-url.ts","webpack:///./src/lib/gltf-utils/get-typed-array.ts","webpack:///./src/lib/extensions/gltf-extensions.ts","webpack:///./src/lib/extensions/KHR_draco_mesh_compression.ts","webpack:///../draco/src/index.ts","webpack:///../draco/src/draco-loader.ts","webpack:///../draco/src/lib/draco-parser.ts","webpack:///../schema/src/lib/table/table-batch-builder.ts","webpack:///../schema/src/lib/table/base-table-batch-aggregator.ts","webpack:///../schema/src/category/mesh/mesh-utils.ts","webpack:///../schema/src/lib/schema/impl/schema.ts","webpack:///../schema/src/lib/utils/assert.ts","webpack:///../schema/src/lib/schema/impl/field.ts","webpack:///../schema/src/lib/schema/impl/type.ts","webpack:///../schema/src/lib/schema/impl/enum.ts","webpack:///../schema/src/lib/schema-utils/deduce-table-schema.ts","webpack:///../schema/src/lib/schema-utils/get-type-info.ts","webpack:///../schema/src/lib/schema-utils/type-utils.ts","webpack:///../schema/src/lib/utils/async-queue.ts","webpack:///../draco/src/lib/utils/schema-attribute-utils.ts","webpack:///../draco/src/draco-writer.ts","webpack:///../draco/src/lib/draco-builder.ts","webpack:///./src/lib/gltf-utils/gltf-attribute-utils.ts","webpack:///./src/lib/extensions/KHR_materials_unlit.ts","webpack:///./src/lib/extensions/KHR_lights_punctual.ts","webpack:///./src/lib/extensions/KHR_techniques_webgl.ts","webpack:///./src/lib/api/normalize-gltf-v1.js","webpack:///./src/lib/extensions/KHR_binary_gltf.ts","webpack:///./src/gltf-writer.ts","webpack:///./src/lib/encoders/encode-gltf.js","webpack:///./src/glb-loader.ts","webpack:///./src/glb-writer.ts","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stat.js","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stats.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","condition","message","Error","componentType","BYTES","type","COMPONENTS","parameter","magFilter","minFilter","wrapS","wrapT","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","5120","5121","5122","5123","5125","5126","DEFAULT_GLTF_JSON","asset","version","generator","buffers","GLTFScenegraph","gltf","this","json","sourceBuffers","byteLength","extras","extensionName","isExtension","getUsedExtensions","find","extensions","getRequiredExtensions","getExtension","extensionsRequired","extensionsUsed","index","getObject","array","bufferView","bufferIndex","getBufferView","buffer","binChunk","assert","byteOffset","Uint8Array","arrayBuffer","accessor","getAccessor","getBuffer","data","getAccessorArrayTypeAndLength","ArrayType","length","image","registerUsedExtension","extension","extensionData","addExtension","registerRequiredExtension","ext","push","_removeStringFromArray","sceneIndex","scene","nodeIndices","scenes","nodes","node","meshIndex","matrix","nodeData","mesh","attributes","indices","material","glTFMesh","primitives","_addAttributes","indicesAccessor","_addIndices","Number","isFinite","meshes","imageData","mimeTypeOpt","metadata","getBinaryImageMetadata","mimeType","glTFImage","addBufferView","images","glTFBufferView","padToNBytes","bufferViews","bufferViewIndex","glTFAccessor","getAccessorTypeFromSize","size","count","max","min","accessors","sourceBuffer","minMax","_getAccessorMinMax","accessorDefaults","getComponentTypeFromArray","Math","round","addAccessor","assign","texture","glTFTexture","source","imageIndex","textures","pbrMaterialInfo","materials","totalByteLength","ArrayBuffer","targetArray","dstByteOffset","copyToArray","binary","string","found","indexOf","splice","result","attributeKey","attributeData","attrName","_getGltfAttributeName","addBinaryBuffer","attributeName","toLowerCase","subarray","componentIndex","getHiResTimestamp","timestamp","window","performance","now","process","hrtime","timeParts","Date","g","Function","e","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","noop","nextTick","args","Array","arguments","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","getImageType","format","getImageTypeOrNull","getImageData","canvas","document","createElement","context","getContext","width","height","drawImage","ImageBitmap","Image","Boolean","close","globals","self","global","self_","window_","global_","document_","isBrowser","String","isWorker","importScripts","matches","exec","nodeVersion","parseFloat","binaryData","dataView","toDataView","getUint32","getPngMetadata","getUint16","getUint8","tableMarkers","Set","add","sofMarkers","getJpegMarkers","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","isView","NullWorker","id","VERSION","options","null","isMobile","orientation","NOOP","WorkerThread","props","url","onMessage","onError","error","console","log","worker","_createBrowserWorker","Worker","terminate","terminated","transferList","getTransferList","postMessage","event","lineno","colno","_loadableURL","getLoadableWorkerURL","onmessage","onerror","_getErrorFromErrorEvent","onmessageerror","isTransferable","MessagePort","OffscreenCanvas","recursive","transfers","transfersSet","undefined","from","TYPES","typedArray","ARRAY_TO_COMPONENT_TYPE","constructor","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","components","ATTRIBUTE_TYPE_TO_COMPONENTS","bytesPerComponent","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Map","imageOptions","imageType","loadType","getLoadableImageType","getDefaultImageType","isImageTypeSupported","IMAGE_BITMAP_SUPPORTED","IMAGE_SUPPORTED","DATA_SUPPORTED","_parseImageNode","NODE_IMAGE_SUPPORTED","blobOrDataUrl","getBlobOrSVGDataUrl","URL","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","src","decode","Promise","resolve","reject","onload","err","isSVG","xmlText","TextDecoder","btoa","getBlob","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","test","Blob","WorkerJob","jobName","workerThread","isRunning","_resolve","_reject","payload","DEFAULT_PROPS","maxConcurrency","maxMobileConcurrency","onDebug","reuseWorkers","WorkerFarm","setProps","workerPools","isSupported","_workerFarm","values","destroy","_getWorkerPoolProps","workerPool","WorkerPool","set","idleQueue","forEach","isDestroyed","job","done","startPromise","onStart","jobQueue","_startQueuedJob","_getAvailableWorker","queuedJob","shift","backlog","returnWorkerToQueue","_getMaxConcurrency","onMessageWrapperMap","WorkerBody","isKnownMessage","onMessageWrapper","addEventListener","removeEventListener","startsWith","warning","workerOptions","workerFile","workerUrl","_workerType","versionTag","asyncIterator","AsyncQueue","_values","_settlers","_closed","enqueue","settler","getMagicString","magic","fromCharCode","slice","toArrayBuffer","text","TextEncoder","encode","_toArrayBuffer","arrayBuffer1","arrayBuffer2","array1","array2","sources","sourceArrays","map","source2","reduce","offset","sourceArray","typedArrays","arrays","TypedArrayConstructor","sumLength","acc","subArray","targetBuffer","target","targetOffset","srcByteOffset","srcByteLength","padding","RowTableBatchAggregator","schema","isArray","_headers","row","cursor","shape","rowObject","convertToObjectRow","addObjectRow","arrayRows","rowArray","convertToArrayRow","addArrayRow","objectRows","rows","batchType","arrayRow","headers","objectRow","ColumnarTableBatchAggregator","_reallocateColumns","fieldName","columns","_pruneColumns","field","allocated","oldColumn","entries","columnName","column","loadDecoderPromise","loadEncoderPromise","DRACO_JS_DECODER_URL","DRACO_WASM_WRAPPER_URL","DRACO_WASM_DECODER_URL","DRACO_ENCODER_URL","draco3d","createDecoderModule","then","draco","loadDracoDecoder","createEncoderModule","loadDracoEncoder","decoderType","loadLibrary","DracoDecoderModule","all","wasmBinary","globalThis","initializeDracoDecoder","onModuleLoaded","DracoEncoderModule","GLTFPostProcessor","postProcess","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","DEFAULT_SAMPLER","TEXTURE_WRAP_","baseUri","_resolveTree","bufView","_resolveBufferView","_resolveImage","samplers","sampler","_resolveSampler","_resolveTexture","_resolveAccessor","_resolveMaterial","_resolveMesh","_resolveNode","skins","skin","_resolveSkin","_resolveScene","_get","warn","getNode","children","child","getMesh","accum","camera","getCamera","getSkin","inverseBindMatrices","primitive","attribute","getMaterial","normalTexture","getTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bytesPerElement","cutBufffer","getSampler","getImage","parameters","glEnum","_enumSamplerParameter","preloadedImage","perspective","orthographic","magic1","glb","header","hasBinChunk","binChunks","parseGLBV1","parseGLBV2","GLB_FILE_HEADER_SIZE","contentLength","contentFormat","parseJSONChunk","parseBINChunk","chunkLength","chunkFormat","strict","parseGLBChunksSync","jsonChunk","jsonText","JSON","parse","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","jsonString","stringify","copyPaddedStringToDataView","jsonByteLength","byteOffsetBinHeader","copyPaddedArrayBufferToDataView","binByteLength","fileByteLength","moduleExports","require","_global","loaders","GLTFLoader","mimeTypes","tests","normalize","loadBuffers","loadImages","decompressMeshes","deprecatedOptions","fetchImages","createImages","decompress","parseGLTF","isGLB","arrayBufferOrString","parseGLTFContainerSync","normalizeGLTFV1","promises","promise","decodeExtensions","postProcessGLTF","uri","parseJSON","_glb","fill","fetch","resolveUrl","response","loadImage","getTypedArrayForBufferView","sliceArrayBuffer","ImageLoader","parsedImage","parseImage","_typecheckImageLoader","EMPTY_OBJECT","imagebitmapOptionsSupported","blob","imagebitmapOptions","imagebitmap","safeCreateImageBitmap","isEmptyObject","createImageBitmap","ImageWriter","jpegQuality","encodeImage","_encodeImageNode","encodeImageInBrowser","qualityParamSupported","getImageSize","drawImageToCanvas","toBlob","x","y","transferFromImageBitmap","clampedArray","Uint8ClampedArray","ImageData","putImageData","getUrl","getImageUrls","imageUrls","deepLoad","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","lod","shallowLoad","getMipLevels","mipLevel","floor","log2","baseUrl","resolvePath","loader","input","parseData","parseOnMainThread","requestId","parseSync","parser","parseTextSync","textDecoder","workerURL","workerURLCache","getLoadableWorkerURLFromSource","getLoadableWorkerURLFromURL","workerSource","getWorkerName","getWorkerURL","workerFarm","getWorkerFarm","getWorkerPool","startJob","transferableOptions","removeNontransferableOptions","v","cache","processInBatches","processOnMainThread","inputBatches","resultIterator","batch","coreVersion","workerVersion","loadLibraryPromises","libraryUrl","moduleName","getLibraryUrl","loadLibraryFromFile","library","CDN","endsWith","requireFromFile","scriptSource","loadLibraryFromString","requireFromString","eval","script","appendChild","createTextNode","body","_","getFirstCharacters","stringBuffer","paddedLength","padLength","setUint8","byteAlignment","ceil","whitespace","charCodeAt","arrayBufferIterator","stream","textIterator","textEncoder","previous","eolIndex","line","lineIterator","counter","iterator","visitor","next","arrayBuffers","chunk","concatenateArrayBuffers","strings","join","throttleRequests","maxRequests","RequestScheduler","stats","Stats","handle","getPriority","requestMap","request","priority","requestQueue","_issueNewRequests","isDone","activeRequestCount","deferredUpdate","_issueNewRequestsAsync","freeSlots","_updateAllRequests","_issueRequest","_updateRequest","sort","a","b","slashIndex","lastIndexOf","substr","parts","separator","part","replace","RegExp","prefix","pathPrefix","aliases","fileAliases","filename","alias","replacement","isBuffer","toBuffer","JSONLoader","category","_typecheckJSONLoader","urlTree","load","asyncDeepMap","isObject","tree","func","mapSubtree","mapArray","mapObject","urlArray","EXTENSIONS","KHR_draco_mesh_compression","KHR_materials_unlit","KHR_lights_punctual","KHR_techniques_webgl","excludes","excludeExtensions","gltfData","scenegraph","Scenegraph","compressMesh","addRequiredExtension","KHR_DRACO_MESH_COMPRESSION","makeMeshPrimitiveIterator","getObjectExtension","decompressPrimitive","removeExtension","dracoExtension","bufferCopy","dracoOptions","DracoLoader","decodedData","decodedAttributes","getGLTFAccessors","decodedAttribute","accessorIndex","getGLTFAccessor","checkPrimitive","DracoWriter","compressedData","encodeSync","fauxAccessors","_addFauxAttributes","keys","f","DracoWorkerLoader","loadDracoDecoderModule","dracoParser","DracoParser","_TypecheckDracoLoader","DEFAULT_DRACO_OPTIONS","WebAssembly","libraryPath","extraAttributes","attributeNameEntry","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","1","2","3","4","5","Int32Array","6","9","decoder","Decoder","metadataQuerier","MetadataQuerier","DecoderBuffer","Init","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","TRIANGULAR_MESH","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","POINT_CLOUD","DecodeBufferToPointCloud","ok","ptr","error_msg","loaderData","_getDracoLoaderData","geometry","_getMeshData","boundingBox","getMeshBoundingBox","makeSchemaFromAttributes","vertexCount","num_points","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","dracoAttribute","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","topology","_getTriangleStripIndices","_getTriangleListIndices","loaderAttribute","_deduceAttributeName","_getAttributeValues","byteStride","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","numValues","intArray","GetValue","getUint32Array","TypedArrayCtor","numComponents","BYTES_PER_ELEMENT","dataType","attributeType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","thisAttributeType","dracoAttributeConstant","entryName","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","dracoAttributeName","SkipAttributeTransform","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","min_value","DEFAULT_OPTIONS","batchSize","batchDebounceMs","limit","_limitMB","TableBatchBuilder","totalLength","totalBytes","limitReached","rowBytes","_estimateRowMB","aggregator","TableBatchType","_getTableBatchType","bytesUsed","isChunkComplete","_isFull","_getBatch","rowCount","lastBatchEmittedMs","normalizedBatch","getBatch","batchCount","BaseTableBatchAggregator","ArrowBatch","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","z","Schema","fields","usedNames","checkNames","other","compareTo","nameMap","columnNames","selectedFields","filter","columnIndices","schemaOrFields","otherSchema","mergeMaps","fieldMap","m1","m2","Field","nullable","typeId","DataType","Type","NONE","Null","Int","Float","Binary","Utf8","Bool","Decimal","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Dictionary","isSigned","bitWidth","Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Precision","precision","Float16","Float32","Float64","DateUnit","DAY","MILLISECOND","unit","DateDay","DateMillisecond","TimeUnit","SECOND","MICROSECOND","NANOSECOND","TimeSecond","TimeMillisecond","timezone","TimestampSecond","TimestampMillisecond","TimestampMicrosecond","TimestampNanosecond","IntervalUnit","DAY_TIME","YEAR_MONTH","IntervalDayTime","IntervalYearMonth","listSize","valueType","deduceTypeFromValue","table","deducedSchema","rowTable","deduceSchemaForRowTable","columnarTable","deduceSchemaForColumnarTable","arrowTypeLike","typeName","toString","typeEnumName","getTypeKey","ReverseType","typeKey","ArrayQueue","dequeue","asyncIterable","metadataMap","makeMetadata","namedLoaderDataAttributes","transformAttributesLoaderData","getArrowFieldFromAttribute","indicesField","getArrowTypeFromTypedArray","pointcloud","loadDracoEncoderModule","dracoBuilder","DRACOBuilder","GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","COLOR_0","TEXCOORD_0","DracoBuilder","dracoEncoder","Encoder","dracoMeshBuilder","MeshBuilder","dracoMetadataBuilder","MetadataBuilder","destroyEncodedObject","_setOptions","_encodePointCloud","_encodeMesh","dracoPointCloud","_addGeometryMetadata","_getAttributesFromMesh","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","dracoInt8ArrayToArrayBuffer","dracoMesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","_getPositionAttribute","_addAttributeToMesh","_addAttributeMetadata","_getDracoAttributeType","numFaces","AddFacesToMesh","builder","AddInt8Attribute","AddInt16Attribute","AddInt32Attribute","AddUInt8Attribute","AddUInt16Attribute","AddUInt32Attribute","AddFloatAttribute","GENERIC","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","container","trunc","AddIntEntry","AddDoubleEntry","AddIntEntryArray","AddStringEntry","outputBuffer","outputData","convertTypedArrays","toTypedArray","getAccessorData","gltfScenegraph","unlit","addObjectExtension","KHR_MATERIALS_UNLIT","removeObjectExtension","KHR_LIGHTS_PUNCTUAL","lights","nodeExtension","light","KHR_TECHNIQUES_WEBGL","techniques","resolveTechniques","materialExtension","technique","resolveValues","techniquesExtension","programs","shaders","shader","code","program","fragmentShader","vertexShader","uniforms","uniform","GLTFV1Normalizer","GLTF_ARRAYS","animations","GLTF_KEYS","idToIndexMap","_addAsset","_convertTopLevelObjectsToArrays","KHR_binary_glTF","_convertObjectIdsToArrayIndices","_updateObjects","_updateMaterial","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","topLevelArrayName","baseColorFactor","metallicFactor","roughnessFactor","textureId","tex","textureIndex","findIndex","KHR_BINARY_GLTF","GLTFWriter","encodeGLTFSync","_TypecheckGLBLoader","firstBuffer","convertBuffersToBase64","GLBLoader","GLBWriter","sampleSize","reset","samples","addCount","subtractCount","_count","_samples","_checkSampling","time","_time","lastTiming","_startTime","_timerPending","addTime","lastSampleCount","lastSampleTime","_initializeStats","seal","_getOrCreate","fn","stat","average","getAverageTime","hz","getHz"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,yFC7E9C,SAAgBC,EAAgBC,GACrC,IAAKD,EACH,MAAM,IAAIE,MAAMD,GAAW,kC,0GC0BxB,SAAmCE,GACxC,OAAOC,EAAMD,I,0BAGR,SAAiCE,GACtC,OAAOC,EAAWD,I,gCAGb,SAAuCE,GAa5C,MAPsB,CACpBC,UAN4B,MAO5BC,UAN4B,MAO5BC,MANwB,MAOxBC,MANwB,OASLJ,I,qKArDQ,kB,6BAGW,6B,sBACP,sB,sBACA,sB,uBACC,uB,0BAGG,0BAEvC,IAAMD,EAAa,CACjBM,OAAQ,EACRC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,IAGFd,EAAQ,CACZe,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,I,s6ICZR,I,EAAA,QACA,QAWA,QACA,QAGA,QAGA,QAOA,QACA,QAIA,QAKA,QAGA,QAMA,QAGA,G,EAAA,Q,2BAGA,W,SAEA,YAIA,W,OAIA,YAEA,Q,mpBC5EO,SAAgBxB,EAAWC,GAChC,IAAKD,EACH,MAAM,IAAIE,MAAMD,GAAW,yB,+FCU/B,YACA,OACA,OACA,Q,slEAYA,IAAMwB,EAA0B,CAC9BC,MAAO,CACLC,QAAS,MACTC,UAAW,cAEbC,QAAS,IAMUC,E,WAMnB,WAAYC,I,4FAAsC,0FAEhDC,KAAKD,KAAOA,GAAQ,CAClBE,KAAM,EAAF,GAAMR,GACVI,QAAS,IAEXG,KAAKE,cAAgB,GACrBF,KAAKG,WAAa,EAGdH,KAAKD,KAAKF,SAAWG,KAAKD,KAAKF,QAAQ,KACzCG,KAAKG,WAAaH,KAAKD,KAAKF,QAAQ,GAAGM,WACvCH,KAAKE,cAAgB,CAACF,KAAKD,KAAKF,QAAQ,K,yCAM5C,WACE,OAAOG,KAAKD,KAAKE,O,gCAGnB,SAAmB1C,GAGjB,OADayC,KAAKC,KAAK1C,K,0BAIzB,SAAaA,GAGX,OADeyC,KAAKC,KAAKG,QAAU,IACrB7C,K,0BAGhB,SAAa8C,GACX,IAAMC,EAAcN,KAAKO,oBAAoBC,MAAK,SAACjE,GAAD,OAAUA,IAAS8D,KAC/DI,EAAaT,KAAKC,KAAKQ,YAAc,GAC3C,OAAOH,EAAcG,EAAWJ,KAAkB,EAAO,O,kCAG3D,SAAqBA,GAEnB,OADmBL,KAAKU,wBAAwBF,MAAK,SAACjE,GAAD,OAAUA,IAAS8D,KACpDL,KAAKW,aAAaN,GAAiB,O,mCAGzD,WACE,OAAOL,KAAKC,KAAKW,oBAAsB,K,+BAGzC,WACE,OAAOZ,KAAKC,KAAKY,gBAAkB,K,gCAGrC,SACEnD,EACA2C,GAGA,OADmB3C,EAAO+C,YAAc,IACtBJ,K,sBAGpB,SAASS,GACP,OAAOd,KAAKe,UAAU,SAAUD,K,qBAGlC,SAAQA,GACN,OAAOd,KAAKe,UAAU,QAASD,K,qBAGjC,SAAQA,GACN,OAAOd,KAAKe,UAAU,QAASD,K,qBAGjC,SAAQA,GACN,OAAOd,KAAKe,UAAU,SAAUD,K,yBAGlC,SAAYA,GACV,OAAOd,KAAKe,UAAU,YAAaD,K,yBAGrC,SAAYA,GACV,OAAOd,KAAKe,UAAU,YAAaD,K,wBAOrC,SAAWA,GACT,OAAOd,KAAKe,UAAU,WAAYD,K,wBAGpC,SAAWA,GACT,OAAOd,KAAKe,UAAU,WAAYD,K,sBAGpC,SAASA,GACP,OAAOd,KAAKe,UAAU,SAAUD,K,2BAGlC,SAAcA,GACZ,OAAOd,KAAKe,UAAU,cAAeD,K,uBAGvC,SAAUA,GACR,OAAOd,KAAKe,UAAU,UAAWD,K,uBAGnC,SAAUE,EAAeF,GAEvB,GAAqB,WAAjB,EAAOA,GACT,OAAOA,EAET,IAAMpD,EAASsC,KAAKC,KAAKe,IAAUhB,KAAKC,KAAKe,GAAOF,GACpD,IAAKpD,EACH,MAAM,IAAIQ,MAAJ,0CAA6C8C,EAA7C,YAAsDF,EAAtD,MAER,OAAOpD,I,wCAOT,SAA2BuD,GAGzB,IAAMC,GAFND,EAAajB,KAAKmB,cAAcF,IAEDG,OAIzBC,EAAWrB,KAAKD,KAAKF,QAAQqB,IACnC,IAAAI,QAAOD,GAGP,IAAME,GAAcN,EAAWM,YAAc,GAAKF,EAASE,WAE3D,OAAO,IAAIC,WAAWH,EAASI,YAAaF,EAAYN,EAAWd,c,sCAMrE,SAAyBuB,GAEvBA,EAAW1B,KAAK2B,YAAYD,GAE5B,IAAMT,EAAajB,KAAKmB,cAAcO,EAAST,YAGzCQ,EAFSzB,KAAK4B,UAAUX,EAAWG,QAEdS,KAG3B,GAA4B,IAAAC,+BAA8BJ,EAAUT,GAA7Dc,EAAP,EAAOA,UAAWC,EAAlB,EAAkBA,OAGlB,OAAO,IAAID,EAAUN,EADFR,EAAWM,WAAaG,EAASH,WACNS,K,uCAMhD,SAA0BC,GAExBA,EAAQjC,KAAK2B,YAAYM,GAEzB,IAAMhB,EAAajB,KAAKmB,cAAcc,EAAMhB,YAGtCQ,EAFSzB,KAAK4B,UAAUX,EAAWG,QAEdS,KAErBN,EAAaN,EAAWM,YAAc,EAC5C,OAAO,IAAIC,WAAWC,EAAaF,EAAYN,EAAWd,c,gCAQ5D,SAAmB5C,EAAasE,GAE9B,OADA7B,KAAKC,KAAK1C,GAAOsE,EACV7B,O,0BAMT,SAAazC,EAAasE,GAGxB,OAFA7B,KAAKC,KAAKG,OAASJ,KAAKC,KAAKG,QAAU,GACvCJ,KAAKC,KAAKG,OAAO7C,GAAOsE,EACjB7B,O,gCAGT,SAAmBtC,EAAgB2C,EAAuBwB,GAOxD,OALAnE,EAAO+C,WAAa/C,EAAO+C,YAAc,GAGzC/C,EAAO+C,WAAWJ,GAAiBwB,EACnC7B,KAAKkC,sBAAsB7B,GACpBL,O,gCAGT,SAAmBtC,EAAgB2C,EAAuBwB,IAErCnE,EAAO+C,YAAc,IAC7BJ,GAAiBwB,I,mCAI9B,SAAsBnE,EAAgB2C,GAEpC,IAAMI,EAAa/C,EAAO+C,YAAc,GAClC0B,EAAY1B,EAAWJ,GAE7B,cADOI,EAAWJ,GACX8B,I,0BAMT,SAAa9B,GAA2D,IAApC+B,EAAoC,uDAAZ,GAK1D,OAJA,IAAAd,QAAOc,GACPpC,KAAKC,KAAKQ,WAAaT,KAAKC,KAAKQ,YAAc,GAC/CT,KAAKC,KAAKQ,WAAWJ,GAAiB+B,EACtCpC,KAAKkC,sBAAsB7B,GACpB+B,I,kCAMT,SAAqB/B,GAAmD,IAApC+B,EAAoC,uDAAZ,GAI1D,OAHA,IAAAd,QAAOc,GACPpC,KAAKqC,aAAahC,EAAe+B,GACjCpC,KAAKsC,0BAA0BjC,GACxB+B,I,mCAMT,SAAsB/B,GACpBL,KAAKC,KAAKY,eAAiBb,KAAKC,KAAKY,gBAAkB,GAClDb,KAAKC,KAAKY,eAAeL,MAAK,SAAC+B,GAAD,OAASA,IAAQlC,MAClDL,KAAKC,KAAKY,eAAe2B,KAAKnC,K,uCAOlC,SAA0BA,GACxBL,KAAKkC,sBAAsB7B,GAC3BL,KAAKC,KAAKW,mBAAqBZ,KAAKC,KAAKW,oBAAsB,GAC1DZ,KAAKC,KAAKW,mBAAmBJ,MAAK,SAAC+B,GAAD,OAASA,IAAQlC,MACtDL,KAAKC,KAAKW,mBAAmB4B,KAAKnC,K,6BAOtC,SAAgBA,GACVL,KAAKC,KAAKW,oBACZZ,KAAKyC,uBAAuBzC,KAAKC,KAAKW,mBAAoBP,GAExDL,KAAKC,KAAKY,gBACZb,KAAKyC,uBAAuBzC,KAAKC,KAAKY,eAAgBR,GAEpDL,KAAKC,KAAKQ,mBACLT,KAAKC,KAAKQ,WAAWJ,K,6BAOhC,SAAgBqC,GACd1C,KAAKC,KAAK0C,MAAQD,I,sBAQpB,SAASC,GACP,IAAOC,EAAeD,EAAfC,YAGP,OAFA5C,KAAKC,KAAK4C,OAAS7C,KAAKC,KAAK4C,QAAU,GACvC7C,KAAKC,KAAK4C,OAAOL,KAAK,CAACM,MAAOF,IACvB5C,KAAKC,KAAK4C,OAAOb,OAAS,I,qBAQnC,SAAQe,GACN,IAAOC,EAAqBD,EAArBC,UAAWC,EAAUF,EAAVE,OAClBjD,KAAKC,KAAK6C,MAAQ9C,KAAKC,KAAK6C,OAAS,GACrC,IAAMI,EAAW,CAACC,KAAMH,GAMxB,OALIC,IAEFC,EAASD,OAASA,GAEpBjD,KAAKC,KAAK6C,MAAMN,KAAKU,GACdlD,KAAKC,KAAK6C,MAAMd,OAAS,I,qBAIlC,SAAQmB,GACN,IAAOC,EAA2CD,EAA3CC,WAAYC,EAA+BF,EAA/BE,QAASC,EAAsBH,EAAtBG,SAA5B,EAAkDH,EAAZhG,YAAtC,MAA6C,EAA7C,EAGMoG,EAAW,CACfC,WAAY,CACV,CACEJ,WALYpD,KAAKyD,eAAeL,GAMhCjG,UAKN,GAAIkG,EAAS,CACX,IAAMK,EAAkB1D,KAAK2D,YAAYN,GAEzCE,EAASC,WAAW,GAAGH,QAAUK,EAUnC,OAPIE,OAAOC,SAASP,KAElBC,EAASC,WAAW,GAAGF,SAAWA,GAGpCtD,KAAKC,KAAK6D,OAAS9D,KAAKC,KAAK6D,QAAU,GACvC9D,KAAKC,KAAK6D,OAAOtB,KAAKe,GACfvD,KAAKC,KAAK6D,OAAO9B,OAAS,I,2BAGnC,SAAcoB,GAEZ,IAEMG,EAAW,CACfC,WAAY,CACV,CACEJ,WALkBpD,KAAKyD,eAAeL,GAMtCjG,KAAM,KAOZ,OAFA6C,KAAKC,KAAK6D,OAAS9D,KAAKC,KAAK6D,QAAU,GACvC9D,KAAKC,KAAK6D,OAAOtB,KAAKe,GACfvD,KAAKC,KAAK6D,OAAO9B,OAAS,I,sBAUnC,SAAS+B,EAAgBC,GAIvB,IAAMC,GAAW,IAAAC,wBAAuBH,GAClCI,EAAWH,IAAeC,aAAJ,EAAIA,EAAUE,UAIpCC,EAAY,CAChBnD,WAHsBjB,KAAKqE,cAAcN,GAIzCI,YAKF,OAFAnE,KAAKC,KAAKqE,OAAStE,KAAKC,KAAKqE,QAAU,GACvCtE,KAAKC,KAAKqE,OAAO9B,KAAK4B,GACfpE,KAAKC,KAAKqE,OAAOtC,OAAS,I,2BAOnC,SAAcZ,GACZ,IAAMjB,EAAaiB,EAAOjB,YAC1B,IAAAmB,QAAOsC,OAAOC,SAAS1D,IAGvBH,KAAKE,cAAgBF,KAAKE,eAAiB,GAC3CF,KAAKE,cAAcsC,KAAKpB,GAExB,IAAMmD,EAAiB,CACrBnD,OAAQ,EAERG,WAAYvB,KAAKG,WACjBA,cAUF,OALAH,KAAKG,aAAc,IAAAqE,aAAYrE,EAAY,GAG3CH,KAAKC,KAAKwE,YAAczE,KAAKC,KAAKwE,aAAe,GACjDzE,KAAKC,KAAKwE,YAAYjC,KAAK+B,GACpBvE,KAAKC,KAAKwE,YAAYzC,OAAS,I,yBAQxC,SAAY0C,EAAyBhD,GACnC,IAAMiD,EAAe,CACnB1D,WAAYyD,EAEZrG,MAAM,IAAAuG,yBAAwBlD,EAASmD,MAEvC1G,cAAeuD,EAASvD,cAExB2G,MAAOpD,EAASoD,MAEhBC,IAAKrD,EAASqD,IAEdC,IAAKtD,EAASsD,KAKhB,OAFAhF,KAAKC,KAAKgF,UAAYjF,KAAKC,KAAKgF,WAAa,GAC7CjF,KAAKC,KAAKgF,UAAUzC,KAAKmC,GAClB3E,KAAKC,KAAKgF,UAAUjD,OAAS,I,6BAUtC,SAAgBkD,GAAyD,IAAtCxD,EAAsC,uDAAnB,CAACmD,KAAM,GACrDH,EAAkB1E,KAAKqE,cAAca,GAEvCC,EAAS,CAACH,IAAKtD,EAASsD,IAAKD,IAAKrD,EAASqD,KAC1CI,EAAOH,KAAQG,EAAOJ,MAEzBI,EAASnF,KAAKoF,mBAAmBF,EAAcxD,EAASmD,OAG1D,IAAMQ,EAAmB,CAEvBR,KAAMnD,EAASmD,KACf1G,eAAe,IAAAmH,2BAA0BJ,GAEzCJ,MAAOS,KAAKC,MAAMN,EAAalD,OAASN,EAASmD,MACjDG,IAAKG,EAAOH,IACZD,IAAKI,EAAOJ,KAGd,OAAO/E,KAAKyF,YAAYf,EAAiBhI,OAAOgJ,OAAOL,EAAkB3D,M,wBAS3E,SAAWiE,GACT,IACMC,EAAc,CAClBC,OAFmBF,EAAdG,YAOP,OAFA9F,KAAKC,KAAK8F,SAAW/F,KAAKC,KAAK8F,UAAY,GAC3C/F,KAAKC,KAAK8F,SAASvD,KAAKoD,GACjB5F,KAAKC,KAAK8F,SAAS/D,OAAS,I,yBAIrC,SAAYgE,GAGV,OAFAhG,KAAKC,KAAKgG,UAAYjG,KAAKC,KAAKgG,WAAa,GAC7CjG,KAAKC,KAAKgG,UAAUzD,KAAKwD,GAClBhG,KAAKC,KAAKgG,UAAUjE,OAAS,I,+BAItC,WAA0B,QAExBhC,KAAKD,KAAKF,QAAU,GAGpB,IALwB,EAKlBqG,EAAkBlG,KAAKG,WACvBsB,EAAc,IAAI0E,YAAYD,GAC9BE,EAAc,IAAI5E,WAAWC,GAG/B4E,EAAgB,EAVI,IAWGrG,KAAKE,eAAiB,IAXzB,IAWxB,2BAAqD,KAA1CgF,EAA0C,QACnDmB,GAAgB,IAAAC,aAAYpB,EAAckB,EAAaC,IAZjC,8BAgBxB,UAAIrG,KAAKC,YAAT,iBAAI,EAAWJ,eAAf,OAAI,EAAqB,GACvBG,KAAKC,KAAKJ,QAAQ,GAAGM,WAAa+F,EAElClG,KAAKC,KAAKJ,QAAU,CAAC,CAACM,WAAY+F,IAIpClG,KAAKD,KAAKwG,OAAS9E,EAGnBzB,KAAKE,cAAgB,CAACuB,K,oCAKxB,SAAuBT,EAAOwF,GAE5B,IADA,IAAIC,GAAQ,EACLA,GAAO,CACZ,IAAM3F,EAAQE,EAAM0F,QAAQF,GACxB1F,GAAS,EACXE,EAAM2F,OAAO7F,EAAO,GAEpB2F,GAAQ,K,4BAQd,WAAgC,IAAjBrD,EAAiB,uDAAJ,GACpBwD,EAAS,GACf,IAAK,IAAMC,KAAgBzD,EAAY,CACrC,IAAM0D,EAAgB1D,EAAWyD,GAC3BE,EAAW/G,KAAKgH,sBAAsBH,GACtCnF,EAAW1B,KAAKiH,gBAAgBH,EAAc7J,MAAO6J,GAC3DF,EAAOG,GAAYrF,EAErB,OAAOkF,I,yBAMT,SAAYvD,GACV,OAAOrD,KAAKiH,gBAAgB5D,EAAS,CAACwB,KAAM,M,mCAM9C,SAAsBqC,GACpB,OAAQA,EAAcC,eACpB,IAAK,WACL,IAAK,YACL,IAAK,WACH,MAAO,WACT,IAAK,SACL,IAAK,UACH,MAAO,SACT,IAAK,QACL,IAAK,SACH,MAAO,UACT,IAAK,WACL,IAAK,YACH,MAAO,aACT,QACE,OAAOD,K,gCAQb,SAAmB9F,EAAQyD,GACzB,IAAM+B,EAAS,CAAC5B,IAAK,KAAMD,IAAK,MAChC,GAAI3D,EAAOY,OAAS6C,EAClB,OAAO+B,EAGTA,EAAO5B,IAAM,GAEb4B,EAAO7B,IAAM,GACb,IAT+B,MASZ3D,EAAOgG,SAAS,EAAGvC,IATP,IAU/B,2BAAgC,KAArB5H,EAAqB,QAE9B2J,EAAO5B,IAAIxC,KAAKvF,GAEhB2J,EAAO7B,IAAIvC,KAAKvF,IAda,8BAiB/B,IAAK,IAAI6D,EAAQ+D,EAAM/D,EAAQM,EAAOY,OAAQlB,GAAS+D,EACrD,IAAK,IAAIwC,EAAiB,EAAGA,EAAiBxC,EAAMwC,IAElDT,EAAO5B,IAAI,EAAIqC,GAAkB9B,KAAKP,IAEpC4B,EAAO5B,IAAI,EAAIqC,GACfjG,EAAON,EAAQuG,IAGjBT,EAAO7B,IAAI,EAAIsC,GAAkB9B,KAAKR,IAEpC6B,EAAO7B,IAAI,EAAIsC,GACfjG,EAAON,EAAQuG,IAIrB,OAAOT,O,2EC1pBX,YAAe,SAASU,IACtB,IAAIC,EAEJ,GAAsB,oBAAXC,QAA0BA,OAAOC,YAC1CF,EAAYC,OAAOC,YAAYC,WAC1B,QAAuB,IAAZC,GAA2BA,EAAQC,OAAQ,CAC3D,MAAMC,EAAYF,EAAQC,SAC1BL,EAA2B,IAAfM,EAAU,GAAYA,EAAU,GAAK,SAEjDN,EAAYO,KAAKJ,MAGnB,OAAOH,EAZT,oC,+BCAA,IAAIQ,EAGJA,EAAI,WACH,OAAO/H,KADJ,GAIJ,IAEC+H,EAAIA,GAAK,IAAIC,SAAS,cAAb,GACR,MAAOC,GAEc,iBAAXT,SAAqBO,EAAIP,QAOrCzL,EAAOD,QAAUiM,G,yGChBM,S,uFCHhB,SAAgB/J,EAAWC,GAChC,IAAKD,EACH,MAAM,IAAIE,MAAMD,K,cCDpB,IAOIiK,EACAC,EARAR,EAAU5L,EAAOD,QAAU,GAU/B,SAASsM,IACL,MAAM,IAAIlK,MAAM,mCAEpB,SAASmK,IACL,MAAM,IAAInK,MAAM,qCAsBpB,SAASoK,EAAWC,GAChB,GAAIL,IAAqBM,WAErB,OAAOA,WAAWD,EAAK,GAG3B,IAAKL,IAAqBE,IAAqBF,IAAqBM,WAEhE,OADAN,EAAmBM,WACZA,WAAWD,EAAK,GAE3B,IAEI,OAAOL,EAAiBK,EAAK,GAC/B,MAAMN,GACJ,IAEI,OAAOC,EAAiB/L,KAAK,KAAMoM,EAAK,GAC1C,MAAMN,GAEJ,OAAOC,EAAiB/L,KAAK6D,KAAMuI,EAAK,MAvCnD,WACG,IAEQL,EADsB,mBAAfM,WACYA,WAEAJ,EAEzB,MAAOH,GACLC,EAAmBE,EAEvB,IAEQD,EADwB,mBAAjBM,aACcA,aAEAJ,EAE3B,MAAOJ,GACLE,EAAqBE,GAjB7B,GAwEA,IAEIK,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAa1G,OACb2G,EAAQD,EAAaK,OAAOJ,GAE5BE,GAAc,EAEdF,EAAM3G,QACNgH,KAIR,SAASA,IACL,IAAIJ,EAAJ,CAGA,IAAIK,EAAUX,EAAWQ,GACzBF,GAAW,EAGX,IADA,IAAIM,EAAMP,EAAM3G,OACVkH,GAAK,CAGP,IAFAR,EAAeC,EACfA,EAAQ,KACCE,EAAaK,GACdR,GACAA,EAAaG,GAAYM,MAGjCN,GAAc,EACdK,EAAMP,EAAM3G,OAEhB0G,EAAe,KACfE,GAAW,EAnEf,SAAyBQ,GACrB,GAAIjB,IAAuBM,aAEvB,OAAOA,aAAaW,GAGxB,IAAKjB,IAAuBE,IAAwBF,IAAuBM,aAEvE,OADAN,EAAqBM,aACdA,aAAaW,GAExB,IAEWjB,EAAmBiB,GAC5B,MAAOnB,GACL,IAEI,OAAOE,EAAmBhM,KAAK,KAAMiN,GACvC,MAAOnB,GAGL,OAAOE,EAAmBhM,KAAK6D,KAAMoJ,KAgD7CC,CAAgBJ,IAiBpB,SAASK,EAAKf,EAAKvH,GACfhB,KAAKuI,IAAMA,EACXvI,KAAKgB,MAAQA,EAYjB,SAASuI,KA5BT5B,EAAQ6B,SAAW,SAAUjB,GACzB,IAAIkB,EAAO,IAAIC,MAAMC,UAAU3H,OAAS,GACxC,GAAI2H,UAAU3H,OAAS,EACnB,IAAK,IAAIhG,EAAI,EAAGA,EAAI2N,UAAU3H,OAAQhG,IAClCyN,EAAKzN,EAAI,GAAK2N,UAAU3N,GAGhC2M,EAAMnG,KAAK,IAAI8G,EAAKf,EAAKkB,IACJ,IAAjBd,EAAM3G,QAAiB4G,GACvBN,EAAWU,IASnBM,EAAK1L,UAAUuL,IAAM,WACjBnJ,KAAKuI,IAAIqB,MAAM,KAAM5J,KAAKgB,QAE9B2G,EAAQkC,MAAQ,UAChBlC,EAAQmC,SAAU,EAClBnC,EAAQoC,IAAM,GACdpC,EAAQqC,KAAO,GACfrC,EAAQhI,QAAU,GAClBgI,EAAQsC,SAAW,GAInBtC,EAAQuC,GAAKX,EACb5B,EAAQwC,YAAcZ,EACtB5B,EAAQyC,KAAOb,EACf5B,EAAQ0C,IAAMd,EACd5B,EAAQ2C,eAAiBf,EACzB5B,EAAQ4C,mBAAqBhB,EAC7B5B,EAAQ6C,KAAOjB,EACf5B,EAAQ8C,gBAAkBlB,EAC1B5B,EAAQ+C,oBAAsBnB,EAE9B5B,EAAQgD,UAAY,SAAUpO,GAAQ,MAAO,IAE7CoL,EAAQiD,QAAU,SAAUrO,GACxB,MAAM,IAAI2B,MAAM,qCAGpByJ,EAAQkD,IAAM,WAAc,MAAO,KACnClD,EAAQmD,MAAQ,SAAUC,GACtB,MAAM,IAAI7M,MAAM,mCAEpByJ,EAAQqD,MAAQ,WAAa,OAAO,I,kQCvK7B,SAASC,EAAahJ,GAC3B,IAAMiJ,EAASC,EAAmBlJ,GAClC,IAAKiJ,EACH,MAAM,IAAIhN,MAAM,gBAElB,OAAOgN,EAOF,SAASE,EAAanJ,GAC3B,OAAQgJ,EAAahJ,IACnB,IAAK,OACH,OAAOA,EAET,IAAK,QACL,IAAK,cAEH,IAAMoJ,EAASC,SAASC,cAAc,UAEhCC,EAAUH,EAAOI,WAAW,MAClC,IAAKD,EACH,MAAM,IAAItN,MAAM,gBASlB,OANAmN,EAAOK,MAAQzJ,EAAMyJ,MAErBL,EAAOM,OAAS1J,EAAM0J,OAEtBH,EAAQI,UAAU3J,EAAO,EAAG,GAErBuJ,EAAQJ,aAAa,EAAG,EAAGnJ,EAAMyJ,MAAOzJ,EAAM0J,QAEvD,QACE,MAAM,IAAIzN,MAAM,iBAOtB,SAASiN,EAAmBlJ,GAC1B,MAA2B,oBAAhB4J,aAA+B5J,aAAiB4J,YAClD,cAEY,oBAAVC,OAAyB7J,aAAiB6J,MAC5C,QAEL7J,GAA0B,WAAjB,EAAOA,IAAsBA,EAAMJ,MAAQI,EAAMyJ,OAASzJ,EAAM0J,OACpE,OAEF,K,2DAnEF,SAAiB1J,GACtB,OAAO8J,QAAQZ,EAAmBlJ,K,cAG7B,SAAqBA,GAC1B,OAAQgJ,EAAahJ,IACnB,IAAK,cACFA,EAAsB+J,U,gCAetB,SAAsB/J,GAC3B,OAAOmJ,EAAanJ,I,2HCnBC,S,kZCkBvB,IAAMgK,EAAU,CACdC,KAAsB,oBAATA,MAAwBA,KACrC1E,OAA0B,oBAAXA,QAA0BA,OACzC2E,YAA0B,IAAXA,GAA0BA,EACzCb,SAA8B,oBAAbA,UAA4BA,UAGzCc,EAAQH,EAAQC,MAAQD,EAAQzE,QAAUyE,EAAQE,O,SACxD,IAAME,EAAUJ,EAAQzE,QAAUyE,EAAQC,MAAQD,EAAQE,O,WAC1D,IAAMG,EAAUL,EAAQE,QAAUF,EAAQC,MAAQD,EAAQzE,O,WAC1D,IAAM+E,EAAYN,EAAQX,UAAY,G,aAI/B,IAAMkB,EAEQ,iBAAnB,IAAO7E,EAAP,cAAOA,KAA4C,qBAApB8E,OAAO9E,IAAmCA,EAAQmC,Q,cAE5E,IAAM4C,EAAoC,mBAAlBC,c,aAG/B,IAAMC,OACe,IAAZjF,GAA2BA,EAAQhI,SAAW,YAAYkN,KAAKlF,EAAQhI,SACnEmN,EAAeF,GAAWG,WAAWH,EAAQ,KAAQ,E,+ICvB3D,SACLI,GAEA,IAAMC,EAAWC,EAAWF,GAC5B,OAUF,SAAwBA,GACtB,IAAMC,EAAWC,EAAWF,GAG5B,KADcC,EAAS9M,YAAc,IAA4C,aAAtC8M,EAASE,UAAU,GA1B7C,IA4Bf,OAAO,KAIT,MAAO,CACLhJ,SAAU,YACVuH,MAAOuB,EAASE,UAAU,IAlCX,GAmCfxB,OAAQsB,EAASE,UAAU,IAnCZ,IAcfC,CAAeH,IAwEnB,SAAyBD,GACvB,IAAMC,EAAWC,EAAWF,GAQ5B,KAJEC,EAAS9M,YAAc,GACe,QAAtC8M,EAASI,UAAU,GA5FJ,IA6FU,MAAzBJ,EAASK,SAAS,IAGlB,OAAO,KAGT,MA6BF,WAIE,IADA,IAAMC,EAAe,IAAIC,IAAI,CAAC,MAAQ,MAAQ,MAAQ,MAAQ,QACrDxR,EAAI,MAAQA,EAAI,QAAUA,EACjCuR,EAAaE,IAAIzR,GAKnB,IAAM0R,EAAa,IAAIF,IAAI,CACzB,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxF,MAAQ,QAGV,MAAO,CAACD,eAAcG,cA5CaC,GAA5BJ,EAAP,EAAOA,aAAcG,EAArB,EAAqBA,WAGjB1R,EAAI,EACR,KAAOA,EAAI,EAAIiR,EAAS9M,YAAY,CAClC,IAAMiJ,EAAS6D,EAASI,UAAUrR,GAxGnB,GA2Gf,GAAI0R,EAAWE,IAAIxE,GACjB,MAAO,CACLjF,SAAU,aACVwH,OAAQsB,EAASI,UAAUrR,EAAI,GA9GpB,GA+GX0P,MAAOuB,EAASI,UAAUrR,EAAI,GA/GnB,IAoHf,IAAKuR,EAAaK,IAAIxE,GACpB,OAAO,KAITpN,GAAK,EACLA,GAAKiR,EAASI,UAAUrR,GA1HT,GA6HjB,OAAO,KA9GL6R,CAAgBZ,IA4BpB,SAAwBD,GACtB,IAAMC,EAAWC,EAAWF,GAG5B,KADcC,EAAS9M,YAAc,IAA4C,aAAtC8M,EAASE,UAAU,GA9C7C,IAgDf,OAAO,KAIT,MAAO,CACLhJ,SAAU,YACVuH,MAAOuB,EAASI,UAAU,GArDR,GAsDlB1B,OAAQsB,EAASI,UAAU,GAtDT,IAelBS,CAAeb,IACfc,EAAed,I,mBA6CZ,SAASc,EAAef,GAC7B,IAAMC,EAAWC,EAAWF,GAQ5B,OAJEC,EAAS9M,YAAc,IACe,QAAtC8M,EAASI,UAAU,GApEJ,IAqEfJ,EAASE,UAAU,GApED,KAoEuBF,EAAS9M,WAO7C,CACLgE,SAAU,YACVuH,MAAOuB,EAASE,UAAU,IA7ER,GA8ElBxB,OAAQsB,EAASE,UAAU,IA9ET,IAuEX,KA2EX,SAASD,EAAWrL,GAClB,GAAIA,aAAgBmM,SAClB,OAAOnM,EAET,GAAIsE,YAAY8H,OAAOpM,GACrB,OAAO,IAAImM,SAASnM,EAAKT,QAS3B,GAAIS,aAAgBsE,YAClB,OAAO,IAAI6H,SAASnM,GAEtB,MAAM,IAAI3D,MAAM,gB,quDClLlB,YAcA,OACA,QAGA,WACA,WAGA,WACA,WACA,WAEA,QACA,QAGA,QACA,QACA,QAGA,QAGA,WAGA,W,mDAKO,IAAMgQ,EAA2B,CACtCC,GAAI,OACJ5R,KAAM,OACNR,OAAQ,eACR4D,QAASyO,UACTC,QAAS,CACPC,KAAM,K,6aCjDV,IAAMrC,EAAU,CACdC,KAAsB,oBAATA,MAAwBA,KACrC1E,OAA0B,oBAAXA,QAA0BA,OACzC2E,YAA0B,IAAXA,GAA0BA,EACzCb,SAA8B,oBAAbA,UAA4BA,UAGzCc,EAA8BH,EAAQC,MAAQD,EAAQzE,QAAUyE,EAAQE,QAAU,G,SACxF,IAAME,EAAgCJ,EAAQzE,QAAUyE,EAAQC,MAAQD,EAAQE,QAAU,G,WAC1F,IAAMG,EAAgCL,EAAQE,QAAUF,EAAQC,MAAQD,EAAQzE,QAAU,G,WAC1F,IAAM+E,EAAkCN,EAAQX,UAAY,G,aAKrD,IAAMkB,EAEQ,iBAAnB,IAAO7E,EAAP,cAAOA,KAA4C,qBAApB8E,OAAO9E,IAAmCA,EAAQmC,Q,cAG5E,IAAM4C,EAA6C,mBAAlBC,c,aAGjC,IAAM4B,EACO,oBAAX/G,aAAwD,IAAvBA,OAAOgH,Y,aAGjD,IAAM5B,OACe,IAAZjF,GAA2BA,EAAQhI,SAAW,YAAYkN,KAAKlF,EAAQhI,SAGnEmN,EAAuBF,GAAWG,WAAWH,EAAQ,KAAQ,E,uICnC1E,WACA,QACA,Q,8RAEA,IAAM6B,EAAO,aAWQC,E,WAenB,WAAYC,I,4FAA0B,iGAXhB,GAWgB,kGANP,IAO7B,IAAOpS,EAAqBoS,EAArBpS,KAAMsJ,EAAe8I,EAAf9I,OAAQ+I,EAAOD,EAAPC,KACrB,IAAAtN,QAAOuE,GAAU+I,GACjB5O,KAAKzD,KAAOA,EACZyD,KAAK6F,OAASA,EACd7F,KAAK4O,IAAMA,EACX5O,KAAK6O,UAAYJ,EACjBzO,KAAK8O,QAAU,SAACC,GAAD,OAAWC,QAAQC,IAAIF,IAEtC/O,KAAKkP,OAASlP,KAAKmP,uB,iDAbrB,WACE,MAAyB,oBAAXC,W,wBAmBhB,WACEpP,KAAK6O,UAAYJ,EACjBzO,KAAK8O,QAAUL,EAEfzO,KAAKkP,OAAOG,YACZrP,KAAKsP,YAAa,I,qBAGpB,WACE,OAAOvD,QAAQ/L,KAAK6O,a,yBAQtB,SAAYhN,EAAW0N,GACrBA,EAAeA,IAAgB,IAAAC,iBAAgB3N,GAE/C7B,KAAKkP,OAAOO,YAAY5N,EAAM0N,K,qCAShC,SAAwBG,GAItB,IAAIzR,EAAU,kBAUd,OATAA,GAAW,UAAJ,OAAc+B,KAAKzD,KAAnB,MACHmT,EAAMzR,UACRA,GAAW,GAAJ,OAAOyR,EAAMzR,QAAb,SAILyR,EAAMC,SACR1R,GAAW,IAAJ,OAAQyR,EAAMC,OAAd,YAAwBD,EAAME,QAEhC,IAAI1R,MAAMD,K,kCAMnB,WAAuB,WACrB+B,KAAK6P,cAAe,IAAAC,sBAAqB,CAACjK,OAAQ7F,KAAK6F,OAAQ+I,IAAK5O,KAAK4O,MACzE,IAAMM,EAAS,IAAIE,OAAOpP,KAAK6P,aAAc,CAACtT,KAAMyD,KAAKzD,OAiBzD,OAfA2S,EAAOa,UAAY,SAACL,GACbA,EAAM7N,KAGT,EAAKgN,UAAUa,EAAM7N,MAFrB,EAAKiN,QAAQ,IAAI5Q,MAAM,sBAM3BgR,EAAOc,QAAU,SAACjB,GAChB,EAAKD,QAAQ,EAAKmB,wBAAwBlB,IAC1C,EAAKO,YAAa,GAGpBJ,EAAOgB,eAAiB,SAACR,GAAD,OAAWV,QAAQD,MAAMW,IAE1CR,O,+SCxEX,SAASiB,EAAezS,GACtB,QAAKA,IAGDA,aAAkByI,cAGK,oBAAhBiK,aAA+B1S,aAAkB0S,cAGjC,oBAAhBvE,aAA+BnO,aAAkBmO,aAG7B,oBAApBwE,iBAAmC3S,aAAkB2S,mB,mEA5C3D,SAASb,EACd9R,GAGgB,IAFhB4S,IAEgB,yDADhBC,EACgB,uCAEVC,EAAeD,GAAa,IAAI/C,IAEtC,GAAK9P,GAEE,GAAIyS,EAAezS,GACxB8S,EAAa/C,IAAI/P,QACZ,GAAIyS,EAAezS,EAAO0D,QAE/BoP,EAAa/C,IAAI/P,EAAO0D,aACnB,GAAI+E,YAAY8H,OAAOvQ,SAGvB,GAAI4S,GAA+B,WAAlB,EAAO5S,GAC7B,IAAK,IAAMH,KAAOG,EAEhB8R,EAAgB9R,EAAOH,GAAM+S,EAAWE,QAM5C,YAAqBC,IAAdF,EAA0B7G,MAAMgH,KAAKF,GAAgB,K,uoGCG9D,eACA,WACA,Q,6JCcO,SAAiC3L,GAEtC,OADa8L,EAAM9L,EAAO,IACX8L,EAAM,I,4BAGhB,SAAmCC,GACxC,IAAMzS,EAAgB0S,EAAwBhU,IAAI+T,EAAWE,aAC7D,IAAK3S,EACH,MAAM,IAAID,MAAM,uBAElB,OAAOC,G,gCAGF,SAAuCuD,EAAUT,GACtD,IAAMc,EAAYgP,EAAkCrP,EAASvD,eACvD6S,EAAaC,EAA6BvP,EAASrD,MACnD6S,EAAoBC,EAAsCzP,EAASvD,eACnE6D,EAASN,EAASoD,MAAQkM,EAC1B7Q,EAAauB,EAASoD,MAAQkM,EAAaE,EAEjD,OADA,IAAA5P,QAAOnB,GAAc,GAAKA,GAAcc,EAAWd,YAC5C,CAAC4B,YAAWC,SAAQ7B,eA7E7B,WAEMwQ,EAAQ,CAAC,SAAU,OAAQ,OAAQ,QAcnCS,EAAyE,CAC7E,CAACC,UAAW,MACZ,CAAC7P,WAAY,MACb,CAAC8P,WAAY,MACb,CAACC,YAAa,MACd,CAACC,YAAa,MACd,CAACC,aAAc,MACf,CAACC,aAAc,OAEXb,EAA0B,IAAIc,IAClCP,GAGIH,EAA+B,CACnCrS,OAAQ,EACRC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,IAGFiS,EAAwC,CAC5ChS,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,GAGFuR,EAAoC,CACxC5R,KAAMkS,UACNjS,KAAMoC,WACNnC,KAAMiS,WACNhS,KAAMiS,YACNhS,KAAMiS,YACNhS,KAAMiS,e,whCClDR,YACA,QAKA,QAGA,QAEA,QAQA,S,yGCpBuB,S,wICHvB,WACA,QACA,QACA,WACA,WACA,W,gaAIe,WAA0BhQ,EAAa4M,EAAS7C,GAAhD,8FAEPoG,GADNvD,EAAUA,GAAW,IACQpM,OAAS,GAGhC4P,EAAYD,EAAavT,MAAQ,OAEhCuQ,GAAOpD,GAAW,IAAlBoD,IAGDkD,EAAWC,EAAqBF,GAVzB,KAaLC,EAbK,OAcN,gBAdM,OAiBN,UAjBM,QAoBN,SApBM,0CAeK,aAAmBrQ,EAAa4M,EAASO,GAf9C,eAeT3M,EAfS,sDAkBK,aAAaR,EAAa4M,EAASO,GAlBxC,eAkBT3M,EAlBS,sDAsBK,aAAiBR,EAAa4M,GAtBnC,eAsBTpM,EAtBS,qCAyBT,IAAAX,SAAO,GAzBE,cA6BK,SAAduQ,IACF5P,GAAQ,IAAAmJ,cAAanJ,IA9BV,kBAiCNA,GAjCM,6C,sBAqCf,SAAS8P,EAAqB1T,GAC5B,OAAQA,GACN,IAAK,OACL,IAAK,OAGH,OAAO,IAAA2T,uBACT,QAGE,OADA,IAAAC,sBAAqB5T,GACdA,K,qGCzCN,SAA8BA,GACnC,OAAQA,GACN,IAAK,OAEH,OAAO6T,GAA0BC,GAAmBC,EAEtD,IAAK,cACH,OAAOF,EACT,IAAK,QACH,OAAOC,EACT,IAAK,OACH,OAAOC,EAET,QACE,MAAM,IAAIlU,MAAJ,oCAAuCG,EAAvC,yC,sBAQL,WACL,GAAI6T,EACF,MAAO,cAET,GAAIC,EACF,MAAO,QAET,GAAIC,EACF,MAAO,OAIT,MAAM,IAAIlU,MAAM,kEAhDlB,YAGOmU,EAAmBlG,SAAnBkG,gBAEDF,EAAmC,oBAAVrG,MACzBoG,EAAgD,oBAAhBrG,YAChCyG,EAAuBvG,QAAQsG,GAC/BD,IAAiB5F,aAAmB8F,G,wJCT1C,Y,6WAGe,WAA4B7Q,EAAa4M,EAASO,GAAlD,iGAKP2D,GAAgB,IAAAC,qBAAoB/Q,EAAamN,GACjD6D,EAAMvG,KAAKuG,KAAOvG,KAAKwG,UACvBC,EAAqC,iBAAlBJ,GAA8BE,EAAIG,gBAAgBL,GAP9D,kBASEM,EAAYF,GAAaJ,EAAelE,GAT1C,+DAWPsE,GACFF,EAAIK,gBAAgBH,GAZX,0E,+BAiBOE,E,qFAAf,WAA2BjE,EAAKP,GAAhC,0FACCpM,EAAQ,IAAI6J,OACZiH,IAAMnE,IASRP,EAAQpM,OAASoM,EAAQpM,MAAM+Q,QAAU/Q,EAAM+Q,QAX9C,gCAYG/Q,EAAM+Q,SAZT,gCAaI/Q,GAbJ,uBAiBQ,IAAIgR,SAAQ,SAACC,EAASC,GACjC,IACElR,EAAMmR,OAAS,kBAAMF,EAAQjR,IAC7BA,EAAM+N,QAAU,SAACqD,GAAD,OAASF,EAAO,IAAIjV,MAAJ,+BAAkC0Q,EAAlC,aAA0CyE,MAC1E,MAAOtE,GACPoE,EAAOpE,OAtBN,oF,sICVA,SAA6BtN,EAAamN,GAC/C,GAAI0E,EAAM1E,GAAM,CAEd,IACM2E,GADc,IAAIC,aACIR,OAAOvR,GAOnC,MADY,6BAAH,OAAgCgS,KAAKF,IAGhD,OAAOG,EAAQjS,EAAamN,I,YApB9B,IAAM+E,EAAuB,wBACvBC,EAAkB,oBAEjB,SAASN,EAAM1E,GACpB,OAAOA,IAAQ+E,EAAqBE,KAAKjF,IAAQgF,EAAgBC,KAAKjF,IAmBjE,SAAS8E,EAAQjS,EAAamN,GACnC,GAAI0E,EAAM1E,GAGR,MAAM,IAAI1Q,MAAM,gDAGlB,OAAO,IAAI4V,KAAK,CAAC,IAAItS,WAAWC,O,uFC7B3B,SAAgBzD,EAAgBC,GACrC,IAAKD,EACH,MAAM,IAAIE,MAAMD,GAAW,8B,+FCJ/B,W,kSAKqB8V,E,WAUnB,WAAYC,EAAiBC,GAA4B,Y,4FAAA,mKACvDjU,KAAKzD,KAAOyX,EACZhU,KAAKiU,aAAeA,EACpBjU,KAAKkU,WAAY,EACjBlU,KAAKmU,SAAW,aAChBnU,KAAKoU,QAAU,aACfpU,KAAK4G,OAAS,IAAIqM,SAAQ,SAACC,EAASC,GAClC,EAAKgB,SAAWjB,EAChB,EAAKkB,QAAUjB,K,kDAQnB,SAAY9U,EAAyBgW,GACnCrU,KAAKiU,aAAaxE,YAAY,CAC5B5J,OAAQ,aACRxH,OACAgW,c,kBAOJ,SAAKpX,IACH,IAAAqE,QAAOtB,KAAKkU,WACZlU,KAAKkU,WAAY,EACjBlU,KAAKmU,SAASlX,K,mBAMhB,SAAM8R,IACJ,IAAAzN,QAAOtB,KAAKkU,WACZlU,KAAKkU,WAAY,EACjBlU,KAAKoU,QAAQrF,Q,4ICxDjB,eACA,W,o6DAYA,IAAMuF,EAAiC,CACrCC,eAAgB,EAChBC,qBAAsB,EACtBC,QAAS,aACTC,cAAc,GAMKC,E,WAmBnB,WAAoBhG,I,4FAAwB,qDAjBtB,IAAIgD,KAkBxB3R,KAAK2O,MAAL,KAAiB2F,GACjBtU,KAAK4U,SAASjG,GAEd3O,KAAK6U,YAAc,IAAIlD,I,iDAhBzB,WACE,OAAOjD,UAAaoG,gB,2BAItB,WAA8D,IAAzCnG,EAAyC,uDAAhB,GAG5C,OAFAgG,EAAWI,YAAcJ,EAAWI,aAAe,IAAIJ,EAAW,IAClEA,EAAWI,YAAYH,SAASjG,GACzBgG,EAAWI,gB,wBAepB,WAAgB,UACW/U,KAAK6U,YAAYG,UAD5B,IACd,2BAAoD,QACvCC,UAFC,iC,sBAUhB,SAAStG,GACP3O,KAAK2O,MAAL,OAAiB3O,KAAK2O,OAAUA,GADK,UAGZ3O,KAAK6U,YAAYG,UAHL,IAGrC,2BAAoD,QACvCJ,SAAS5U,KAAKkV,uBAJU,iC,2BAiBvC,SAAc7G,GACZ,IAAO9R,EAAqB8R,EAArB9R,KAAMsJ,EAAewI,EAAfxI,OAAQ+I,EAAOP,EAAPO,IACjBuG,EAAanV,KAAK6U,YAAYhY,IAAIN,GAUtC,OATK4Y,KACHA,EAAa,IAAIC,UAAW,CAC1B7Y,OACAsJ,SACA+I,SAESgG,SAAS5U,KAAKkV,uBACzBlV,KAAK6U,YAAYQ,IAAI9Y,EAAM4Y,IAEtBA,I,iCAGT,WACE,MAAO,CACLZ,eAAgBvU,KAAK2O,MAAM4F,eAC3BC,qBAAsBxU,KAAK2O,MAAM6F,qBACjCE,aAAc1U,KAAK2O,MAAM+F,aACzBD,QAASzU,KAAK2O,MAAM8F,c,8CA7ELE,E,sHCtBrB,YACA,WACA,W,gtCAqCqBS,E,WAmBnB,WAAYzG,I,4FAAwB,uBAlBrB,WAkBqB,qEAfX,GAeW,8BAdL,GAcK,kBAbW,eAaX,uBAZZ,GAYY,eAVH,IAUG,kBATJ,IASI,mBARA,IAQA,eAPpB,GAOoB,sBANd,GAOpB3O,KAAK6F,OAAS8I,EAAM9I,OACpB7F,KAAK4O,IAAMD,EAAMC,IACjB5O,KAAK4U,SAASjG,G,kDAOhB,WAEE3O,KAAKsV,UAAUC,SAAQ,SAACrG,GAAD,OAAYA,EAAO+F,aAC1CjV,KAAKwV,aAAc,I,sBAGrB,SAAS7G,GACP3O,KAAK2O,MAAL,OAAiB3O,KAAK2O,OAAUA,QAEb8B,IAAf9B,EAAMpS,OACRyD,KAAKzD,KAAOoS,EAAMpS,WAESkU,IAAzB9B,EAAM4F,iBACRvU,KAAKuU,eAAiB5F,EAAM4F,qBAEK9D,IAA/B9B,EAAM6F,uBACRxU,KAAKwU,qBAAuB7F,EAAM6F,2BAET/D,IAAvB9B,EAAM+F,eACR1U,KAAK0U,aAAe/F,EAAM+F,mBAENjE,IAAlB9B,EAAM8F,UACRzU,KAAKyU,QAAU9F,EAAM8F,W,oDAIzB,WACElY,GADF,oHAEEsS,EAFF,+BAEyB,SAAC4G,EAAKpX,EAAMwD,GAAZ,OAAqB4T,EAAIC,KAAK7T,IACrDiN,EAHF,+BAGqB,SAAC2G,EAAK1G,GAAN,OAAgB0G,EAAI1G,MAAMA,IAGvC4G,EAAe,IAAI1C,SAAmB,SAAC2C,GAG3C,OADA,EAAKC,SAASrT,KAAK,CAACjG,OAAMsS,YAAWC,UAAS8G,YACvC,KAET5V,KAAK8V,kBAXP,SAYeH,EAZf,wF,yGAqBA,0GACO3V,KAAK6V,SAAS7T,OADrB,oDAKQiS,EAAejU,KAAK+V,sBAL5B,sDAWQC,EAAYhW,KAAK6V,SAASI,SAXlC,wBAeIjW,KAAKyU,QAAQ,CACXxW,QAAS,eACT1B,KAAMyZ,EAAUzZ,KAChB0X,eACAiC,QAASlW,KAAK6V,SAAS7T,SAInByT,EAAM,IAAI1B,UAAUiC,EAAUzZ,KAAM0X,GAG1CA,EAAapF,UAAY,SAAChN,GAAD,OAAUmU,EAAUnH,UAAU4G,EAAK5T,EAAKxD,KAAMwD,EAAKwS,UAC5EJ,EAAanF,QAAU,SAACC,GAAD,OAAWiH,EAAUlH,QAAQ2G,EAAK1G,IAGzDiH,EAAUJ,QAAQH,GA9BtB,oBAkCYA,EAAI7O,OAlChB,yBAoCM5G,KAAKmW,oBAAoBlC,GApC/B,4E,8EAiDA,SAAoB/E,GAEhBlP,KAAKwV,cAAgBxV,KAAK0U,cAAgB1U,KAAK8E,MAAQ9E,KAAKoW,sBAG5DlH,EAAO+F,UACPjV,KAAK8E,SAEL9E,KAAKsV,UAAU9S,KAAK0M,GAGjBlP,KAAKwV,aACRxV,KAAK8V,oB,iCAOT,WAEE,GAAI9V,KAAKsV,UAAUtT,OAAS,EAC1B,OAAOhC,KAAKsV,UAAUW,SAAW,KAInC,GAAIjW,KAAK8E,MAAQ9E,KAAKoW,qBAAsB,CAC1CpW,KAAK8E,QACL,IAAMvI,EAAO,GAAH,OAAMyD,KAAKzD,KAAK4K,cAAhB,cAAmCnH,KAAK8E,MAAxC,eAAoD9E,KAAKuU,eAAzD,KACV,OAAO,IAAI7F,UAAa,CAACnS,OAAMsJ,OAAQ7F,KAAK6F,OAAQ+I,IAAK5O,KAAK4O,MAIhE,OAAO,O,gCAGT,WACE,OAAOL,WAAWvO,KAAKwU,qBAAuBxU,KAAKuU,oB,4ICzMvD,Y,sKAEA,IAAM8B,EAAsB,IAAI1E,IAKX2E,E,2KAInB,SAAqBzH,GAEnB3C,KAAK6D,UAAY,SAAC9R,GAChB,GAAKsY,EAAetY,GAApB,CAKA,MAAwBA,EAAQ4D,KAAzBxD,EAAP,EAAOA,KAAMgW,EAAb,EAAaA,QACbxF,EAAUxQ,EAAMgW,O,8BAIpB,SACExF,GAEA,IAAI2H,EAAmBH,EAAoBxZ,IAAIgS,GAE1C2H,IACHA,EAAmB,SAACvY,GAClB,GAAKsY,EAAetY,GAApB,CAKA,MAAwBA,EAAQ4D,KAAzBxD,EAAP,EAAOA,KAAMgW,EAAb,EAAaA,QACbxF,EAAUxQ,EAAMgW,MAKpBnI,KAAKuK,iBAAiB,UAAWD,K,iCAGnC,SACE3H,GAEA,IAAM2H,EAAmBH,EAAoBxZ,IAAIgS,GACjDwH,EAAmB,OAAQxH,GAE3B3C,KAAKwK,oBAAoB,UAAWF,K,yBAQtC,SAAmBnY,EAAyBgW,GAC1C,GAAInI,KAAM,CACR,IAAMrK,EAA0B,CAACgE,OAAQ,aAAcxH,OAAMgW,WACvD9E,GAAe,IAAAC,iBAAgB6E,GAGrCnI,KAAKuD,YAAY5N,EAAM0N,Q,yCAM7B,SAASgH,EAAetY,GACtB,IAAOI,EAAcJ,EAAdI,KAAMwD,EAAQ5D,EAAR4D,KACb,MACW,YAATxD,GACAwD,GACuB,iBAAhBA,EAAKgE,QACZhE,EAAKgE,OAAO8Q,WAAW,c,2GCpEpB,SAAuBzH,GAC5B,IAAM0H,EANQ,UAME1H,EAAOvP,QAAP,yBANF,QAME,KAA4D,GAC5E,gBAAUuP,EAAO3S,KAAjB,YAAyB2S,EAAOvP,SAAhC,OAA0CiX,I,eAUrC,SAAsB1H,GAA2D,IAArCb,EAAqC,uDAAZ,GACpEwI,EAAgBxI,EAAQa,EAAOf,KAAO,GAEtC2I,EAAa,GAAH,OAAM5H,EAAOf,GAAb,cAEZS,EAAMiI,EAAcE,UAII,SAAxB1I,EAAQ2I,cACVpI,EAAM,WAAH,OAAcM,EAAOnT,OAArB,iBAAoC+a,IAIzC,IAAKlI,EAAK,CAER,IAAIjP,EAAUuP,EAAOvP,QAEL,WAAZA,IAEFA,EAtCU,UAwCZ,IAAMsX,EAAatX,EAAU,IAAH,OAAOA,GAAY,GAC7CiP,EAAM,iCAAH,OAAoCM,EAAOnT,QAA3C,OAAoDkb,EAApD,iBAAuEH,GAM5E,OAHA,IAAAxV,QAAOsN,GAGAA,GAlDT,WACA,O,qYCyBG7R,OAAOma,c,IAZWC,E,WAKnB,c,4FAAc,sFACZnX,KAAKoX,QAAU,GACfpX,KAAKqX,UAAY,GACjBrX,KAAKsX,SAAU,E,sCAIjB,WACE,OAAOtX,O,kBAIT,SAAK/C,GACH,OAAO+C,KAAKuX,QAAQta,K,qBAOtB,SAAQA,GACN,GAAI+C,KAAKsX,QACP,MAAM,IAAIpZ,MAAM,UAGlB,GAAI8B,KAAKqX,UAAUrV,OAAS,EAAG,CAC7B,GAAIhC,KAAKoX,QAAQpV,OAAS,EACxB,MAAM,IAAI9D,MAAM,0BAElB,IAAMsZ,EAAUxX,KAAKqX,UAAUpB,QAC3BhZ,aAAiBiB,MACnBsZ,EAAQrE,OAAOlW,GAEfua,EAAQtE,QAAQ,CAACjW,eAGnB+C,KAAKoX,QAAQ5U,KAAKvF,K,mBAKtB,WACE,KAAO+C,KAAKqX,UAAUrV,OAAS,GACbhC,KAAKqX,UAAUpB,QACvB/C,QAAQ,CAACwC,MAAM,IAEzB1V,KAAKsX,SAAU,I,kBAMjB,WAAwC,WAEtC,GAAItX,KAAKoX,QAAQpV,OAAS,EAAG,CAC3B,IAAM/E,EAAQ+C,KAAKoX,QAAQnB,QAC3B,OAAIhZ,aAAiBiB,MACZ+U,QAAQE,OAAOlW,GAEjBgW,QAAQC,QAAQ,CAACwC,MAAM,EAAOzY,UAIvC,GAAI+C,KAAKsX,QAAS,CAChB,GAAItX,KAAKqX,UAAUrV,OAAS,EAC1B,MAAM,IAAI9D,MAAM,0BAElB,OAAO+U,QAAQC,QAAQ,CAACwC,MAAM,EAAMzY,WAAOwT,IAI7C,OAAO,IAAIwC,SAAQ,SAACC,EAASC,GAC3B,EAAKkE,UAAU7U,KAAK,CAAC0Q,UAASC,mB,0EC/E7B,SAASsE,EACdhW,EACAF,EACAS,GAEA,GAAIP,EAAYtB,YAAcoB,EAAaS,EACzC,MAAO,GAIT,IAFA,IAAMiL,EAAW,IAAIe,SAASvM,GAC1BiW,EAAQ,GACH1b,EAAI,EAAGA,EAAIgG,EAAQhG,IAC1B0b,GAASjL,OAAOkL,aAAa1K,EAASK,SAAS/L,EAAavF,IAE9D,OAAO0b,E,sEA1BF,SAA4B7V,GAA0B,IAApBG,EAAoB,uDAAX,EAChD,GAAoB,iBAATH,EACT,OAAOA,EAAK+V,MAAM,EAAG5V,GAChB,GAAImE,YAAY8H,OAAOpM,GAE5B,OAAO4V,EAAe5V,EAAKT,OAAQS,EAAKN,WAAYS,GAC/C,GAAIH,aAAgBsE,YAAa,CACtC,IAAM5E,EAAa,EACnB,OAAOkW,EAAe5V,EAAMN,EAAYS,GAE1C,MAAO,I,kHCJF,SAAuBH,GAExBkB,EAAK8U,gBAEPhW,EAAOkB,EAAK8U,cAAchW,IAG5B,GAAIA,aAAgBsE,YAClB,OAAOtE,EAIT,GAAIsE,YAAY8H,OAAOpM,GACrB,OAAOA,EAAKT,OAGd,GAAoB,iBAATS,EAAmB,CAC5B,IAAMiW,EAAOjW,EAEb,OADmB,IAAIkW,aAAcC,OAAOF,GAC1B1W,OAIpB,GAAIS,GAAwB,WAAhB,EAAOA,IAAqBA,EAAKoW,eAC3C,OAAOpW,EAAKoW,iBAGd,MAAM,IAAI/Z,MAAM,kB,sBASX,SACLga,EACAC,EACAhY,GAGA,GADAA,EAAaA,GAAc+X,EAAa/X,WACpC+X,EAAa/X,WAAaA,GAAcgY,EAAahY,WAAaA,EACpE,OAAO,EAIT,IAFA,IAAMiY,EAAS,IAAI5W,WAAW0W,GACxBG,EAAS,IAAI7W,WAAW2W,GACrBnc,EAAI,EAAGA,EAAIoc,EAAOpW,SAAUhG,EACnC,GAAIoc,EAAOpc,KAAOqc,EAAOrc,GACvB,OAAO,EAGX,OAAO,G,0BAOF,WAAwF,2BAApDsc,EAAoD,yBAApDA,EAAoD,gBAE7F,IAF6F,EAEvFC,EAAeD,EAAQE,KAAI,SAACC,GAAD,OAC/BA,aAAmBtS,YAAc,IAAI3E,WAAWiX,GAAWA,KAIvDtY,EAAaoY,EAAaG,QAAO,SAAC1W,EAAQ4O,GAAT,OAAwB5O,EAAS4O,EAAWzQ,aAAY,GAGzFyG,EAAS,IAAIpF,WAAWrB,GAG1BwY,EAAS,EAbgF,IAcnEJ,GAdmE,IAc7F,2BAAwC,KAA7BK,EAA6B,QACtChS,EAAOyO,IAAIuD,EAAaD,GACxBA,GAAUC,EAAYzY,YAhBqE,8BAoB7F,OAAOyG,EAAOxF,Q,yBAST,WAA2D,2BAArByX,EAAqB,yBAArBA,EAAqB,gBAEhE,IAAMC,EAASD,EAETE,EAAyBD,GAAUA,EAAO9W,OAAS,GAAK8W,EAAO,GAAGhI,aAAgB,KACxF,IAAKiI,EACH,MAAM,IAAI7a,MACR,wGAQJ,IAJA,IAAM8a,EAAYF,EAAOJ,QAAO,SAACO,EAAKhc,GAAN,OAAgBgc,EAAMhc,EAAM+E,SAAQ,GAE9D4E,EAAS,IAAImS,EAAsBC,GACrCL,EAAS,EACb,MAAoBG,EAApB,eAA4B,CAAvB,IAAM9X,EAAK,KACd4F,EAAOyO,IAAIrU,EAAO2X,GAClBA,GAAU3X,EAAMgB,OAElB,OAAO4E,G,mBASF,SACLnF,EACAF,EACApB,GAEA,IAAM+Y,OACWzI,IAAftQ,EACI,IAAIqB,WAAWC,GAAa2F,SAAS7F,EAAYA,EAAapB,GAC9D,IAAIqB,WAAWC,GAAa2F,SAAS7F,GAE3C,OADkB,IAAIC,WAAW0X,GAChB9X,QAnInB,M,ybAAA,Q,0/CCoBO,SACL+X,EACAjU,EACA3D,GAEa,IADbpB,EACa,uDADQ+E,EAAa/E,WAE5BiG,EAAc,IAAI5E,WAAW2X,EAAc5X,EAAYpB,GACvDyY,EAAc,IAAIpX,WAAW0D,GAEnC,OADAkB,EAAYiP,IAAIuD,GACTO,G,cAWF,SAAqBtT,EAA2BuT,EAAaC,GAClE,IAAIT,EAEJ,GAAI/S,aAAkBM,YACpByS,EAAc,IAAIpX,WAAWqE,OACxB,CAOL,IAAMyT,EAAgBzT,EAAOtE,WACvBgY,EAAgB1T,EAAO1F,WAG7ByY,EAAc,IAAIpX,WAAWqE,EAAOzE,QAAUyE,EAAOpE,YAAa6X,EAAeC,GAMnF,OAFAH,EAAO/D,IAAIuD,EAAaS,GAEjBA,EAAe7U,EAAYoU,EAAYzY,WAAY,IA/D5D,YASO,SAASqE,EAAYrE,EAAoBqZ,GAG9C,OAFA,IAAAlY,QAAOnB,GAAc,IACrB,IAAAmB,QAAOkY,EAAU,GACTrZ,GAAcqZ,EAAU,KAAQA,EAAU,K,yGCT7B,S,8oICoBvB,eAEA,WACA,WAEA,QAOA,QA+BA,QAuCA,QACA,QACA,QAGA,W,oJC3GA,Y,8RAGA,IAEqBC,E,WAUnB,WAAYC,EAAgBrL,GAM1B,G,4FANsD,0EANvC,GAMuC,oBALP,MAKO,mBAJ9B,MAI8B,gBAHvC,GAGuC,kBAF3B,IAG3BrO,KAAKqO,QAAUA,EACfrO,KAAK0Z,OAASA,GAIThQ,MAAMiQ,QAAQD,GAEjB,IAAK,IAAMnc,KADXyC,KAAK4Z,SAAW,GACEF,EAChB1Z,KAAK4Z,SAASF,EAAOnc,GAAKuD,OAAS4Y,EAAOnc,GAAKhB,K,+CAKrD,WACE,OAAOyD,KAAKgC,S,yBAGd,SAAY6X,EAAYC,GAMtB,OALIlW,OAAOC,SAASiW,KAClB9Z,KAAK8Z,OAASA,GAIR9Z,KAAKqO,QAAQ0L,OACnB,IAAK,mBACH,IAAMC,GAAY,IAAAC,oBAAmBJ,EAAK7Z,KAAK4Z,UAC/C5Z,KAAKka,aAAaF,EAAWF,GAC7B,MACF,IAAK,kBACH9Z,KAAKma,UAAYna,KAAKma,WAAa,IAAIzQ,MA1CrB,KA2ClB1J,KAAKma,UAAUna,KAAKgC,QAAU6X,EAC9B7Z,KAAKgC,Y,0BAKX,SAAa6X,EAAkCC,GAM7C,OALIlW,OAAOC,SAASiW,KAClB9Z,KAAK8Z,OAASA,GAIR9Z,KAAKqO,QAAQ0L,OACnB,IAAK,kBACH,IAAMK,GAAW,IAAAC,mBAAkBR,EAAK7Z,KAAK4Z,UAC7C5Z,KAAKsa,YAAYF,EAAUN,GAC3B,MACF,IAAK,mBACH9Z,KAAKua,WAAava,KAAKua,YAAc,IAAI7Q,MA7DvB,KA8DlB1J,KAAKua,WAAWva,KAAKgC,QAAU6X,EAC/B7Z,KAAKgC,Y,sBAKX,WACE,IAAIwY,EAAOxa,KAAKma,WAAana,KAAKua,WAClC,OAAKC,GAILA,EAAOA,EAAK5C,MAAM,EAAG5X,KAAKgC,QAC1BhC,KAAKma,UAAY,KACjBna,KAAKua,WAAa,KAEX,CACLR,MAAO/Z,KAAKqO,QAAQ0L,MACpBU,UAAW,OACX5Y,KAAM2Y,EACNxY,OAAQhC,KAAKgC,OACb0X,OAAQ1Z,KAAK0Z,OACbI,OAAQ9Z,KAAK8Z,SAbN,U,gJC5EN,SACLY,EACAC,GAEA,IAAKD,EACH,MAAM,IAAIxc,MAAM,YAElB,IAAKyc,EACH,MAAM,IAAIzc,MAAM,cAGlB,IADA,IAAM0c,EAAY,GACT5e,EAAI,EAAGA,EAAI2e,EAAQ3Y,OAAQhG,IAClC4e,EAAUD,EAAQ3e,IAAM0e,EAAS1e,GAEnC,OAAO4e,G,oBAIF,SACLA,EACAD,GAEA,IAAKC,EACH,MAAM,IAAI1c,MAAM,YAElB,IAAKyc,EACH,MAAM,IAAIzc,MAAM,cAGlB,IADA,IAAMwc,EAAW,IAAIhR,MAAMiR,EAAQ3Y,QAC1BhG,EAAI,EAAGA,EAAI2e,EAAQ3Y,OAAQhG,IAClC0e,EAAS1e,GAAK4e,EAAUD,EAAQ3e,IAElC,OAAO0e,I,60CC3BT,IAEqBG,E,WAMnB,WAAYnB,EAAgBrL,I,4FAAoC,iDAJ/C,GAI+C,mBAH5C,GAG4C,iBAFvB,IAGvCrO,KAAK0Z,OAASA,EACd1Z,KAAK8a,qB,+CAGP,WACE,OAAO9a,KAAKgC,S,yBAGd,SAAY6X,GAEV7Z,KAAK8a,qBACL,IAAI9e,EAAI,EAER,IAAK,IAAM+e,KAAa/a,KAAKgb,QAC3Bhb,KAAKgb,QAAQD,GAAW/a,KAAKgC,QAAU6X,EAAI7d,KAE7CgE,KAAKgC,W,0BAGP,SAAa6X,GAGX,IAAK,IAAMkB,KADX/a,KAAK8a,qBACmBjB,EACtB7Z,KAAKgb,QAAQD,GAAW/a,KAAKgC,QAAU6X,EAAIkB,GAE7C/a,KAAKgC,W,sBAGP,WACEhC,KAAKib,gBACL,IAAMD,EAAUtR,MAAMiQ,QAAQ3Z,KAAK0Z,QAAU1Z,KAAKgb,QAAU,GAK5D,IAAKtR,MAAMiQ,QAAQ3Z,KAAK0Z,QACtB,IAAK,IAAMqB,KAAa/a,KAAK0Z,OAAQ,CACnC,IAAMwB,EAAQlb,KAAK0Z,OAAOqB,GAC1BC,EAAQE,EAAM3e,MAAQyD,KAAKgb,QAAQE,EAAMpa,OAc7C,OAVAd,KAAKgb,QAAU,GAEmB,CAChCjB,MAAO,iBACPU,UAAW,OACX5Y,KAAMmZ,EACNtB,OAAQ1Z,KAAK0Z,OACb1X,OAAQhC,KAAKgC,U,gCAQjB,WACE,KAAIhC,KAAKgC,OAAShC,KAAKmb,WAQvB,IAAK,IAAMJ,KAHX/a,KAAKmb,UAAYnb,KAAKmb,UAAY,EAAKnb,KAAKmb,WAAa,EAxEnC,IAyEtBnb,KAAKgb,QAAU,GAEShb,KAAK0Z,OAAQ,CACnC,IAAMwB,EAAQlb,KAAK0Z,OAAOqB,GACpBhZ,EAAYmZ,EAAM7c,MAAQoT,aAC1B2J,EAAYpb,KAAKgb,QAAQE,EAAMpa,OAErC,GAAIsa,GAAajV,YAAY8H,OAAOmN,GAAY,CAE9C,IAAMxK,EAAa,IAAI7O,EAAU/B,KAAKmb,WACtCvK,EAAWyE,IAAI+F,GACfpb,KAAKgb,QAAQE,EAAMpa,OAAS8P,OACnBwK,GAETA,EAAUpZ,OAAShC,KAAKmb,UACxBnb,KAAKgb,QAAQE,EAAMpa,OAASsa,GAG5Bpb,KAAKgb,QAAQE,EAAMpa,OAAS,IAAIiB,EAAU/B,KAAKmb,c,2BAKrD,WACE,cAAmCze,OAAO2e,QAAQrb,KAAKgb,SAAvD,eAAiE,CAA5D,gBAAOM,EAAP,KAAmBC,EAAnB,KACHvb,KAAKgb,QAAQM,GAAcC,EAAO3D,MAAM,EAAG5X,KAAKgC,c,qQCpGtD,Y,m8DAEA,IAOIwZ,EACAC,EAPEC,EAAuB,oDAAH,OADJ,QACI,qBACpBC,EAAyB,oDAAH,OAFN,QAEM,0BACtBC,EAAyB,oDAAH,OAHN,QAGM,uBAEtBC,EAAoB,kDAAH,OALD,QAKC,gC,iDAKhB,WAAsCxN,GAAtC,6FACCnS,EAAUmS,EAAQnS,SAAW,GAIjCsf,EADEtf,EAAQ4f,QAERN,GACAtf,EAAQ4f,QAAQC,oBAAoB,IAAIC,MAAK,SAACC,GAC5C,MAAO,CAACA,YAIST,GAAsBU,EAAiB7N,GAZzD,SAcQmN,EAdR,oF,uEAiBA,WAAsCnN,GAAtC,6FACCnS,EAAUmS,EAAQnS,SAAW,GAIjCuf,EADEvf,EAAQ4f,QAERL,GACAvf,EAAQ4f,QAAQK,oBAAoB,IAAIH,MAAK,SAACC,GAC5C,MAAO,CAACA,YAISR,GAAsBW,EAAiB/N,GAZzD,SAcQoN,EAdR,oF,+BAmBQS,E,mFAAf,WAAgC7N,GAAhC,iGAGUA,EAAQ4N,OAAS5N,EAAQ4N,MAAMI,YAHzC,OAIS,OAJT,8CAKiC,IAAAC,aAAYZ,EAAsB,QAASrN,GAL5E,cAKMkO,EALN,+CAU+CtJ,QAV/C,WAWc,IAAAqJ,aAAYX,EAAwB,QAAStN,GAX3D,sCAYc,IAAAiO,aAAYV,EAAwB,QAASvN,GAZ3D,2DAUuDmO,IAVvD,0CAUOD,EAVP,KAU2BE,EAV3B,oBAiBEF,EAAqBA,GAAsBG,WAAWH,mBAjBxD,UAkBeI,EAAuBJ,EAAoBE,GAlB1D,sF,sBAqBA,SAASE,EAAuBJ,EAAoBE,GAClD,IAAMpO,EAA8B,GAKpC,OAJIoO,IACFpO,EAAQoO,WAAaA,GAGhB,IAAIxJ,SAAQ,SAACC,GAClBqJ,EAAmB,EAAD,KACblO,GADa,IAEhBuO,eAAgB,SAACX,GAAD,OAAW/I,EAAQ,CAAC+I,iB,SAO3BG,E,mFAAf,WAAgC/N,GAAhC,uGACiC,IAAAiO,aAAYT,EAAmB,QAASxN,GADzE,cAGEwO,GAFIA,EADN,SAG6CH,WAAWG,mBAHxD,kBAKS,IAAI5J,SAAQ,SAACC,GAClB2J,EAAmB,CACjBD,eAAgB,SAACX,GAAD,OAAW/I,EAAQ,CAAC+I,iBAP1C,4C,wHCwSO,SAAyBlc,EAAMsO,GACpC,OAAO,IAAIyO,GAAoBC,YAAYhd,EAAMsO,IAlYnD,I,EAAA,OACA,Q,kkCAYA,IAAM/P,EAAa,CACjBM,OAAQ,EACRC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,IAGFd,EAAQ,CACZe,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,GAGFwd,EAAa,CAEjBC,mBAAoB,MACpBC,mBAAoB,MACpBC,eAAgB,MAChBC,eAAgB,MAGhBC,OAAQ,MACRC,OAAQ,KACRC,sBAAuB,MAGnBC,EAA+B,CACnChf,UAAWwe,EAAWC,mBACtBxe,UAAWue,EAAWE,mBACtBxe,MAAOse,EAAWG,eAClBxe,MAAOqe,EAAWI,gBAKdK,GAAe,OAClBT,EAAWC,mBAAqBD,EAAWM,QADzB,IAElBN,EAAWE,mBAAqBF,EAAWO,uBAFzB,IAGlBP,EAAWG,eAAiBH,EAAWK,QAHrB,IAIlBL,EAAWU,cAAgBV,EAAWK,QAJpB,G,IAefP,E,gLACJ,SAAY/c,GAAoB,IAAdsO,EAAc,uDAAJ,GACnBpO,EAAiDF,EAAjDE,KAAP,EAAwDF,EAA3CF,eAAb,MAAuB,GAAvB,IAAwDE,EAA7BuE,cAA3B,MAAoC,GAApC,IAAwDvE,EAAhB4d,eAAxC,MAAkD,GAAlD,EAUA,OATA,IAAArc,QAAOrB,GAEPD,KAAK2d,QAAUA,EACf3d,KAAKC,KAAOA,EACZD,KAAKH,QAAUA,EACfG,KAAKsE,OAASA,EAEdtE,KAAK4d,aAAa5d,KAAKC,KAAMoO,GAEtBrO,KAAKC,O,0BAMd,SAAaA,GAAoB,WAC3BA,EAAKwE,cACPxE,EAAKwE,YAAcxE,EAAKwE,YAAY+T,KAAI,SAACqF,EAAS7hB,GAAV,OAAgB,EAAK8hB,mBAAmBD,EAAS7hB,OAEvFiE,EAAKqE,SACPrE,EAAKqE,OAASrE,EAAKqE,OAAOkU,KAAI,SAACvW,EAAOjG,GAAR,OAAc,EAAK+hB,cAAc9b,EAAOjG,OAEpEiE,EAAK+d,WACP/d,EAAK+d,SAAW/d,EAAK+d,SAASxF,KAAI,SAACyF,EAASjiB,GAAV,OAAgB,EAAKkiB,gBAAgBD,EAASjiB,OAE9EiE,EAAK8F,WACP9F,EAAK8F,SAAW9F,EAAK8F,SAASyS,KAAI,SAAC7S,EAAS3J,GAAV,OAAgB,EAAKmiB,gBAAgBxY,EAAS3J,OAE9EiE,EAAKgF,YACPhF,EAAKgF,UAAYhF,EAAKgF,UAAUuT,KAAI,SAAC9W,EAAU1F,GAAX,OAAiB,EAAKoiB,iBAAiB1c,EAAU1F,OAEnFiE,EAAKgG,YACPhG,EAAKgG,UAAYhG,EAAKgG,UAAUuS,KAAI,SAAClV,EAAUtH,GAAX,OAAiB,EAAKqiB,iBAAiB/a,EAAUtH,OAEnFiE,EAAK6D,SACP7D,EAAK6D,OAAS7D,EAAK6D,OAAO0U,KAAI,SAACrV,EAAMnH,GAAP,OAAa,EAAKsiB,aAAanb,EAAMnH,OAEjEiE,EAAK6C,QACP7C,EAAK6C,MAAQ7C,EAAK6C,MAAM0V,KAAI,SAACzV,EAAM/G,GAAP,OAAa,EAAKuiB,aAAaxb,EAAM/G,OAE/DiE,EAAKue,QACPve,EAAKue,MAAQve,EAAKue,MAAMhG,KAAI,SAACiG,EAAMziB,GAAP,OAAa,EAAK0iB,aAAaD,EAAMziB,OAE/DiE,EAAK4C,SACP5C,EAAK4C,OAAS5C,EAAK4C,OAAO2V,KAAI,SAAC7V,EAAO3G,GAAR,OAAc,EAAK2iB,cAAchc,EAAO3G,YAErDyU,IAAfxQ,EAAK0C,QACP1C,EAAK0C,MAAQ1C,EAAK4C,OAAO7C,KAAKC,KAAK0C,U,sBAIvC,SAAS7B,GACP,OAAOd,KAAK4e,KAAK,SAAU9d,K,qBAG7B,SAAQA,GACN,OAAOd,KAAK4e,KAAK,QAAS9d,K,qBAG5B,SAAQA,GACN,OAAOd,KAAK4e,KAAK,QAAS9d,K,qBAG5B,SAAQA,GACN,OAAOd,KAAK4e,KAAK,SAAU9d,K,yBAG7B,SAAYA,GACV,OAAOd,KAAK4e,KAAK,YAAa9d,K,yBAGhC,SAAYA,GACV,OAAOd,KAAK4e,KAAK,YAAa9d,K,uBAGhC,SAAUA,GACR,OAAO,O,wBAGT,SAAWA,GACT,OAAOd,KAAK4e,KAAK,WAAY9d,K,wBAG/B,SAAWA,GACT,OAAOd,KAAK4e,KAAK,WAAY9d,K,sBAG/B,SAASA,GACP,OAAOd,KAAK4e,KAAK,SAAU9d,K,2BAG7B,SAAcA,GACZ,OAAOd,KAAK4e,KAAK,cAAe9d,K,uBAGlC,SAAUA,GACR,OAAOd,KAAK4e,KAAK,UAAW9d,K,kBAG9B,SAAKE,EAAOF,GAEV,GAAqB,WAAjB,EAAOA,GACT,OAAOA,EAET,IAAMpD,EAASsC,KAAKC,KAAKe,IAAUhB,KAAKC,KAAKe,GAAOF,GAIpD,OAHKpD,GACHsR,QAAQ6P,KAAR,0CAAgD7d,EAAhD,YAAyDF,EAAzD,MAEKpD,I,2BAKT,SAAciF,EAAO7B,GAAO,WAI1B,OAFA6B,EAAMwL,GAAKxL,EAAMwL,IAAN,gBAAqBrN,GAChC6B,EAAMG,OAASH,EAAMG,OAAS,IAAI0V,KAAI,SAACzV,GAAD,OAAU,EAAK+b,QAAQ/b,MACtDJ,I,0BAGT,SAAaI,EAAMjC,GAAO,WAyBxB,OAvBAiC,EAAKoL,GAAKpL,EAAKoL,IAAL,eAAmBrN,GACzBiC,EAAKgc,WACPhc,EAAKgc,SAAWhc,EAAKgc,SAASvG,KAAI,SAACwG,GAAD,OAAW,EAAKF,QAAQE,YAE1CvO,IAAd1N,EAAKI,KACPJ,EAAKI,KAAOnD,KAAKif,QAAQlc,EAAKI,WACLsN,IAAhB1N,EAAKe,QAAwBf,EAAKe,OAAO9B,SAClDe,EAAKI,KAAOJ,EAAKe,OAAO4U,QACtB,SAACwG,EAAOlc,GACN,IAAMG,EAAO,EAAK8b,QAAQjc,GAG1B,OAFAkc,EAAM/Q,GAAKhL,EAAKgL,GAChB+Q,EAAM1b,WAAa0b,EAAM1b,WAAWuF,OAAO5F,EAAKK,YACzC0b,IAET,CAAC1b,WAAY,WAGGiN,IAAhB1N,EAAKoc,SACPpc,EAAKoc,OAASnf,KAAKof,UAAUrc,EAAKoc,cAElB1O,IAAd1N,EAAK0b,OACP1b,EAAK0b,KAAOze,KAAKqf,QAAQtc,EAAK0b,OAEzB1b,I,0BAGT,SAAa0b,EAAM3d,GAIjB,OAFA2d,EAAKtQ,GAAKsQ,EAAKtQ,IAAL,eAAmBrN,GAC7B2d,EAAKa,oBAAsBtf,KAAK2B,YAAY8c,EAAKa,qBAC1Cb,I,0BAGT,SAAatb,EAAMrC,GAAO,WAoBxB,OAlBAqC,EAAKgL,GAAKhL,EAAKgL,IAAL,eAAmBrN,GACzBqC,EAAKK,aACPL,EAAKK,WAAaL,EAAKK,WAAWgV,KAAI,SAAC+G,GAErC,IAAMnc,GADNmc,EAAY,EAAH,GAAOA,IACanc,WAE7B,IAAK,IAAMoc,KADXD,EAAUnc,WAAa,GACCA,EACtBmc,EAAUnc,WAAWoc,GAAa,EAAK7d,YAAYyB,EAAWoc,IAQhE,YAN0B/O,IAAtB8O,EAAUlc,UACZkc,EAAUlc,QAAU,EAAK1B,YAAY4d,EAAUlc,eAEtBoN,IAAvB8O,EAAUjc,WACZic,EAAUjc,SAAW,EAAKmc,YAAYF,EAAUjc,WAE3Cic,MAGJpc,I,8BAGT,SAAiBG,EAAUxC,GAmBzB,GAjBAwC,EAAS6K,GAAK7K,EAAS6K,IAAT,mBAA2BrN,GACrCwC,EAASoc,gBACXpc,EAASoc,cAAT,KAA6Bpc,EAASoc,eACtCpc,EAASoc,cAAc/Z,QAAU3F,KAAK2f,WAAWrc,EAASoc,cAAc5e,QAEtEwC,EAASsc,mBACXtc,EAASuc,kBAAT,KAAiCvc,EAASuc,mBAC1Cvc,EAASsc,iBAAiBja,QAAU3F,KAAK2f,WAAWrc,EAASsc,iBAAiB9e,QAE5EwC,EAASwc,kBACXxc,EAASyc,gBAAT,KAA+Bzc,EAASyc,iBACxCzc,EAASwc,gBAAgBna,QAAU3F,KAAK2f,WAAWrc,EAASwc,gBAAgBhf,QAEzEwC,EAAS0c,iBACZ1c,EAAS0c,eAAiB1c,EAASyc,gBAAkB,CAAC,EAAG,EAAG,GAAK,CAAC,EAAG,EAAG,IAGtEzc,EAAS2c,qBAAsB,CACjC3c,EAAS2c,qBAAT,KAAoC3c,EAAS2c,sBAC7C,IAAMC,EAAK5c,EAAS2c,qBAChBC,EAAGC,mBACLD,EAAGC,iBAAH,KAA0BD,EAAGC,kBAC7BD,EAAGC,iBAAiBxa,QAAU3F,KAAK2f,WAAWO,EAAGC,iBAAiBrf,QAEhEof,EAAGE,2BACLF,EAAGE,yBAAH,KAAkCF,EAAGE,0BACrCF,EAAGE,yBAAyBza,QAAU3F,KAAK2f,WAAWO,EAAGE,yBAAyBtf,QAGtF,OAAOwC,I,8BAGT,SAAiB5B,EAAUZ,GA/N7B,IAAmC3C,EAIFE,EA2O7B,GAdAqD,EAASyM,GAAKzM,EAASyM,IAAT,mBAA2BrN,QACb2P,IAAxB/O,EAAST,aAEXS,EAAST,WAAajB,KAAKmB,cAAcO,EAAST,aAIpDS,EAASwP,mBAxOsB/S,EAwOwBuD,EAASvD,cAvO3DC,EAAMD,IAwOXuD,EAASsP,YArOoB3S,EAqOiBqD,EAASrD,KApOlDC,EAAWD,IAqOhBqD,EAAS2e,gBAAkB3e,EAASwP,kBAAoBxP,EAASsP,WAK7DtP,EAAST,WAAY,CACvB,IAAMG,EAASM,EAAST,WAAWG,OACnC,GAAgC,IAAAU,+BAA8BJ,EAAUA,EAAST,YAA1Ec,EAAP,EAAOA,UAAW5B,EAAlB,EAAkBA,WACZoB,GACHG,EAAST,WAAWM,YAAc,IAAMG,EAASH,YAAc,GAAKH,EAAOG,WACxE+e,EAAalf,EAAOK,YAAYmW,MAAMrW,EAAYA,EAAapB,GACrEuB,EAASzE,MAAQ,IAAI8E,EAAUue,GAGjC,OAAO5e,I,6BAGT,SAAgBiE,EAAS7E,GAKvB,OAHA6E,EAAQwI,GAAKxI,EAAQwI,IAAR,kBAAyBrN,GACtC6E,EAAQsY,QAAU,YAAatY,EAAU3F,KAAKugB,WAAW5a,EAAQsY,SAAWR,EAC5E9X,EAAQE,OAAS7F,KAAKwgB,SAAS7a,EAAQE,QAChCF,I,6BAGT,SAAgBsY,EAASnd,GAKvB,IAAK,IAAMvD,KAHX0gB,EAAQ9P,GAAK8P,EAAQ9P,IAAR,kBAAyBrN,GAEtCmd,EAAQwC,WAAa,GACHxC,EAAS,CACzB,IAAMyC,EAAS1gB,KAAK2gB,sBAAsBpjB,QAC3BkT,IAAXiQ,IACFzC,EAAQwC,WAAWC,GAAUzC,EAAQ1gB,IAGzC,OAAO0gB,I,mCAGT,SAAsB1gB,GACpB,OAAOigB,EAA6BjgB,K,2BAGtC,SAAc0E,EAAOnB,GAEnBmB,EAAMkM,GAAKlM,EAAMkM,IAAN,gBAAqBrN,QACP2P,IAArBxO,EAAMhB,aACRgB,EAAMhB,WAAajB,KAAKmB,cAAcc,EAAMhB,aAK9C,IAAM2f,EAAiB5gB,KAAKsE,OAAOxD,GAKnC,OAJI8f,IACF3e,EAAMA,MAAQ2e,GAGT3e,I,gCAGT,SAAmBhB,EAAYH,GAE7BG,EAAWkN,GAAKlN,EAAWkN,IAAX,qBAA+BrN,GAC/C,IAAMI,EAAcD,EAAWG,OAC/BH,EAAWG,OAASpB,KAAKH,QAAQqB,GAEjC,IAAMO,EAAczB,KAAKH,QAAQqB,GAAaO,YAC1CF,EAAavB,KAAKH,QAAQqB,GAAaK,YAAc,EAOzD,MALI,eAAgBN,IAClBM,GAAcN,EAAWM,YAG3BN,EAAWY,KAAO,IAAIL,WAAWC,EAAaF,EAAYN,EAAWd,YAC9Dc,I,4BAGT,SAAeke,EAAQre,GASrB,OARAqe,EAAOhR,GAAKgR,EAAOhR,IAAP,iBAAuBrN,GAE/Bqe,EAAO0B,YAGP1B,EAAO2B,aAGJ3B,O,uHC3VJ,SACL1d,GAGS,IAFTF,EAES,uDAFY,EACrB8M,EACS,uDADkB,GAErBpB,EAAW,IAAIe,SAASvM,GAE9B,EAA6B4M,EAAtBqJ,aAAP,MA9BiB,WA8BjB,EACMqJ,EAAS9T,EAASE,UAAU5L,GAAY,GAC9C,OAAOwf,IAAWrJ,GAhCD,aAgCUqJ,G,UAGd,SACbC,EACAvf,GAGA,IAFAF,EAEA,uDAFqB,EAIf0L,EAAW,IAAIe,SAASvM,GAGxBpD,EAAOoZ,EAAexK,EAAU1L,EAAa,GAC7C5B,EAAUsN,EAASE,UAAU5L,EAAa,GAlCvC,GAmCHpB,EAAa8M,EAASE,UAAU5L,EAAa,GAnC1C,GAsDT,OAjBA7E,OAAOgJ,OAAOsb,EAAK,CAEjBC,OAAQ,CACN1f,aACApB,aACA+gB,aAAa,GAGf7iB,OACAsB,UAEAM,KAAM,GACNkhB,UAAW,KAGb5f,GA9D2B,GAgEnByf,EAAIrhB,SACV,KAAK,EAEH,OAAOyhB,EAAWJ,EAAK/T,EAAU1L,GACnC,KAAK,EAEH,OAAO8f,EAAWL,EAAK/T,EAAU1L,EAAuB,IAC1D,QACE,MAAM,IAAIrD,MAAJ,8BAAiC8iB,EAAIrhB,QAArC,iCAjFZ,WAqBA,SAAS8X,EAAexK,GAA0B,IAAhB1L,EAAgB,uDAAH,EAC7C,gBACAkL,OAAOkL,aAAa1K,EAASK,SAAS/L,EAAa,KADnD,OAEAkL,OAAOkL,aAAa1K,EAASK,SAAS/L,EAAa,KAFnD,OAGAkL,OAAOkL,aAAa1K,EAASK,SAAS/L,EAAa,KAHnD,OAIAkL,OAAOkL,aAAa1K,EAASK,SAAS/L,EAAa,KA2DrD,SAAS6f,EAAWJ,EAAU/T,EAAoB1L,IAEhD,IAAAD,QAAO0f,EAAIC,OAAO9gB,WAAamhB,IAI/B,IAAMC,EAAgBtU,EAASE,UAAU5L,EAAa,GAxE7C,GAyEHigB,EAAgBvU,EAASE,UAAU5L,EAAa,GAzE7C,GAoFT,OAVAA,GAnF4B,GAsF5B,IAAAD,QA/EiC,IA+E1BkgB,GAEPC,EAAeT,EAAK/T,EAAU1L,EAAYggB,GAE1ChgB,GAAcggB,EACdhgB,GAAcmgB,EAAcV,EAAK/T,EAAU1L,EAAYyf,EAAIC,OAAO9gB,YAKpE,SAASkhB,EACPL,EACA/T,EACA1L,EACA8M,GAOA,OAJA,IAAA/M,QAAO0f,EAAIC,OAAO9gB,WAAamhB,IAOjC,SACEN,EACA/T,EACA1L,EACA8M,GAIA,KAAO9M,EAAa,GAAKyf,EAAIC,OAAO9gB,YAAY,CAC9C,IAAMwhB,EAAc1U,EAASE,UAAU5L,EAAa,GA9G7C,GA+GDqgB,EAAc3U,EAASE,UAAU5L,EAAa,GA/G7C,GAmHP,OAHAA,GAzH0B,EA4HlBqgB,GACN,KA3HsB,WA4HpBH,EAAeT,EAAK/T,EAAU1L,EAAYogB,GAC1C,MACF,KA7HqB,QA8HnBD,EAAcV,EAAK/T,EAAU1L,EAAYogB,GACzC,MAGF,KAjIsC,EAkI/BtT,EAAQwT,QACXJ,EAAeT,EAAK/T,EAAU1L,EAAYogB,GAE5C,MACF,KArIqC,EAsI9BtT,EAAQwT,QACXH,EAAcV,EAAK/T,EAAU1L,EAAYogB,GAU/CpgB,IAAc,IAAAiD,aAAYmd,EAAa,IA7CzCG,CAAmBd,EAAK/T,EAAU1L,EAAY8M,GAEvC9M,EAAayf,EAAIC,OAAO9gB,WAkDjC,SAASshB,EAAeT,EAAU/T,EAAoB1L,EAAoBogB,GAExE,IAAMI,EAAY,IAAIvgB,WAAWyL,EAAS7L,OAAQG,EAAYogB,GAIxDK,EADc,IAAIxO,YAAY,QACPR,OAAO+O,GAKpC,OAFAf,EAAI/gB,KAAOgiB,KAAKC,MAAMF,IAEf,IAAAxd,aAAYmd,EAAa,GAIlC,SAASD,EAAcV,EAAU/T,EAAU1L,EAAYogB,GAUrD,OARAX,EAAIC,OAAOC,aAAc,EACzBF,EAAIG,UAAU3e,KAAK,CACjBjB,aACApB,WAAYwhB,EACZlgB,YAAawL,EAAS7L,UAIjB,IAAAoD,aAAYmd,EAAa,K,wFCrLnB,SAAuBX,EAAK/T,GAAwC,IAA9B1L,EAA8B,uDAAjB,EAChE,EAA6Dyf,EAAtDtJ,aAAP,MAViB,WAUjB,IAA6DsJ,EAAlCrhB,eAA3B,MAAqC,EAArC,IAA6DqhB,EAArB/gB,YAAxC,MAA+C,GAA/C,EAAmDsG,EAAUya,EAAVza,OAE7C4b,EAAkB5gB,EAGpB0L,IACFA,EAASmV,UAAU7gB,EAAa,EAAGmW,GAZ5B,GAaPzK,EAASmV,UAAU7gB,EAAa,EAAG5B,GAb5B,GAcPsN,EAASmV,UAAU7gB,EAAa,EAAG,GAd5B,IAgBT,IAAM8gB,EAAuB9gB,EAAa,EAIpC+gB,EAHN/gB,GAAc,GAIV0L,IACFA,EAASmV,UAAU7gB,EAAa,EAAG,GAtB5B,GAuBP0L,EAASmV,UAAU7gB,EAAa,EA1BjB,YAGR,IAyBTA,GAAc,EAGd,IAAMghB,EAAaN,KAAKO,UAAUviB,GAIlC,GAHAsB,GAAa,IAAAkhB,4BAA2BxV,EAAU1L,EAAYghB,EAAY,GAGtEtV,EAAU,CACZ,IAAMyV,EAAiBnhB,EAAa+gB,EAAuB,EAC3DrV,EAASmV,UAAUE,EAAuB,EAAGI,GAlCtC,GAsCT,GAAInc,EAAQ,CACV,IAAMoc,EAAsBphB,EAY5B,GATI0L,IACFA,EAASmV,UAAU7gB,EAAa,EAAG,GA3C9B,GA4CL0L,EAASmV,UAAU7gB,EAAa,EA9CpB,SAEP,IA8CPA,GAAc,EAEdA,GAAa,IAAAqhB,iCAAgC3V,EAAU1L,EAAYgF,EAAQ,GAGvE0G,EAAU,CACZ,IAAM4V,EAAgBthB,EAAaohB,EAAsB,EACzD1V,EAASmV,UAAUO,EAAsB,EAAGE,GArDvC,IA0DT,GAAI5V,EAAU,CACZ,IAAM6V,EAAiBvhB,EAAa4gB,EACpClV,EAASmV,UAAUC,EAAsBS,GA5DlC,GA+DT,OAAOvhB,GAxET,Y,0CCAA,IAAMwhB,EAAgBC,EAAQ,IACxBC,EAA4B,oBAAXzb,OAAyB2E,EAAS3E,OACzDyb,EAAQC,QAAUD,EAAQC,SAAW,GACrCnnB,EAAOD,QAAUY,OAAOgJ,OAAOud,EAAQC,QAASH,K,4vBCchD,I,EAAA,OAGA,QACA,SAGA,SACA,SAGA,G,EAAA,O,2BACA,S,4GCzBA,WACA,Q,m/BAeO,IAAMI,EAA+B,CAC1C5mB,KAAM,OACN4R,GAAI,OACJpS,OAAQ,OACR4D,QAASyO,UACT3N,WAAY,CAAC,OAAQ,OACrB2iB,UAAW,CAAC,kBAAmB,qBAE/BtL,MAAM,EACNvR,QAAQ,EACR8c,MAAO,CAAC,QACRnB,QAEA7T,QAAS,CACPtO,KAAM,CACJujB,WAAW,EACXC,aAAa,EACbC,YAAY,EACZC,kBAAkB,EAClB1G,aAAa,GAIf9N,IAAKD,SAEP0U,kBAAmB,CACjBC,YAAa,kBACbC,aAAc,kBACdC,WAAY,wBACZ9G,YAAa,mBACbhd,KAAM,CACJ8jB,WAAY,2B,SAKI3B,E,mFAAf,WAAqBzgB,GAArB,iHAAkC4M,EAAlC,+BAA+D,GAAI7C,EAAnE,wBAEL6C,EAAU,EAAH,KAAO8U,EAAW9U,SAAYA,IAE7BtO,KAAR,OAAmBojB,EAAW9U,QAAQtO,MAASsO,EAAQtO,MAJlD,EAMoBsO,EAAlB9M,kBANF,MAMe,EANf,EAOCxB,EAAO,GAPR,UAQQ,IAAA+jB,WAAU/jB,EAAM0B,EAAaF,EAAY8M,EAAS7C,GAR1D,oF,kWC7BA,SAAgB/J,EAAa4M,GAElC,OAAO,IAAA0V,OAAMtiB,EADM,EACmB4M,I,0DAzBxC,YACA,OACA,OACA,QACA,QACA,QACA,SACA,QACA,E,ybAAA,Q,4eAoBO,WACLtO,EACAikB,GAFK,uHAGLziB,EAHK,+BAGQ,EACb8M,EAJK,uBAQL7C,EARK,uBAULyY,EAAuBlkB,EAAMikB,EAAqBziB,EAAY8M,IAE9D,IAAA6V,iBAAgBnkB,EAAM,CAACujB,UAAWjV,SAAF,UAAEA,EAAStO,YAAX,aAAE,EAAeujB,YAE3Ca,EAA2B,GAG7B9V,SAAA,UAAAA,EAAStO,YAAT,UAAewjB,cAAexjB,EAAKE,KAAKJ,QAjBvC,gCAkBG0jB,EAAYxjB,EAAMsO,EAAS7C,GAlB9B,cAqBD6C,SAAJ,UAAIA,EAAStO,YAAb,OAAI,EAAeyjB,aACXY,EAAUZ,EAAWzjB,EAAMsO,EAAS7C,GAC1C2Y,EAAS3hB,KAAK4hB,IAGVA,GAAU,IAAAC,kBAAiBtkB,EAAMsO,EAAS7C,GAChD2Y,EAAS3hB,KAAK4hB,GA3BT,UA8BCnR,QAAQuJ,IAAI2H,GA9Bb,iCAiCE9V,SAAA,UAAAA,EAAStO,YAAT,SAAegd,aAAc,IAAAuH,iBAAgBvkB,EAAMsO,GAAWtO,GAjChE,6C,sBAqCP,SAASkkB,EAAuBlkB,EAAM8B,EAAMN,EAAY8M,IAElDA,EAAQkW,MACVxkB,EAAK4d,QAAUtP,EAAQkW,KAIrB1iB,aAAgBsE,eAAgB,IAAA4d,OAAMliB,EAAMN,EAAY8M,MAE1DxM,GADoB,IAAI2R,aACLR,OAAOnR,IAG5B,GAAoB,iBAATA,EAET9B,EAAKE,MAAO,IAAAukB,WAAU3iB,QACjB,GAAIA,aAAgBsE,YAAa,CAEtC,IAAM6a,EAAW,GACjBzf,GAAa,aAAayf,EAAKnf,EAAMN,EAAY8M,EAAQ2S,MAEzD,IAAA1f,QAAoB,SAAb0f,EAAI3iB,KAAX,mCAAwD2iB,EAAI3iB,OAE5D0B,EAAK0kB,KAAOzD,EACZjhB,EAAKE,KAAO+gB,EAAI/gB,UAEhB,IAAAqB,SAAO,EAAO,uCAKhB,IAAMzB,EAAUE,EAAKE,KAAKJ,SAAW,GAIrC,GAHAE,EAAKF,QAAU,IAAI6J,MAAM7J,EAAQmC,QAAQ0iB,KAAK,MAG1C3kB,EAAK0kB,MAAQ1kB,EAAK0kB,KAAKxD,OAAOC,YAAa,CAC7C,IAAOC,EAAaphB,EAAK0kB,KAAlBtD,UACPphB,EAAKF,QAAQ,GAAK,CAChB4B,YAAa0f,EAAU,GAAG1f,YAC1BF,WAAY4f,EAAU,GAAG5f,WACzBpB,WAAYghB,EAAU,GAAGhhB,YAS7B,IAAMmE,EAASvE,EAAKE,KAAKqE,QAAU,GACnCvE,EAAKuE,OAAS,IAAIoF,MAAMpF,EAAOtC,QAAQ0iB,KAAK,I,SAI/BnB,E,uFAAf,WAA2BxjB,EAAMsO,EAAS7C,GAA1C,oGACWxP,EAAI,EADf,YACkBA,EAAI+D,EAAKE,KAAKJ,QAAQmC,QADxC,sBAEUZ,EAASrB,EAAKE,KAAKJ,QAAQ7D,IACtBuoB,IAHf,wBAIaI,EAASnZ,EAATmZ,OACP,IAAArjB,QAAOqjB,GAEDJ,GAAM,IAAAK,YAAWxjB,EAAOmjB,IAAKlW,GAPzC,SAQ6B7C,SAR7B,UAQ6BA,EAASmZ,aARtC,aAQ6B,OAAAnZ,EAAiB+Y,GAR9C,cAQYM,EARZ,iBASgCA,SAThC,UASgCA,EAAUpjB,mBAT1C,aASgC,OAAAojB,GAThC,QASYpjB,EATZ,OAWM1B,EAAKF,QAAQ7D,GAAK,CAChByF,cACAF,WAAY,EACZpB,WAAYsB,EAAYtB,mBAGnBiB,EAAOmjB,IAjBpB,UACkDvoB,EADlD,4D,+BAsBewnB,E,uFAAf,WAA0BzjB,EAAMsO,EAAS7C,GAAzC,0FAIE,IAHMlH,EAASvE,EAAKE,KAAKqE,QAAU,GAE7B6f,EAA2B,GACxBnoB,EAAI,EAAGA,EAAIsI,EAAOtC,SAAUhG,EACnCmoB,EAAS3hB,KAAKsiB,EAAU/kB,EAAMuE,EAAOtI,GAAIA,EAAGqS,EAAS7C,IALzD,gBAQeyH,QAAQuJ,IAAI2H,GAR3B,oF,+BAYeW,E,2FAAf,WAAyB/kB,EAAMkC,EAAOnB,EAAeuN,EAAS7C,GAA9D,qGACSmZ,EAAgBnZ,EAAhBmZ,MAAOzC,EAAS1W,EAAT0W,OAIVjgB,EAAMsiB,IALZ,uBAMUA,GAAM,IAAAK,YAAW3iB,EAAMsiB,IAAKlW,GANtC,SAO2BsW,EAAMJ,GAPjC,cAOUM,EAPV,gBAQwBA,EAASpjB,cARjC,OAQIA,EARJ,qBAWMmC,OAAOC,SAAS5B,EAAMhB,cAClBD,GAAQ,IAAA+jB,4BAA2BhlB,EAAKE,KAAMF,EAAKF,QAASoC,EAAMhB,YACxEQ,GAAc,IAAAujB,kBAAiBhkB,EAAMI,OAAQJ,EAAMO,WAAYP,EAAMb,cAGvE,IAAAmB,QAAOG,EAAa,0BAhBtB,UAmB4BygB,EAAMzgB,EAAawjB,cAAa,GAAIzZ,GAnBhE,QAmBQ0Z,EAnBR,OAuBEnlB,EAAKuE,OAAOxD,GAASokB,EAvBvB,6C,mJC5JA,I,EAAA,QACA,G,EAAA,Q,2BACA,QAEA,IAeaD,EAAc,CACzB9W,GAAI,QACJpS,OAAQ,SACRQ,KAAM,SACNoD,QAASyO,UACTgV,UAnBiB,CACjB,YACA,aACA,YACA,aACA,YACA,2BACA,iBAaA3iB,WArBiB,CAAC,MAAO,MAAO,OAAQ,MAAO,OAAQ,MAAO,MAAO,OAsBrEyhB,MAAOiD,UAEP9B,MAAO,CAAC,SAAC5hB,GAAD,OAAiBsK,SAAQ,IAAA7H,wBAAuB,IAAI8J,SAASvM,OACrE4M,QAAS,CACPpM,MAAO,CACL5D,KAAM,OACN2U,QAAQ,K,gBAMP,IAAMoS,EAA0CH,E,mKCvCvD,I,EAAA,QACA,G,EAAA,Q,uVAEA,IAAMI,EAAe,GAEjBC,GAA8B,E,iDASnB,WAAkC7jB,EAAa4M,EAASO,GAAxD,+FAIT,IAAA0E,OAAM1E,GAJG,iCAMS,aAAanN,EAAa4M,EAASO,GAN5C,OAML3M,EANK,OAOXsjB,EAAOtjB,EAPI,sBAUXsjB,GAAO,IAAA7R,SAAQjS,EAAamN,GAVjB,cAaP4W,EAAqBnX,GAAWA,EAAQoX,YAbjC,UAeAC,EAAsBH,EAAMC,GAf5B,sF,+BAwBAE,E,mFAAf,WAAqCH,GAArC,sGACMI,EADqCH,EAA3C,+BAAgE,OACpBF,IACxCE,EAAqB,OAGnBA,EALN,0CAQmBI,kBAAkBL,EAAMC,GAR3C,wEAUMxW,QAAQ6P,KAAR,MACAyG,GAA8B,EAXpC,yBAeeM,kBAAkBL,GAfjC,mG,sBAkBA,SAASI,EAAcjoB,GAErB,IAAK,IAAMH,KAAOG,GAAU2nB,EAC1B,OAAO,EAET,OAAO,I,wFCxDM,SAA0B5jB,EAAa4M,GACpD,IAAOlK,IAAY,IAAAD,wBAAuBzC,IAAgB,IAAnD0C,SAGAkO,EAAmBlG,SAAnBkG,gBAGP,OAFA,IAAA/Q,QAAO+Q,GAEAA,EAAgB5Q,EAAa0C,EAAUkK,IAZhD,YACA,OACA,S,mGCDA,YACA,QAEawX,EAAc,CACzBtpB,KAAM,SACN4R,GAAI,QACJpS,OAAQ,SACR4D,QAASyO,UACT3N,WAAY,CAAC,QACb4N,QAAS,CACPpM,MAAO,CACLkC,SAAU,YACV2hB,YAAa,OAGjB9N,OAAQ+N,e,2JCfV,YACA,Q,4TAGA,IAAOC,EAAoB7Z,SAApB6Z,iB,iDAUA,WACL/jB,EACAoM,GAFK,uFAILA,EAAUA,GAAW,IACbpM,MAAQoM,EAAQpM,OAAU,GAL7B,kBAOE+jB,EACHA,EAAiB/jB,EAAO,CAAC5D,KAAMgQ,EAAQpM,MAAMkC,WAC7C8hB,EAAqBhkB,EAAOoM,IAT3B,4C,sBAaP,IAAI6X,GAAwB,E,SASbD,E,qFAAf,WAAoChkB,EAAOoM,GAA3C,6GACkCA,EAAQpM,MAAjCkC,EADT,EACSA,SAAU2hB,EADnB,EACmBA,YADnB,GAG0B,IAAAK,cAAalkB,GAA9ByJ,EAHT,EAGSA,MAAOC,EAHhB,EAGgBA,QAGRN,EAASC,SAASC,cAAc,WAC/BG,MAAQA,EACfL,EAAOM,OAASA,EAEhBya,EAAkBnkB,EAAOoJ,GAV3B,SAaqB,IAAI4H,SAAqB,SAACC,GAE3C,GAAI4S,GAAeI,EACjB,IAEE,YADA7a,EAAOgb,OAAOnT,EAAS/O,EAAU2hB,GAEjC,MAAO/W,GACPmX,GAAwB,EAG5B7a,EAAOgb,OAAOnT,EAAS/O,MAvB3B,UAaQohB,EAbR,8BA2BU,IAAIrnB,MAAM,yBA3BpB,yBA8BeqnB,EAAK9jB,cA9BpB,sF,sBAiCA,SAAS2kB,EAAkBnkB,EAAOoJ,GAAsB,IAAdib,EAAc,uDAAV,EAAGC,EAAO,uDAAH,EAEnD,GAAU,IAAND,GAAiB,IAANC,GAAkC,oBAAhB1a,aAA+B5J,aAAiB4J,YAAa,CAC5F,IAAML,EAAUH,EAAOI,WAAW,kBAClC,GAAID,EAGF,OADAA,EAAQgb,wBAAwBvkB,GACzBoJ,EAKX,IAAMG,EAAUH,EAAOI,WAAW,MAClC,GAAIxJ,EAAMJ,KAAM,CAEd,IAAM4kB,EAAe,IAAIC,kBAAkBzkB,EAAMJ,MAC3CkC,EAAY,IAAI4iB,UAAUF,EAAcxkB,EAAMyJ,MAAOzJ,EAAM0J,QAEjE,OADAH,EAAQob,aAAa7iB,EAAW,EAAG,GAC5BsH,EAKT,OADAG,EAAQI,UAAU3J,EAAO,EAAG,GACrBoJ,I,wKC7FT,I,EAAA,OACA,G,EAAA,Q,2BACA,QACA,QACA,Q,oiCAEO,WAAyBwb,GAAzB,2GAAiCxY,EAAjC,+BAA2C,GAA3C,SACmByY,EAAaD,EAAQxY,GADxC,cACC0Y,EADD,iBAEQ,IAAAC,UAASD,EAAW5B,UAAY9W,GAFxC,oF,+BAKeyY,E,qFAAf,WAA4BD,EAAQxY,GAApC,uGAA6C4Y,EAA7C,+BAA0D,GAE1C,KADfC,EAAa7Y,GAAWA,EAAQpM,OAASoM,EAAQpM,MAAMilB,WAAc,GADtE,gCAGKC,EAAsBN,EAAQK,EAAW7Y,EAAS4Y,GAHvD,+CAID,IAAAG,aAAYP,EAAQxY,EAAS4Y,GAJ5B,mF,+BAOQE,E,yFAAf,WAAqCN,EAAQK,EAAW7Y,EAAS4Y,GAAjE,uGACQI,EAAiB,GAGL,SAAdH,EAJN,uBAKUtY,GAAM,IAAAwY,aAAYP,EAAQxY,EAApB,OAAiC4Y,GAAjC,IAA6CK,IAAK,KALlE,UAMwB,IAAAC,aAAY3Y,EAAKuW,UAAY9W,GANrD,OAMUpM,EANV,UAQ4B,IAAAkkB,cAAalkB,GAA9ByJ,EARX,EAQWA,MAAOC,EARlB,EAQkBA,OACdub,EAAYM,EAAa,CAAC9b,QAAOC,WAGjC0b,EAAK7kB,KAAKoM,GAZd,OAkBE,KAFA,IAAAtN,QAAO4lB,EAAY,GAEVO,EAAWJ,EAAKrlB,OAAQylB,EAAWP,IAAaO,EACjD7Y,GAAM,IAAAwY,aAAYP,EAAQxY,EAApB,OAAiC4Y,GAAjC,IAA6CK,IAAKG,KAC9DJ,EAAK7kB,KAAKoM,GApBd,yBAuBSyY,GAvBT,6C,sBA2BO,SAASG,EAAT,GAAuC,IAAhB9b,EAAgB,EAAhBA,MAAOC,EAAS,EAATA,OACnC,OAAO,EAAIpG,KAAKmiB,MAAMniB,KAAKoiB,KAAKpiB,KAAKR,IAAI2G,EAAOC,O,4FC1C3C,SAAqBkb,EAAQxY,EAAS4Y,GAE3C,IAAIrY,EAAMiY,EACY,mBAAXA,IACTjY,EAAMiY,EAAO,EAAD,KAAKxY,GAAY4Y,MAE/B,IAAA3lB,QAAsB,iBAARsN,GAGd,IAAOgZ,EAAWvZ,EAAXuZ,QACHA,IACFhZ,EAAsC,MAAhCgZ,EAAQA,EAAQ5lB,OAAS,GAAzB,UAAyC4lB,GAAzC,OAAmDhZ,GAAnD,UAA8DgZ,EAA9D,YAAyEhZ,IAGjF,OAAO,IAAAiZ,aAAYjZ,IAlBrB,WACA,O,2kCCGA,IAAM3C,EAAU,CACdC,KAAsB,oBAATA,MAAwBA,KACrC1E,OAA0B,oBAAXA,QAA0BA,OACzC2E,YAA0B,IAAXA,GAA0BA,EACzCb,SAA8B,oBAAbA,UAA4BA,UAIzCc,EAAaH,EAAQC,MAAQD,EAAQzE,QAAUyE,EAAQE,QAAU,G,SACvE,IAAME,EAAeJ,EAAQzE,QAAUyE,EAAQC,MAAQD,EAAQE,QAAU,G,WACzE,IAAMG,EAAeL,EAAQE,QAAUF,EAAQC,MAAQD,EAAQzE,QAAU,G,WACzE,IAAM+E,EAAiBN,EAAQX,UAAY,G,aAKpC,IAAMkB,EAEQ,iBAAnB,IAAO7E,EAAP,cAAOA,KAA4C,qBAApB8E,OAAO9E,IAAmCA,EAAQmC,Q,cAG5E,IAAM4C,EAA6C,mBAAlBC,c,aAGxC,IAAMC,OACe,IAAZjF,GAA2BA,EAAQhI,SAAW,YAAYkN,KAAKlF,EAAQhI,SAEnEmN,EAAuBF,GAAWG,WAAWH,EAAQ,KAAQ,E,2ICpBnE,SAA4Bkb,GAEjC,GAAoB,oBAAT5b,KACT,OAGFoK,aAAWvG,UAAX,4CAAuB,WAAO1R,EAAMgW,GAAb,mGACbhW,EADa,OAEd,YAFc,uCAMR0pB,EAAuB1T,EAAvB0T,MANQ,EAMe1T,EAAhBhG,eANC,MAMS,GANT,WAQM2Z,EAAU,CAC7BF,SACArmB,YAAasmB,EACb1Z,UACA7C,QAAS,CACP0W,MAAO+F,KAbI,OAQTrhB,EARS,OAgBf0P,aAAW7G,YAAY,OAAQ,CAAC7I,WAhBjB,kDAkBT3I,EAAU,gBAAiBC,MAAQ,KAAMD,QAAU,GACzDqY,aAAW7G,YAAY,QAAS,CAACV,MAAO9Q,IAnBzB,8FAAvB,yDAfF,Y,m/BAGA,IAAIiqB,EAAY,EAuChB,SAASD,EAAkBxmB,EAA0B4M,GACnD,OAAO,IAAI4E,SAAQ,SAACC,EAASC,GAC3B,IAAMhF,EAAK+Z,IA0BX5R,aAAWG,kBAtBO,SAAZ5H,EAAaxQ,EAAMgW,GACvB,GAAIA,EAAQlG,KAAOA,EAKnB,OAAQ9P,GACN,IAAK,OACHiY,aAAWI,oBAAoB7H,GAC/BqE,EAAQmB,EAAQzN,QAChB,MAEF,IAAK,QACH0P,aAAWI,oBAAoB7H,GAC/BsE,EAAOkB,EAAQtF,WAWrB,IAAMsF,EAAU,CAAClG,KAAI4Z,MAAOtmB,EAAa4M,WACzCiI,aAAW7G,YAAY,UAAW4E,M,SAQvB2T,E,mFAAf,mHAA0BF,EAA1B,EAA0BA,OAAQrmB,EAAlC,EAAkCA,YAAa4M,EAA/C,EAA+CA,QAAS7C,EAAxD,EAAwDA,SAGlDsc,EAAOK,YAAaL,EAAO5F,MAHjC,gBAIIrgB,EAAOJ,EACP2mB,EAASN,EAAOK,WAAaL,EAAO5F,MALxC,2BAMa4F,EAAOO,cANpB,iBAOUC,EAAc,IAAI9U,YACxB3R,EAAOymB,EAAYtV,OAAOvR,GAC1B2mB,EAASN,EAAOO,cATpB,8BAWU,IAAInqB,MAAJ,mCAAsC4pB,EAAOvrB,KAA7C,YAXV,eAeE8R,EAAU,EAAH,KACFA,GADE,IAELnS,QAAU4rB,GAAUA,EAAOzZ,SAAWyZ,EAAOzZ,QAAQnS,SAAY,GACjEgT,QAAQ,IAlBZ,UAqBekZ,EAAOvmB,EAAD,KAAWwM,GAAU7C,EAASsc,GArBnD,sF,6HCvEO,SAA8BnZ,IACnC,IAAArN,QAAQqN,EAAM9I,SAAW8I,EAAMC,MAAUD,EAAM9I,QAAU8I,EAAMC,KAE/D,IAAI2Z,EAAYC,EAAe3rB,IAAI8R,EAAM9I,QAAU8I,EAAMC,KACpD2Z,IAEC5Z,EAAMC,MACR2Z,EAmBN,SAAqC3Z,GAEnC,IAAKA,EAAI+H,WAAW,QAClB,OAAO/H,EAKT,OAAO6Z,GAuBkB1R,EAxBcnI,EAyBvC,kCAEiBmI,EAFjB,wEADF,IAA2BA,EAlDT2R,CAA4B/Z,EAAMC,KAC9C4Z,EAAenT,IAAI1G,EAAMC,IAAK2Z,IAG5B5Z,EAAM9I,SACR0iB,EAAYE,EAA+B9Z,EAAM9I,QACjD2iB,EAAenT,IAAI1G,EAAM9I,OAAQ0iB,KAKrC,OADA,IAAAjnB,QAAOinB,GACAA,GA/BT,WAEMC,EAAiB,IAAI7W,IAqD3B,SAAS8W,EAA+BE,GAGtC,IAAMpD,EAAO,IAAIzR,KAAK,CAAC6U,GAAe,CAACtqB,KAAM,2BAC7C,OAAOoU,IAAIG,gBAAgB2S,K,mGCpCtB,SAA4BrW,EAAsBb,GACvD,IAAKsG,UAAWG,cACd,OAAO,EAGT,OAAO5F,EAAOA,SAAUb,aAAjB,EAAiBA,EAASa,S,gEApBnC,I,EAAA,G,EAAA,Q,2BACA,QACA,Q,6WA0BO,WACLA,EACArN,GAFK,2HAGLwM,EAHK,+BAG6B,GAClC7C,EAJK,+BAIoB,GAEnBjP,GAAO,IAAAqsB,eAAc1Z,GACrBN,GAAM,IAAAia,cAAa3Z,EAAQb,GAE3Bya,EAAanU,UAAWoU,cAAc1a,GACtC8G,EAAa2T,EAAWE,cAAc,CAACzsB,OAAMqS,QAE7CoF,EAAU3F,EAAQ2F,SAAW9E,EAAO3S,KAZrC,SAaa4Y,EAAW8T,SAC3BjV,EAEAnF,EAAUrR,KAAK,KAAMgO,IAhBlB,cAaCiK,EAbD,OAoBCyT,GAAsB,IAAAC,8BAA6B9a,GACzDoH,EAAIhG,YAAY,UAAW,CAACsY,MAAOlmB,EAAMwM,QAAS6a,IArB7C,UAuBgBzT,EAAI7O,OAvBpB,eAuBCA,EAvBD,yBAwBEA,EAAOA,QAxBT,6C,+BAgCQiI,E,yFAAf,WACErD,EACAiK,EACApX,EACAgW,GAJF,mGAMUhW,EANV,OAOS,SAPT,OAYS,UAZT,OAiBS,YAjBT,8BASMoX,EAAIC,KAAKrB,GATf,mCAcMoB,EAAI1G,MAAMsF,EAAQtF,OAdxB,+BAmBaZ,EAAsBkG,EAAtBlG,GAAI4Z,EAAkB1T,EAAlB0T,MAAO1Z,EAAWgG,EAAXhG,QAnBxB,SAqBa7C,EAAQ7D,QArBrB,wBAsBU8N,EAAIhG,YAAY,QAAS,CAACtB,KAAIY,MAAO,gDAtB/C,4CAyB6BvD,EAAQ7D,QAAQogB,EAAO1Z,GAzBpD,QAyBczH,EAzBd,OA0BQ6O,EAAIhG,YAAY,OAAQ,CAACtB,KAAIvH,WA1BrC,kDA4Bc3I,EAAU,gBAAiBC,MAAQ,KAAMD,QAAU,gBACzDwX,EAAIhG,YAAY,QAAS,CAACtB,KAAIY,MAAO9Q,IA7B7C,4CAmCM+Q,QAAQ6P,KAAR,6CAAmDxgB,IAnCzD,2D,0WChEO,SAAsCX,GAI3C,OAAOukB,KAAKC,OAGSkH,EAHW1rB,EAI1B2rB,EAAQ,IAAI7b,IACXyU,KAAKO,UAAU4G,GAAG,SAAC7rB,EAAKN,GAC7B,GAAqB,WAAjB,EAAOA,IAAgC,OAAVA,EAAgB,CAC/C,GAAIosB,EAAMzb,IAAI3Q,GAEZ,IAEE,OAAOglB,KAAKC,MAAMD,KAAKO,UAAUvlB,IACjC,MAAOoW,GAEP,OAIJgW,EAAM5b,IAAIxQ,GAEZ,OAAOA,OAjBX,IAAuBmsB,EACfC,I,6FCSD,SAAsB1hB,EAAkB2hB,GAE7C,GAAoB,oBAATpd,KACT,OAGF,IAAMV,EAAyB,CAC7B7D,QAAS4hB,GAIXjT,UAAWvG,UAAX,e,EAAA,G,EAAA,yBAAuB,WAAO1R,EAAyBgW,GAAhC,sHAEXhW,EAFW,OAGZ,YAHY,OAWZ,uBAXY,QAwBZ,gBAxBY,QA4BZ,eA5BY,2BAIVsJ,EAJU,sBAKP,IAAIzJ,MAAM,6CALH,uBAOMyJ,EAAQ0M,EAAQ0T,MAAO1T,EAAQhG,SAAW,GAAI7C,GAPpD,cAOT5E,EAPS,OAQf0P,UAAW7G,YAAY,OAAQ,CAAC7I,WARjB,gCAYV0iB,EAZU,uBAaP,IAAIprB,MAAM,8CAbH,QAefsrB,EAAe,IAAIrS,UACnB9I,EAAUgG,EAAQhG,SAAW,GACvBob,EAAiBH,EAAiBE,EAAcnb,EAAS7C,aAAxB,EAAwBA,EAAS8d,kBAjBzD,wBAkBWG,GAlBX,4HAkBEC,EAlBF,EAmBbpT,UAAW7G,YAAY,eAAgB,CAAC7I,OAAQ8iB,IAnBnC,0TAqBfpT,UAAW7G,YAAY,OAAQ,IArBhB,oCAyBf+Z,EAAahnB,KAAK6R,EAAQ0T,OAzBX,oCA6BfyB,EAAaxd,QA7BE,+EAmCb/N,EAAU,gBAAiBC,MAAQ,KAAMD,QAAU,GACzDqY,UAAW7G,YAAY,QAAS,CAACV,MAAO9Q,IApCrB,mF,+KAAvB,yDAzBF,eACA,W,gdAIA,IACIurB,EACAnb,EAFA6Z,EAAY,EA6DhB,SAASqB,EAAoB9nB,GAA2B,IAAd4M,EAAc,uDAAJ,GAClD,OAAO,IAAI4E,SAAQ,SAACC,EAASC,GAC3B,IAAMhF,EAAK+Z,IA0BX5R,UAAWG,kBAtBO,SAAZ5H,EAAaxQ,EAAMgW,GACvB,GAAIA,EAAQlG,KAAOA,EAKnB,OAAQ9P,GACN,IAAK,OACHiY,UAAWI,oBAAoB7H,GAC/BqE,EAAQmB,EAAQzN,QAChB,MAEF,IAAK,QACH0P,UAAWI,oBAAoB7H,GAC/BsE,EAAOkB,EAAQtF,WAWrB,IAAMsF,EAAU,CAAClG,KAAI4Z,MAAOtmB,EAAa4M,WACzCiI,UAAW7G,YAAY,UAAW4E,Q,sGC/F/B,SACLnF,GAES,IADTya,EACS,uDADavb,WAEtB,IAAA9M,QAAO4N,EAAQ,sBAEf,IAAM0a,EAAgB1a,EAAOvP,QAC7B,IAAKgqB,IAAgBC,EACnB,OAAO,EAaT,OAAO,GA9BT,WACA,S,+XCDA,YACA,E,ybAAA,QACA,OACA,M,2bAGA,IAGMC,EAAsB,G,iDAiBrB,WACLC,GADK,2GAELC,EAFK,+BAEuB,KAC5B1b,EAHK,+BAGa,GAEd0b,IACFD,EAAaE,EAAcF,EAAYC,EAAY1b,IAIrDwb,EAAoBC,GAClBD,EAAoBC,IAAeG,EAAoBH,GAXpD,SAYQD,EAAoBC,GAZ5B,oF,sBAgBA,SAASE,EAAcE,EAASH,EAAqB1b,GAE1D,GAAI6b,EAAQvT,WAAW,QACrB,OAAOuT,EAIT,IAAMhuB,EAAUmS,EAAQnS,SAAW,GACnC,OAAIA,EAAQguB,GACHhuB,EAAQguB,GAKZ1d,YAKD6B,EAAQ8b,MACV,IAAA7oB,QAAO+M,EAAQ8b,IAAIxT,WAAW,SAC9B,UAAUtI,EAAQ8b,IAAlB,YAAyBJ,EAAzB,YAxDY,QAwDZ,sBAA4DG,IAI1Dxd,WACF,sBAAsBwd,GAGxB,kBAAkBH,EAAlB,qBAAyCG,GAdvC,kBAAkBH,EAAlB,sBAA0CG,G,SAiB/BD,E,mFAAf,WAAmCH,GAAnC,8FACMA,EAAWM,SAAS,QAD1B,gCAE2BzF,MAAMmF,GAFjC,cAEUjF,EAFV,gBAGiBA,EAASpjB,cAH1B,kDAMO+K,YANP,yBAOWzJ,EAAKsnB,iBAPhB,uCAO0CtnB,EAAKsnB,gBAAgBP,GAP/D,uEASMpd,WATN,0CAUWC,cAAcmd,IAVzB,yBAiByBnF,MAAMmF,GAjB/B,eAiBQjF,EAjBR,iBAkB6BA,EAAS/M,OAlBtC,eAkBQwS,EAlBR,yBAmBSC,EAAsBD,EAAcR,IAnB7C,6C,sBAwCA,SAASS,EAAsBD,EAAcnc,GAC3C,IAAK3B,YACH,OAAOzJ,EAAKynB,mBAAqBznB,EAAKynB,kBAAkBF,EAAcnc,GAGxE,GAAIzB,WAKF,OAHA+d,KAAKtuB,KAAKgQ,SAAQme,GAGX,KAGT,IAAMI,EAASpf,SAASC,cAAc,UACtCmf,EAAOvc,GAAKA,EAEZ,IACEuc,EAAOC,YAAYrf,SAASsf,eAAeN,IAC3C,MAAOriB,GACPyiB,EAAO5S,KAAOwS,EAGhB,OADAhf,SAASuf,KAAKF,YAAYD,GACnB,O,mIChIF,SAA4B5C,EAAgBzZ,GACjD,IAAKsG,aAAWG,cACd,OAAO,EAGT,OAAOgT,EAAO5Y,SAAUb,aAAjB,EAAiBA,EAASa,S,sEAZnC,Y,6WAmBO,WACL4Y,EACAjmB,EACAwM,EACA7C,EACAyc,GALK,uGAOC1rB,EAAOurB,EAAO3Z,GACdS,GAAM,IAAAia,cAAaf,EAAQzZ,GAE3Bya,EAAanU,aAAWoU,cAAc1a,GACtC8G,EAAa2T,EAAWE,cAAc,CAACzsB,OAAMqS,QAInDP,EAAU4T,KAAKC,MAAMD,KAAKO,UAAUnU,IAf/B,SAiBa8G,EAAW8T,SAC3B,oBAEApa,EAAUrR,KAAK,KAAMyqB,IApBlB,cAiBCxS,EAjBD,QAuBDhG,YAAY,UAAW,CAEzBsY,MAAOlmB,EACPwM,YA1BG,UA6BgBoH,EAAI7O,OA7BpB,eA6BCA,EA7BD,iBA8BQA,EAAOA,OA9Bf,sF,+BAuCQiI,E,yFAAf,WACEoZ,EACAxS,EACApX,EACAgW,GAJF,mGAMUhW,EANV,OAOS,SAPT,OAWS,UAXT,OAeS,YAfT,8BAQMoX,EAAIC,KAAKrB,GARf,mCAYMoB,EAAI1G,MAAMsF,EAAQtF,OAZxB,mCAiBaZ,EAAsBkG,EAAtBlG,GAAI4Z,EAAkB1T,EAAlB0T,MAAO1Z,EAAWgG,EAAXhG,QAjBxB,mBAmB6B4Z,EAAkBF,EAAO1Z,GAnBtD,QAmBczH,EAnBd,OAoBQ6O,EAAIhG,YAAY,OAAQ,CAACtB,KAAIvH,WApBrC,kDAsBc3I,EAAU,gBAAiBC,MAAQ,KAAMD,QAAU,gBACzDwX,EAAIhG,YAAY,QAAS,CAACtB,KAAIY,MAAO9Q,IAvB7C,4CA6BM+Q,QAAQ6P,KAAR,4CAAkDxgB,IA7BxD,2D,kHCvDO,SAAmBmI,GACxB,IACE,OAAOyb,KAAKC,MAAM1b,GAClB,MAAOskB,GACP,MAAM,IAAI5sB,MAAJ,yDAA2D,IAAA6sB,oBAAmBvkB,GAA9E,QATV,a,+ICoDO,SACLyG,EACA1L,EACAiF,EACAgT,GAEA,IAGMwR,GAHc,IAAIjT,aAGSC,OAAOxR,GAIxC,OAFAjF,EAAaqhB,EAAgC3V,EAAU1L,EAAYypB,EAAcxR,IA9DnF,YAYO,SAASoJ,EACd3V,EACA1L,EACA2D,EACAsU,GAEA,IAAMyR,GAAe,IAAAzmB,aAAYU,EAAa/E,WAAYqZ,GACpD0R,EAAYD,EAAe/lB,EAAa/E,WAE9C,GAAI8M,EAAU,CAEZ,IAAM7G,EAAc,IAAI5E,WACtByL,EAAS7L,OACT6L,EAAS1L,WAAaA,EACtB2D,EAAa/E,YAETyY,EAAc,IAAIpX,WAAW0D,GACnCkB,EAAYiP,IAAIuD,GAGhB,IAAK,IAAI5c,EAAI,EAAGA,EAAIkvB,IAAalvB,EAE/BiR,EAASke,SAAS5pB,EAAa2D,EAAa/E,WAAanE,EAAG,IAIhE,OADAuF,GAAc0pB,I,yGClCT,SAAkCzkB,EAAQ4kB,GAK/C,IAJA,IAAMppB,EAASwE,EAAOxE,OAEhBwX,EADejU,KAAK8lB,KAAKrpB,EAASopB,GAAiBA,EAC1BppB,EAC3BspB,EAAa,GACRtvB,EAAI,EAAGA,EAAIwd,IAAWxd,EAC7BsvB,GAAc,IAEhB,OAAO9kB,EAAS8kB,G,uBAGX,SAA8Bre,EAAU1L,EAAYiF,EAAQrG,GACjE,GAAI8M,EACF,IAAK,IAAIjR,EAAI,EAAGA,EAAImE,EAAYnE,IAC9BiR,EAASke,SAAS5pB,EAAavF,EAAGwK,EAAO+kB,WAAWvvB,IAGxD,OAAOuF,EAAapB,G,uBAGf,SAA8B8M,EAAU1L,EAAYgF,EAAQpG,GACjE,GAAI8M,EACF,IAAK,IAAIjR,EAAI,EAAGA,EAAImE,EAAYnE,IAC9BiR,EAASke,SAAS5pB,EAAavF,EAAGuK,EAAOvK,IAG7C,OAAOuF,EAAapB,I,8lCC3Bf,WACLqrB,GADK,kHAELnd,EAFK,+BAEyB,GAExBia,EAAc,IAAI9U,iBAAY/C,EAAWpC,GAJ1C,uBAK2Bmd,GAL3B,+HAMH,OADe/pB,EALZ,YAM0B,iBAAhBA,EACTA,EACA6mB,EAAYtV,OAAOvR,EAAa,CAACgqB,QAAQ,IAR1C,yX,uEAiBA,WACLC,GADK,oGAGCC,EAAc,IAAI5T,YAHnB,uBAIoB2T,GAJpB,+HAKH,OADe5T,EAJZ,YAKmB,iBAATA,EAAoB6T,EAAY3T,OAAOF,GAAQA,EALzD,yX,uEAeA,WACL4T,GADK,sGAGDE,EAAW,GAHV,uBAIyBF,GAJzB,+HAKHE,GALG,EAMCC,OAND,gBAOKA,EAAWD,EAASllB,QAAQ,QAAU,GAP3C,iBAWD,OAFMolB,EAAOF,EAAShU,MAAM,EAAGiU,EAAW,GAC1CD,EAAWA,EAAShU,MAAMiU,EAAW,GAVpC,UAWKC,EAXL,iVAeDF,EAAS5pB,OAAS,GAfjB,iBAgBH,OAhBG,UAgBG4pB,EAhBH,6E,uEA0BA,WACLG,GADK,oGAGDC,EAAU,EAHT,uBAIoBD,GAJpB,+HAKH,OADeD,EAJZ,YAKG,CAACE,UAASF,QALb,QAMHE,IANG,yX,m5BC7DP,Y,ipBAgBO,WAAuBC,EAAUC,GAAjC,0GAGyBD,EAASE,OAHlC,mBAGIzW,EAHJ,EAGIA,KAAMzY,EAHV,EAGUA,OACTyY,EAJD,uBAKDuW,EAAQ,SALP,8BAQYC,EAAQjvB,GARpB,+G,uEAsBA,WACLia,GADK,oGAGCkV,EAA8B,GAH/B,uBAIqBlV,GAJrB,yHAIYmV,EAJZ,EAKHD,EAAa5pB,KAAK6pB,GALf,0UAOEC,uCAA2BF,IAP7B,6E,uEAUA,WACLlV,GADK,oGAGCqV,EAAoB,GAHrB,uBAIqBrV,GAJrB,yHAIYmV,EAJZ,EAKHE,EAAQ/pB,KAAK6pB,GALV,0UAOEE,EAAQC,KAAK,KAPf,6E,uHChDP,a,27BAgBA,IAMMlY,EAAiD,CACrDnG,GAAI,oBAEJse,kBAAkB,EAElBC,YAAa,GAeMC,E,WAUnB,aAA+C,IAAnChe,EAAmC,uDAAJ,GAAI,oFAPlB,GAOkB,sBAJb,IAIa,oBAHW,IAAIgD,KAGf,wBAFjB,MAG5B3R,KAAK2O,MAAL,OAAiB2F,GAAkB3F,GAGnC3O,KAAK4sB,MAAQ,IAAIC,QAAM,CAAC1e,GAAInO,KAAK2O,MAAMR,KACvCnO,KAAK4sB,MAAM/vB,IAzCc,mBA0CzBmD,KAAK4sB,MAAM/vB,IAzCc,mBA0CzBmD,KAAK4sB,MAAM/vB,IAzCiB,sBA0C5BmD,KAAK4sB,MAAM/vB,IAzCmB,wBA0C9BmD,KAAK4sB,MAAM/vB,IAzCmB,wB,sDA4DhC,SACEiwB,GAEwB,IADxBC,EACwB,uDADW,kBAAM,GAGzC,IAAK/sB,KAAK2O,MAAM8d,iBACd,OAAOxZ,QAAQC,QAAQ,CAACwC,KAAM,eAIhC,GAAI1V,KAAKgtB,WAAWpf,IAAIkf,GACtB,OAAO9sB,KAAKgtB,WAAWnwB,IAAIiwB,GAG7B,IAAMG,EAAmB,CAACH,SAAQI,SAAU,EAAGH,eACzC3I,EAAU,IAAInR,SAAuB,SAACC,GAG1C,OADA+Z,EAAQ/Z,QAAUA,EACX+Z,KAMT,OAHAjtB,KAAKmtB,aAAa3qB,KAAKyqB,GACvBjtB,KAAKgtB,WAAW3X,IAAIyX,EAAQ1I,GAC5BpkB,KAAKotB,oBACEhJ,I,2BAKT,SAAc6I,GAAgC,WACrCH,EAAmBG,EAAnBH,OAAQ5Z,EAAW+Z,EAAX/Z,QACXma,GAAS,EAEP3X,EAAO,WAEN2X,IACHA,GAAS,EAGT,EAAKL,WAAL,OAAuBF,GACvB,EAAKQ,qBAEL,EAAKF,sBAOT,OAFAptB,KAAKstB,qBAEEpa,EAAUA,EAAQ,CAACwC,SAASzC,QAAQC,QAAQ,CAACwC,W,+BAItD,WAA0B,WACnB1V,KAAKutB,iBACRvtB,KAAKutB,eAAiB/kB,YAAW,kBAAM,EAAKglB,2BAA0B,M,oCAK1E,WAEExtB,KAAKutB,eAAiB,KAEtB,IAAME,EAAYloB,KAAKR,IAAI/E,KAAK2O,MAAM+d,YAAc1sB,KAAKstB,mBAAoB,GAE7E,GAAkB,IAAdG,EAAJ,CAIAztB,KAAK0tB,qBAGL,IAAK,IAAI1xB,EAAI,EAAGA,EAAIyxB,IAAazxB,EAAG,CAClC,IAAMixB,EAAUjtB,KAAKmtB,aAAalX,QAC9BgX,GACFjtB,KAAK2tB,cAAcV,O,gCASzB,WAEE,IADA,IAAME,EAAentB,KAAKmtB,aACjBnxB,EAAI,EAAGA,EAAImxB,EAAanrB,SAAUhG,EAAG,CAC5C,IAAMixB,EAAUE,EAAanxB,GACxBgE,KAAK4tB,eAAeX,KAEvBE,EAAaxmB,OAAO3K,EAAG,GACvBgE,KAAKgtB,WAAL,OAAuBC,EAAQH,QAC/B9wB,KAKJmxB,EAAaU,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEZ,SAAWa,EAAEb,c,4BAI7C,SAAeD,GAIb,OAHAA,EAAQC,SAAWD,EAAQF,YAAYE,EAAQH,UAG3CG,EAAQC,SAAW,IACrBD,EAAQ/Z,QAAQ,MACT,S,qICtLN,SAAiBtE,GACtB,IAAMof,EAAapf,GAAOA,EAAIqf,YAAY,KAC1C,OAAOD,GAAc,EAAIpf,EAAIsf,OAAO,EAAGF,GAAwB,I,OAO1D,WAA0C,2BAAzBG,EAAyB,yBAAzBA,EAAyB,gBAC/C,IAAMC,EAAY,IAUlB,OATAD,EAAQA,EAAM3V,KAAI,SAAC6V,EAAMvtB,GAOvB,OANIA,IACFutB,EAAOA,EAAKC,QAAQ,IAAIC,OAAJ,WAAeH,IAAc,KAE/CttB,IAAUqtB,EAAMnsB,OAAS,IAC3BqsB,EAAOA,EAAKC,QAAQ,IAAIC,OAAJ,UAAcH,EAAd,MAA6B,KAE5CC,MAEI7B,KAAK4B,K,8FClBb,SAAuBI,GAC5BC,EAAaD,G,gBAMR,WACL,OAAOC,G,aAUF,SAAoBC,GACzBhyB,OAAOgJ,OAAOipB,EAAaD,I,cAMtB,SAAqBE,GAC1B,IAAK,IAAMC,KAASF,EAClB,GAAIC,EAASjY,WAAWkY,GAAQ,CAC9B,IAAMC,EAAcH,EAAYE,GAChCD,EAAWA,EAASN,QAAQO,EAAOC,GAGlCF,EAASjY,WAAW,YAAeiY,EAASjY,WAAW,cAC1DiY,EAAW,GAAH,OAAMH,GAAN,OAAmBG,IAE7B,OAAOA,GAzCT,IAAIH,EAAa,GACXE,EAA6C,I,yGCE5C,SAAkB1xB,GACvB,OAAOA,GAA0B,WAAjB,EAAOA,IAAsBA,EAAM8xB,U,WAO9C,SAAkBltB,GACvB,OAAOkB,EAAKisB,SAAWjsB,EAAKisB,SAASntB,GAAQA,G,sBAOxC,SAA6BA,GAClC,GAAIkB,EAAK8U,cAEP,OAAO9U,EAAK8U,cAAchW,GAE5B,OAAOA,GA1BT,M,ybAAA,Q,wlBCIA,I,EAgBO,EAVMotB,EAAa,CACxB1yB,KAAM,OACN4R,GAAI,OACJpS,OAAQ,OACR4D,QAVc,QAWdc,WAAY,CAAC,OAAQ,WACrB2iB,UAAW,CAAC,oBACZ8L,SAAU,OACVpX,MAAM,EACNuQ,gBACAnG,O,EAAK,yBAAE,WAAOzgB,GAAP,yGAAuB4mB,GAAc,IAAI7U,aAAcR,OAAOvR,KAA9D,0CAAF,E,8KAAA,6CACL4M,QAAS,IAIX,SAASga,EAAcvQ,GACrB,OAAOmK,KAAKC,MAAMpK,G,eAGb,IAAMqX,EAAyCF,E,mLC7BtD,Y,6WAEO,WAAwBG,EAASC,EAAMhhB,GAAvC,iGACQ,IAAAihB,cAAaF,GAAS,SAACxgB,GAAD,OAAS2Y,EAAY3Y,EAAKygB,EAAMhhB,MAD9D,oF,+BAIekZ,E,uFAAf,WAA2B3Y,EAAKygB,EAAMhhB,GAAtC,wGAEkBsW,MAAM/V,EAAKP,EAAQsW,OAFrC,cAECE,EAFD,gBAGqBA,EAASpjB,cAH9B,cAGCA,EAHD,gBAIQ4tB,EAAK5tB,EAAa4M,GAJ1B,oF,mtBCUP,IAAMkhB,EAAW,SAACtyB,GAAD,OAAWA,GAA0B,WAAjB,EAAOA,I,iDAKrC,WAA4BuyB,EAAMC,GAAlC,yGAAwCphB,EAAxC,+BAAkD,GAAlD,SACQqhB,EAAWF,EAAMC,EAAMphB,GAD/B,oF,+BAIeqhB,E,uFAAf,WAA0BhyB,EAAQ+xB,EAAMphB,GAAxC,0FACD3E,MAAMiQ,QAAQjc,GADb,gCAEUiyB,EAASjyB,EAAQ+xB,EAAMphB,GAFjC,mDAKDkhB,EAAS7xB,GALR,gCAMUkyB,EAAUlyB,EAAQ+xB,EAAMphB,GANlC,sDAUCO,EAAMlR,EAVP,UAWQ+xB,EAAK7gB,EAAKP,GAXlB,sF,+BAgBQuhB,E,uFAAf,WAAyBlyB,EAAQ+xB,EAAMphB,GAAvC,4FAIE,IAAW9Q,KAHL4mB,EAA2B,GAC3BnP,EAAS,GAFjB,WAIazX,GACT,IACM6mB,EAAUsL,EADJhyB,EAAOH,GACakyB,EAAMphB,GAAS2N,MAAK,SAAC/e,GACnD+X,EAAOzX,GAAON,KAEhBknB,EAAS3hB,KAAK4hB,IALE1mB,EAAQ,EAAfH,GAJb,gBAYQ0V,QAAQuJ,IAAI2H,GAZpB,gCAcSnP,GAdT,4C,+BAiBe2a,E,qFAAf,WAAwBE,EAAUJ,GAAlC,2GAAwCphB,EAAxC,+BAAkD,GAC1C8V,EAAW0L,EAASrX,KAAI,SAAC5J,GAAD,OAAS8gB,EAAW9gB,EAAK6gB,EAAMphB,MAD/D,SAEe4E,QAAQuJ,IAAI2H,GAF3B,oF,mHCxDO,SAAoBvV,EAAKP,GAG9B,GADiBO,EAAI+H,WAAW,UAAY/H,EAAI+H,WAAW,UAAY/H,EAAI+H,WAAW,UAEpF,OAAO/H,EAET,IAAMgZ,EAAUvZ,EAAQsP,SAAWtP,EAAQkW,IAC3C,IAAKqD,EACH,MAAM,IAAI1pB,MAAJ,6DAAgE0Q,IAExE,OAAOgZ,EAAQsG,OAAO,EAAGtG,EAAQqG,YAAY,KAAO,GAAKrf,I,yICQpD,SAAmC3O,EAAMJ,EAASiG,GACvD,IAAM7D,EAAQhC,EAAKqE,OAAOwB,GACpBpB,EAAkBzE,EAAKwE,YAAYxC,EAAMhB,YAC/C,OAAO8jB,EAA2B9kB,EAAMJ,EAAS6E,IAtBnD,WAIO,SAASqgB,EAA2B9kB,EAAMJ,EAAS6E,GACxD,IAAMzD,EAAahB,EAAKwE,YAAYC,IACpC,IAAApD,QAAOL,GAGP,IACMI,EAAWxB,EADGoB,EAAWG,SAE/B,IAAAE,QAAOD,GAEP,IAAME,GAAcN,EAAWM,YAAc,GAAKF,EAASE,WAC3D,OAAO,IAAIC,WAAWH,EAASI,YAAaF,EAAYN,EAAWd,c,4vCCS9D,IAAM2vB,EAA6D,CAMxEC,2BAtBF,SAuBEC,oBAtBF,UAuBEC,oBAtBF,UAuBEC,qBAtBF,W,iDAyBO,WAAgCnwB,GAAhC,4GAAsCsO,EAAtC,+BAAmE,GAAI7C,EAAvE,oDACuBskB,GADvB,iDACMzvB,EADN,WAEG8vB,GAAW9hB,SAAA,UAAAA,EAAStO,YAAT,eAAeqwB,oBAAqB,GACrC/vB,KAAiB8vB,IAAaA,EAAS9vB,GAHpD,wBAKK8B,EAAY2tB,EAAWzvB,GAL5B,UAQK8B,EAAU6Q,OAAOjT,EAAMsO,EAAS7C,GARrC,oE,sLCIA,SAAgB6kB,GAAiD,MAAvChiB,EAAuC,uDAAV,GACtDiiB,EAAa,IAAIC,UAAWF,GADoC,IAGnDC,EAAWrwB,KAAK6D,QAAU,IAHyB,IAGtE,2BAAiD,KAAtCX,EAAsC,QAG/CqtB,EAAartB,EAAMkL,GAEnBiiB,EAAWG,qBAAqBC,+BARoC,gCAhCxE,I,EAAA,QAEA,OACA,G,EAAA,O,2BACA,OACA,S,2pCAuJUC,G,++CApJH,WACLN,EACAhiB,EACA7C,GAHK,mGAKA6C,SALA,UAKAA,EAAStO,YALT,OAKA,EAAe0jB,iBALf,iDASC6M,EAAa,IAAIC,UAAWF,GAC5BlM,EAA4B,GAV7B,IAWmBwM,EAA0BL,IAX7C,IAWL,2BAAW/Q,EAAoD,QACzD+Q,EAAWM,mBAAmBrR,EAAWmR,+BAC3CvM,EAAS3hB,KAAKquB,EAAoBP,EAAY/Q,EAAWlR,EAAS7C,IAbjE,8CAkBCyH,QAAQuJ,IAAI2H,GAlBb,OAqBLmM,EAAWQ,gBAAgBJ,8BArBtB,4C,+BA4CQG,E,yFAAf,WACEP,EACA/Q,EACAlR,EACA7C,GAJF,mHAMQulB,EAAiBT,EAAWM,mBAAmBrR,EAAWmR,8BANlE,wDAWQtvB,EAASkvB,EAAWvL,2BAA2BgM,EAAe9vB,YAG9D+vB,GAAa,IAAAhM,kBAAiB5jB,EAAOA,OAAQA,EAAOG,YAEnD2gB,EAAS1W,EAAT0W,aACD+O,EAjBR,KAiB+C5iB,IAGzB,YApBtB,UAqB6B6T,EACzB8O,EACAE,cACAD,EACAzlB,GAzBJ,QA+BE,IAVM2lB,EArBR,OA4BQC,GAAmD,IAAAC,kBAAiBF,EAAY/tB,YAGtF,MAAgD1G,OAAO2e,QAAQ+V,GAA/D,eAAmF,YAAvElqB,EAAuE,KAAxDoqB,EAAwD,KAC7EpqB,KAAiBqY,EAAUnc,aACvBmuB,EAAwBhS,EAAUnc,WAAW8D,GAE/CxF,OADEA,EAAW4uB,EAAW3uB,YAAY4vB,KACpC7vB,EAAUsD,KAAVtD,MAAiBA,KAAUqD,MAC7BusB,EAAiBtsB,IAAMtD,EAASsD,IAChCssB,EAAiBvsB,IAAMrD,EAASqD,MAMtCwa,EAAUnc,WAAaguB,EACnBD,EAAY9tB,UAEdkc,EAAUlc,SAAU,IAAAmuB,iBAAgBL,EAAY9tB,UAMlDouB,EAAelS,GApDjB,6C,sBA2DA,SAASiR,EAAaptB,EAAYC,GAA4D,MAAnDlG,EAAmD,uDAApC,EAAGkR,EAAiC,uCAAxB7C,EAAwB,uCAC5F,IAAK6C,EAAQqjB,YACX,MAAM,IAAIxzB,MAAM,yCAIlB,IAAMyzB,EAAiBtjB,EAAQqjB,YAAYE,WAAW,CAACxuB,eAQjD+tB,EAAc3lB,SAAH,UAAGA,EAAS2c,iBAAZ,aAAG,OAAA3c,EAAqB,CAACpI,eACpCyuB,EAAgBxjB,EAAQyjB,mBAAmBX,EAAY/tB,YAEvDsB,EAAkB2J,EAAQhK,cAAcstB,GAExCpuB,EAAW,CACfC,WAAY,CACV,CACEJ,WAAYyuB,EACZ10B,OACAsD,WAAY,EAAF,GACPiwB,6BAA6B,CAC5BzvB,WAAYyD,EACZtB,WAAYyuB,OAOtB,OAAOtuB,EAKT,SAASkuB,EAAelS,GACtB,IAAKA,EAAUnc,YAAc1G,OAAOq1B,KAAKxS,EAAUnc,YAAYpB,OAAS,EACtE,MAAM,IAAI9D,MAAM,gEAIpB,SAAUyyB,EAA0BL,GAApC,oGACqBA,EAAWrwB,KAAK6D,QAAU,IAD/C,yDACaX,EADb,YAE4BA,EAAKK,YAFjC,yDAGM,OADS+b,EAFf,kBAGYA,EAHZ,sHAAAyS,IAAA,mIAAAA,IAAA,wF,yTCjKA,I,EAAA,QACA,G,EAAA,Q,2BACA,QASA,S,m/BAUO,IAAMd,EAAc,EAAH,KACnBe,eADmB,IAEtB/P,M,iGAGF,WACEzgB,EACA4M,GAFF,2GAIwB,IAAA6jB,wBAAuB7jB,GAJ/C,uBAIS4N,EAJT,EAISA,MACDkW,EAAc,IAAIC,UAAYnW,GALtC,2BAOWkW,EAAYhK,UAAU1mB,EAAa4M,aAAnC,EAAmCA,EAAS4N,QAPvD,uBASIkW,EAAYld,UAThB,0E,sCAcO,IAAMod,EAA0CnB,E,sJCxCvD,Y,qOAWA,IAAMoB,EAA4C,CAChDrW,MAAO,CACLI,YAAoC,YAAvB,oBAAOkW,YAAP,cAAOA,cAA2B,OAAS,KACxDC,YAAa,QACbC,gBAAiB,GACjBC,wBAAoBjiB,IAOXygB,EAAc,CACzB30B,KAAM,QACN4R,GAAI,QACJpS,OAAQ,QACR4D,QAASyO,UACTc,QAAQ,EACRzO,WAAY,CAAC,OACb2iB,UAAW,CAAC,4BACZ7c,QAAQ,EACR8c,MAAO,CAAC,SACRhV,QAASikB,G,gBAGJ,IAAMD,EAAgCnB,E,0HCT7C,YACA,S,8oEAmBA,IAMMyB,EAAmC,CACvCC,SAAU,WACVC,OAAQ,SACRC,MAAO,UACPC,UAAW,cAGPC,EAAqC,CACzCC,EAAG5hB,UACH6hB,EAAG1xB,WACH2xB,EAAG7hB,WACH8hB,EAAG7hB,YACH8hB,EAAGC,WACHC,EAAG/hB,YACHgiB,EAAG/hB,cAKgB2gB,E,WAMnB,WAAYnW,I,4FAAgB,0FAC1Bjc,KAAKic,MAAQA,EACbjc,KAAKyzB,QAAU,IAAIzzB,KAAKic,MAAMyX,QAC9B1zB,KAAK2zB,gBAAkB,IAAI3zB,KAAKic,MAAM2X,gB,8CAMxC,WACE5zB,KAAKic,MAAMhH,QAAQjV,KAAKyzB,SACxBzzB,KAAKic,MAAMhH,QAAQjV,KAAK2zB,mB,uBAQ1B,SAAUlyB,GAA0E,IAAhD4M,EAAgD,uDAAnB,GACzDjN,EAAS,IAAIpB,KAAKic,MAAM4X,cAC9BzyB,EAAO0yB,KAAK,IAAIziB,UAAU5P,GAAcA,EAAYtB,YAEpDH,KAAK+zB,4BAA4B1lB,GAEjC,IAAM2lB,EAAgBh0B,KAAKyzB,QAAQQ,uBAAuB7yB,GACpD8yB,EACJF,IAAkBh0B,KAAKic,MAAMkY,gBACzB,IAAIn0B,KAAKic,MAAMmY,KACf,IAAIp0B,KAAKic,MAAMoY,WAErB,IACE,IAAIC,EACJ,OAAQN,GACN,KAAKh0B,KAAKic,MAAMkY,gBACdG,EAAct0B,KAAKyzB,QAAQc,mBAAmBnzB,EAAQ8yB,GACtD,MAEF,KAAKl0B,KAAKic,MAAMuY,YACdF,EAAct0B,KAAKyzB,QAAQgB,yBAAyBrzB,EAAQ8yB,GAC5D,MAEF,QACE,MAAM,IAAIh2B,MAAM,iCAGpB,IAAKo2B,EAAYI,OAASR,EAAcS,IAAK,CAC3C,IAAM12B,EAAU,+BAAH,OAAkCq2B,EAAYM,aAE3D,MAAM,IAAI12B,MAAMD,GAGlB,IAAM42B,EAAa70B,KAAK80B,oBAAoBZ,EAAeF,EAAe3lB,GAEpE0mB,EAAW/0B,KAAKg1B,aAAad,EAAeW,EAAYxmB,GAExD4mB,GAAc,IAAAC,oBAAmBH,EAAS3xB,YAE1CsW,GAAS,IAAAyb,0BAAyBJ,EAAS3xB,WAAYyxB,EAAYE,EAAS1xB,SAE5ExB,EAAsB,EAAH,GACvBimB,OAAQ,QACR+M,aACA5T,OAAQ,CACNmU,YAAalB,EAAcmB,aAC3BJ,gBAECF,GAPoB,IAQvBrb,WAEF,OAAO7X,EAvCT,QAyCE7B,KAAKic,MAAMhH,QAAQ7T,GACf8yB,GACFl0B,KAAKic,MAAMhH,QAAQif,M,iCAczB,SACEA,EACAF,EACA3lB,GAEA,IAAMpK,EAAWjE,KAAKs1B,qBAAqBpB,GACrC9wB,EAAapD,KAAKu1B,oBAAoBrB,EAAe7lB,GAE3D,MAAO,CACL2lB,gBACAwB,eAAgBtB,EAAcsB,iBAC9BH,WAAYnB,EAAcmB,aAC1BI,UAAWvB,aAAyBl0B,KAAKic,MAAMmY,KAAOF,EAAcuB,YAAc,EAClFxxB,WACAb,gB,iCAUJ,SACE8wB,EACA7lB,GAIA,IAFA,IAAMqnB,EAAyD,GAEtDC,EAAc,EAAGA,EAAczB,EAAcsB,iBAAkBG,IAAe,CAGrF,IAAMC,EAAiB51B,KAAKyzB,QAAQoC,aAAa3B,EAAeyB,GAE1D1xB,EAAWjE,KAAK81B,sBAAsB5B,EAAeyB,GAE3DD,EAAgBE,EAAeG,aAAe,CAC5CA,UAAWH,EAAeG,YAC1BC,eAAgBJ,EAAeI,iBAC/BC,UAAWL,EAAeK,YAC1BC,eAAgBN,EAAeM,iBAE/BC,YAAaP,EAAeO,cAC5BC,YAAaR,EAAeQ,cAC5BC,WAAYT,EAAeS,aAC3BC,gBAAiBX,EAEjB1xB,YAIF,IAAMsyB,EAAev2B,KAAKw2B,0BAA0BZ,EAAgBvnB,GAChEkoB,IACFb,EAAgBE,EAAeG,aAAaU,uBAAyBF,GAGvE,IAAMG,EAAa12B,KAAK22B,wBAAwBf,EAAgBvnB,GAC5DqoB,IACFhB,EAAgBE,EAAeG,aAAaa,qBAAuBF,GAIvE,OAAOhB,I,0BAST,SACExB,EACAW,EACAxmB,GAEA,IAAMjL,EAAapD,KAAK62B,mBAAmBhC,EAAYX,EAAe7lB,GAGtE,IAD0BjL,EAAWwvB,SAEnC,MAAM,IAAI10B,MAAM,uCAIlB,GAAIg2B,aAAyBl0B,KAAKic,MAAMmY,KACtC,OAAQ/lB,EAAQyoB,UACd,IAAK,iBACH,MAAO,CACLA,SAAU,iBACV35B,KAAM,EACNiG,aACAC,QAAS,CACPpG,MAAO+C,KAAK+2B,yBAAyB7C,GACrCrvB,KAAM,IAGZ,IAAK,gBACL,QACE,MAAO,CACLiyB,SAAU,gBACV35B,KAAM,EACNiG,aACAC,QAAS,CACPpG,MAAO+C,KAAKg3B,wBAAwB9C,GACpCrvB,KAAM,IAOhB,MAAO,CACLiyB,SAAU,aACV35B,KAAM,EACNiG,gB,gCAIJ,SACEyxB,EACAX,EACA7lB,GAIA,IAFA,IAAMjL,EAA6C,GAEnD,MAA8B1G,OAAOsY,OAAO6f,EAAWzxB,YAAvD,eAAoE,CAA/D,IAAM6zB,EAAe,KAClB/vB,EAAgBlH,KAAKk3B,qBAAqBD,EAAiB5oB,GACjE4oB,EAAgB16B,KAAO2K,EACvB,MAAsBlH,KAAKm3B,oBAAoBjD,EAAe+C,GAAvDh6B,EAAP,EAAOA,MAAO4H,EAAd,EAAcA,KACdzB,EAAW8D,GAAiB,CAC1BjK,QACA4H,OACAtD,WAAY01B,EAAgBd,YAC5BiB,WAAYH,EAAgBb,YAC5BC,WAAYY,EAAgBZ,YAIhC,OAAOjzB,I,qCAST,SAAwB8wB,GAEtB,IACMmD,EAAwB,EADbnD,EAAcuB,YAEzBt1B,EAxPc,EAwPDk3B,EAEb1C,EAAM30B,KAAKic,MAAMqb,QAAQn3B,GAC/B,IAEE,OADAH,KAAKyzB,QAAQ8D,wBAAwBrD,EAAe/zB,EAAYw0B,GACzD,IAAInjB,YAAYxR,KAAKic,MAAMub,QAAQp2B,OAAQuzB,EAAK0C,GAAYzf,QAFrE,QAIE5X,KAAKic,MAAMwb,MAAM9C,M,sCAQrB,SAAyBT,GACvB,IAAMwD,EAAa,IAAI13B,KAAKic,MAAM0b,gBAClC,IAEE,OADwB33B,KAAKyzB,QAAQmE,0BAA0B1D,EAAewD,GA0QpF,SAAwBA,GAGtB,IAFA,IAAMG,EAAYH,EAAW7yB,OACvBizB,EAAW,IAAIxE,WAAWuE,GACvB77B,EAAI,EAAGA,EAAI67B,EAAW77B,IAC7B87B,EAAS97B,GAAK07B,EAAWK,SAAS/7B,GAEpC,OAAO87B,EA/QIE,CAAeN,GAFxB,QAIE13B,KAAKic,MAAMhH,QAAQyiB,M,iCAUvB,SACExD,EACA1U,GAEA,IAQIviB,EAREg7B,EAAiBjF,EAAmCxT,EAAUyW,WAC9DiC,EAAgB1Y,EAAU0W,eAE1B2B,EADY3D,EAAcmB,aACF6C,EAExB/3B,EAAa03B,EAAYI,EAAeE,kBACxCC,EA+MV,SAA0Bnc,EAAgBoc,GACxC,OAAQA,GACN,KAAK5mB,aACH,OAAOwK,EAAMqc,WACf,KAAKjnB,UACH,OAAO4K,EAAMsc,QACf,KAAKjnB,WACH,OAAO2K,EAAMuc,SACf,KAAKlF,WACH,OAAOrX,EAAMwc,SACf,KAAKj3B,WACH,OAAOya,EAAMyc,SACf,KAAKnnB,YACH,OAAO0K,EAAM0c,UACf,KAAKnnB,YACH,OAAOyK,EAAM2c,UACf,QACE,OAAO3c,EAAM4c,YAhOEC,CAAiB94B,KAAKic,MAAOgc,GAIxCtD,EAAM30B,KAAKic,MAAMqb,QAAQn3B,GAC/B,IACE,IAAMy1B,EAAiB51B,KAAKyzB,QAAQoC,aAAa3B,EAAe1U,EAAU8W,iBAC1Et2B,KAAKyzB,QAAQsF,kCACX7E,EACA0B,EACAwC,EACAj4B,EACAw0B,GAEF13B,EAAQ,IAAIg7B,EAAej4B,KAAKic,MAAMub,QAAQp2B,OAAQuzB,EAAKkD,GAAWjgB,QATxE,QAWE5X,KAAKic,MAAMwb,MAAM9C,GAGnB,MAAO,CAAC13B,QAAO4H,KAAMqzB,K,kCA6BvB,SAAqB1Y,EAA2BnR,GAG9C,IADA,IAAM2qB,EAAWxZ,EAAUuW,UAC3B,MAAiDr5B,OAAO2e,QACtDhN,EAAQokB,iBAAmB,IAD7B,eAEG,CAFE,gBAAOvrB,EAAP,KAGH,GAHG,OAGuB8xB,EACxB,OAAO9xB,EAKX,IAAM+xB,EAAoBzZ,EAAUwW,eACpC,IAAK,IAAMkD,KAA0BvG,EAEnC,GADsB3yB,KAAKic,MAAMid,KACXD,EAGpB,OAAOtG,EAAiCuG,GAM5C,IAAMC,EAAY9qB,EAAQqkB,oBAAsB,OAChD,OAAIlT,EAAUvb,SAASk1B,GACd3Z,EAAUvb,SAASk1B,GAAW3yB,OAIvC,2BAA2BwyB,K,kCAM7B,SAAqB9E,GACnB,IAAMkF,EAAgBp5B,KAAKyzB,QAAQ4F,YAAYnF,GAC/C,OAAOl0B,KAAKs5B,kBAAkBF,K,mCAIhC,SAAsBlF,EAAkCyB,GACtD,IAAMyD,EAAgBp5B,KAAKyzB,QAAQ8F,qBAAqBrF,EAAeyB,GACvE,OAAO31B,KAAKs5B,kBAAkBF,K,+BAQhC,SAAkBA,GAEhB,IAAKA,IAAkBA,EAAczE,IACnC,MAAO,GAIT,IAFA,IAAM/tB,EAAS,GACT4yB,EAAax5B,KAAK2zB,gBAAgB8F,WAAWL,GAC1CM,EAAa,EAAGA,EAAaF,EAAYE,IAAc,CAC9D,IAAMP,EAAYn5B,KAAK2zB,gBAAgBgG,aAAaP,EAAeM,GACnE9yB,EAAOuyB,GAAan5B,KAAK45B,uBAAuBR,EAAeD,GAEjE,OAAOvyB,I,oCAQT,SAAuBwyB,EAAyBD,GAC9C,IAAMzB,EAAa,IAAI13B,KAAKic,MAAM0b,gBAClC,IAEE33B,KAAK2zB,gBAAgBkG,iBAAiBT,EAAeD,EAAWzB,GAChE,IAAMI,EA2GZ,SAAuBJ,GAGrB,IAFA,IAAMG,EAAYH,EAAW7yB,OACvBizB,EAAW,IAAIxE,WAAWuE,GACvB77B,EAAI,EAAGA,EAAI67B,EAAW77B,IAC7B87B,EAAS97B,GAAK07B,EAAWK,SAAS/7B,GAEpC,OAAO87B,EAjHcgC,CAAcpC,GAC/B,MAAO,CACLqC,IAAK/5B,KAAK2zB,gBAAgBqG,YAAYZ,EAAeD,GACrD3yB,OAAQxG,KAAK2zB,gBAAgBsG,eAAeb,EAAeD,GAC3De,OAAQl6B,KAAK2zB,gBAAgBwG,eAAef,EAAeD,GAC3DrB,YARJ,QAWE93B,KAAKic,MAAMhH,QAAQyiB,M,yCAOvB,SAA4BrpB,GAC1B,IADsD,EACtD,EAA8DA,EAAvD+rB,2BAAP,MAA6B,GAA7B,IAA8D/rB,EAA7BgsB,4BAAjC,MAAwD,GAAxD,EADsD,E,goBAAA,CAE/B,GAAH,SAAOD,GAAP,EAA+BC,KAFG,IAGtD,2BAAiD,KAAtCC,EAAsC,QAC/Ct6B,KAAKyzB,QAAQ8G,uBAAuBv6B,KAAKic,MAAMqe,KAJK,iC,uCAYxD,SACE1E,EACAvnB,GACmC,WACnC,EAAmCA,EAA5B+rB,2BAAP,MAA6B,GAA7B,EACMpE,EAAiBJ,EAAeI,iBAEtC,GADaoE,EAAoB5hB,KAAI,SAACna,GAAD,OAAU,EAAKo1B,QAAQp1B,MAAOm8B,SAASxE,GAClE,CACR,IAAMyE,EAAY,IAAIz6B,KAAKic,MAAMye,+BACjC,IACE,GAAID,EAAUE,kBAAkB/E,GAC9B,MAAO,CACLgF,kBAAmBH,EAAUG,oBAC7BC,MAAOJ,EAAUI,QACjBC,WAAY,IAAIrpB,aAAa,CAAC,EAAG,EAAG,IAAI+G,KAAI,SAACxc,GAAD,OAAOy+B,EAAUM,UAAU/+B,OAL7E,QASEgE,KAAKic,MAAMhH,QAAQwlB,IAGvB,OAAO,O,qCAGT,SACE7E,EACAvnB,GACiC,WACjC,EAAoCA,EAA7BgsB,4BAAP,MAA8B,GAA9B,EACMrE,EAAiBJ,EAAeI,iBAItC,GAHmBqE,EAChB7hB,KAAI,SAACna,GAAD,OAAU,EAAKo1B,QAAQp1B,MAC3Bm8B,SAASxE,GACI,CACd,IAAMyE,EAAY,IAAIz6B,KAAKic,MAAMye,+BACjC,IACE,GAAID,EAAUE,kBAAkB/E,GAC9B,MAAO,CACLgF,kBAAmBH,EAAUG,qBAHnC,QAOE56B,KAAKic,MAAMhH,QAAQwlB,IAGvB,OAAO,U,4IC3iBX,eACA,WACA,W,g5BAgBA,IAAMO,EAAsD,CAC1DjhB,MAAO,kBACPkhB,UAAW,OACXC,gBAAiB,EACjBC,MAAO,EACPC,SAAU,GAMSC,E,WAenB,WAAY3hB,EAAgBrL,I,4FAAoC,8EAXd,MAWc,oBAVnC,GAUmC,mBATpC,GASoC,0BAR7B,GAQ6B,4BAP3BvG,KAAKJ,OAOsB,qBANlC,GAMkC,oBALnC,GAKmC,kBAJrC,GAKzB1H,KAAK0Z,OAASA,EACd1Z,KAAKqO,QAAL,OAAmB2sB,GAAoB3sB,G,mDAGzC,WAAwB,QACtB,SAAItC,QAAO,UAAC/L,KAAKqO,eAAN,aAAC,EAAc8sB,QAAUn7B,KAAKs7B,aAAet7B,KAAKqO,QAAQ8sB,WAGjEpvB,QAAO,UAAC/L,KAAKqO,eAAN,aAAC,EAAc+sB,WAAap7B,KAAKu7B,WAAa,KAAOv7B,KAAKqO,QAAQ+sB,Y,oBAO/E,SAAOvhB,GACD7Z,KAAKw7B,iBAGTx7B,KAAKs7B,cACLt7B,KAAKy7B,SAAWz7B,KAAKy7B,UAAYz7B,KAAK07B,eAAe7hB,GACrD7Z,KAAKu7B,YAAcv7B,KAAKy7B,SACpB/xB,MAAMiQ,QAAQE,GAChB7Z,KAAKsa,YAAYT,GAEjB7Z,KAAKka,aAAaL,M,yBAKtB,SAAsBA,GACpB,IAAK7Z,KAAK27B,WAAY,CACpB,IAAMC,EAAiB57B,KAAK67B,qBAC5B77B,KAAK27B,WAAa,IAAIC,EAAe57B,KAAK0Z,OAAQ1Z,KAAKqO,SAEzDrO,KAAK27B,WAAWrhB,YAAYT,K,0BAI9B,SAAuBA,GACrB,IAAK7Z,KAAK27B,WAAY,CACpB,IAAMC,EAAiB57B,KAAK67B,qBAC5B77B,KAAK27B,WAAa,IAAIC,EAAe57B,KAAK0Z,OAAQ1Z,KAAKqO,SAEzDrO,KAAK27B,WAAWzhB,aAAaL,K,2BAI/B,SAAcwS,GACRA,aAAiBlmB,cACnBnG,KAAK87B,WAAazP,EAAMlsB,YAEL,iBAAVksB,IACTrsB,KAAK87B,WAAazP,EAAMrqB,QAE1BhC,KAAK+7B,iBAAkB,I,0BAGzB,SAAa1tB,GACX,OAAOrO,KAAKg8B,UAAYh8B,KAAKi8B,UAAU5tB,GAAW,O,2BAGpD,SAAcA,GACZ,OAAOrO,KAAKi8B,UAAU5tB,K,4BAKxB,SAAewL,GACb,OAAOnQ,MAAMiQ,QAAQE,GAAoB,EAAbA,EAAI7X,OAAuC,EAA1BtF,OAAOq1B,KAAKlY,GAAK7X,S,qBAGhE,WAEE,IAAKhC,KAAK27B,YAA6C,IAA/B37B,KAAK27B,WAAWO,WACtC,OAAO,EAKT,GAA+B,SAA3Bl8B,KAAKqO,QAAQ4sB,WACf,IAAKj7B,KAAK+7B,gBACR,OAAO,OAEJ,GAAI/7B,KAAKqO,QAAQ4sB,UAAYj7B,KAAK27B,WAAWO,WAClD,OAAO,EAIT,QAAIl8B,KAAKqO,QAAQ6sB,gBAAkBpzB,KAAKJ,MAAQ1H,KAAKm8B,qBAKrDn8B,KAAK+7B,iBAAkB,EACvB/7B,KAAKm8B,mBAAqBr0B,KAAKJ,MACxB,M,uBAMT,SAAkB2G,GAChB,IAAKrO,KAAK27B,WACR,OAAO,KAILttB,WAASytB,YACX97B,KAAK87B,UAAYztB,EAAQytB,WAE3B,IAAMM,EAAkBp8B,KAAK27B,WAAWU,WAOxC,OANAD,EAAgBt3B,MAAQ9E,KAAKs8B,WAC7BF,EAAgBN,UAAY97B,KAAK87B,UACjCp/B,OAAOgJ,OAAO02B,EAAiB/tB,GAE/BrO,KAAKs8B,aACLt8B,KAAK27B,WAAa,KACXS,I,gCAGT,WACE,OAAQp8B,KAAKqO,QAAQ0L,OACnB,IAAK,YACH,OAAOwiB,UACT,IAAK,kBACL,IAAK,mBACH,OAAO9iB,UACT,IAAK,iBACH,OAAOoB,UACT,IAAK,cACH,IAAKwgB,EAAkBmB,WACrB,MAAM,IAAIt+B,MAvJA,qBAyJZ,OAAOm9B,EAAkBmB,WAC3B,QACE,MAAM,IAAIt+B,MA3JE,2B,8CAGCm9B,E,mZC5BrB,IAEqB5hB,E,WASnB,WAAYC,EAAgBrL,GAM1B,G,4FANsD,0EALvC,GAKuC,cAJnC,MAImC,gBAHvC,GAGuC,kBAF3B,IAG3BrO,KAAKqO,QAAUA,EACfrO,KAAK0Z,OAASA,GAIThQ,MAAMiQ,QAAQD,GAEjB,IAAK,IAAMnc,KADXyC,KAAK4Z,SAAW,GACEF,EAChB1Z,KAAK4Z,SAASF,EAAOnc,GAAKuD,OAAS4Y,EAAOnc,GAAKhB,K,+CAKrD,WACE,OAAOyD,KAAKgC,S,yBAGd,SAAY6X,EAAYC,GAClBlW,OAAOC,SAASiW,KAClB9Z,KAAK8Z,OAASA,GAGhB9Z,KAAKwa,KAAOxa,KAAKwa,MAAQ,IAAI9Q,MAlCP,KAmCtB1J,KAAKwa,KAAKxa,KAAKgC,QAAU6X,EACzB7Z,KAAKgC,W,0BAGP,SAAa6X,EAAkCC,GACzClW,OAAOC,SAASiW,KAClB9Z,KAAK8Z,OAASA,GAGhB9Z,KAAKwa,KAAOxa,KAAKwa,MAAQ,IAAI9Q,MA5CP,KA6CtB1J,KAAKwa,KAAKxa,KAAKgC,QAAU6X,EACzB7Z,KAAKgC,W,sBAGP,WACE,IAAIwY,EAAOxa,KAAKwa,KAChB,OAAKA,GAILA,EAAOA,EAAK5C,MAAM,EAAG5X,KAAKgC,QAC1BhC,KAAKwa,KAAO,KAEc,CACxBT,MAAO/Z,KAAKqO,QAAQ0L,MACpBU,UAAW,OACX5Y,KAAM2Y,EACNxY,OAAQhC,KAAKgC,OACb0X,OAAQ1Z,KAAK0Z,OACbI,OAAQ9Z,KAAK8Z,SAZN,U,yIChCN,SAAqB1W,GAC1B,IAAIyB,EAAO,EACX,IAAK,IAAMqC,KAAiB9D,EAAY,CACtC,IAAMoc,EAAYpc,EAAW8D,GACzBf,YAAY8H,OAAOuR,KAErB3a,GAAQ2a,EAAUrf,WAAaqf,EAAU2Y,mBAG7C,OAAOtzB,G,qBASF,SAA4BzB,GAWjC,IAVA,IAAIq5B,EAAOC,IACPC,EAAOD,IACPE,EAAOF,IACPG,GAAQH,IACRI,GAAQJ,IACRK,GAAQL,IAENM,EAAY55B,EAAWwvB,SAAWxvB,EAAWwvB,SAAS31B,MAAQ,GAC9DiM,EAAM8zB,GAAaA,EAAUh7B,OAE1BhG,EAAI,EAAGA,EAAIkN,EAAKlN,GAAK,EAAG,CAC/B,IAAMsqB,EAAI0W,EAAUhhC,GACduqB,EAAIyW,EAAUhhC,EAAI,GAClBihC,EAAID,EAAUhhC,EAAI,GAExBygC,EAAOnW,EAAImW,EAAOnW,EAAImW,EACtBE,EAAOpW,EAAIoW,EAAOpW,EAAIoW,EACtBC,EAAOK,EAAIL,EAAOK,EAAIL,EAEtBC,EAAOvW,EAAIuW,EAAOvW,EAAIuW,EACtBC,EAAOvW,EAAIuW,EAAOvW,EAAIuW,EACtBC,EAAOE,EAAIF,EAAOE,EAAIF,EAExB,MAAO,CACL,CAACN,EAAME,EAAMC,GACb,CAACC,EAAMC,EAAMC,M,+FCpEjB,Y,upDASqBG,E,WAKnB,WAAYC,EAAiBl5B,I,4FAA2B,4DACtD,IAAA3C,QAAOoI,MAAMiQ,QAAQwjB,IAqEzB,SAAoBA,GAClB,IAD0B,EACpBC,EAAY,GADQ,IAEND,GAFM,IAE1B,2BAA4B,KAAjBjiB,EAAiB,QACtBkiB,EAAUliB,EAAM3e,OAElByS,QAAQ6P,KAAK,gCAAiC3D,EAAM3e,KAAM2e,GAE5DkiB,EAAUliB,EAAM3e,OAAQ,GAPA,+BApExB8gC,CAAWF,GAEXn9B,KAAKm9B,OAASA,EACdn9B,KAAKiE,SAAWA,GAAY,IAAI0N,I,gDAIlC,SAAU2rB,GACR,GAAIt9B,KAAKiE,WAAaq5B,EAAMr5B,SAC1B,OAAO,EAET,GAAIjE,KAAKm9B,OAAOn7B,SAAWs7B,EAAMH,OAAOn7B,OACtC,OAAO,EAET,IAAK,IAAIhG,EAAI,EAAGA,EAAIgE,KAAKm9B,OAAOn7B,SAAUhG,EACxC,IAAKgE,KAAKm9B,OAAOnhC,GAAGuhC,UAAUD,EAAMH,OAAOnhC,IACzC,OAAO,EAGX,OAAO,I,oBAGT,WAAyC,IAEvC,IAAMwhC,EAAU9gC,OAAOY,OAAO,MAFS,mBAA/BmgC,EAA+B,yBAA/BA,EAA+B,gBAGvC,cAAmBA,EAAnB,eAAgC,CAA3B,IAAMlhC,EAAI,KACbihC,EAAQjhC,IAAQ,EAElB,IAAMmhC,EAAiB19B,KAAKm9B,OAAOQ,QAAO,SAACziB,GAAD,OAAWsiB,EAAQtiB,EAAM3e,SACnE,OAAO,IAAI2gC,EAAOQ,EAAgB19B,KAAKiE,Y,sBAGzC,WAA6C,kCAAjC25B,EAAiC,yBAAjCA,EAAiC,gBAE3C,IAAMF,EAAiBE,EAAcplB,KAAI,SAAC1X,GAAD,OAAW,EAAKq8B,OAAOr8B,MAAQ68B,OAAO5xB,SAC/E,OAAO,IAAImxB,EAAOQ,EAAgB19B,KAAKiE,Y,oBAGzC,SAAO45B,GACL,IAAIV,EACAl5B,EAA2BjE,KAAKiE,SAEpC,GAAI45B,aAA0BX,EAAQ,CACpC,IAAMY,EAAcD,EACpBV,EAASW,EAAYX,OACrBl5B,EAAW85B,EAAUA,EAAU,IAAIpsB,IAAO3R,KAAKiE,UAAW65B,EAAY75B,eAEtEk5B,EAASU,EAIX,IAb+C,EAazCG,EAAmCthC,OAAOY,OAAO,MAbR,IAe3B0C,KAAKm9B,QAfsB,IAe/C,2BAAiC,KAAtBjiB,EAAsB,QAC/B8iB,EAAS9iB,EAAM3e,MAAQ2e,GAhBsB,wCAmB3BiiB,GAnB2B,IAmB/C,2BAA4B,KAAjBjiB,EAAiB,QAC1B8iB,EAAS9iB,EAAM3e,MAAQ2e,GApBsB,8BAyB/C,OAAO,IAAIgiB,EAFUxgC,OAAOsY,OAAOgpB,GAEH/5B,Q,gCAgBpC,SAAS85B,EAAaE,EAAOC,GAE3B,OAAO,IAAIvsB,IAAJ,YAAassB,GAAM,IAAItsB,KAAvB,EAAmCusB,GAAM,IAAIvsB,O,oGC9F/C,SAAgB3T,EAAoBC,GACzC,IAAKD,EACH,MAAM,IAAIE,MAAMD,GAAW,8B,+dCGVkgC,E,WAMnB,WACE5hC,EACA8B,GAGA,IAFA+/B,EAEA,wDADAn6B,EACA,uDADgC,IAAI0N,IACpC,0GACA3R,KAAKzD,KAAOA,EACZyD,KAAK3B,KAAOA,EACZ2B,KAAKo+B,SAAWA,EAChBp+B,KAAKiE,SAAWA,E,2CAGlB,WACE,OAAOjE,KAAK3B,MAAQ2B,KAAK3B,KAAKggC,S,mBAGhC,WACE,OAAO,IAAIF,EAAMn+B,KAAKzD,KAAMyD,KAAK3B,KAAM2B,KAAKo+B,SAAUp+B,KAAKiE,Y,uBAG7D,SAAUq5B,GACR,OACEt9B,KAAKzD,OAAS+gC,EAAM/gC,MACpByD,KAAK3B,OAASi/B,EAAMj/B,MACpB2B,KAAKo+B,WAAad,EAAMc,UACxBp+B,KAAKiE,WAAaq5B,EAAMr5B,W,sBAI5B,WACE,gBAAUjE,KAAK3B,MAAf,OAAsB2B,KAAKo+B,SAAW,aAAe,IAArD,OACEp+B,KAAKiE,SAAL,sBAA+BjE,KAAKiE,UAAa,S,wzBC1CvD,I,cAAA,Q,m+CAuBaq6B,E,gEAwDX,WACE,OAAOC,OAAKC,O,uBAQd,SAAUlB,GAER,OAAOt9B,OAASs9B,K,qBAlElB,SAAchX,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKE,O,mBAEhC,SAAanY,GACX,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKG,M,qBAEhC,SAAepY,GACb,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKI,Q,sBAEhC,SAAgBrY,GACd,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKK,S,oBAEhC,SAActY,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKM,O,oBAEhC,SAAcvY,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKO,O,uBAEhC,SAAiBxY,GACf,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKQ,U,oBAEhC,SAAczY,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKz2B,O,oBAEhC,SAAcwe,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKS,O,yBAEhC,SAAmB1Y,GACjB,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKU,Y,wBAEhC,SAAkB3Y,GAChB,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKW,W,oBAEhC,SAAc5Y,GACZ,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKY,O,sBAEhC,SAAgB7Y,GACd,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKa,S,qBAEhC,SAAe9Y,GACb,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKc,Q,+BAEhC,SAAyB/Y,GACvB,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKe,kB,6BAEhC,SAAuBhZ,GACrB,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKgB,gB,mBAEhC,SAAajZ,GACX,OAAOA,GAAKA,EAAE+X,SAAWE,OAAK5sB,M,0BAEhC,SAAoB2U,GAClB,OAAOA,GAAKA,EAAE+X,SAAWE,OAAKiB,e,sBAoBrBf,E,kHACX,WACE,OAAOF,OAAKE,O,KAET1hC,OAAOC,Y,IAAZ,WACE,MAAO,S,sBAET,WACE,MAAO,W,GAReshC,G,aAcbQ,E,kHACX,WACE,OAAOP,OAAKO,O,KAKT/hC,OAAOC,Y,IAAZ,WACE,MAAO,S,sBAET,WACE,MAAO,W,GAXeshC,G,WA0CnBvhC,OAAOC,Y,IAzBD0hC,E,8BAGX,WAAYe,EAAUC,GAAU,2BAC9B,gBAD8B,6CAE9B,EAAKD,SAAWA,EAChB,EAAKC,SAAWA,EAHc,E,8BAKhC,WACE,OAAOnB,OAAKG,M,WAgBd,WACE,MAAO,Q,sBAET,WACE,gBAAU1+B,KAAKy/B,SAAW,IAAM,KAAhC,aAAyCz/B,KAAK0/B,c,GA7BzBpB,G,YAiCZqB,E,8BACX,aAAc,8BACN,EAAM,G,UAFUjB,G,aAKbkB,E,8BACX,aAAc,8BACN,EAAM,I,UAFWlB,G,cAKdmB,E,8BACX,aAAc,8BACN,EAAM,I,UAFWnB,G,cAKdoB,E,8BACX,aAAc,8BACN,EAAM,I,UAFWpB,G,cAKdqB,E,8BACX,aAAc,8BACN,EAAO,G,UAFUrB,G,cAKdsB,E,8BACX,aAAc,8BACN,EAAO,I,UAFWtB,G,eAKfuB,E,8BACX,aAAc,8BACN,EAAO,I,UAFWvB,G,eAKfwB,E,8BACX,aAAc,8BACN,EAAO,I,UAFWxB,G,WAQ5B,IAAMyB,EACE,GADFA,EAEI,GAFJA,EAGI,G,EAwBHpjC,OAAOC,Y,IArBD2hC,E,8BAEX,WAAYyB,GAAW,2BACrB,gBADqB,oBAErB,EAAKA,UAAYA,EAFI,E,8BAIvB,WACE,OAAO7B,OAAKI,Q,WAcd,WACE,MAAO,U,sBAET,WACE,qBAAe3+B,KAAKogC,e,GAzBG9B,G,cA6Bd+B,E,8BACX,aAAc,6BACNF,G,UAFmBxB,G,gBAKhB2B,E,8BACX,aAAc,6BACNH,G,UAFmBxB,G,gBAKhB4B,E,8BACX,aAAc,6BACNJ,G,UAFmBxB,G,gBAMhBC,E,8BACX,aAAc,8B,8BAGd,WACE,OAAOL,OAAKK,S,sBAEd,WACE,MAAO,W,KAEJ7hC,OAAOC,Y,IAAZ,WACE,MAAO,a,GAXiBshC,G,eAiBfO,E,kHACX,WACE,OAAON,OAAKM,O,KAKT9hC,OAAOC,Y,IAAZ,WACE,MAAO,S,sBAET,WACE,MAAO,W,GAXeshC,G,SAiB1B,IAAMkC,EAAW,CACfC,IAAK,EACLC,YAAa,G,EAeR3jC,OAAOC,Y,IAZD8K,E,8BAEX,WAAY64B,GAAM,2BAChB,gBADgB,eAEhB,EAAKA,KAAOA,EAFI,E,8BAIlB,WACE,OAAOpC,OAAKz2B,O,WAKd,WACE,MAAO,S,sBAET,WACE,oBAAgC,IAAjB9H,KAAK2gC,KAAO,GAA3B,YAAsCH,EAASxgC,KAAK2gC,MAApD,S,GAhBsBrC,G,aAoBbsC,E,8BACX,aAAc,6BACNJ,EAASC,K,UAFU34B,G,gBAKhB+4B,E,8BACX,aAAc,6BACNL,EAASE,a,UAFkB54B,G,oBAMrC,IAAMg5B,EAAW,CACfC,OAAQ,EACRL,YAAa,IACbM,YAAa,IACbC,WAAY,K,EAkBPlkC,OAAOC,Y,IAfDgiC,E,8BAIX,WAAY2B,EAAMjB,GAAU,2BAC1B,gBAD0B,yCAE1B,EAAKiB,KAAOA,EACZ,EAAKjB,SAAWA,EAHU,E,8BAK5B,WACE,OAAOnB,OAAKS,O,sBAEd,WACE,oBAAch/B,KAAK0/B,SAAnB,YAA+BoB,EAAS9gC,KAAK2gC,MAA7C,O,WAEF,WACE,MAAO,W,GAhBerC,G,aAuBb4C,E,8BACX,aAAc,6BACNJ,EAASC,OAAQ,I,UAFK/B,G,mBAKnBmC,E,8BACX,aAAc,6BACNL,EAASJ,YAAa,I,UAFK1B,G,sBAuB9BjiC,OAAOC,Y,IAfDiiC,E,8BAIX,WAAY0B,GAA4B,MAAjBS,EAAiB,uDAAN,KAAM,qBACtC,gBADsC,yCAEtC,EAAKT,KAAOA,EACZ,EAAKS,SAAWA,EAHsB,E,8BAKxC,WACE,OAAO7C,OAAKU,Y,WAKd,WACE,MAAO,c,sBAET,WACE,0BAAoB6B,EAAS9gC,KAAK2gC,OAAlC,OAA0C3gC,KAAKohC,SAAL,YAAqBphC,KAAKohC,UAAa,GAAjF,S,GAnB2B9C,G,kBAuBlB+C,E,8BACX,aAA6B,IAAjBD,EAAiB,uDAAN,KAAM,6BACrBN,EAASC,OAAQK,G,UAFUnC,G,wBAKxBqC,E,8BACX,aAA6B,IAAjBF,EAAiB,uDAAN,KAAM,6BACrBN,EAASJ,YAAaU,G,UAFUnC,G,6BAK7BsC,G,8BACX,aAA6B,IAAjBH,EAAiB,uDAAN,KAAM,6BACrBN,EAASE,YAAaI,G,UAFUnC,G,8BAK7BuC,G,8BACX,aAA6B,IAAjBJ,EAAiB,uDAAN,KAAM,6BACrBN,EAASG,WAAYG,G,UAFUnC,G,yBAMzC,IAAMwC,GAAe,CACnBC,SAAU,EACVC,WAAY,G,EAeP5kC,OAAOC,Y,IAZDkiC,G,8BAEX,WAAYyB,GAAc,2BACxB,gBADwB,eAExB,EAAKA,KAAOA,EAFY,E,8BAI1B,WACE,OAAOpC,OAAKW,W,WAKd,WACE,MAAO,a,sBAET,WACE,yBAAmBuC,GAAazhC,KAAK2gC,MAArC,S,GAhB0BrC,G,kBAoBjBsD,G,8BACX,aAAc,6BACNH,GAAaC,U,UAFcxC,I,yBAKxB2C,G,8BACX,aAAc,6BACNJ,GAAaE,Y,UAFgBzC,I,yBA2BhCniC,OAAOC,Y,IArBDuiC,G,8BAIX,WAAYuC,EAAkB9iB,GAAc,2BAC1C,gBAD0C,6CAE1C,EAAK8iB,SAAWA,EAChB,EAAK/iB,SAAW,CAACC,GAHyB,E,8BAK5C,WACE,OAAOuf,OAAKgB,gB,qBAEd,WACE,OAAOv/B,KAAK+e,SAAS,GAAG1gB,O,sBAE1B,WACE,OAAO2B,KAAK+e,SAAS,K,WAKvB,WACE,MAAO,kB,sBAET,WACE,8BAAwB/e,KAAK8hC,SAA7B,aAA0C9hC,KAAK+hC,UAA/C,S,GAzB+BzD,G,qDCravBC,E,iFAAAA,O,eAAAA,I,eAAAA,I,aAAAA,I,iBAAAA,I,mBAAAA,I,eAAAA,I,eAAAA,I,qBAAAA,I,eAAAA,I,eAAAA,I,0BAAAA,I,wBAAAA,I,gBAAAA,I,oBAAAA,I,kBAAAA,I,sCAAAA,I,kCAAAA,I,cAAAA,I,4BAAAA,I,gBAAAA,I,kBAAAA,I,kBAAAA,I,kBAAAA,I,kBAAAA,I,oBAAAA,I,oBAAAA,I,oBAAAA,I,uBAAAA,I,uBAAAA,I,uBAAAA,I,uBAAAA,I,uCAAAA,I,uCAAAA,I,iDAAAA,I,iDAAAA,I,+CAAAA,I,6BAAAA,I,uCAAAA,I,uCAAAA,I,qCAAAA,I,6BAAAA,I,+BAAAA,I,uCAAAA,I,4CAAAA,I,OAAAA,E,mCCoDZ,SAASyD,EAAoB/kC,GAC3B,OAAIA,aAAiB6K,KACZA,KACE7K,aAAiB2G,OACnB6N,aACmB,iBAAVxU,EACTwP,OAEF,K,qEAhDF,SAA2Bw1B,EAAOvoB,GACvC,IAAMwoB,EAAgBx4B,MAAMiQ,QAAQsoB,GA0BtC,SAAiCE,GAC/B,IAAMzoB,EAAS,GACf,GAAIyoB,EAASngC,OAAQ,CACnB,IAAM6X,EAAMsoB,EAAS,GAErB,IAAK,IAAMjnB,KAASrB,EAAK,CACvB,IAAM5c,EAAQ4c,EAAIqB,GAClBxB,EAAOwB,GAAS8mB,EAAoB/kC,IAGxC,OAAOyc,EAnCH0oB,CAAwBH,GAM9B,SAAsCI,GACpC,IAAM3oB,EAAS,GACf,IAAK,IAAMwB,KAASmnB,EAAe,CACjC,IAAM9mB,EAAS8mB,EAAcnnB,GAE7B,GAAI/U,YAAY8H,OAAOsN,GACrB7B,EAAOwB,GAASK,EAAOzK,iBAElB,GAAIyK,EAAOvZ,OAAQ,CACxB,IAAM/E,EAAQse,EAAO,GACrB7B,EAAOwB,GAAS8mB,EAAoB/kC,GAItCyc,EAAOwB,GAASxB,EAAOwB,IAAU,KAEnC,OAAOxB,EArBH4oB,CAA6BL,GAEjC,OAAOvlC,OAAOgJ,OAAOw8B,EAAexoB,K,4FCvC/B,SAAqB6oB,GAO1B,MAAO,CACLlE,OAAQkE,EAAclE,OACtBt8B,UAAWwgC,EAAcxgC,UACzBygC,SAAUD,EAAcE,WACxBC,aAAcC,EAAWJ,EAAclE,QACvC+B,UAAWmC,EAAcnC,YAnB7B,YAuBA,IAAIwC,EAA8C,KAElD,SAASD,EAAWE,GAClB,IAAKD,EAEH,IAAK,IAAMrlC,KADXqlC,EAAc,GACIrE,OAChBqE,EAAYrE,OAAKhhC,IAAQA,EAI7B,OAAOqlC,EAAYC,K,2GC9Bd,SAAoC7hC,GACzC,OAAQA,EAAM8P,aACZ,KAAKO,UACH,OAAO,IAAIsuB,OACb,KAAKn+B,WACH,OAAO,IAAIu+B,QACb,KAAKzuB,WACH,OAAO,IAAIsuB,QACb,KAAKruB,YACH,OAAO,IAAIyuB,SACb,KAAK1M,WACH,OAAO,IAAIuM,QACb,KAAKruB,YACH,OAAO,IAAIyuB,SACb,KAAKxuB,aACH,OAAO,IAAI6uB,UACb,KAAK5uB,aACH,OAAO,IAAI6uB,UACb,QACE,MAAM,IAAIriC,MAAM,8BArBtB,a,+7ECEM4kC,E,8eACJ,SAAQ7lC,GAEN,OAAO+C,KAAKwC,KAAKvF,K,qBAEnB,WAEE,OAAO+C,KAAKiW,Y,KAPYvM,Q,EA+BzB3M,OAAOma,c,IApBWC,E,WAKnB,aAAc,uFAEZnX,KAAKoX,QAAU,IAAI0rB,EAEnB9iC,KAAKqX,UAAY,IAAIyrB,EACrB9iC,KAAKsX,SAAU,E,+BAGjB,WACE,KAAOtX,KAAKqX,UAAUrV,OAAS,GAC7BhC,KAAKqX,UAAU0rB,UAAU7vB,QAAQ,CAACwC,MAAM,IAE1C1V,KAAKsX,SAAU,I,aAGjB,WACE,OAAOtX,O,qBAGT,SAAQ/C,GACN,GAAI+C,KAAKsX,QACP,MAAM,IAAIpZ,MAAM,UAGlB,GAAI8B,KAAKqX,UAAUrV,OAAS,EAAG,CAC7B,GAAIhC,KAAKoX,QAAQpV,OAAS,EACxB,MAAM,IAAI9D,MAAM,0BAElB,IAAMsZ,EAAUxX,KAAKqX,UAAU0rB,UAC3B9lC,aAAiBiB,MACnBsZ,EAAQrE,OAAOlW,GAEfua,EAAQtE,QAAQ,CAACjW,eAGnB+C,KAAKoX,QAAQG,QAAQta,K,kBAOzB,WAAqB,WACnB,GAAI+C,KAAKoX,QAAQpV,OAAS,EAAG,CAC3B,IAAM/E,EAAQ+C,KAAKoX,QAAQ2rB,UAC3B,OAAI9lC,aAAiBiB,MACZ+U,QAAQE,OAAOlW,GAEjBgW,QAAQC,QAAQ,CAACjW,UAG1B,GAAI+C,KAAKsX,QAAS,CAChB,GAAItX,KAAKqX,UAAUrV,OAAS,EAC1B,MAAM,IAAI9D,MAAM,0BAElB,OAAO+U,QAAQC,QAAQ,CAACwC,MAAM,IAGhC,OAAO,IAAIzC,SAAQ,SAACC,EAASC,GAC3B,EAAKkE,UAAUE,QAAQ,CAACrE,UAASC,kB,sDAQhC,WACL6vB,GADK,0GAELl+B,EAFK,+BAEG43B,IAEF91B,EAAqB,GACrBqlB,EAAW+W,EAAcjmC,OAAOma,iBALjC,YAMEtQ,EAAO5E,OAAS8C,GANlB,iCAOyBmnB,EAASE,OAPlC,mBAOIlvB,EAPJ,EAOIA,OAPJ,EAOWyY,KAPX,qDAWH9O,EAAOpE,KAAKvF,GAXT,gDAaE2J,GAbF,6C,4IClFA,SACLxD,EACAyxB,EACAxxB,GAEA,IAAM4/B,EAAcC,EAAarO,EAAW5wB,UACtCk5B,EAAkB,GAClBgG,EAiBR,SAAuCtO,GAGrC,IAAMjuB,EAAoD,GAC1D,IAAK,IAAMrJ,KAAOs3B,EAAY,CAC5B,IAAMe,EAAiBf,EAAWt3B,GAClCqJ,EAAOgvB,EAAer5B,MAAQ,aAAeq5B,EAE/C,OAAOhvB,EAzB2Bw8B,CAA8BvO,EAAWzxB,YAC3E,IAAK,IAAM8D,KAAiB9D,EAAY,CACtC,IAAMoc,EAAYpc,EAAW8D,GACvBgU,EAAQmoB,EACZn8B,EACAsY,EACA2jB,EAA0Bj8B,IAE5Bi2B,EAAO36B,KAAK0Y,GAEd,GAAI7X,EAAS,CACX,IAAMigC,EAAeD,EAA2B,UAAWhgC,GAC3D85B,EAAO36B,KAAK8gC,GAEd,OAAO,IAAIpG,SAAOC,EAAQ8F,IAzB5B,YAuCA,SAASI,EACPn8B,EACAsY,EACAqV,GAEA,IAAMoO,EAAcpO,EAAaqO,EAAarO,EAAW5wB,eAAYwM,EAC/DpS,GAAO,IAAAklC,4BAA2B/jB,EAAUviB,OAClD,OAAO,IAAIkhC,QACTj3B,EACA,IAAIq4B,gBAAc/f,EAAU3a,KAAM,IAAIs5B,QAAM,QAAS9/B,KACrD,EACA4kC,GAIJ,SAASC,EAAaj/B,GACpB,IAAMg/B,EAAc,IAAItxB,IACxB,IAAK,IAAMpU,KAAO0G,EAChBg/B,EAAY5tB,IAAZ,UAAmB9X,EAAnB,WAAiC0kB,KAAKO,UAAUve,EAAS1G,KAG3D,OAAO0lC,I,mGCzDT,I,EAAA,G,EAAA,S,2BACA,Q,4TAKA,IAcavR,EAAsB,CACjCn1B,KAAM,QACN4R,GAAI,QACJpS,OAAQ,QACR4D,QAtBF,MAsBWyO,QACT3N,WAAY,CAAC,OACbuX,O,4CACA3J,QAAS,CACP4N,MAtB0B,CAC5BunB,YAAY,EACZ9Q,mBAAoB,U,iDAwBtB,WACE7wB,GADF,+GAEEwM,EAFF,+BAE0C,GAF1C,UAKwB,IAAAo1B,wBAAuBp1B,GAL/C,uBAKS4N,EALT,EAKSA,MACDynB,EAAe,IAAIC,UAAa1nB,GANxC,2BASWynB,EAAa9R,WAAW/vB,EAAMwM,EAAQ4N,QATjD,uBAWIynB,EAAazuB,UAXjB,0E,y/ECNA,IAAM2uB,EAAmC,CACvChR,SAAU,WACVC,OAAQ,SACRgR,QAAS,QACTC,WAAY,aAGRv6B,EAAO,aAEQw6B,E,WAQnB,WAAY9nB,I,4FAAgB,2JAC1Bjc,KAAKic,MAAQA,EACbjc,KAAKgkC,aAAe,IAAIhkC,KAAKic,MAAMgoB,QACnCjkC,KAAKkkC,iBAAmB,IAAIlkC,KAAKic,MAAMkoB,YACvCnkC,KAAKokC,qBAAuB,IAAIpkC,KAAKic,MAAMooB,gB,8CAG7C,WACErkC,KAAKskC,qBAAqBtkC,KAAKkkC,kBAC/BlkC,KAAKskC,qBAAqBtkC,KAAKgkC,cAC/BhkC,KAAKskC,qBAAqBtkC,KAAKokC,sBAE/BpkC,KAAKkkC,iBAAmB,KAExBlkC,KAAKgkC,aAAe,KAEpBhkC,KAAKic,MAAQ,O,kCAIf,SAAqBve,GACfA,GACFsC,KAAKic,MAAMhH,QAAQvX,K,wBASvB,SAAWyF,GAAmE,IAA9CkL,EAA8C,uDAAjB,GAI3D,OAHArO,KAAKiP,IAAM1F,EACXvJ,KAAKukC,YAAYl2B,GAEVA,EAAQm1B,WACXxjC,KAAKwkC,kBAAkBrhC,EAAMkL,GAC7BrO,KAAKykC,YAAYthC,EAAMkL,K,oCAK7B,SAAuBlL,GAErB,IAAMC,EAAa,EAAH,KAAOD,GAASA,EAAKC,YAKrC,OAHID,EAAKE,UACPD,EAAWC,QAAUF,EAAKE,SAErBD,I,+BAGT,SAAkBogC,EAA2Bn1B,GAC3C,IAAMq2B,EAAkB,IAAI1kC,KAAKic,MAAMoY,WAEnChmB,EAAQpK,UACVjE,KAAK2kC,qBAAqBD,EAAiBr2B,EAAQpK,UAGrD,IAAMb,EAAapD,KAAK4kC,uBAAuBpB,GAG/CxjC,KAAK6kC,uBAAuBH,EAAiBthC,EAAYiL,GAEzD,IAAMy2B,EAAY,IAAI9kC,KAAKic,MAAM8oB,eAEjC,IACE,IAAMC,EAAahlC,KAAKgkC,aAAaiB,8BACnCP,GACA,EACAI,GAGF,KAAME,EAAa,GACjB,MAAM,IAAI9mC,MAAM,0BAMlB,OAHA8B,KAAKiP,IAAL,wBAA0By1B,EAAgBrP,aAA1C,iCACSqP,EAAgBlP,iBADzB,4BAC6DwP,EAD7D,WAGOE,EAA4BJ,GAdrC,QAgBE9kC,KAAKskC,qBAAqBQ,GAC1B9kC,KAAKskC,qBAAqBI,M,yBAI9B,SAAYvhC,EAAqBkL,GAC/B,IAAM82B,EAAY,IAAInlC,KAAKic,MAAMmY,KAE7B/lB,EAAQpK,UACVjE,KAAK2kC,qBAAqBQ,EAAW92B,EAAQpK,UAG/C,IAAMb,EAAapD,KAAK4kC,uBAAuBzhC,GAG/CnD,KAAKolC,iBAAiBD,EAAW/hC,EAAYiL,GAE7C,IAAMy2B,EAAY,IAAI9kC,KAAKic,MAAM8oB,eAEjC,IACE,IAAMC,EAAahlC,KAAKgkC,aAAaqB,wBAAwBF,EAAWL,GACxE,GAAIE,GAAc,EAChB,MAAM,IAAI9mC,MAAM,0BAMlB,OAHA8B,KAAKiP,IAAL,wBAA0Bk2B,EAAU9P,aAApC,iCACS8P,EAAU3P,iBADnB,4BACuDwP,EADvD,WAGOE,EAA4BJ,GATrC,QAWE9kC,KAAKskC,qBAAqBQ,GAC1B9kC,KAAKskC,qBAAqBa,M,yBAQ9B,SAAY92B,GACc,MAIxB,GAJI,UAAWA,IAEb,EAAArO,KAAKgkC,cAAasB,gBAAlB,UAAqCj3B,EAAQk3B,QAE3C,WAAYl3B,EAAS,CACvB,IAAMm3B,EAAcxlC,KAAKic,MAAM5N,EAAQo3B,QAAU,4BAEjDzlC,KAAKgkC,aAAa0B,kBAAkBF,GAEtC,GAAI,iBAAkBn3B,EACpB,IAAK,IAAMmR,KAAanR,EAAQkoB,aAAc,CAC5C,IAAMoP,EAAOt3B,EAAQkoB,aAAa/W,GAC5BomB,EAAgB5lC,KAAKic,MAAMuD,GACjCxf,KAAKgkC,aAAa6B,yBAAyBD,EAAeD,M,8BAUhE,SAAiBR,EAAiB/hC,EAAYiL,GAC5C,IAAMy3B,EAAmBz3B,EAAQ03B,oBAAsB,GAEvD,IACE,IAAM/I,EAAYh9B,KAAKgmC,sBAAsB5iC,GAC7C,IAAK45B,EACH,MAAM,IAAI9+B,MAAM,aAElB,IAAMk3B,EAAc4H,EAAUh7B,OAAS,EAEvC,IAAK,IAAIkF,KAAiB9D,EAAY,CACpC,IAAMoc,EAAYpc,EAAW8D,GAC7BA,EAAgB08B,EAAiC18B,IAAkBA,EACnE,IAAM8xB,EAAWh5B,KAAKimC,oBAAoBd,EAAWj+B,EAAesY,EAAW4V,IAE7D,IAAd4D,GACFh5B,KAAKkmC,sBAAsBf,EAAWnM,EAAtC,GACEz8B,KAAM2K,GACF4+B,EAAiB5+B,IAAkB,MAI7C,MAAO6H,GAEP,MADA/O,KAAKskC,qBAAqBa,GACpBp2B,EAGR,OAAOo2B,I,oCAOT,SACET,EACAthC,EACAiL,GAEA,IAAMy3B,EAAmBz3B,EAAQ03B,oBAAsB,GAEvD,IACE,IAAM/I,EAAYh9B,KAAKgmC,sBAAsB5iC,GAC7C,IAAK45B,EACH,MAAM,IAAI9+B,MAAM,aAElB,IAAMk3B,EAAc4H,EAAUh7B,OAAS,EAEvC,IAAK,IAAIkF,KAAiB9D,EAAY,CACpC,IAAMoc,EAAYpc,EAAW8D,GAC7BA,EAAgB08B,EAAiC18B,IAAkBA,EACnE,IAAM8xB,EAAWh5B,KAAKimC,oBACpBvB,EACAx9B,EACAsY,EACA4V,IAEgB,IAAd4D,GACFh5B,KAAKkmC,sBAAsBxB,EAAiB1L,EAA5C,GACEz8B,KAAM2K,GACF4+B,EAAiB5+B,IAAkB,MAI7C,MAAO6H,GAEP,MADA/O,KAAKskC,qBAAqBI,GACpB31B,EAGR,OAAO21B,I,iCAST,SACEvhC,EACA+D,EACAsY,EACA4V,GAEA,IAAKjvB,YAAY8H,OAAOuR,GACtB,OAAQ,EAGV,IAAMnhB,EAAO2B,KAAKmmC,uBAAuBj/B,GAEnCrC,EAAO2a,EAAUxd,OAASozB,EAEhC,GAAa,YAAT/2B,EAAoB,CAEtB,IAAM+nC,EAAW5mB,EAAUxd,OAAS,EAKpC,OAJAhC,KAAKiP,IAAL,2BAA6B/H,EAA7B,kBAAoDk/B,IAGpDpmC,KAAKkkC,iBAAiBmC,eAAeljC,EAAMijC,EAAU5mB,IAC7C,EAGVxf,KAAKiP,IAAL,2BAA6B/H,EAA7B,kBAAoDrC,IAEpD,IAAMyhC,EAAUtmC,KAAKkkC,iBACd9iC,EAAUoe,EAAVpe,OAEP,OAAQoe,EAAU1O,aAChB,KAAKO,UACH,OAAOi1B,EAAQC,iBAAiBpjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAIwM,UAAUjQ,IAE/E,KAAKkQ,WACH,OAAOg1B,EAAQE,kBAAkBrjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAIyM,WAAWlQ,IAEjF,KAAKkyB,WACH,OAAOgT,EAAQG,kBAAkBtjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAIyuB,WAAWlyB,IACjF,KAAKI,WACL,KAAKklB,kBACH,OAAO4f,EAAQI,kBAAkBvjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAIrD,WAAWJ,IAEjF,KAAKmQ,YACH,OAAO+0B,EAAQK,mBAAmBxjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAI0M,YAAYnQ,IAEnF,KAAKoQ,YACH,OAAO80B,EAAQM,mBAAmBzjC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAI2M,YAAYpQ,IAEnF,KAAKqQ,aACL,QACE,OAAO60B,EAAQO,kBAAkB1jC,EAAM9E,EAAM+2B,EAAavwB,EAAM,IAAI4M,aAAarQ,O,oCASvF,SAAuB8F,GACrB,OAAQA,EAAcC,eACpB,IAAK,UACH,MAAO,UACT,IAAK,WACL,IAAK,YACL,IAAK,WACH,OAAOnH,KAAKic,MAAM2W,SACpB,IAAK,SACL,IAAK,UACH,OAAO5yB,KAAKic,MAAM4W,OACpB,IAAK,QACL,IAAK,SACH,OAAO7yB,KAAKic,MAAM6W,MACpB,IAAK,WACL,IAAK,YACH,OAAO9yB,KAAKic,MAAM8W,UACpB,QACE,OAAO/yB,KAAKic,MAAM6qB,W,mCAIxB,SAAsB1jC,GACpB,IAAK,IAAM8D,KAAiB9D,EAAY,CACtC,IAAMoc,EAAYpc,EAAW8D,GAE7B,GADkBlH,KAAKmmC,uBAAuBj/B,KAC5BlH,KAAKic,MAAM2W,SAC3B,OAAOpT,EAGX,OAAO,O,kCAQT,SAAqB0U,EAA2BjwB,GAC9C,IAAMm1B,EAAgB,IAAIp5B,KAAKic,MAAM8qB,SACrC/mC,KAAKgnC,uBAAuB5N,EAAen1B,GAC3CjE,KAAKkkC,iBAAiB+C,YAAY/S,EAAekF,K,mCASnD,SACElF,EACAgT,EACAjjC,GAIA,IAAMkjC,EAAyB,IAAInnC,KAAKic,MAAM8qB,SAC9C/mC,KAAKgnC,uBAAuBG,EAAwBljC,GAGpDjE,KAAKkkC,iBAAiBkD,wBACpBlT,EACAgT,EACAC,K,oCASJ,SACE/N,EACAn1B,GACA,MAwCgBojC,EAxChB,E,goBAAA,EAwCgBA,EAvCsBpjC,GAwCPoX,UAAYgsB,EAAUxpC,eAAe,WAC9CwpC,EAAUhsB,UAAY3e,OAAO2e,QAAQgsB,IA1C3D,IACA,2BAAiD,oBAArC9pC,EAAqC,KAAhCN,EAAgC,KAC/C,SAAeA,IACb,IAAK,SACCsI,KAAK+hC,MAAMrqC,KAAWA,EACxB+C,KAAKokC,qBAAqBmD,YAAYnO,EAAe77B,EAAKN,GAE1D+C,KAAKokC,qBAAqBoD,eAAepO,EAAe77B,EAAKN,GAE/D,MACF,IAAK,SACCA,aAAiBq2B,YACnBtzB,KAAKokC,qBAAqBqD,iBAAiBrO,EAAe77B,EAAKN,EAAOA,EAAM+E,QAE9E,MACF,IAAK,SACL,QACEhC,KAAKokC,qBAAqBsD,eAAetO,EAAe77B,EAAKN,KAjBnE,oC,gCA6BJ,SAASioC,EAA4BJ,GAInC,IAHA,IAAM3kC,EAAa2kC,EAAUjgC,OACvB8iC,EAAe,IAAIxhC,YAAYhG,GAC/BynC,EAAa,IAAIv2B,UAAUs2B,GACxB3rC,EAAI,EAAGA,EAAImE,IAAcnE,EAChC4rC,EAAW5rC,GAAK8oC,EAAU/M,SAAS/7B,GAErC,OAAO2rC,E,8GChbF,SAA0BvkC,GAC/B,IAAM6B,EAAY,GAClB,IAAK,IAAM1I,KAAQ6G,EAAY,CAC7B,IAAMoc,EAAYpc,EAAW7G,GAC7B,GAAa,YAATA,EAAoB,CACtB,IAAMoI,EAAe6sB,EAAgBhS,GACrCva,EAAU1I,GAAQoI,GAGtB,OAAOM,G,oBAdT,YAoBO,SAASusB,EAAgBhS,GAC9B,MAwBF,SAAyBA,GACvB,IAAIpe,EAASoe,EACT3a,EAAO,EACPC,EAAQ,EAER0a,GAAaA,EAAUviB,QACzBmE,EAASoe,EAAUviB,MACnB4H,EAAO2a,EAAU3a,MAAQ,GAGvBzD,IACG+E,YAAY8H,OAAO7M,KACtBA,EASN,SAAsBJ,EAAOe,GAAuC,IAA5B8lC,EAA4B,wDAClE,IAAK7mC,EACH,OAAO,KAET,GAAI0I,MAAMiQ,QAAQ3Y,GAChB,OAAO,IAAIe,EAAUf,GAEvB,GAAI6mC,KAAwB7mC,aAAiBe,GAC3C,OAAO,IAAIA,EAAUf,GAEvB,OAAOA,EAnBM8mC,CAAa1mC,EAAQqQ,eAEhC3M,EAAQ1D,EAAOY,OAAS6C,GAG1B,MAAO,CAACzD,SAAQyD,OAAMC,SAzCQijC,CAAgBvoB,GAAvCpe,EAAP,EAAOA,OAAQyD,EAAf,EAAeA,KAiBf,MAfmC,CAMjC5H,MAAOmE,EACPyD,OAEAtD,WAAY,EACZuD,MAZF,EAAqBA,MAanBzG,MAAM,IAAAuG,yBAAwBC,GAC9B1G,eAAe,IAAAmH,2BAA0BlE,M,4ICXtC,SAAgBivB,GACrB,IAAM2X,EAAiB,IAAIloC,UAAeuwB,GACnCpwB,EAAQ+nC,EAAR/nC,KAKP,GAAI+nC,EAAe/hC,UAAW,WACLhG,EAAKgG,WAAa,IADb,IAC5B,2BAA6C,KAAlC3C,EAAkC,QAEvCA,EAAS2kC,eAEJ3kC,EAAS2kC,MAChBD,EAAeE,mBAAmB5kC,EAAU6kC,sBAAqB,IACjEH,EAAe3lC,aAAa8lC,yBAPJ,iCA7BhC,I,EAAA,G,EAAA,O,2BACA,O,i4CAEO,WAAsB9X,GAAtB,8FACC2X,EAAiB,IAAIloC,UAAeuwB,GACnCpwB,EAAQ+nC,EAAR/nC,KAGP+nC,EAAelX,gBAAgBqX,uBAL1B,IASkBloC,EAAKgG,WAAa,IATpC,IASL,2BAAW3C,EAAkC,QACzBA,EAAS7C,YAAc6C,EAAS7C,WAAWuvB,sBAG3D1sB,EAAS2kC,OAAQ,GAEnBD,EAAeI,sBAAsB9kC,EAAU6kC,uBAf5C,0E,gNCHP,I,EAAA,OACA,G,EAAA,O,2BACA,O,i4CAEO,WAAsB9X,GAAtB,kGACC2X,EAAiB,IAAIloC,UAAeuwB,GACnCpwB,EAAQ+nC,EAAR/nC,MAGDkC,EAAY6lC,EAAernC,aAAa0nC,0BAG5CL,EAAe/nC,KAAKqoC,OAASnmC,EAAUmmC,OACvCN,EAAelX,gBAAgBuX,wBAT5B,IAccpoC,EAAK6C,OAAS,IAd5B,IAcL,2BAAWC,EAA0B,SAC7BwlC,EAAgBP,EAAepX,mBAAmB7tB,EAAMslC,0BAG5DtlC,EAAKylC,MAAQD,EAAcC,OAE7BR,EAAeI,sBAAsBrlC,EAAMslC,uBApBxC,0E,uEAyBA,WAAsBhY,GAAtB,kGAkBL,GAjBM2X,EAAiB,IAAIloC,UAAeuwB,IACnCpwB,EAAQ+nC,EAAR/nC,MAGEqoC,SACDnmC,EAAY6lC,EAAe3lC,aAAagmC,wBAE9C,IAAA/mC,SAAQa,EAAUmmC,QAElBnmC,EAAUmmC,OAASroC,EAAKqoC,cAEjBroC,EAAKqoC,QAMVN,EAAe/nC,KAAKqoC,OAAQ,KAEVN,EAAe/nC,KAAKqoC,QAFV,IAE9B,2BAAWE,EAAqC,QACxCzlC,EAAOylC,EAAMzlC,KACnBilC,EAAeE,mBAAmBnlC,EAAMslC,sBAAqBG,GAJjC,qCAOvBR,EAAe/nC,KAAKqoC,OAzBxB,4C,kNC7BP,I,EAAA,G,EAAA,O,2BACA,O,smDAEO,WAAsBjY,GAAtB,oGAKL,GAJM2X,EAAiB,IAAIloC,UAAeuwB,GACnCpwB,EAAQ+nC,EAAR/nC,KAEDkC,EAAY6lC,EAAernC,aAAa8nC,wBAC/B,CACPC,EAAaC,EAAkBxmC,EAAW6lC,GADnC,IAGU/nC,EAAKgG,WAAa,IAH5B,IAGb,2BAAW3C,EAAkC,SACrCslC,EAAoBZ,EAAepX,mBAAmBttB,EAAUmlC,2BAGpEnlC,EAASulC,UAAYnsC,OAAOgJ,OAC1B,GACAkjC,EAEAF,EAAWE,EAAkBC,YAG/BvlC,EAASulC,UAAU7zB,OAAS8zB,EAAcxlC,EAASulC,UAAWb,IAEhEA,EAAeI,sBAAsB9kC,EAAUmlC,wBAhBpC,8BAmBbT,EAAelX,gBAAgB2X,wBAxB5B,4C,uEA4BA,WAAsBpY,EAAUhiB,GAAhC,qH,sBAIP,SAASs6B,EACPI,EAIAf,GAEA,MAAuDe,EAAhDC,gBAAP,MAAkB,GAAlB,IAAuDD,EAAjCE,eAAtB,MAAgC,GAAhC,IAAuDF,EAAnBL,kBAApC,MAAiD,GAAjD,EACMpgB,EAAc,IAAI9U,YAsBxB,OApBAy1B,EAAQ1zB,SAAQ,SAAC2zB,GACf,IAAItlC,OAAOC,SAASqlC,EAAOjoC,YAMzB,MAAM,IAAI/C,MAAM,wCALhBgrC,EAAOC,KAAO7gB,EAAYtV,OACxBg1B,EAAejjB,2BAA2BmkB,EAAOjoC,gBAQvD+nC,EAASzzB,SAAQ,SAAC6zB,GAChBA,EAAQC,eAAiBJ,EAAQG,EAAQC,gBACzCD,EAAQE,aAAeL,EAAQG,EAAQE,iBAGzCZ,EAAWnzB,SAAQ,SAACszB,GAClBA,EAAUO,QAAUJ,EAASH,EAAUO,YAGlCV,EAGT,SAASI,EAAcD,EAAWb,GAChC,IAAMhzB,EAAStY,OAAOgJ,OAAO,GAAImjC,EAAU7zB,QAkB3C,OAfAtY,OAAOq1B,KAAK8W,EAAUU,UAAY,IAAIh0B,SAAQ,SAACi0B,GACzCX,EAAUU,SAASC,GAASvsC,SAAWusC,KAAWx0B,KACpDA,EAAOw0B,GAAWX,EAAUU,SAASC,GAASvsC,UAKlDP,OAAOq1B,KAAK/c,GAAQO,SAAQ,SAACi0B,GACI,WAA3B,EAAOx0B,EAAOw0B,UAAmD/4B,IAA1BuE,EAAOw0B,GAAS1oC,QAGzDkU,EAAOw0B,GAAS7jC,QAAUqiC,EAAeroB,WAAW3K,EAAOw0B,GAAS1oC,WAIjEkU,I,qUCsNF,SAAyBjV,GAAoB,IAAdsO,EAAc,uDAAJ,GAC9C,OAAO,IAAIo7B,GAAmBnmB,UAAUvjB,EAAMsO,IAlThD,M,ybAAA,S,yzCA+CA,IAAMq7B,EAAc,CAClBzkC,UAAW,WACX0kC,WAAY,YACZ9pC,QAAS,SACT4E,YAAa,aACbH,OAAQ,QACR2B,UAAW,WACXnC,OAAQ,OACRhB,MAAO,OACPkb,SAAU,UACVnb,OAAQ,QACR2b,MAAO,OACPzY,SAAU,WAGN6jC,EAAY,CAChBloC,SAAU,YACVioC,WAAY,YACZvoC,OAAQ,UACRH,WAAY,cACZgB,MAAO,SACPqB,SAAU,YACVH,KAAM,SACNJ,KAAM,QACNkb,QAAS,WACTtb,MAAO,SACP8b,KAAM,QACN9Y,QAAS,YAML8jC,E,WACJ,WAAY1pC,I,4FAAM,SAChBC,KAAK6pC,aAAe,CAClBF,WAAY,GACZ1kC,UAAW,GACXpF,QAAS,GACT4E,YAAa,GACbH,OAAQ,GACR2B,UAAW,GACXnC,OAAQ,GACRhB,MAAO,GACPkb,SAAU,GACVnb,OAAQ,GACR2b,MAAO,GACPzY,SAAU,I,gDAUd,SAAUhG,EAAMsO,GACdrO,KAAKC,KAAOF,EAAKE,KACjB,IAAMA,EAAOF,EAAKE,KAGlB,OAAQA,EAAKP,OAASO,EAAKP,MAAMC,SAE/B,IAAK,MACH,OAGF,UAAK8Q,EACL,IAAK,MACH,MAEF,QAGE,YADAzB,QAAQ6P,KAAR,gCAAsC5e,EAAKP,MAAMC,UAIrD,IAAK0O,EAAQiV,UAEX,MAAM,IAAIplB,MAAM,6BAIlB8Q,QAAQ6P,KAAK,4EAEb7e,KAAK8pC,UAAU7pC,GAGfD,KAAK+pC,gCAAgC9pC,GAIrC+pC,EAAgBh3B,OAAOjT,GAGvBC,KAAKiqC,gCAAgChqC,GAErCD,KAAKkqC,eAAejqC,GAEpBD,KAAKmqC,gBAAgBlqC,K,uBAIvB,SAAUA,GACRA,EAAKP,MAAQO,EAAKP,OAAS,GAE3BO,EAAKP,MAAMC,QAAU,MACrBM,EAAKP,MAAME,UAAYK,EAAKP,MAAME,WAAa,yC,6CAGjD,SAAgCK,GAE9B,IAAK,IAAMmqC,KAAaV,EACtB1pC,KAAKqqC,8BAA8BpqC,EAAMmqC,K,2CAK7C,SAA8BnqC,EAAMqqC,GAClC,IAAMC,EAAYtqC,EAAKqqC,GACvB,GAAKC,IAAa7gC,MAAMiQ,QAAQ4wB,GAOhC,IAAK,IAAMp8B,KAFXlO,EAAKqqC,GAAW,GAECC,EAAW,CAC1B,IAAM7sC,EAAS6sC,EAAUp8B,GACzBzQ,EAAOyQ,GAAKzQ,EAAOyQ,IAAMA,EACzB,IAAMrN,EAAQb,EAAKqqC,GAAStoC,OAC5B/B,EAAKqqC,GAAS9nC,KAAK9E,GACnBsC,KAAK6pC,aAAaS,GAASn8B,GAAMrN,K,6CAKrC,SAAgCb,GAC9B,IAAK,IAAMmqC,KAAaV,EACtB1pC,KAAKwqC,qBAAqBvqC,EAAMmqC,GAE9B,UAAWnqC,IACbA,EAAK0C,MAAQ3C,KAAKyqC,kBAAkBxqC,EAAK0C,MAAO,UALd,UAWd1C,EAAK8F,UAXS,IAWpC,2BAAqC,KAA1BJ,EAA0B,QACnC3F,KAAK0qC,mBAAmB/kC,IAZU,wCAcjB1F,EAAK6D,QAdY,IAcpC,2BAAgC,KAArBX,EAAqB,QAC9BnD,KAAK2qC,gBAAgBxnC,IAfa,wCAiBjBlD,EAAK6C,OAjBY,IAiBpC,2BAA+B,KAApBC,EAAoB,QAC7B/C,KAAK4qC,gBAAgB7nC,IAlBa,wCAoBjB9C,EAAK4C,QApBY,IAoBpC,2BAAgC,KAArBE,EAAqB,QAC9B/C,KAAK6qC,iBAAiB9nC,IArBY,iC,gCAyBtC,SAAmB4C,GACbA,EAAQE,SACVF,EAAQE,OAAS7F,KAAKyqC,kBAAkB9kC,EAAQE,OAAQ,Y,6BAI5D,SAAgB1C,GAAM,UACIA,EAAKK,YADT,IACpB,2BAAyC,KAA9B+b,EAA8B,QAChCnc,EAAiCmc,EAAjCnc,WAAYC,EAAqBkc,EAArBlc,QAASC,EAAYic,EAAZjc,SAC5B,IAAK,IAAM4D,KAAiB9D,EAC1BA,EAAW8D,GAAiBlH,KAAKyqC,kBAAkBrnC,EAAW8D,GAAgB,YAE5E7D,IACFkc,EAAUlc,QAAUrD,KAAKyqC,kBAAkBpnC,EAAS,aAElDC,IACFic,EAAUjc,SAAWtD,KAAKyqC,kBAAkBnnC,EAAU,cAVtC,iC,6BAetB,SAAgBP,GAAM,WAChBA,EAAKgc,WACPhc,EAAKgc,SAAWhc,EAAKgc,SAASvG,KAAI,SAACwG,GAAD,OAAW,EAAKyrB,kBAAkBzrB,EAAO,YAEzEjc,EAAKe,SACPf,EAAKe,OAASf,EAAKe,OAAO0U,KAAI,SAACrV,GAAD,OAAU,EAAKsnC,kBAAkBtnC,EAAM,c,8BAIzE,SAAiBR,GAAO,WAClBA,EAAMG,QACRH,EAAMG,MAAQH,EAAMG,MAAM0V,KAAI,SAACzV,GAAD,OAAU,EAAK0nC,kBAAkB1nC,EAAM,c,kCAKzE,SAAqB9C,EAAM6qC,GACpB7qC,EAAK6qC,KACR97B,QAAQ6P,KAAR,kDAAwDisB,IACxD7qC,EAAK6qC,GAAqB,IAHgB,UAKvB7qC,EAAK6qC,IALkB,IAK5C,2BAA8C,KAAnCptC,EAAmC,QAC5C,IAAK,IAAMH,KAAOG,EAAQ,CACxB,IAAMyQ,EAAKzQ,EAAOH,GACZuD,EAAQd,KAAKyqC,kBAAkBt8B,EAAI5Q,GACzCG,EAAOH,GAAOuD,IAT0B,iC,+BAc9C,SAAkBqN,EAAI5Q,GACpB,IAAM6sC,EAAYR,EAAUrsC,GAC5B,GAAI6sC,KAAapqC,KAAK6pC,aAAc,CAClC,IAAM/oC,EAAQd,KAAK6pC,aAAaO,GAAWj8B,GAC3C,IAAKvK,OAAOC,SAAS/C,GACnB,MAAM,IAAI5C,MAAJ,qCAAwCX,EAAxC,oBAAuD4Q,IAE/D,OAAOrN,EAET,OAAOqN,I,4BAOT,SAAelO,GAAM,UACED,KAAKC,KAAKJ,SADZ,IACnB,kCAAwC,QAExBxB,KAHG,iC,6BAWrB,SAAgB4B,GAAM,UACGA,EAAKgG,WADR,yBACT3C,EADS,QAElBA,EAAS2c,qBAAuB,CAC9B8qB,gBAAiB,CAAC,EAAG,EAAG,EAAG,GAC3BC,eAAgB,EAChBC,gBAAiB,GAGnB,IAAMC,EAAY5nC,EAAS0R,QAAU1R,EAAS0R,OAAOm2B,IAC/CC,EAAenrC,EAAK8F,SAASslC,WAAU,SAAC1lC,GAAD,OAAaA,EAAQwI,KAAO+8B,MACnD,IAAlBE,IACF9nC,EAAS2c,qBAAqBE,iBAAmB,CAACrf,MAAOsqC,KAV7D,2BAAuC,IADnB,oC,wHCzRjB,SAAgB/a,GACrB,IADmD,EAC7C2X,EAAiB,IAAIloC,UAAeuwB,GACnCpwB,EAAQ+nC,EAAR/nC,KAF4C,E,w6BAAA,CAShCA,EAAKqE,QAAU,IATiB,IASnD,2BAAsC,KAA3BvB,EAA2B,QAC9BZ,EAAY6lC,EAAeI,sBAAsBrlC,EAAMuoC,mBAEzDnpC,GACFzF,OAAOgJ,OAAO3C,EAAMZ,IAb2B,8BAqB/ClC,EAAKJ,SAAWI,EAAKJ,QAAQ,WACxBI,EAAKJ,QAAQ,GAAG0kB,IAIzByjB,EAAelX,gBAAgBwa,oB,SAI1B,WACL,MAAM,IAAIptC,MAAMotC,oBAlClB,I,EAAA,G,EAAA,O,2BACA,O,oOCLA,WACA,SAUaC,EAAa,CACxBhvC,KAAM,OACN4R,GAAI,OACJpS,OAAQ,OACR4D,QAASyO,UAET3N,WAAY,CAAC,OACb2iB,UAAW,CAAC,qBACZ7c,QAAQ,EAERqrB,WAOF,SAAoB7xB,GAAuC,IAAjCsO,EAAiC,uDAAJ,GACrD,EAAyBA,EAAlB9M,kBAAP,MAAoB,EAApB,EAGMpB,GAAa,IAAAqrC,gBAAezrC,EAAM,KAAMwB,EAAY8M,GACpD5M,EAAc,IAAI0E,YAAYhG,GAC9B8M,EAAW,IAAIe,SAASvM,GAG9B,OAFA,IAAA+pC,gBAAezrC,EAAMkN,EAAU1L,EAAY8M,GAEpC5M,GAdP4M,QAAS,CACPtO,KAAM,K,eAiBH,IAAM0rC,EAA8BF,E,wHC9BpC,SAAwBxrC,EAAM0B,EAAaF,EAAY8M,GAK5D,OAGF,SAAgCtO,GAA8B,6DAAJ,GAAI,IAAvB2rC,mBAAuB,MAAT,EAAS,EAC5D,GAAI3rC,EAAKF,SAAWE,EAAKF,QAAQmC,OAAS0pC,EACxC,MAAM,IAAIxtC,MAAM,oDATlBytC,CAAuB5rC,IAIhB,aAAcA,EAAM0B,EAAaF,EAAY8M,IAjBtD,I,EAAA,G,EAAA,Q,mJCGA,I,EAAA,OACA,G,EAAA,Q,uVAWO,IAAMu9B,EAA8B,CACzCrvC,KAAM,MACN4R,GAAI,MACJpS,OAAQ,OACR4D,QAASyO,UACT3N,WAAY,CAAC,OACb2iB,UAAW,CAAC,qBACZ7c,QAAQ,EACR2b,M,8CACAiG,YACA9Z,QAAS,CACP2S,IAAK,CACHa,QAAQ,K,iDAKd,WAAqBpgB,EAA0B4M,GAA/C,yGACS8Z,EAAU1mB,EAAa4M,IADhC,4C,sBAIA,SAAS8Z,EAAU1mB,EAA0B4M,GAC3C,OAAyBA,GAAW,IAA7B9M,kBAAP,MAAoB,EAApB,EACMyf,EAAW,GAEjB,OADA,aAAaA,EAAKvf,EAAaF,EAAY8M,aAA3C,EAA2CA,EAAS2S,KAC7CA,E,cAIF,IAAMyqB,EAAwCG,E,gJC3CrD,I,EAAA,OACA,G,EAAA,Q,2BAMO,IAAMC,EAAY,CACvBtvC,KAAM,MACN4R,GAAI,MACJpS,OAAQ,OACR4D,QAASyO,UAET3N,WAAY,CAAC,OACb2iB,UAAW,CAAC,qBACZ7c,QAAQ,EAERqrB,WAOF,SAAoB5Q,EAAK3S,GACvB,MAAyBA,EAAlB9M,kBAAP,MAAoB,EAApB,EAGMpB,GAAa,aAAc6gB,EAAK,KAAMzf,EAAY8M,GAClD5M,EAAc,IAAI0E,YAAYhG,GAG9B8M,EAAW,IAAIe,SAASvM,GAG9B,OAFA,aAAcuf,EAAK/T,EAAU1L,EAAY8M,GAElC5M,GAhBP4M,QAAS,CACP2S,IAAK,K,cAmBF,IAAMyqB,EAA8BI,E,wMCvC5B,MAAM,EACnB,YAAYtvC,EAAM8B,GAChB2B,KAAKzD,KAAOA,EACZyD,KAAK3B,KAAOA,EACZ2B,KAAK8rC,WAAa,EAClB9rC,KAAK+rC,QAGP,cAAcC,GAEZ,OADAhsC,KAAK8rC,WAAaE,EACXhsC,KAGT,iBAEE,OADAA,KAAKisC,SAAS,GACPjsC,KAGT,iBAEE,OADAA,KAAKksC,cAAc,GACZlsC,KAGT,SAAS/C,GAMP,OALA+C,KAAKmsC,QAAUlvC,EACf+C,KAAKosC,WAELpsC,KAAKqsC,iBAEErsC,KAGT,cAAc/C,GAMZ,OALA+C,KAAKmsC,QAAUlvC,EACf+C,KAAKosC,WAELpsC,KAAKqsC,iBAEErsC,KAGT,QAAQssC,GAON,OANAtsC,KAAKusC,OAASD,EACdtsC,KAAKwsC,WAAaF,EAClBtsC,KAAKosC,WAELpsC,KAAKqsC,iBAEErsC,KAGT,YAGE,OAFAA,KAAKysC,WAAa,cAClBzsC,KAAK0sC,eAAgB,EACd1sC,KAGT,UACE,OAAKA,KAAK0sC,eAIV1sC,KAAK2sC,QAAQ,cAAsB3sC,KAAKysC,YACxCzsC,KAAK0sC,eAAgB,EAErB1sC,KAAKqsC,iBAEErsC,MAREA,KAWX,wBACE,OAAOA,KAAK8rC,WAAa,EAAI9rC,KAAK4sC,gBAAkB5sC,KAAK8rC,WAAa,EAGxE,uBACE,OAAO9rC,KAAK8rC,WAAa,EAAI9rC,KAAK6sC,eAAiB7sC,KAAK8rC,WAAa,EAGvE,cACE,OAAO9rC,KAAK6sC,eAAiB,EAAI7sC,KAAK8rC,YAAc9rC,KAAK6sC,eAAiB,KAAQ,EAGpF,kBACE,OAAO7sC,KAAKgsC,QAAU,EAAIhsC,KAAK8E,MAAQ9E,KAAKgsC,QAAU,EAGxD,iBACE,OAAOhsC,KAAKgsC,QAAU,EAAIhsC,KAAKssC,KAAOtsC,KAAKgsC,QAAU,EAGvD,QACE,OAAOhsC,KAAKssC,KAAO,EAAItsC,KAAKgsC,SAAWhsC,KAAKssC,KAAO,KAAQ,EAG7D,QAYE,OAXAtsC,KAAKssC,KAAO,EACZtsC,KAAK8E,MAAQ,EACb9E,KAAKgsC,QAAU,EACfhsC,KAAKwsC,WAAa,EAClBxsC,KAAK6sC,eAAiB,EACtB7sC,KAAK4sC,gBAAkB,EACvB5sC,KAAKmsC,OAAS,EACdnsC,KAAKusC,MAAQ,EACbvsC,KAAKosC,SAAW,EAChBpsC,KAAKysC,WAAa,EAClBzsC,KAAK0sC,eAAgB,EACd1sC,KAGT,iBACMA,KAAKosC,WAAapsC,KAAK8rC,aACzB9rC,KAAK6sC,eAAiB7sC,KAAKusC,MAC3BvsC,KAAK4sC,gBAAkB5sC,KAAKmsC,OAC5BnsC,KAAK8E,OAAS9E,KAAKmsC,OACnBnsC,KAAKssC,MAAQtsC,KAAKusC,MAClBvsC,KAAKgsC,SAAWhsC,KAAKosC,SACrBpsC,KAAKusC,MAAQ,EACbvsC,KAAKmsC,OAAS,EACdnsC,KAAKosC,SAAW,ICtHP,MAAM,EACnB,aAAY,GACVj+B,EAAE,MACFye,IAEA5sB,KAAKmO,GAAKA,EACVnO,KAAK4sB,MAAQ,GAEb5sB,KAAK8sC,iBAAiBlgB,GAEtBlwB,OAAOqwC,KAAK/sC,MAGd,IAAIzD,EAAM8B,EAAO,SACf,OAAO2B,KAAKgtC,aAAa,CACvBzwC,OACA8B,SAIJ,WACE,OAAO3B,OAAOq1B,KAAK/xB,KAAK4sB,OAAO5qB,OAGjC,QACE,IAAK,MAAMzE,KAAOyC,KAAK4sB,MACrB5sB,KAAK4sB,MAAMrvB,GAAKwuC,QAGlB,OAAO/rC,KAGT,QAAQitC,GACN,IAAK,MAAM1vC,KAAOyC,KAAK4sB,MACrBqgB,EAAGjtC,KAAK4sB,MAAMrvB,IAIlB,WACE,MAAM0kC,EAAQ,GASd,OARAjiC,KAAKuV,QAAQ23B,IACXjL,EAAMiL,EAAK3wC,MAAQ,CACjB+vC,KAAMY,EAAKZ,MAAQ,EACnBxnC,MAAOooC,EAAKpoC,OAAS,EACrBqoC,QAASD,EAAKE,kBAAoB,EAClCC,GAAIH,EAAKI,SAAW,KAGjBrL,EAGT,iBAAiBrV,EAAQ,IACvBA,EAAMrX,QAAQ23B,GAAQltC,KAAKgtC,aAAaE,IAG1C,aAAaA,GACX,IAAKA,IAASA,EAAK3wC,KACjB,OAAO,KAGT,MAAM,KACJA,EAAI,KACJ8B,GACE6uC,EAUJ,OARKltC,KAAK4sB,MAAMrwB,KAEZyD,KAAK4sB,MAAMrwB,GADT2wC,aAAgB,EACCA,EAEA,IAAI,EAAK3wC,EAAM8B,IAI/B2B,KAAK4sB,MAAMrwB","file":"dist.es5.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 46);\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n","// GLTF 1.0 extensions\nexport const KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n// GLTF 2.0 extensions\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\n// External extensions\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n","// TYPES\nexport type {\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions,\n  Writer,\n  WriterOptions,\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  IFileSystem,\n  IRandomAccessReadFileSystem\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {\n  isBrowser,\n  isWorker,\n  nodeVersion,\n  self,\n  window,\n  global,\n  document\n} from './lib/env-utils/globals';\n\n// LOADERS.GL-SPECIFIC WORKER UTILS\nexport {createLoaderWorker} from './lib/worker-loader-utils/create-loader-worker';\nexport {parseWithWorker, canParseWithWorker} from './lib/worker-loader-utils/parse-with-worker';\n\n// PARSER UTILS\nexport {parseJSON} from './lib/parser-utils/parse-json';\n\n// MEMORY COPY UTILS\nexport {\n  toArrayBuffer,\n  sliceArrayBuffer,\n  concatenateArrayBuffers,\n  concatenateTypedArrays,\n  compareArrayBuffers\n} from './lib/binary-utils/array-buffer-utils';\nexport {padToNBytes, copyToArray, copyArrayBuffer} from './lib/binary-utils/memory-copy-utils';\nexport {\n  copyPaddedArrayBufferToDataView,\n  copyPaddedStringToDataView\n} from './lib/binary-utils/binary-copy-utils';\nexport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from './lib/binary-utils/encode-utils';\nexport {getFirstCharacters, getMagicString} from './lib/binary-utils/get-first-characters';\n\n// ITERATOR UTILS\nexport {\n  makeTextEncoderIterator,\n  makeTextDecoderIterator,\n  makeLineIterator,\n  makeNumberedLineIterator\n} from './lib/iterators/text-iterators';\nexport {forEach, concatenateArrayBuffersAsync} from './lib/iterators/async-iteration';\n\n// REQUEST UTILS\nexport {default as RequestScheduler} from './lib/request-utils/request-scheduler';\n\n// NODE `path`` REPLACEMENT\nimport * as path from './lib/path-utils/path';\nexport {path};\nexport {setPathPrefix, getPathPrefix, resolvePath} from './lib/path-utils/file-aliases';\nexport {addAliases as _addAliases} from './lib/path-utils/file-aliases';\n\n// NODE `fs` WRAPPERS\nimport * as fs from './lib/node/fs';\nexport {fs};\n\n// NODE `buffer` WRAPPERS\nexport {isBuffer, toBuffer, bufferToArrayBuffer} from './lib/binary-utils/buffer-utils';\n\nexport {JSONLoader} from './json-loader';\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n","import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\ntype GLTFWithBuffers = {\n  json: GLTF;\n  buffers: any[];\n  binary?: ArrayBuffer;\n};\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName: string): {[key: string]: any} | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName: string): {[key: string]: any} | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension(\n    object: {[key: string]: any},\n    extensionName: string\n  ): {[key: string]: any} | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices: object; material: number; mode: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n","export default function getHiResTimestamp() {\n  let timestamp;\n\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n//# sourceMappingURL=hi-res-timestamp.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","export function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import type {ImageType, ImageTypeEnum, ImageDataType} from '../../types';\n\nexport function isImage(image: ImageType): boolean {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image: ImageType): void {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      (image as ImageBitmap).close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image: ImageType): ImageTypeEnum {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageSize(image: ImageType): {width: number; height: number} {\n  return getImageData(image);\n}\n\nexport function getImageData(image: ImageType): ImageDataType | ImageData {\n  switch (getImageType(image)) {\n    case 'data':\n      return image as unknown as ImageData;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      // @ts-ignore\n      canvas.width = image.width;\n      // @ts-ignore\n      canvas.height = image.height;\n      // @ts-ignore\n      context.drawImage(image, 0, 0);\n      // @ts-ignore\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'beta';\ndeclare let __VERSION__;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\n/** MIME type, width and height extracted from binary compressed image data */\nexport type BinaryImageMetadata = {\n  mimeType: string;\n  width: number;\n  height: number;\n};\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(\n  binaryData: DataView | ArrayBuffer\n): BinaryImageMetadata | null {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n    0xffcf, 0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n","import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n","// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","import {assert} from '../env-utils/assert';\nimport {getLoadableWorkerURL} from '../worker-utils/get-loadable-worker-url';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst NOOP = () => {};\n\nexport type WorkerThreadProps = {\n  name: string;\n  source?: string;\n  url?: string;\n};\n\n/**\n * Represents one worker thread\n */\nexport default class WorkerThread {\n  readonly name: string;\n  readonly source: string | undefined;\n  readonly url: string | undefined;\n  terminated: boolean = false;\n  worker: Worker;\n  onMessage: (message: any) => void;\n  onError: (error: Error) => void;\n\n  private _loadableURL: string = '';\n\n  static isSupported(): boolean {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor(props: WorkerThreadProps) {\n    const {name, source, url} = props;\n    assert(source || url); // Either source or url must be defined\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = (error) => console.log(error); // eslint-disable-line\n\n    this.worker = this._createBrowserWorker();\n  }\n\n  /**\n   * Terminate this worker thread\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    // @ts-ignore\n    this.worker.terminate();\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  /**\n   * Send a message to this worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   * @param transferList If not supplied, calculated automatically by traversing data\n   */\n  postMessage(data: any, transferList?: any[]): void {\n    transferList = transferList || getTransferList(data);\n    // @ts-ignore\n    this.worker.postMessage(data, transferList);\n  }\n\n  // PRIVATE\n\n  /**\n   * Generate a standard Error from an ErrorEvent\n   * @param {ErrorEvent} event\n   */\n  _getErrorFromErrorEvent(event) {\n    // Note Error object does not have the expected fields if loading failed completely\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n    // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n    let message = 'Failed to load ';\n    message += `worker ${this.name}. `;\n    if (event.message) {\n      message += `${event.message} in `;\n    }\n    // const hasFilename = event.filename && !event.filename.startsWith('blob:');\n    // message += hasFilename ? event.filename : this.source.slice(0, 100);\n    if (event.lineno) {\n      message += `:${event.lineno}:${event.colno}`;\n    }\n    return new Error(message);\n  }\n\n  /**\n   * Creates a worker thread on the browser\n   */\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({source: this.source, url: this.url});\n    const worker = new Worker(this._loadableURL, {name: this.name});\n\n    worker.onmessage = (event) => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    // This callback represents an uncaught exception in the worker thread\n    worker.onerror = (error) => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    // TODO - not clear when this would be called, for now just log in case it happens\n    worker.onmessageerror = (event) => console.error(event); // eslint-disable-line\n\n    return worker;\n  }\n}\n","// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n","/*\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  TimeMicrosecond,\n  TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from 'apache-arrow';\n*/\nexport {default as Schema} from './impl/schema';\nexport {default as Field} from './impl/field';\nexport {Type} from './impl/type';\nexport {\n  DataType,\n  Null,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Binary,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeSecond,\n  TimeMillisecond,\n  // TimeMicrosecond,\n  // TimeNanosecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './impl/type';\n","import {assert} from '../utils/assert';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n","// TYPES\nexport type {ImageDataType, ImageType, ImageTypeEnum} from './types';\n\n// LOADERS AND WRITERS\nexport {ImageLoader} from './image-loader';\nexport {ImageWriter} from './image-writer';\n\n// IMAGE CATEGORY API\n\n// Binary Image API\nexport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\n// Parsed Image API\nexport {isImageTypeSupported, getDefaultImageType} from './lib/category-api/image-type';\n\nexport {\n  isImage,\n  getImageType,\n  getImageSize,\n  getImageData\n} from './lib/category-api/parsed-image-api';\n\n// DEPRECATED - Remove in V3 (fix dependency in luma.gl)\nexport {loadImage} from './lib/texture-api/load-image';\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import {assert} from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n","import type {ImageTypeEnum} from '../../types';\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type: string): boolean {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType(): ImageTypeEnum {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    const xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {\n    //   xmlText = unescape(encodeURLComponent(xmlText));\n    // }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport WorkerThread from './worker-thread';\nimport {assert} from '../env-utils/assert';\n\n/**\n * Represents one Job handled by a WorkerPool or WorkerFarm\n */\nexport default class WorkerJob {\n  readonly name: string;\n  readonly workerThread: WorkerThread;\n  isRunning: boolean;\n  /** Promise that resolves when Job is done */\n  readonly result: Promise<any>;\n\n  private _resolve: (value: any) => void;\n  private _reject: (reason?: any) => void;\n\n  constructor(jobName: string, workerThread: WorkerThread) {\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.isRunning = true;\n    this._resolve = () => {};\n    this._reject = () => {};\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * Send a message to the job's worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   */\n  postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    this.workerThread.postMessage({\n      source: 'loaders.gl', // Lets worker ignore unrelated messages\n      type,\n      payload\n    });\n  }\n\n  /**\n   * Call to resolve the `result` Promise with the supplied value\n   */\n  done(value): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  /**\n   * Call to reject the `result` Promise with the supplied error\n   */\n  error(error): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n","import WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\n/**\n * @param maxConcurrency {number} - max count of workers\n */\nexport type WorkerFarmProps = {\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  reuseWorkers?: boolean;\n  onDebug?: () => void;\n};\n\nconst DEFAULT_PROPS: WorkerFarmProps = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  onDebug: () => {},\n  reuseWorkers: true\n};\n\n/**\n * Process multiple jobs with a \"farm\" of different workers in worker pools.\n */\nexport default class WorkerFarm {\n  private props: WorkerFarmProps;\n  private workerPools = new Map<string, WorkerPool>();\n  // singleton\n  private static _workerFarm?: WorkerFarm;\n\n  /** Check if Workers are supported */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /** Get the singleton instance of the global worker farm */\n  static getWorkerFarm(props: WorkerFarmProps = {}): WorkerFarm {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  /** get global instance with WorkerFarm.getWorkerFarm() */\n  private constructor(props: WorkerFarmProps) {\n    this.props = {...DEFAULT_PROPS};\n    this.setProps(props);\n    /** @type Map<string, WorkerPool>} */\n    this.workerPools = new Map();\n  }\n\n  /**\n   * Terminate all workers in the farm\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n  }\n\n  /**\n   * Set props used when initializing worker pools\n   * @param props\n   */\n  setProps(props: WorkerFarmProps): void {\n    this.props = {...this.props, ...props};\n    // Update worker pool props\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  /**\n   * Returns a worker pool for the specified worker\n   * @param options - only used first time for a specific worker name\n   * @param options.name - the name of the worker - used to identify worker pool\n   * @param options.url -\n   * @param options.source -\n   * @example\n   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);\n   */\n  getWorkerPool(options: {name: string; source?: string; url?: string}): WorkerPool {\n    const {name, source, url} = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n","import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    // eslint-disable-next-line no-restricted-globals\n    self.onmessage = (message) => {\n      if (!isKnownMessage(message)) {\n        return;\n      }\n\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = message.data;\n      onMessage(type, payload);\n    };\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('message', onMessageWrapper);\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    // eslint-disable-next-line no-restricted-globals\n    self.removeEventListener('message', onMessageWrapper);\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    if (self) {\n      const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n      const transferList = getTransferList(payload);\n      // eslint-disable-next-line no-restricted-globals\n      // @ts-ignore\n      self.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n","import type {WorkerObject, WorkerOptions} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\nconst NPM_TAG = 'latest';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : NPM_TAG;\n\n/**\n * Gets worker object's name (for debugging in Chrome thread inspector window)\n */\nexport function getWorkerName(worker: WorkerObject): string {\n  const warning = worker.version !== VERSION ? ` (worker-utils@${VERSION})` : '';\n  return `${worker.name}@${worker.version}${warning}`;\n}\n\n/**\n * Generate a worker URL based on worker object and options\n * @returns A URL to one of the following:\n * - a published worker on unpkg CDN\n * - a local test worker\n * - a URL provided by the user in options\n */\nexport function getWorkerURL(worker: WorkerObject, options: WorkerOptions = {}): string {\n  const workerOptions = options[worker.id] || {};\n\n  const workerFile = `${worker.id}-worker.js`;\n\n  let url = workerOptions.workerUrl;\n\n  // If URL is test, generate local loaders.gl url\n  // @ts-ignore _workerType\n  if (options._workerType === 'test') {\n    url = `modules/${worker.module}/dist/${workerFile}`;\n  }\n\n  // If url override is not provided, generate a URL to published version on npm CDN unpkg.com\n  if (!url) {\n    // GENERATE\n    let version = worker.version;\n    // On master we need to load npm alpha releases published with the `beta` tag\n    if (version === 'latest') {\n      // throw new Error('latest worker version specified');\n      version = NPM_TAG;\n    }\n    const versionTag = version ? `@${version}` : '';\n    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;\n  }\n\n  assert(url);\n\n  // Allow user to override location\n  return url;\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n","export function getFirstCharacters(data, length = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n","import {TypedArray} from '../../types';\nimport * as node from '../node/buffer-utils.node';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n","import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","// COMMON CATEGORY\nexport type {TypedArray, NumberArray, AnyArray} from './types';\n\nexport type {Batch} from './category/common';\n\n// TABLE CATEGORY TYPES\n\nexport type {\n  Table,\n  ArrayRowTable,\n  ObjectRowTable,\n  ColumnarTable,\n  ArrowTable\n} from './category/table';\nexport type {\n  TableBatch,\n  RowArrayTableBatch,\n  RowObjectTableBatch,\n  ColumnarTableBatch,\n  ArrowTableBatch\n} from './category/table';\n\n// TABLE CATEGORY UTILS\nexport {default as TableBatchBuilder} from './lib/table/table-batch-builder';\nexport type {TableBatchAggregator} from './lib/table/table-batch-aggregator';\nexport {default as RowTableBatchAggregator} from './lib/table/row-table-batch-aggregator';\nexport {default as ColumnarTableBatchAggregator} from './lib/table/columnar-table-batch-aggregator';\n\nexport {convertToObjectRow, convertToArrayRow} from './lib/utils/row-utils';\n\n// MESH CATEGORY\nexport type {MeshTable, MeshArrowTable, Mesh, MeshAttribute} from './category/mesh';\n\n// MESH CATEGORY UTILS\nexport type {Attributes as _Attributes} from './category/mesh/mesh-utils';\nexport {getMeshSize, getMeshBoundingBox} from './category/mesh/mesh-utils';\n\n// TYPES\n// GIS CATEGORY - GEOJSON\nexport type {GeoJSON, Feature, Geometry, Position, GeoJsonProperties} from './category/gis';\nexport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from './category/gis';\n\n// GIS CATEGORY - BINARY\nexport type {\n  BinaryGeometryType,\n  BinaryGeometry,\n  BinaryPointGeometry,\n  BinaryLineGeometry,\n  BinaryPolygonGeometry,\n  BinaryAttribute\n} from './category/gis';\nexport type {\n  BinaryFeatures,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures\n} from './category/gis';\n\n// SCHEMA\nexport {\n  Schema,\n  Field,\n  DataType,\n  Null,\n  Binary,\n  Bool,\n  Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  Float,\n  Float16,\n  Float32,\n  Float64,\n  Utf8,\n  Date,\n  DateDay,\n  DateMillisecond,\n  Time,\n  TimeMillisecond,\n  TimeSecond,\n  Timestamp,\n  TimestampSecond,\n  TimestampMillisecond,\n  TimestampMicrosecond,\n  TimestampNanosecond,\n  Interval,\n  IntervalDayTime,\n  IntervalYearMonth,\n  FixedSizeList\n} from './lib/schema';\n\n// SCHEMA UTILS\nexport {deduceTableSchema} from './lib/schema-utils/deduce-table-schema';\nexport {getTypeInfo} from './lib/schema-utils/get-type-info';\nexport {getArrowTypeFromTypedArray} from './lib/schema-utils/type-utils';\n\n// EXPERIMENTAL APIs\nexport {default as AsyncQueue} from './lib/utils/async-queue';\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n","/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n","import type {Schema} from '../schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n","// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n","import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      const cutBufffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      accessor.value = new ArrayType(cutBufffer);\n    }\n\n    return accessor;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    // bufferView = {...bufferView};\n    bufferView.id = bufferView.id || `bufferView-${index}`;\n    const bufferIndex = bufferView.buffer;\n    bufferView.buffer = this.buffers[bufferIndex];\n\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return bufferView;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n","/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n","/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","export type {GLB} from './lib/types/glb-types';\nexport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFBuffer,\n  GLTFBufferView,\n  GLTFMeshPrimitive,\n  GLTFMesh,\n  GLTFNode,\n  GLTFMaterial,\n  GLTFSampler,\n  GLTFScene,\n  GLTFSkin,\n  GLTFTexture,\n  GLTFImage\n} from './lib/types/gltf-types';\n\n// Constants\nexport {KHR_DRACO_MESH_COMPRESSION} from './lib/gltf-utils/gltf-constants';\n\n// glTF loader/writer definition objects\nexport {GLTFLoader} from './gltf-loader';\nexport {GLTFWriter} from './gltf-writer';\n\n// GLB Loader & Writer (for custom formats that want to leverage the GLB binary \"envelope\")\nexport {GLBLoader} from './glb-loader';\nexport {GLBWriter} from './glb-writer';\n\n// glTF Data Access Helper Class\nexport {default as GLTFScenegraph} from './lib/api/gltf-scenegraph';\nexport {postProcessGLTF} from './lib/api/post-process-gltf';\nexport type {Mesh} from './lib/types/gltf-json-schema';\nexport type {GLTFObject} from './lib/types/gltf-types';\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\n// import type {ImageLoaderOptions} from '@loaders.gl/images';\n// import type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport {VERSION} from './lib/utils/version';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n","/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport type {GLB} from '../types/glb-types';\nimport type {GLBParseOptions} from './parse-glb';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {decodeExtensions} from '../extensions/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  excludeExtensions?: string[];\n  decompressMeshes?: boolean;\n  normalize?: boolean;\n  loadBuffers?: boolean;\n  loadImages?: boolean;\n  postProcess?: boolean;\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: {\n    gltf?: GLTFParseOptions;\n    glb?: GLBParseOptions;\n  },\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context: LoaderContext) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context: LoaderContext) {\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, index: number, options, context: LoaderContext) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[index] = parsedImage;\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport const _typecheckImageLoader: LoaderWithParser = ImageLoader;\n","import {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n","import {global} from '../utils/globals';\nimport {assert} from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n","// import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeImage} from './lib/encoders/encode-image';\n\nexport const ImageWriter = {\n  name: 'Images',\n  id: 'image',\n  module: 'images',\n  version: VERSION,\n  extensions: ['jpeg'],\n  options: {\n    image: {\n      mimeType: 'image/png',\n      jpegQuality: null\n    }\n  },\n  encode: encodeImage\n};\n","// Image loading/saving for browser and Node.js\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(\n  image: any,\n  options?: {[key: string]: any}\n): Promise<ArrayBuffer> {\n  options = options || {};\n  options.image = options.image || ({} as {[key: string]: any});\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise<Blob | null>((resolve) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n","import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n","import {resolvePath} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\n\n// Generate a url by calling getUrl with mix of options, applying options.baseUrl\nexport function generateUrl(getUrl, options, urlOptions) {\n  // Get url\n  let url = getUrl;\n  if (typeof getUrl === 'function') {\n    url = getUrl({...options, ...urlOptions});\n  }\n  assert(typeof url === 'string');\n\n  // Apply options.baseUrl\n  const {baseUrl} = options;\n  if (baseUrl) {\n    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;\n  }\n\n  return resolvePath(url);\n}\n","// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\ntype obj = {[key: string]: any};\nconst self_: obj = globals.self || globals.window || globals.global || {};\nconst window_: obj = globals.window || globals.self || globals.global || {};\nconst global_: obj = globals.global || globals.self || globals.window || {};\nconst document_: obj = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in a browser */\nexport const isBrowser: boolean =\n  // @ts-ignore process does not exist on browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running in a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n","import {assert} from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props: {source?: string; url?: string}) {\n  assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    // Differentiate worker urls from worker source code\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert(workerURL);\n  return workerURL;\n}\n\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url: string): string {\n  // A local script url, we can use it to initialize a Worker directly\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  // A remote script, we need to use `importScripts` to load from different origin\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource: string): string {\n  // NOTE: webworkify was previously used\n  // const blob = webworkify(workerSource, {bare: true});\n  const blob = new Blob([workerSource], {type: 'application/javascript'});\n  return URL.createObjectURL(blob);\n}\n\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl: string): string {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n","import type {\n  WorkerObject,\n  WorkerOptions,\n  WorkerContext,\n  WorkerMessageType,\n  WorkerMessagePayload\n} from '../../types';\nimport type WorkerJob from '../worker-farm/worker-job';\nimport WorkerFarm from '../worker-farm/worker-farm';\nimport {removeNontransferableOptions} from '../worker-utils/remove-nontransferable-options';\nimport {getWorkerURL, getWorkerName} from './get-worker-url';\n\ntype ProcessOnWorkerOptions = WorkerOptions & {\n  jobName?: string;\n  [key: string]: any;\n};\n\n/**\n * Determines if we can parse with worker\n * @param loader\n * @param data\n * @param options\n */\nexport function canProcessOnWorker(worker: WorkerObject, options?: WorkerOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return worker.worker && options?.worker;\n}\n\n/**\n * This function expects that the worker thread sends certain messages,\n * Creating such a worker can be automated if the worker is wrapper by a call to\n * createWorker in @loaders.gl/worker-utils.\n */\nexport async function processOnWorker(\n  worker: WorkerObject,\n  data: any,\n  options: ProcessOnWorkerOptions = {},\n  context: WorkerContext = {}\n): Promise<any> {\n  const name = getWorkerName(worker);\n  const url = getWorkerURL(worker, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(\n    jobName,\n    // eslint-disable-next-line\n    onMessage.bind(null, context)\n  );\n\n  // Kick off the processing in the worker\n  const transferableOptions = removeNontransferableOptions(options);\n  job.postMessage('process', {input: data, options: transferableOptions});\n\n  const result = await job.result;\n  return result.result;\n}\n\n/**\n * Job completes when we receive the result\n * @param job\n * @param message\n */\nasync function onMessage(\n  context: WorkerContext,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      // Worker is done\n      job.done(payload);\n      break;\n\n    case 'error':\n      // Worker encountered an error\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for us (main thread) to process something\n      const {id, input, options} = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {id, error: 'Worker not set up to process on main thread'});\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`process-on-worker: unknown message ${type}`);\n  }\n}\n","/**\n * Safely stringify JSON (drop non serializable values like functions and regexps)\n * @param value\n */\nexport function removeNontransferableOptions(object: object): object {\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  // TODO - warn if options stringification is long\n  return JSON.parse(stringifyJSON(object));\n}\n\nfunction stringifyJSON(v) {\n  const cache = new Set();\n  return JSON.stringify(v, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        // Circular reference found\n        try {\n          // If this value does not reference a parent it can be deduped\n          return JSON.parse(JSON.stringify(value));\n        } catch (err) {\n          // discard key if value cannot be deduped\n          return undefined;\n        }\n      }\n      // Store value in our set\n      cache.add(value);\n    }\n    return value;\n  });\n}\n","import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n","import type {WorkerObject} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\n/**\n * Check if worker is compatible with this library version\n * @param worker\n * @param libVersion\n * @returns `true` if the two versions are compatible\n */\nexport function validateWorkerVersion(\n  worker: WorkerObject,\n  coreVersion: string = VERSION\n): boolean {\n  assert(worker, 'no worker provided');\n\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  // TODO enable when fix the __version__ injection\n  // const coreVersions = parseVersion(coreVersion);\n  // const workerVersions = parseVersion(workerVersion);\n  // assert(\n  //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,\n  //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n\n  return true;\n}\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n","/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName?: string, options?): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && (await node.requireFromFile(libraryUrl));\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n","import type {WorkerJob, WorkerMessageType, WorkerMessagePayload} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // eslint-disable-next-line\n    onMessage.bind(null, parseOnMainThread)\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options\n  });\n\n  const result = await job.result;\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n","import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n/**\n * Minimal JSON parser that throws more meaningful error messages\n */\nexport function parseJSON(string: string): any {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n","import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n","// Note: These were broken out from gltf loader...\n// eslint-disable-next-line complexity\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n","// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n","import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n","import {Stats} from '@probe.gl/stats';\n\ntype Handle = any;\ntype DoneFunction = () => any;\ntype GetPriorityFunction = () => number;\ntype RequestResult = {\n  done: DoneFunction;\n} | null;\n\n/** RequestScheduler Options */\nexport type RequestSchedulerProps = {\n  id?: string;\n  throttleRequests?: boolean;\n  maxRequests?: number;\n};\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS: Required<RequestSchedulerProps> = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n/** Tracks one request */\ntype Request = {\n  handle: Handle;\n  priority: number;\n  getPriority: GetPriorityFunction;\n  resolve?: (value: any) => any;\n};\n\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  readonly props: Required<RequestSchedulerProps>;\n  readonly stats: Stats;\n  activeRequestCount: number = 0;\n\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  private requestQueue: Request[] = [];\n  private requestMap: Map<Handle, Promise<RequestResult>> = new Map();\n  private deferredUpdate: any = null;\n\n  constructor(props: RequestSchedulerProps = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: this.props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(\n    handle: Handle,\n    getPriority: GetPriorityFunction = () => 0\n  ): Promise<RequestResult> {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle) as Promise<any>;\n    }\n\n    const request: Request = {handle, priority: 0, getPriority};\n    const promise = new Promise<RequestResult>((resolve) => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request: Request): Promise<any> {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests(): void {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    // TODO - shouldn't we clear the timeout?\n    this.deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n","// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex as number) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n","// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n","import * as node from '../node/buffer-utils.node';\n\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value: any): boolean {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data: any): Buffer {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/**\n * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function bufferToArrayBuffer(data: any): ArrayBuffer {\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    return node.toArrayBuffer(data);\n  }\n  return data;\n}\n","import type {LoaderWithParser} from './types';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n/**\n * A JSON Micro loader (minimal bundle size)\n * Alternative to `@loaders.gl/json`\n */\nexport const JSONLoader = {\n  name: 'JSON',\n  id: 'json',\n  module: 'json',\n  version: VERSION,\n  extensions: ['json', 'geojson'],\n  mimeTypes: ['application/json'],\n  category: 'json',\n  text: true,\n  parseTextSync,\n  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),\n  options: {}\n};\n\n// TODO - deprecated\nfunction parseTextSync(text) {\n  return JSON.parse(text);\n}\n\nexport const _typecheckJSONLoader: LoaderWithParser = JSONLoader;\n","import {asyncDeepMap} from './async-deep-map';\n\nexport async function deepLoad(urlTree, load, options) {\n  return await asyncDeepMap(urlTree, (url) => shallowLoad(url, load, options));\n}\n\nexport async function shallowLoad(url, load, options) {\n  // console.error('loading', url);\n  const response = await fetch(url, options.fetch);\n  const arrayBuffer = await response.arrayBuffer();\n  return await load(arrayBuffer, options);\n}\n","/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\n\nconst isObject = (value) => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree, func, options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(object, func, options) {\n  const promises: Promise<any>[] = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray, func, options = {}) {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n","// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n","// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n","/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (read only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 extensions (read/write)\nimport * as KHR_draco_mesh_compression from './KHR_draco_mesh_compression';\nimport * as KHR_materials_unlit from './KHR_materials_unlit';\nimport * as KHR_lights_punctual from './KHR_lights_punctual';\nimport * as KHR_techniques_webgl from './KHR_techniques_webgl';\n\ntype GLTFExtensionPlugin = {\n  decode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n\n  encode: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: {[extensionName: string]: GLTFExtensionPlugin} = {\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  KHR_draco_mesh_compression,\n  KHR_materials_unlit,\n  KHR_lights_punctual,\n  KHR_techniques_webgl\n};\n\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  for (const extensionName in EXTENSIONS) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    if (!exclude) {\n      const extension = EXTENSIONS[extensionName];\n      // Note: We decode async extensions sequentially, this might not be necessary\n      // Currently we only have Draco, but when we add Basis we may revisit\n      await extension.decode(gltf, options, context);\n    }\n  }\n}\n","// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\nimport type {GLTF, GLTFAccessor, GLTFMeshPrimitive} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMeshData} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-utils/gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on DracoWriter to avoid bundling it when not needed\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(\n    bufferCopy,\n    DracoLoader,\n    dracoOptions,\n    context\n  )) as DracoMeshData;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\n\n// Draco data types\n\nexport type {DracoMeshData, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(\n  arrayBuffer: ArrayBuffer,\n  options?: DracoLoaderOptions\n): Promise<DracoMeshData> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n","import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n","/* eslint-disable camelcase */\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  TypedArray,\n  // standard mesh output data\n  MeshData,\n  MeshAttribute,\n  // standard mesh with draco metadata\n  DracoMeshData,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {makeSchemaFromAttributes} from './utils/schema-attribute-utils';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMeshData {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMeshData = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshData {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n","import type {Schema} from '../schema';\nimport type {TableBatch} from '../../category/table';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: number;\n  readonly bitWidth: number;\n\n  constructor(unit, bitWidth) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n","// Type deduction\nimport {\n  Schema\n  // Int,\n  // Int8,\n  // Int16,\n  // Int32,\n  // Uint8,\n  // Uint16,\n  // Uint32,\n  // Float32,\n  // Float64\n  // Bool,\n  // Utf8,\n  // TimestampMillisecond,\n  // Null\n} from '../schema';\n\n// const TYPED_ARRAY_TO_TYPE = {\n//   Int8Array: new Int8(),\n//   Int16Array: new Int16(),\n//   Int32Array: new Int32(),\n//   Uint8Array: new Uint8(),\n//   Uint8ClampedArray: new Uint8(),\n//   Uint16Array: new Uint16(),\n//   Uint32Array: new Uint32(),\n//   Float32Array: new Float32(),\n//   Float64Array: new Float64()\n// };\n\n// if (typeof BigInt64Array !== 'undefined') {\n//   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n//   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n// }\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table, schema?: Schema) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n","import {Type} from '../schema';\nimport {AnyArray} from '../../types';\n\n/**\n * Gets type information from an Arrow type object or \"mock\" Arrow type object\n * @param arrowTypeLike Arrow Type or type object of similar shape\n */\nexport function getTypeInfo(arrowTypeLike: any): {\n  typeId: Type;\n  ArrayType: AnyArray;\n  typeName: string;\n  typeEnumName?: string;\n  precision?: number;\n} {\n  return {\n    typeId: arrowTypeLike.typeId,\n    ArrayType: arrowTypeLike.ArrayType,\n    typeName: arrowTypeLike.toString(),\n    typeEnumName: getTypeKey(arrowTypeLike.typeId),\n    precision: arrowTypeLike.precision\n  };\n}\n\nlet ReverseType: {[key: string]: string} | null = null;\n\nfunction getTypeKey(typeKey) {\n  if (!ReverseType) {\n    ReverseType = {};\n    for (const key in Type) {\n      ReverseType[Type[key]] = key;\n    }\n  }\n\n  return ReverseType[typeKey];\n}\n","import type {TypedArray} from '../../types';\nimport {DataType, Float32, Float64, Int16, Int32, Int8, Uint16, Uint32, Uint8} from '../schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T>;\n  private _settlers: ArrayQueue<{resolve; reject}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{resolve; reject}>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n","import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nimport {MeshAttribute, DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\nexport function makeSchemaFromAttributes(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadataMap\n  );\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData} from './lib/draco-types';\nimport type {DracoBuildOptions} from './lib/draco-builder';\nimport DRACOBuilder from './lib/draco-builder';\nimport {loadDracoEncoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoWriterOptions = DracoBuildOptions & {};\n\nconst DEFAULT_DRACO_OPTIONS = {\n  pointcloud: false, // Set to true if pointcloud (mode: 0, no indices)\n  attributeNameEntry: 'name'\n  // Draco Compression Parameters\n  // method: 'MESH_EDGEBREAKER_ENCODING',\n  // speed: [5, 5],\n  // quantization: {\n  //   POSITION: 10\n  // }\n};\n\n/**\n * Exporter for Draco3D compressed geometries\n */\nexport const DracoWriter: Writer = {\n  name: 'DRACO',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  extensions: ['drc'],\n  encode,\n  options: {\n    draco: DEFAULT_DRACO_OPTIONS\n  }\n};\n\nasync function encode(\n  data: DracoMeshData,\n  options: {draco?: DracoWriterOptions} = {}\n): Promise<ArrayBuffer> {\n  // Dynamically load draco\n  const {draco} = await loadDracoEncoderModule(options);\n  const dracoBuilder = new DRACOBuilder(draco);\n\n  try {\n    return dracoBuilder.encodeSync(data, options.draco);\n  } finally {\n    dracoBuilder.destroy();\n  }\n}\n","/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray, DracoMeshData} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMeshData, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMeshData) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMeshData` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n","// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n","// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_MATERIALS_UNLIT} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n","// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport {assert} from '../utils/assert';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_LIGHTS_PUNCTUAL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n","// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_TECHNIQUES_WEBGL} from '../gltf-utils/gltf-constants';\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n","/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  constructor(gltf) {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    };\n  }\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    KHR_binary_glTF.decode(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n","// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\nimport type {GLTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {KHR_BINARY_GLTF} from '../gltf-utils/gltf-constants';\n\nexport function decode(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const node of json.images || []) {\n    const extension = gltfScenegraph.removeObjectExtension(node, KHR_BINARY_GLTF);\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(node, extension);\n    }\n  }\n\n  // TODO shaders\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been removed from all nodes\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\nexport function encode() {\n  throw new Error(KHR_BINARY_GLTF);\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeGLTFSync} from './lib/encoders/encode-gltf';\n\nexport type GLTFWriterOptions = {\n  gltf?: {};\n  byteOffset?: number;\n};\n\n/**\n * GLTF exporter\n */\nexport const GLTFWriter = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF\n  mimeTypes: ['model/gltf-binary'], // 'model/gltf+json',\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    gltf: {}\n  }\n};\n\nfunction encodeSync(gltf, options: GLTFWriterOptions = {}) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length, then create arraybuffer and encode\n  const byteLength = encodeGLTFSync(gltf, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n  encodeGLTFSync(gltf, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLTFWriter;\n","import encodeGLBSync from './encode-glb';\n\n// Encode the full glTF file as a binary GLB file\n// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file\n//\n// TODO - Does not support encoding to non-GLB versions of glTF format\n// - Encode as a textual JSON file with binary data in base64 data URLs.\n// - Encode as a JSON with all images (and buffers?) in separate binary files\n//\n// glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n\nexport function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {\n  convertBuffersToBase64(gltf);\n\n  // TODO: Copy buffers to binary\n\n  return encodeGLBSync(gltf, arrayBuffer, byteOffset, options);\n}\n\nfunction convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {\n  if (gltf.buffers && gltf.buffers.length > firstBuffer) {\n    throw new Error('encodeGLTF: multiple buffers not yet implemented');\n  }\n}\n","import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {GLB} from './lib/types/glb-types';\nimport type {GLBParseOptions} from './lib/parsers/parse-glb';\nimport {VERSION} from './lib/utils/version';\nimport parseGLBSync from './lib/parsers/parse-glb';\n\nexport type GLBLoaderOptions = LoaderOptions & {\n  glb?: GLBParseOptions;\n  byteOffset?: number;\n};\n\n/**\n * GLB Loader -\n * GLB is the binary container format for GLTF\n */\nexport const GLBLoader: LoaderWithParser = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n  parse,\n  parseSync,\n  options: {\n    glb: {\n      strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)\n    }\n  }\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): Promise<GLB> {\n  return parseSync(arrayBuffer, options);\n}\n\nfunction parseSync(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): GLB {\n  const {byteOffset = 0} = options || {};\n  const glb: GLB = {} as GLB;\n  parseGLBSync(glb, arrayBuffer, byteOffset, options?.glb);\n  return glb;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: LoaderWithParser = GLBLoader;\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport encodeGLBSync from './lib/encoders/encode-glb';\n\n/**\n * GLB exporter\n * GLB is the binary container format for GLTF\n */\nexport const GLBWriter = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    glb: {}\n  }\n};\n\nfunction encodeSync(glb, options) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length and allocate buffer\n  const byteLength = encodeGLBSync(glb, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n\n  // Encode into buffer\n  const dataView = new DataView(arrayBuffer);\n  encodeGLBSync(glb, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLBWriter;\n","import getHiResTimestamp from '../utils/hi-res-timestamp';\nexport default class Stat {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n    this.sampleSize = 1;\n    this.reset();\n  }\n\n  setSampleSize(samples) {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  incrementCount() {\n    this.addCount(1);\n    return this;\n  }\n\n  decrementCount() {\n    this.subtractCount(1);\n    return this;\n  }\n\n  addCount(value) {\n    this._count += value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  subtractCount(value) {\n    this._count -= value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  addTime(time) {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  timeStart() {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n    return this;\n  }\n\n  timeEnd() {\n    if (!this._timerPending) {\n      return this;\n    }\n\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset() {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n    return this;\n  }\n\n  _checkSampling() {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n\n}\n//# sourceMappingURL=stat.js.map","import Stat from './stat';\nexport default class Stats {\n  constructor({\n    id,\n    stats\n  }) {\n    this.id = id;\n    this.stats = {};\n\n    this._initializeStats(stats);\n\n    Object.seal(this);\n  }\n\n  get(name, type = 'count') {\n    return this._getOrCreate({\n      name,\n      type\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn) {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable() {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n    return table;\n  }\n\n  _initializeStats(stats = []) {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat) {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {\n      name,\n      type\n    } = stat;\n\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n\n    return this.stats[name];\n  }\n\n}\n//# sourceMappingURL=stats.js.map"],"sourceRoot":""}