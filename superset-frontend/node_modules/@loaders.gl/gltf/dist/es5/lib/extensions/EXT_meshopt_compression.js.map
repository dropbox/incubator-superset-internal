{"version":3,"sources":["../../../../src/lib/extensions/EXT_meshopt_compression.ts"],"names":["DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","decode","gltfData","options","gltf","decompressMeshes","promises","json","bufferViews","bufferViewIndex","push","decodeMeshoptBufferView","Promise","all","scenegraph","GLTFScenegraph","removeExtension","EXT_MESHOPT_COMPRESSION","index","bufferView","meshoptExtension","extensions","buffer","buffers","byteLength","byteStride","count","mode","source","Uint8Array","result","ArrayBuffer"],"mappings":";;;;;;;;;;;;;AAEA;;AACA;;AACA;;;;;;;;AAcA,IAAMA,uBAAuB,GAAG;AAC9BC,EAAAA,UAAU,EAAE,CADkB;AAE9BC,EAAAA,MAAM,EAAE;AAFsB,CAAhC;;SAMsBC,M;;;;;sEAAf,iBAAsBC,QAAtB,EAAgCC,OAAhC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBACD,EAACA,OAAD,aAACA,OAAD,gCAACA,OAAO,CAAEC,IAAV,0CAAC,cAAeC,gBAAhB,KAAoC,CAAC,yCADpC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAKCC,YAAAA,QALD,GAK4B,EAL5B;AAAA,mDAMyBJ,QAAQ,CAACK,IAAT,CAAcC,WAAd,IAA6B,EANtD;;AAAA;AAML,kEAA+D;AAApDC,gBAAAA,eAAoD;AAC7DH,gBAAAA,QAAQ,CAACI,IAAT,CAAcC,uBAAuB,CAACT,QAAQ,CAACK,IAAV,EAAgBE,eAAhB,CAArC;AACD;AARI;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWCG,OAAO,CAACC,GAAR,CAAYP,QAAZ,CAXD;;AAAA;AAcCQ,YAAAA,UAdD,GAcc,IAAIC,uBAAJ,CAAmBb,QAAnB,CAdd;AAeLY,YAAAA,UAAU,CAACE,eAAX,CAA2BC,sCAA3B;;AAfK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAmBQN,uB;;;;;uFAAf,kBAAuCJ,IAAvC,EAA6CW,KAA7C;AAAA;;AAAA;AAAA;AAAA;AAAA;AACQC,YAAAA,UADR,GACqBZ,IAAI,CAACC,WAAL,CAAiBU,KAAjB,CADrB;AAGQE,YAAAA,gBAHR,GAIID,UAAU,CAACE,UAAX,IACCF,UAAU,CAACE,UAAX,CAAsBJ,sCAAtB,CALL;;AAAA,iBAMMG,gBANN;AAAA;AAAA;AAAA;;AAOUE,YAAAA,MAPV,GAOmBf,IAAI,CAACgB,OAAL,CAAaH,gBAAgB,CAACE,MAA9B,CAPnB;AAAA,oCAgBQF,gBAhBR,CAUMrB,UAVN,EAUMA,UAVN,sCAUmB,CAVnB,mDAgBQqB,gBAhBR,CAWMI,UAXN,EAWMA,UAXN,uCAWmB,CAXnB,2BAYMC,UAZN,GAgBQL,gBAhBR,CAYMK,UAZN,EAaMC,KAbN,GAgBQN,gBAhBR,CAaMM,KAbN,EAcMC,IAdN,GAgBQP,gBAhBR,CAcMO,IAdN,0BAgBQP,gBAhBR,CAeMpB,MAfN,EAeMA,MAfN,sCAee,MAff;AAiBU4B,YAAAA,MAjBV,GAiBmB,IAAIC,UAAJ,CAAeP,MAAf,EAAuBvB,UAAvB,EAAmCyB,UAAnC,CAjBnB;AAkBUM,YAAAA,MAlBV,GAkBmB,IAAIC,WAAJ,CAAgBL,KAAK,GAAGD,UAAxB,CAlBnB;AAAA;AAAA,mBAmBU,6CAAwB,IAAII,UAAJ,CAAeC,MAAf,CAAxB,EAAgDJ,KAAhD,EAAuDD,UAAvD,EAAmEG,MAAnE,EAA2ED,IAA3E,EAAiF3B,MAAjF,CAnBV;;AAAA;AAAA,8CAoBW8B,MApBX;;AAAA;AAAA,8CAuBS,IAvBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {EXT_MESHOPT_COMPRESSION} from '../gltf-utils/gltf-constants';\nimport {isMeshoptSupported, meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\ntype GLTF_EXT_meshopt_compression = {\n  buffer: number;\n  byteOffset?: number;\n  byteLength: number;\n  byteStride: number;\n  count: number;\n  mode: 'ATTRIBUTES' | 'TRIANGLES' | 'INDICES';\n  filter?: 'NONE' | 'OCTAHEDRAL' | 'QUATERNION' | 'EXPONENTIAL';\n};\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n// Note: We have a \"soft dependency\" on DracoWriter to avoid bundling it when not needed\nexport async function decode(gltfData, options: GLTFLoaderOptions) {\n  if (!options?.gltf?.decompressMeshes || !isMeshoptSupported()) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(gltfData.json, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  const scenegraph = new GLTFScenegraph(gltfData);\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(json, index: number): Promise<ArrayBuffer | null> {\n  const bufferView = json.bufferViews[index];\n\n  const meshoptExtension =\n    bufferView.extensions &&\n    (bufferView.extensions[EXT_MESHOPT_COMPRESSION] as GLTF_EXT_meshopt_compression);\n  if (meshoptExtension) {\n    const buffer = json.buffers[meshoptExtension.buffer];\n\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n"],"file":"EXT_meshopt_compression.js"}