{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/lib/utils/globals.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/bundle.ts","webpack:////home/user/apps/loaders.gl/node_modules/process/browser.js","webpack:///./src/lib/utils/assert.js","webpack:///./src/lib/category-api/image-type.ts","webpack:///./src/lib/category-api/parsed-image-api.ts","webpack:///./src/lib/parsers/svg-utils.ts","webpack:///./src/lib/parsers/parse-to-image.ts","webpack:///./src/lib/parsers/parse-to-image-bitmap.ts","webpack:///./src/lib/category-api/binary-image-api.ts","webpack:///./src/lib/parsers/parse-image.ts","webpack:///./src/lib/parsers/parse-to-node-image.ts","webpack:///./src/image-loader.ts","webpack:///./src/lib/utils/version.ts","webpack:///./src/lib/encoders/encode-image.ts","webpack:///./src/image-writer.ts","webpack:///../loader-utils/src/lib/path-utils/file-aliases.ts","webpack:///./src/lib/texture-api/generate-url.ts","webpack:///./src/lib/texture-api/async-deep-map.ts","webpack:///./src/lib/texture-api/deep-load.ts","webpack:///./src/lib/texture-api/load-image.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","globals","self","global","document","global_","isBrowser","process","String","browser","matches","version","exec","parseFloat","g","this","Function","e","moduleExports","require","_global","loaders","assign","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","assert","condition","message","_parseImageNode","IMAGE_SUPPORTED","Image","IMAGE_BITMAP_SUPPORTED","ImageBitmap","NODE_IMAGE_SUPPORTED","Boolean","DATA_SUPPORTED","isImageTypeSupported","type","getDefaultImageType","isImage","image","getImageTypeOrNull","getImageType","format","getImageSize","getImageData","canvas","createElement","context","getContext","width","height","drawImage","data","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","isSVG","url","test","getBlob","arrayBuffer","Blob","Uint8Array","async","parseToImage","options","blobOrDataUrl","xmlText","TextDecoder","decode","btoa","getBlobOrSVGDataUrl","URL","webkitURL","objectUrl","createObjectURL","src","Promise","resolve","reject","onload","onerror","err","error","loadToImage","revokeObjectURL","EMPTY_OBJECT","imagebitmapOptionsSupported","parseToImageBitmap","blob","imagebitmapOptions","imagebitmap","isEmptyObject","createImageBitmap","console","warn","safeCreateImageBitmap","getBinaryImageMetadata","binaryData","dataView","toDataView","byteLength","getUint32","mimeType","getPngMetadata","getUint16","getUint8","tableMarkers","sofMarkers","Set","add","getJpegMarkers","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","ArrayBuffer","isView","buffer","parseImage","imageType","getLoadableImageType","parseToNodeImage","ImageLoader","id","mimeTypes","extensions","parse","tests","_encodeImageNode","qualityParamSupported","ImageWriter","jpegQuality","encode","x","y","transferFromImageBitmap","clampedArray","Uint8ClampedArray","imageData","ImageData","putImageData","drawImageToCanvas","toBlob","encodeImageInBrowser","pathPrefix","fileAliases","generateUrl","getUrl","urlOptions","baseUrl","filename","alias","startsWith","replacement","replace","resolvePath","mapSubtree","func","isArray","urlArray","promises","map","all","mapArray","values","promise","then","mapObject","deepLoad","urlTree","load","tree","asyncDeepMap","shallowLoad","response","fetch","loadImage","imageUrls","mipLevels","urls","lod","Math","floor","log2","max","getMipLevels","mipLevel","getMipmappedImageUrls","getImageUrls"],"mappings":"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","file":"dist.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","export function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","import type {ImageTypeEnum} from '../../types';\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type: string): boolean {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType(): ImageTypeEnum {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","import type {ImageType, ImageTypeEnum, ImageDataType} from '../../types';\n\nexport function isImage(image: ImageType): boolean {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image: ImageType): void {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      (image as ImageBitmap).close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image: ImageType): ImageTypeEnum {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageSize(image: ImageType): {width: number; height: number} {\n  return getImageData(image);\n}\n\nexport function getImageData(image: ImageType): ImageDataType | ImageData {\n  switch (getImageType(image)) {\n    case 'data':\n      return image as unknown as ImageData;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      // @ts-ignore\n      canvas.width = image.width;\n      // @ts-ignore\n      canvas.height = image.height;\n      // @ts-ignore\n      context.drawImage(image, 0, 0);\n      // @ts-ignore\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    const xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {\n    //   xmlText = unescape(encodeURLComponent(xmlText));\n    // }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","import {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\n/** MIME type, width and height extracted from binary compressed image data */\nexport type BinaryImageMetadata = {\n  mimeType: string;\n  width: number;\n  height: number;\n};\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(\n  binaryData: DataView | ArrayBuffer\n): BinaryImageMetadata | null {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n    0xffcf, 0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n","import {assert} from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n","import {global} from '../utils/globals';\nimport {assert} from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport const _typecheckImageLoader: LoaderWithParser = ImageLoader;\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","// Image loading/saving for browser and Node.js\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(\n  image: any,\n  options?: {[key: string]: any}\n): Promise<ArrayBuffer> {\n  options = options || {};\n  options.image = options.image || ({} as {[key: string]: any});\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise<Blob | null>((resolve) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n","// import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeImage} from './lib/encoders/encode-image';\n\nexport const ImageWriter = {\n  name: 'Images',\n  id: 'image',\n  module: 'images',\n  version: VERSION,\n  extensions: ['jpeg'],\n  options: {\n    image: {\n      mimeType: 'image/png',\n      jpegQuality: null\n    }\n  },\n  encode: encodeImage\n};\n","// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n","import {resolvePath} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\n\n// Generate a url by calling getUrl with mix of options, applying options.baseUrl\nexport function generateUrl(getUrl, options, urlOptions) {\n  // Get url\n  let url = getUrl;\n  if (typeof getUrl === 'function') {\n    url = getUrl({...options, ...urlOptions});\n  }\n  assert(typeof url === 'string');\n\n  // Apply options.baseUrl\n  const {baseUrl} = options;\n  if (baseUrl) {\n    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;\n  }\n\n  return resolvePath(url);\n}\n","/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\n\nconst isObject = (value) => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree, func, options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(object, func, options) {\n  const promises: Promise<any>[] = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray, func, options = {}) {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n","import {asyncDeepMap} from './async-deep-map';\n\nexport async function deepLoad(urlTree, load, options) {\n  return await asyncDeepMap(urlTree, (url) => shallowLoad(url, load, options));\n}\n\nexport async function shallowLoad(url, load, options) {\n  // console.error('loading', url);\n  const response = await fetch(url, options.fetch);\n  const arrayBuffer = await response.arrayBuffer();\n  return await load(arrayBuffer, options);\n}\n","import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"],"sourceRoot":""}