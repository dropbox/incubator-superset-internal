{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../worker-utils/src/lib/env-utils/assert.ts","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/lib/utils/assert.js","webpack:////home/user/apps/loaders.gl/node_modules/process/browser.js","webpack:///./src/lib/category-api/parsed-image-api.ts","webpack:///../worker-utils/src/lib/env-utils/version.ts","webpack:///./src/lib/utils/globals.ts","webpack:///./src/lib/category-api/binary-image-api.ts","webpack:///../worker-utils/src/lib/env-utils/globals.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-thread.ts","webpack:///../worker-utils/src/lib/worker-utils/get-transfer-list.ts","webpack:///./src/lib/utils/version.ts","webpack:///./src/lib/parsers/parse-image.ts","webpack:///./src/lib/category-api/image-type.ts","webpack:///./src/lib/parsers/parse-to-image.ts","webpack:///./src/lib/parsers/svg-utils.ts","webpack:///../loader-utils/src/lib/env-utils/assert.ts","webpack:///../worker-utils/src/index.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-job.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-farm.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-pool.ts","webpack:///../worker-utils/src/lib/worker-farm/worker-body.ts","webpack:///../worker-utils/src/lib/worker-api/get-worker-url.ts","webpack:///../worker-utils/src/lib/async-queue/async-queue.ts","webpack:///../loader-utils/src/lib/binary-utils/get-first-characters.ts","webpack:///../loader-utils/src/lib/binary-utils/array-buffer-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/memory-copy-utils.ts","webpack:///./src/bundle.ts","webpack:///./src/index.ts","webpack:///./src/image-loader.ts","webpack:///./src/lib/parsers/parse-to-image-bitmap.ts","webpack:///./src/lib/parsers/parse-to-node-image.ts","webpack:///./src/image-writer.ts","webpack:///./src/lib/encoders/encode-image.ts","webpack:///./src/lib/texture-api/load-image.ts","webpack:///./src/lib/texture-api/generate-url.ts","webpack:///../loader-utils/src/index.ts","webpack:///../loader-utils/src/lib/env-utils/globals.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/create-loader-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/get-loadable-worker-url.ts","webpack:///../worker-utils/src/lib/worker-api/process-on-worker.ts","webpack:///../worker-utils/src/lib/worker-utils/remove-nontransferable-options.ts","webpack:///../worker-utils/src/lib/worker-api/create-worker.ts","webpack:///../worker-utils/src/lib/worker-api/validate-worker-version.ts","webpack:///../worker-utils/src/lib/library-utils/library-utils.ts","webpack:///../loader-utils/src/lib/worker-loader-utils/parse-with-worker.ts","webpack:///../loader-utils/src/lib/parser-utils/parse-json.ts","webpack:///../loader-utils/src/lib/binary-utils/binary-copy-utils.ts","webpack:///../loader-utils/src/lib/binary-utils/encode-utils.ts","webpack:///../loader-utils/src/lib/iterators/text-iterators.ts","webpack:///../loader-utils/src/lib/iterators/async-iteration.ts","webpack:///../loader-utils/src/lib/request-utils/request-scheduler.ts","webpack:///../loader-utils/src/lib/path-utils/path.ts","webpack:///../loader-utils/src/lib/path-utils/file-aliases.ts","webpack:///../loader-utils/src/lib/binary-utils/buffer-utils.ts","webpack:///../loader-utils/src/json-loader.ts","webpack:///./src/lib/texture-api/deep-load.ts","webpack:///./src/lib/texture-api/async-deep-map.ts","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stat.js","webpack:////home/user/apps/loaders.gl/node_modules/@probe.gl/stats/dist/esm/lib/stats.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","condition","message","Error","getHiResTimestamp","timestamp","window","performance","now","process","hrtime","timeParts","Date","g","this","Function","e","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","getImageType","image","format","getImageTypeOrNull","getImageData","canvas","document","createElement","context","getContext","width","height","drawImage","ImageBitmap","Image","data","Boolean","close","globals","self","global","self_","window_","global_","document_","isBrowser","String","isWorker","importScripts","matches","exec","nodeVersion","parseFloat","binaryData","dataView","toDataView","byteLength","getUint32","mimeType","getPngMetadata","getUint16","getUint8","tableMarkers","Set","add","sofMarkers","getJpegMarkers","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","ArrayBuffer","isView","buffer","isMobile","orientation","NOOP","WorkerThread","props","source","url","assert","onMessage","onError","error","console","log","worker","_createBrowserWorker","Worker","terminate","terminated","transferList","getTransferList","postMessage","event","lineno","colno","_loadableURL","getLoadableWorkerURL","onmessage","onerror","_getErrorFromErrorEvent","onmessageerror","isTransferable","MessagePort","OffscreenCanvas","recursive","transfers","transfersSet","undefined","from","arrayBuffer","options","imageOptions","imageType","type","loadType","getLoadableImageType","getDefaultImageType","isImageTypeSupported","IMAGE_BITMAP_SUPPORTED","IMAGE_SUPPORTED","DATA_SUPPORTED","_parseImageNode","NODE_IMAGE_SUPPORTED","blobOrDataUrl","getBlobOrSVGDataUrl","URL","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","src","decode","Promise","resolve","reject","onload","err","isSVG","xmlText","TextDecoder","btoa","getBlob","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","test","Blob","Uint8Array","NullWorker","id","VERSION","null","WorkerJob","jobName","workerThread","isRunning","_resolve","_reject","result","payload","DEFAULT_PROPS","maxConcurrency","maxMobileConcurrency","onDebug","reuseWorkers","WorkerFarm","Map","setProps","workerPools","isSupported","_workerFarm","values","destroy","_getWorkerPoolProps","workerPool","WorkerPool","set","idleQueue","forEach","isDestroyed","job","done","startPromise","onStart","jobQueue","_startQueuedJob","_getAvailableWorker","queuedJob","shift","backlog","returnWorkerToQueue","count","_getMaxConcurrency","toLowerCase","onMessageWrapperMap","WorkerBody","isKnownMessage","onMessageWrapper","addEventListener","removeEventListener","startsWith","warning","workerOptions","workerFile","workerUrl","_workerType","versionTag","asyncIterator","AsyncQueue","_values","_settlers","_closed","enqueue","settler","getMagicString","byteOffset","magic","fromCharCode","slice","node","toArrayBuffer","text","TextEncoder","encode","_toArrayBuffer","arrayBuffer1","arrayBuffer2","array1","array2","sources","sourceArrays","map","source2","reduce","typedArray","offset","sourceArray","typedArrays","arrays","TypedArrayConstructor","constructor","sumLength","acc","subArray","subarray","targetBuffer","sourceBuffer","targetArray","target","targetOffset","srcByteOffset","srcByteLength","padToNBytes","padding","moduleExports","require","_global","loaders","assign","ImageLoader","mimeTypes","extensions","parse","parseImage","tests","getBinaryImageMetadata","_typecheckImageLoader","EMPTY_OBJECT","imagebitmapOptionsSupported","blob","imagebitmapOptions","imagebitmap","safeCreateImageBitmap","isEmptyObject","createImageBitmap","warn","ImageWriter","jpegQuality","encodeImage","_encodeImageNode","encodeImageInBrowser","qualityParamSupported","getImageSize","drawImageToCanvas","toBlob","x","y","transferFromImageBitmap","clampedArray","Uint8ClampedArray","imageData","ImageData","putImageData","getUrl","getImageUrls","imageUrls","deepLoad","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","lod","shallowLoad","getMipLevels","mipLevel","Math","floor","log2","max","baseUrl","resolvePath","loader","input","parseData","parseOnMainThread","requestId","parseSync","parser","parseTextSync","textDecoder","workerURL","workerURLCache","getLoadableWorkerURLFromSource","getLoadableWorkerURLFromURL","workerSource","getWorkerName","getWorkerURL","workerFarm","getWorkerFarm","getWorkerPool","startJob","transferableOptions","removeNontransferableOptions","JSON","v","cache","stringify","processInBatches","processOnMainThread","inputBatches","resultIterator","batch","coreVersion","workerVersion","loadLibraryPromises","libraryUrl","moduleName","getLibraryUrl","loadLibraryFromFile","library","CDN","endsWith","fetch","response","requireFromFile","scriptSource","loadLibraryFromString","requireFromString","eval","script","appendChild","createTextNode","body","string","_","getFirstCharacters","stringBuffer","copyPaddedArrayBufferToDataView","paddedLength","padLength","setUint8","byteAlignment","ceil","whitespace","charCodeAt","binary","arrayBufferIterator","stream","textIterator","textEncoder","previous","eolIndex","indexOf","line","lineIterator","counter","iterator","visitor","next","arrayBuffers","chunk","concatenateArrayBuffers","strings","join","throttleRequests","maxRequests","RequestScheduler","stats","Stats","handle","getPriority","requestMap","request","priority","promise","requestQueue","_issueNewRequests","isDone","activeRequestCount","deferredUpdate","_issueNewRequestsAsync","freeSlots","_updateAllRequests","_issueRequest","_updateRequest","splice","sort","a","b","slashIndex","lastIndexOf","substr","parts","separator","part","index","replace","RegExp","prefix","pathPrefix","aliases","fileAliases","filename","alias","replacement","isBuffer","toBuffer","JSONLoader","category","_typecheckJSONLoader","urlTree","load","asyncDeepMap","isObject","tree","func","mapSubtree","isArray","mapArray","mapObject","promises","then","all","urlArray","sampleSize","reset","samples","addCount","subtractCount","_count","_samples","_checkSampling","time","_time","lastTiming","_startTime","_timerPending","addTime","lastSampleCount","lastSampleTime","_initializeStats","seal","_getOrCreate","keys","fn","table","stat","average","getAverageTime","hz","getHz"],"mappings":"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","file":"dist.es5.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 29);\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n","export default function getHiResTimestamp() {\n  let timestamp;\n\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n//# sourceMappingURL=hi-res-timestamp.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import type {ImageType, ImageTypeEnum, ImageDataType} from '../../types';\n\nexport function isImage(image: ImageType): boolean {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image: ImageType): void {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      (image as ImageBitmap).close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image: ImageType): ImageTypeEnum {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageSize(image: ImageType): {width: number; height: number} {\n  return getImageData(image);\n}\n\nexport function getImageData(image: ImageType): ImageDataType | ImageData {\n  switch (getImageType(image)) {\n    case 'data':\n      return image as unknown as ImageData;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      // @ts-ignore\n      canvas.width = image.width;\n      // @ts-ignore\n      canvas.height = image.height;\n      // @ts-ignore\n      context.drawImage(image, 0, 0);\n      // @ts-ignore\n      return context.getImageData(0, 0, image.width, image.height);\n\n    default:\n      throw new Error('getImageData');\n  }\n}\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'beta';\ndeclare let __VERSION__;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\n/** MIME type, width and height extracted from binary compressed image data */\nexport type BinaryImageMetadata = {\n  mimeType: string;\n  width: number;\n  height: number;\n};\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(\n  binaryData: DataView | ArrayBuffer\n): BinaryImageMetadata | null {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n    0xffcf, 0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n","// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","import {assert} from '../env-utils/assert';\nimport {getLoadableWorkerURL} from '../worker-utils/get-loadable-worker-url';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst NOOP = () => {};\n\nexport type WorkerThreadProps = {\n  name: string;\n  source?: string;\n  url?: string;\n};\n\n/**\n * Represents one worker thread\n */\nexport default class WorkerThread {\n  readonly name: string;\n  readonly source: string | undefined;\n  readonly url: string | undefined;\n  terminated: boolean = false;\n  worker: Worker;\n  onMessage: (message: any) => void;\n  onError: (error: Error) => void;\n\n  private _loadableURL: string = '';\n\n  static isSupported(): boolean {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor(props: WorkerThreadProps) {\n    const {name, source, url} = props;\n    assert(source || url); // Either source or url must be defined\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = (error) => console.log(error); // eslint-disable-line\n\n    this.worker = this._createBrowserWorker();\n  }\n\n  /**\n   * Terminate this worker thread\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    // @ts-ignore\n    this.worker.terminate();\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  /**\n   * Send a message to this worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   * @param transferList If not supplied, calculated automatically by traversing data\n   */\n  postMessage(data: any, transferList?: any[]): void {\n    transferList = transferList || getTransferList(data);\n    // @ts-ignore\n    this.worker.postMessage(data, transferList);\n  }\n\n  // PRIVATE\n\n  /**\n   * Generate a standard Error from an ErrorEvent\n   * @param {ErrorEvent} event\n   */\n  _getErrorFromErrorEvent(event) {\n    // Note Error object does not have the expected fields if loading failed completely\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n    // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n    let message = 'Failed to load ';\n    message += `worker ${this.name}. `;\n    if (event.message) {\n      message += `${event.message} in `;\n    }\n    // const hasFilename = event.filename && !event.filename.startsWith('blob:');\n    // message += hasFilename ? event.filename : this.source.slice(0, 100);\n    if (event.lineno) {\n      message += `:${event.lineno}:${event.colno}`;\n    }\n    return new Error(message);\n  }\n\n  /**\n   * Creates a worker thread on the browser\n   */\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({source: this.source, url: this.url});\n    const worker = new Worker(this._loadableURL, {name: this.name});\n\n    worker.onmessage = (event) => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    // This callback represents an uncaught exception in the worker thread\n    worker.onerror = (error) => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    // TODO - not clear when this would be called, for now just log in case it happens\n    worker.onmessageerror = (event) => console.error(event); // eslint-disable-line\n\n    return worker;\n  }\n}\n","// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import {assert} from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n","import type {ImageTypeEnum} from '../../types';\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type: string): boolean {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType(): ImageTypeEnum {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","import {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    const xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {\n    //   xmlText = unescape(encodeURLComponent(xmlText));\n    // }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport WorkerThread from './worker-thread';\nimport {assert} from '../env-utils/assert';\n\n/**\n * Represents one Job handled by a WorkerPool or WorkerFarm\n */\nexport default class WorkerJob {\n  readonly name: string;\n  readonly workerThread: WorkerThread;\n  isRunning: boolean;\n  /** Promise that resolves when Job is done */\n  readonly result: Promise<any>;\n\n  private _resolve: (value: any) => void;\n  private _reject: (reason?: any) => void;\n\n  constructor(jobName: string, workerThread: WorkerThread) {\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.isRunning = true;\n    this._resolve = () => {};\n    this._reject = () => {};\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * Send a message to the job's worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   */\n  postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    this.workerThread.postMessage({\n      source: 'loaders.gl', // Lets worker ignore unrelated messages\n      type,\n      payload\n    });\n  }\n\n  /**\n   * Call to resolve the `result` Promise with the supplied value\n   */\n  done(value): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  /**\n   * Call to reject the `result` Promise with the supplied error\n   */\n  error(error): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n","import WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\n/**\n * @param maxConcurrency {number} - max count of workers\n */\nexport type WorkerFarmProps = {\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  reuseWorkers?: boolean;\n  onDebug?: () => void;\n};\n\nconst DEFAULT_PROPS: WorkerFarmProps = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  onDebug: () => {},\n  reuseWorkers: true\n};\n\n/**\n * Process multiple jobs with a \"farm\" of different workers in worker pools.\n */\nexport default class WorkerFarm {\n  private props: WorkerFarmProps;\n  private workerPools = new Map<string, WorkerPool>();\n  // singleton\n  private static _workerFarm?: WorkerFarm;\n\n  /** Check if Workers are supported */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /** Get the singleton instance of the global worker farm */\n  static getWorkerFarm(props: WorkerFarmProps = {}): WorkerFarm {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  /** get global instance with WorkerFarm.getWorkerFarm() */\n  private constructor(props: WorkerFarmProps) {\n    this.props = {...DEFAULT_PROPS};\n    this.setProps(props);\n    /** @type Map<string, WorkerPool>} */\n    this.workerPools = new Map();\n  }\n\n  /**\n   * Terminate all workers in the farm\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n  }\n\n  /**\n   * Set props used when initializing worker pools\n   * @param props\n   */\n  setProps(props: WorkerFarmProps): void {\n    this.props = {...this.props, ...props};\n    // Update worker pool props\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  /**\n   * Returns a worker pool for the specified worker\n   * @param options - only used first time for a specific worker name\n   * @param options.name - the name of the worker - used to identify worker pool\n   * @param options.url -\n   * @param options.source -\n   * @example\n   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);\n   */\n  getWorkerPool(options: {name: string; source?: string; url?: string}): WorkerPool {\n    const {name, source, url} = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n","import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n","import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    // eslint-disable-next-line no-restricted-globals\n    self.onmessage = (message) => {\n      if (!isKnownMessage(message)) {\n        return;\n      }\n\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = message.data;\n      onMessage(type, payload);\n    };\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('message', onMessageWrapper);\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    // eslint-disable-next-line no-restricted-globals\n    self.removeEventListener('message', onMessageWrapper);\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    if (self) {\n      const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n      const transferList = getTransferList(payload);\n      // eslint-disable-next-line no-restricted-globals\n      // @ts-ignore\n      self.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n","import type {WorkerObject, WorkerOptions} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\nconst NPM_TAG = 'latest';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : NPM_TAG;\n\n/**\n * Gets worker object's name (for debugging in Chrome thread inspector window)\n */\nexport function getWorkerName(worker: WorkerObject): string {\n  const warning = worker.version !== VERSION ? ` (worker-utils@${VERSION})` : '';\n  return `${worker.name}@${worker.version}${warning}`;\n}\n\n/**\n * Generate a worker URL based on worker object and options\n * @returns A URL to one of the following:\n * - a published worker on unpkg CDN\n * - a local test worker\n * - a URL provided by the user in options\n */\nexport function getWorkerURL(worker: WorkerObject, options: WorkerOptions = {}): string {\n  const workerOptions = options[worker.id] || {};\n\n  const workerFile = `${worker.id}-worker.js`;\n\n  let url = workerOptions.workerUrl;\n\n  // If URL is test, generate local loaders.gl url\n  // @ts-ignore _workerType\n  if (options._workerType === 'test') {\n    url = `modules/${worker.module}/dist/${workerFile}`;\n  }\n\n  // If url override is not provided, generate a URL to published version on npm CDN unpkg.com\n  if (!url) {\n    // GENERATE\n    let version = worker.version;\n    // On master we need to load npm alpha releases published with the `beta` tag\n    if (version === 'latest') {\n      // throw new Error('latest worker version specified');\n      version = NPM_TAG;\n    }\n    const versionTag = version ? `@${version}` : '';\n    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;\n  }\n\n  assert(url);\n\n  // Allow user to override location\n  return url;\n}\n","// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n","export function getFirstCharacters(data, length = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n","import {TypedArray} from '../../types';\nimport * as node from '../node/buffer-utils.node';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n","import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","// TYPES\nexport type {ImageDataType, ImageType, ImageTypeEnum} from './types';\n\n// LOADERS AND WRITERS\nexport {ImageLoader} from './image-loader';\nexport {ImageWriter} from './image-writer';\n\n// IMAGE CATEGORY API\n\n// Binary Image API\nexport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\n// Parsed Image API\nexport {isImageTypeSupported, getDefaultImageType} from './lib/category-api/image-type';\n\nexport {\n  isImage,\n  getImageType,\n  getImageSize,\n  getImageData\n} from './lib/category-api/parsed-image-api';\n\n// DEPRECATED - Remove in V3 (fix dependency in luma.gl)\nexport {loadImage} from './lib/texture-api/load-image';\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport const _typecheckImageLoader: LoaderWithParser = ImageLoader;\n","import {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n","import {global} from '../utils/globals';\nimport {assert} from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n","// import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeImage} from './lib/encoders/encode-image';\n\nexport const ImageWriter = {\n  name: 'Images',\n  id: 'image',\n  module: 'images',\n  version: VERSION,\n  extensions: ['jpeg'],\n  options: {\n    image: {\n      mimeType: 'image/png',\n      jpegQuality: null\n    }\n  },\n  encode: encodeImage\n};\n","// Image loading/saving for browser and Node.js\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(\n  image: any,\n  options?: {[key: string]: any}\n): Promise<ArrayBuffer> {\n  options = options || {};\n  options.image = options.image || ({} as {[key: string]: any});\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise<Blob | null>((resolve) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n","import {assert} from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n","import {resolvePath} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\n\n// Generate a url by calling getUrl with mix of options, applying options.baseUrl\nexport function generateUrl(getUrl, options, urlOptions) {\n  // Get url\n  let url = getUrl;\n  if (typeof getUrl === 'function') {\n    url = getUrl({...options, ...urlOptions});\n  }\n  assert(typeof url === 'string');\n\n  // Apply options.baseUrl\n  const {baseUrl} = options;\n  if (baseUrl) {\n    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;\n  }\n\n  return resolvePath(url);\n}\n","// TYPES\nexport type {\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions,\n  Writer,\n  WriterOptions,\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  IFileSystem,\n  IRandomAccessReadFileSystem\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {\n  isBrowser,\n  isWorker,\n  nodeVersion,\n  self,\n  window,\n  global,\n  document\n} from './lib/env-utils/globals';\n\n// LOADERS.GL-SPECIFIC WORKER UTILS\nexport {createLoaderWorker} from './lib/worker-loader-utils/create-loader-worker';\nexport {parseWithWorker, canParseWithWorker} from './lib/worker-loader-utils/parse-with-worker';\n\n// PARSER UTILS\nexport {parseJSON} from './lib/parser-utils/parse-json';\n\n// MEMORY COPY UTILS\nexport {\n  toArrayBuffer,\n  sliceArrayBuffer,\n  concatenateArrayBuffers,\n  concatenateTypedArrays,\n  compareArrayBuffers\n} from './lib/binary-utils/array-buffer-utils';\nexport {padToNBytes, copyToArray, copyArrayBuffer} from './lib/binary-utils/memory-copy-utils';\nexport {\n  copyPaddedArrayBufferToDataView,\n  copyPaddedStringToDataView\n} from './lib/binary-utils/binary-copy-utils';\nexport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from './lib/binary-utils/encode-utils';\nexport {getFirstCharacters, getMagicString} from './lib/binary-utils/get-first-characters';\n\n// ITERATOR UTILS\nexport {\n  makeTextEncoderIterator,\n  makeTextDecoderIterator,\n  makeLineIterator,\n  makeNumberedLineIterator\n} from './lib/iterators/text-iterators';\nexport {forEach, concatenateArrayBuffersAsync} from './lib/iterators/async-iteration';\n\n// REQUEST UTILS\nexport {default as RequestScheduler} from './lib/request-utils/request-scheduler';\n\n// NODE `path`` REPLACEMENT\nimport * as path from './lib/path-utils/path';\nexport {path};\nexport {setPathPrefix, getPathPrefix, resolvePath} from './lib/path-utils/file-aliases';\nexport {addAliases as _addAliases} from './lib/path-utils/file-aliases';\n\n// NODE `fs` WRAPPERS\nimport * as fs from './lib/node/fs';\nexport {fs};\n\n// NODE `buffer` WRAPPERS\nexport {isBuffer, toBuffer, bufferToArrayBuffer} from './lib/binary-utils/buffer-utils';\n\nexport {JSONLoader} from './json-loader';\n","// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\ntype obj = {[key: string]: any};\nconst self_: obj = globals.self || globals.window || globals.global || {};\nconst window_: obj = globals.window || globals.self || globals.global || {};\nconst global_: obj = globals.global || globals.self || globals.window || {};\nconst document_: obj = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in a browser */\nexport const isBrowser: boolean =\n  // @ts-ignore process does not exist on browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running in a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n","import {assert} from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props: {source?: string; url?: string}) {\n  assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    // Differentiate worker urls from worker source code\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert(workerURL);\n  return workerURL;\n}\n\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url: string): string {\n  // A local script url, we can use it to initialize a Worker directly\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  // A remote script, we need to use `importScripts` to load from different origin\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource: string): string {\n  // NOTE: webworkify was previously used\n  // const blob = webworkify(workerSource, {bare: true});\n  const blob = new Blob([workerSource], {type: 'application/javascript'});\n  return URL.createObjectURL(blob);\n}\n\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl: string): string {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n","import type {\n  WorkerObject,\n  WorkerOptions,\n  WorkerContext,\n  WorkerMessageType,\n  WorkerMessagePayload\n} from '../../types';\nimport type WorkerJob from '../worker-farm/worker-job';\nimport WorkerFarm from '../worker-farm/worker-farm';\nimport {removeNontransferableOptions} from '../worker-utils/remove-nontransferable-options';\nimport {getWorkerURL, getWorkerName} from './get-worker-url';\n\ntype ProcessOnWorkerOptions = WorkerOptions & {\n  jobName?: string;\n  [key: string]: any;\n};\n\n/**\n * Determines if we can parse with worker\n * @param loader\n * @param data\n * @param options\n */\nexport function canProcessOnWorker(worker: WorkerObject, options?: WorkerOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return worker.worker && options?.worker;\n}\n\n/**\n * This function expects that the worker thread sends certain messages,\n * Creating such a worker can be automated if the worker is wrapper by a call to\n * createWorker in @loaders.gl/worker-utils.\n */\nexport async function processOnWorker(\n  worker: WorkerObject,\n  data: any,\n  options: ProcessOnWorkerOptions = {},\n  context: WorkerContext = {}\n): Promise<any> {\n  const name = getWorkerName(worker);\n  const url = getWorkerURL(worker, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(\n    jobName,\n    // eslint-disable-next-line\n    onMessage.bind(null, context)\n  );\n\n  // Kick off the processing in the worker\n  const transferableOptions = removeNontransferableOptions(options);\n  job.postMessage('process', {input: data, options: transferableOptions});\n\n  const result = await job.result;\n  return result.result;\n}\n\n/**\n * Job completes when we receive the result\n * @param job\n * @param message\n */\nasync function onMessage(\n  context: WorkerContext,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      // Worker is done\n      job.done(payload);\n      break;\n\n    case 'error':\n      // Worker encountered an error\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for us (main thread) to process something\n      const {id, input, options} = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {id, error: 'Worker not set up to process on main thread'});\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`process-on-worker: unknown message ${type}`);\n  }\n}\n","/**\n * Safely stringify JSON (drop non serializable values like functions and regexps)\n * @param value\n */\nexport function removeNontransferableOptions(object: object): object {\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  // TODO - warn if options stringification is long\n  return JSON.parse(stringifyJSON(object));\n}\n\nfunction stringifyJSON(v) {\n  const cache = new Set();\n  return JSON.stringify(v, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        // Circular reference found\n        try {\n          // If this value does not reference a parent it can be deduped\n          return JSON.parse(JSON.stringify(value));\n        } catch (err) {\n          // discard key if value cannot be deduped\n          return undefined;\n        }\n      }\n      // Store value in our set\n      cache.add(value);\n    }\n    return value;\n  });\n}\n","import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n\nexport type ProcessOnMainThread = (data: any, options?: {[key: string]: any}, context?) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context?.processInBatches);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n","import type {WorkerObject} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\n/**\n * Check if worker is compatible with this library version\n * @param worker\n * @param libVersion\n * @returns `true` if the two versions are compatible\n */\nexport function validateWorkerVersion(\n  worker: WorkerObject,\n  coreVersion: string = VERSION\n): boolean {\n  assert(worker, 'no worker provided');\n\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  // TODO enable when fix the __version__ injection\n  // const coreVersions = parseVersion(coreVersion);\n  // const workerVersions = parseVersion(workerVersion);\n  // assert(\n  //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,\n  //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n\n  return true;\n}\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n","/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName?: string, options?): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && (await node.requireFromFile(libraryUrl));\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n","import type {WorkerJob, WorkerMessageType, WorkerMessagePayload} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // eslint-disable-next-line\n    onMessage.bind(null, parseOnMainThread)\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options\n  });\n\n  const result = await job.result;\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(payload.error);\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n","import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n/**\n * Minimal JSON parser that throws more meaningful error messages\n */\nexport function parseJSON(string: string): any {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n","import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n","// Note: These were broken out from gltf loader...\n// eslint-disable-next-line complexity\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n","// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n","import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n","import {Stats} from '@probe.gl/stats';\n\ntype Handle = any;\ntype DoneFunction = () => any;\ntype GetPriorityFunction = () => number;\ntype RequestResult = {\n  done: DoneFunction;\n} | null;\n\n/** RequestScheduler Options */\nexport type RequestSchedulerProps = {\n  id?: string;\n  throttleRequests?: boolean;\n  maxRequests?: number;\n};\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS: Required<RequestSchedulerProps> = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n/** Tracks one request */\ntype Request = {\n  handle: Handle;\n  priority: number;\n  getPriority: GetPriorityFunction;\n  resolve?: (value: any) => any;\n};\n\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  readonly props: Required<RequestSchedulerProps>;\n  readonly stats: Stats;\n  activeRequestCount: number = 0;\n\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  private requestQueue: Request[] = [];\n  private requestMap: Map<Handle, Promise<RequestResult>> = new Map();\n  private deferredUpdate: any = null;\n\n  constructor(props: RequestSchedulerProps = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: this.props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(\n    handle: Handle,\n    getPriority: GetPriorityFunction = () => 0\n  ): Promise<RequestResult> {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle) as Promise<any>;\n    }\n\n    const request: Request = {handle, priority: 0, getPriority};\n    const promise = new Promise<RequestResult>((resolve) => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request: Request): Promise<any> {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests(): void {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    // TODO - shouldn't we clear the timeout?\n    this.deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n","// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex as number) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n","// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n","import * as node from '../node/buffer-utils.node';\n\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value: any): boolean {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data: any): Buffer {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/**\n * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function bufferToArrayBuffer(data: any): ArrayBuffer {\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    return node.toArrayBuffer(data);\n  }\n  return data;\n}\n","import type {LoaderWithParser} from './types';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n/**\n * A JSON Micro loader (minimal bundle size)\n * Alternative to `@loaders.gl/json`\n */\nexport const JSONLoader = {\n  name: 'JSON',\n  id: 'json',\n  module: 'json',\n  version: VERSION,\n  extensions: ['json', 'geojson'],\n  mimeTypes: ['application/json'],\n  category: 'json',\n  text: true,\n  parseTextSync,\n  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),\n  options: {}\n};\n\n// TODO - deprecated\nfunction parseTextSync(text) {\n  return JSON.parse(text);\n}\n\nexport const _typecheckJSONLoader: LoaderWithParser = JSONLoader;\n","import {asyncDeepMap} from './async-deep-map';\n\nexport async function deepLoad(urlTree, load, options) {\n  return await asyncDeepMap(urlTree, (url) => shallowLoad(url, load, options));\n}\n\nexport async function shallowLoad(url, load, options) {\n  // console.error('loading', url);\n  const response = await fetch(url, options.fetch);\n  const arrayBuffer = await response.arrayBuffer();\n  return await load(arrayBuffer, options);\n}\n","/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\n\nconst isObject = (value) => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree, func, options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(object, func, options) {\n  const promises: Promise<any>[] = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray, func, options = {}) {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n","import getHiResTimestamp from '../utils/hi-res-timestamp';\nexport default class Stat {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n    this.sampleSize = 1;\n    this.reset();\n  }\n\n  setSampleSize(samples) {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  incrementCount() {\n    this.addCount(1);\n    return this;\n  }\n\n  decrementCount() {\n    this.subtractCount(1);\n    return this;\n  }\n\n  addCount(value) {\n    this._count += value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  subtractCount(value) {\n    this._count -= value;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  addTime(time) {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  timeStart() {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n    return this;\n  }\n\n  timeEnd() {\n    if (!this._timerPending) {\n      return this;\n    }\n\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset() {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n    return this;\n  }\n\n  _checkSampling() {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n\n}\n//# sourceMappingURL=stat.js.map","import Stat from './stat';\nexport default class Stats {\n  constructor({\n    id,\n    stats\n  }) {\n    this.id = id;\n    this.stats = {};\n\n    this._initializeStats(stats);\n\n    Object.seal(this);\n  }\n\n  get(name, type = 'count') {\n    return this._getOrCreate({\n      name,\n      type\n    });\n  }\n\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n\n  reset() {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn) {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable() {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n    return table;\n  }\n\n  _initializeStats(stats = []) {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat) {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {\n      name,\n      type\n    } = stat;\n\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n\n    return this.stats[name];\n  }\n\n}\n//# sourceMappingURL=stats.js.map"],"sourceRoot":""}