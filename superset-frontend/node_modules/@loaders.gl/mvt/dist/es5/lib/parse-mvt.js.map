{"version":3,"sources":["../../../src/lib/parse-mvt.js"],"names":["parseMVT","arrayBuffer","options","normalizeOptions","binary","gis","format","features","firstPassData","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","byteLength","tile","BinaryVectorTile","Protobuf","VectorTile","loaderOptions","mvt","selectedLayers","Array","isArray","layers","Object","keys","forEach","layerName","vectorTileLayer","featureOptions","i","length","vectorTileFeature","feature","decodedFeature","getDecodedFeatureBinary","getDecodedFeature","push","data","wgs84Coordinates","coordinates","tileIndex","hasTileIndex","Number","isFinite","x","y","z","Error","toGeoJSON","transformToLocalCoordinates","layerProperty","properties","toBinaryCoordinates","transformToLocalCoordinatesBinary","line","extent","p","il"],"mappings":"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","sourcesContent":["// import {VectorTile} from '@mapbox/vector-tile';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\n\nimport {featuresToBinary} from './binary-vector-tile/features-to-binary';\nimport Protobuf from 'pbf';\n\n/*\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param {arrayBuffer} _ A MVT arrayBuffer\n * @return {?Object} A GeoJSON geometry object or a binary representation\n */\nexport default function parseMVT(arrayBuffer, options) {\n  options = normalizeOptions(options);\n\n  const binary = options.gis.format === 'binary';\n  const features = [];\n  const firstPassData = {\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n\n  if (arrayBuffer.byteLength > 0) {\n    const tile = binary\n      ? new BinaryVectorTile(new Protobuf(arrayBuffer))\n      : new VectorTile(new Protobuf(arrayBuffer));\n    const loaderOptions = options.mvt;\n\n    const selectedLayers = Array.isArray(loaderOptions.layers)\n      ? loaderOptions.layers\n      : Object.keys(tile.layers);\n\n    selectedLayers.forEach((layerName) => {\n      const vectorTileLayer = tile.layers[layerName];\n      const featureOptions = {...loaderOptions, layerName};\n\n      if (!vectorTileLayer) {\n        return;\n      }\n\n      for (let i = 0; i < vectorTileLayer.length; i++) {\n        const vectorTileFeature = vectorTileLayer.feature(i, firstPassData);\n\n        const decodedFeature = binary\n          ? getDecodedFeatureBinary(vectorTileFeature, featureOptions)\n          : getDecodedFeature(vectorTileFeature, featureOptions);\n        features.push(decodedFeature);\n      }\n    });\n  }\n\n  if (binary) {\n    const data = featuresToBinary(features, firstPassData, options.gis);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    data.byteLength = arrayBuffer.byteLength;\n    return data;\n  }\n\n  return features;\n}\n\nfunction normalizeOptions(options) {\n  options = {\n    ...options,\n    mvt: options.mvt || {},\n    gis: options.gis || {}\n  };\n\n  // Validate\n  const wgs84Coordinates = options.coordinates === 'wgs84';\n  const {tileIndex} = options;\n  const hasTileIndex =\n    tileIndex &&\n    Number.isFinite(tileIndex.x) &&\n    Number.isFinite(tileIndex.y) &&\n    Number.isFinite(tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  return options;\n}\n\nfunction getDecodedFeature(feature, options = {}) {\n  const decodedFeature = feature.toGeoJSON(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction getDecodedFeatureBinary(feature, options = {}) {\n  const decodedFeature = feature.toBinaryCoordinates(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction transformToLocalCoordinates(line, feature) {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n  const {extent} = feature;\n\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data, feature) {\n  // For the binary code path, the feature data is just\n  // one big flat array, so we just divide each value\n  const {extent} = feature;\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}\n"],"file":"parse-mvt.js"}