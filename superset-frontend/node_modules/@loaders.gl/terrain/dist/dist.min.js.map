{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/bundle.ts","webpack:///(webpack)/buildin/global.js","webpack:///../schema/src/category/mesh/mesh-utils.ts","webpack:///./src/lib/decode-quantized-mesh.js","webpack:///../loader-utils/src/lib/binary-utils/array-buffer-utils.ts","webpack:///./src/lib/helpers/skirt.js","webpack:///./src/lib/parse-quantized-mesh.js","webpack:////home/user/apps/loaders.gl/node_modules/@mapbox/martini/index.js","webpack:///./src/lib/delatin/index.js","webpack:///./src/lib/parse-terrain.js","webpack:///./src/lib/utils/version.js","webpack:///./src/terrain-loader.ts","webpack:///./src/quantized-mesh-loader.ts","webpack:///./src/index.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","moduleExports","require","_global","global","loaders","assign","g","this","Function","e","getMeshBoundingBox","attributes","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","POSITION","len","length","x","y","z","QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","decodeIndex","buffer","position","indicesCount","bytesPerIndex","encoded","indices","Uint16Array","Uint32Array","highest","code","decodeWaterMaskExtension","extensionDataView","slice","byteOffset","byteLength","DECODING_STEPS","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","view","DataView","header","headerEndPosition","dataView","bytesCount","getFloat64","getFloat32","decodeHeader","vertexData","vertexDataEndPosition","vertexCount","getUint32","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","getUint16","decodeVertexData","triangleIndices","triangleIndicesEndPosition","triangleCount","triangleIndicesCount","decodeTriangleIndices","westIndices","southIndices","eastIndices","northIndices","edgeIndicesEndPosition","westVertexCount","southVertexCount","eastVertexCount","northVertexCount","decodeEdgeIndices","extensions","indicesEndPosition","extensionsEndPosition","extensionId","getUint8","Uint8Array","extensionLength","extensionView","vertexNormals","waterMask","decodeExtensions","concatenateTypedArrays","typedArrays","arrays","TypedArrayConstructor","constructor","Error","result","reduce","acc","offset","array","set","addSkirt","triangles","skirtHeight","outsideIndices","outsideEdges","sort","b","edges","index","indexGroup","push","getOutsideEdgesFromIndices","Math","min","max","getOutsideEdgesFromTriangles","newPosition","newTexcoord0","TEXCOORD_0","newTriangles","updateAttributesForNewEdge","edge","edgeIndex","Array","concat","positionsLength","vertex1Offset","vertex2Offset","subarray","triangle1Offset","getTileMesh","arrayBuffer","bounds","originalTriangleIndices","minHeight","maxHeight","xScale","yScale","zScale","nCoords","texCoords","size","getMeshAttributes","boundingBox","newAttributes","loaderData","loadQuantizedMesh","Martini","gridSize","tileSize","numTriangles","numParentTriangles","coords","id","ax","ay","bx","by","cx","cy","mx","my","k","terrain","Tile","martini","errors","update","interpolatedHeight","middleIndex","middleError","abs","leftChildIndex","rightChildIndex","maxError","numVertices","countElements","fill","vertices","triIndex","processTriangle","Delatin","width","_halfedges","_candidates","_queueIndices","_queue","_errors","_rms","_pending","_pendingLen","_rmsSum","x1","y1","p0","_addPoint","p1","p2","p3","t0","_addTriangle","_flush","run","getMaxError","refine","_step","getRMSD","sqrt","heightAt","_findCandidate","p0x","p0y","p1x","p1y","p2x","p2y","w00","orient","w01","w02","a01","b01","a12","b12","a20","b20","z0","z1","z2","rms","dx","floor","w0","w1","w2","wasInside","dz","_queuePush","_queuePop","e0","e1","e2","px","py","pn","_handleCollinear","h0","h1","h2","t1","t2","_legalize","ab","bc","ca","a0","b0","al","ar","bl","br","pr","pl","dy","ex","ey","fx","fy","bp","cp","inCircle","hal","har","hbl","hbr","_queueRemove","t3","error","_queueUp","_queueSwap","_queueDown","_queuePopBack","pop","it","indexOf","_queueLess","j","pi","pj","j0","i0","j1","j2","getTerrain","imageData","elevationDecoder","tesselator","rScaler","bScaler","gScaler","getMesh","terrainImage","terrainOptions","meshMaxError","mesh","getMartiniTileMesh","getDelatinTileMesh","numOfVerticies","pixelIdx","from","tile","createTile","tin","TerrainLoader","version","worker","mimeTypes","QuantizedMeshLoader","TerrainWorkerLoader","parse","async","context","image","type","baseUri","_typecheckTerrainLoader","QuantizedMeshWorkerLoader","parseSync","parseQuantizedMesh","_typecheckQuantizedMeshLoader"],"mappings":"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","file":"dist.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n","import {TypedArray} from '../../types';\nimport * as node from '../node/buffer-utils.node';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n","import {concatenateTypedArrays} from '@loaders.gl/loader-utils';\n\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param {number} skirtHeight - height of the skirt geometry\n * @param {object} outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices = null) {\n  const outsideEdges = outsideIndices\n    ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value)\n    : getOutsideEdgesFromTriangles(triangles);\n\n  // 2 new vertices for each outside edge\n  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n\n  // 2 new triangles for each outside edge\n  const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n\n  for (let i = 0; i < outsideEdges.length; i++) {\n    const edge = outsideEdges[i];\n\n    updateAttributesForNewEdge({\n      edge,\n      edgeIndex: i,\n      attributes,\n      skirtHeight,\n      newPosition,\n      newTexcoord0,\n      newTriangles\n    });\n  }\n\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  const resultTriangles =\n    triangles instanceof Array\n      ? triangles.concat(newTriangles)\n      : concatenateTypedArrays(triangles, newTriangles);\n\n  return {\n    attributes,\n    triangles: resultTriangles\n  };\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n  const edges = [];\n  for (let i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n\n  edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n\n  const outsideEdges = [];\n  let index = 1;\n  while (index < edges.length) {\n    if (edges[index][0] === edges[index - 1][1] && edges[index][1] === edges[index - 1][0]) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index - 1]);\n      index++;\n    }\n  }\n  return outsideEdges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices, position) {\n  // Sort skirt indices to create adjacent triangles\n  indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n  // Reverse (b - a) to match triangle winding\n  indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n  indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n  // Reverse (b - a) to match triangle winding\n  indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n\n  const edges = [];\n  for (const index in indices) {\n    const indexGroup = indices[index];\n    for (let i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n  return edges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({\n  edge,\n  edgeIndex,\n  attributes,\n  skirtHeight,\n  newPosition,\n  newTexcoord0,\n  newTriangles\n}) {\n  const positionsLength = attributes.POSITION.value.length;\n  const vertex1Offset = edgeIndex * 2;\n  const vertex2Offset = edgeIndex * 2 + 1;\n\n  // Define POSITION for new 1st vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3),\n    vertex1Offset * 3\n  );\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Define POSITION for new 2nd vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3),\n    vertex2Offset * 3\n  );\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Use same TEXCOORDS for skirt vertices\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2),\n    vertex1Offset * 2\n  );\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2),\n    vertex2Offset * 2\n  );\n\n  // Define new triangles\n  const triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = edge[1];\n  newTriangles[triangle1Offset + 2] = positionsLength / 3 + vertex2Offset;\n\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = positionsLength / 3 + vertex1Offset;\n  newTriangles[triangle1Offset + 5] = edge[0];\n}\n","import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport decode, {DECODING_STEPS} from './decode-quantized-mesh';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {minHeight, maxHeight} = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  const {bounds} = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (options.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangleIndices,\n      options.skirtHeight,\n      {\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices\n      }\n    );\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangleIndices, size: 1},\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}\n","\nexport default class Martini {\n    constructor(gridSize = 257) {\n        this.gridSize = gridSize;\n        const tileSize = gridSize - 1;\n        if (tileSize & (tileSize - 1)) throw new Error(\n            `Expected grid size to be 2^n+1, got ${gridSize}.`);\n\n        this.numTriangles = tileSize * tileSize * 2 - 2;\n        this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n\n        this.indices = new Uint32Array(this.gridSize * this.gridSize);\n\n        // coordinates for all possible triangles in an RTIN tile\n        this.coords = new Uint16Array(this.numTriangles * 4);\n\n        // get triangle coordinates from its index in an implicit binary tree\n        for (let i = 0; i < this.numTriangles; i++) {\n            let id = i + 2;\n            let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;\n            if (id & 1) {\n                bx = by = cx = tileSize; // bottom-left triangle\n            } else {\n                ax = ay = cy = tileSize; // top-right triangle\n            }\n            while ((id >>= 1) > 1) {\n                const mx = (ax + bx) >> 1;\n                const my = (ay + by) >> 1;\n\n                if (id & 1) { // left half\n                    bx = ax; by = ay;\n                    ax = cx; ay = cy;\n                } else { // right half\n                    ax = bx; ay = by;\n                    bx = cx; by = cy;\n                }\n                cx = mx; cy = my;\n            }\n            const k = i * 4;\n            this.coords[k + 0] = ax;\n            this.coords[k + 1] = ay;\n            this.coords[k + 2] = bx;\n            this.coords[k + 3] = by;\n        }\n    }\n\n    createTile(terrain) {\n        return new Tile(terrain, this);\n    }\n}\n\nclass Tile {\n    constructor(terrain, martini) {\n        const size = martini.gridSize;\n        if (terrain.length !== size * size) throw new Error(\n            `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`);\n\n        this.terrain = terrain;\n        this.martini = martini;\n        this.errors = new Float32Array(terrain.length);\n        this.update();\n    }\n\n    update() {\n        const {numTriangles, numParentTriangles, coords, gridSize: size} = this.martini;\n        const {terrain, errors} = this;\n\n        // iterate over all possible triangles, starting from the smallest level\n        for (let i = numTriangles - 1; i >= 0; i--) {\n            const k = i * 4;\n            const ax = coords[k + 0];\n            const ay = coords[k + 1];\n            const bx = coords[k + 2];\n            const by = coords[k + 3];\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n            const cx = mx + my - ay;\n            const cy = my + ax - mx;\n\n            // calculate error in the middle of the long edge of the triangle\n            const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n            const middleIndex = my * size + mx;\n            const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n\n            errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n\n            if (i < numParentTriangles) { // bigger triangles; accumulate error with children\n                const leftChildIndex = ((ay + cy) >> 1) * size + ((ax + cx) >> 1);\n                const rightChildIndex = ((by + cy) >> 1) * size + ((bx + cx) >> 1);\n                errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n            }\n        }\n    }\n\n    getMesh(maxError = 0) {\n        const {gridSize: size, indices} = this.martini;\n        const {errors} = this;\n        let numVertices = 0;\n        let numTriangles = 0;\n        const max = size - 1;\n\n        // use an index grid to keep track of vertices that were already used to avoid duplication\n        indices.fill(0);\n\n        // retrieve mesh in two stages that both traverse the error map:\n        // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n        // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n        function countElements(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                countElements(cx, cy, ax, ay, mx, my);\n                countElements(bx, by, cx, cy, mx, my);\n            } else {\n                indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n                indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n                indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n                numTriangles++;\n            }\n        }\n        countElements(0, 0, max, max, max, 0);\n        countElements(max, max, 0, 0, 0, max);\n\n        const vertices = new Uint16Array(numVertices * 2);\n        const triangles = new Uint32Array(numTriangles * 3);\n        let triIndex = 0;\n\n        function processTriangle(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                // triangle doesn't approximate the surface well enough; drill down further\n                processTriangle(cx, cy, ax, ay, mx, my);\n                processTriangle(bx, by, cx, cy, mx, my);\n\n            } else {\n                // add a triangle\n                const a = indices[ay * size + ax] - 1;\n                const b = indices[by * size + bx] - 1;\n                const c = indices[cy * size + cx] - 1;\n\n                vertices[2 * a] = ax;\n                vertices[2 * a + 1] = ay;\n\n                vertices[2 * b] = bx;\n                vertices[2 * b + 1] = by;\n\n                vertices[2 * c] = cx;\n                vertices[2 * c + 1] = cy;\n\n                triangles[triIndex++] = a;\n                triangles[triIndex++] = b;\n                triangles[triIndex++] = c;\n            }\n        }\n        processTriangle(0, 0, max, max, max, 0);\n        processTriangle(max, max, 0, 0, 0, max);\n\n        return {vertices, triangles};\n    }\n}\n","// ISC License\n\n// Copyright(c) 2019, Michael Fogleman, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and / or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS.IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n//   INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\n/* eslint-disable complexity, max-params, max-statements, max-depth, no-constant-condition */\nexport default class Delatin {\n  constructor(data, width, height = width) {\n    this.data = data; // height data\n    this.width = width;\n    this.height = height;\n\n    this.coords = []; // vertex coordinates (x, y)\n    this.triangles = []; // mesh triangle indices\n\n    // additional triangle data\n    this._halfedges = [];\n    this._candidates = [];\n    this._queueIndices = [];\n\n    this._queue = []; // queue of added triangles\n    this._errors = [];\n    this._rms = [];\n    this._pending = []; // triangles pending addition to queue\n    this._pendingLen = 0;\n\n    this._rmsSum = 0;\n\n    const x1 = width - 1;\n    const y1 = height - 1;\n    const p0 = this._addPoint(0, 0);\n    const p1 = this._addPoint(x1, 0);\n    const p2 = this._addPoint(0, y1);\n    const p3 = this._addPoint(x1, y1);\n\n    // add initial two triangles\n    const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);\n    this._addTriangle(p0, p3, p1, t0, -1, -1);\n    this._flush();\n  }\n\n  // refine the mesh until its maximum error gets below the given one\n  run(maxError = 1) {\n    while (this.getMaxError() > maxError) {\n      this.refine();\n    }\n  }\n\n  // refine the mesh with a single point\n  refine() {\n    this._step();\n    this._flush();\n  }\n\n  // max error of the current mesh\n  getMaxError() {\n    return this._errors[0];\n  }\n\n  // root-mean-square deviation of the current mesh\n  getRMSD() {\n    return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;\n  }\n\n  // height value at a given position\n  heightAt(x, y) {\n    return this.data[this.width * y + x];\n  }\n\n  // rasterize and queue all triangles that got added or updated in _step\n  _flush() {\n    const coords = this.coords;\n    for (let i = 0; i < this._pendingLen; i++) {\n      const t = this._pending[i];\n      // rasterize triangle to find maximum pixel error\n      const a = 2 * this.triangles[t * 3 + 0];\n      const b = 2 * this.triangles[t * 3 + 1];\n      const c = 2 * this.triangles[t * 3 + 2];\n      this._findCandidate(\n        coords[a],\n        coords[a + 1],\n        coords[b],\n        coords[b + 1],\n        coords[c],\n        coords[c + 1],\n        t\n      );\n    }\n    this._pendingLen = 0;\n  }\n\n  // rasterize a triangle, find its max error, and queue it for processing\n  _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t) {\n    // triangle bounding box\n    const minX = Math.min(p0x, p1x, p2x);\n    const minY = Math.min(p0y, p1y, p2y);\n    const maxX = Math.max(p0x, p1x, p2x);\n    const maxY = Math.max(p0y, p1y, p2y);\n\n    // forward differencing variables\n    let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);\n    let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);\n    let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);\n    const a01 = p1y - p0y;\n    const b01 = p0x - p1x;\n    const a12 = p2y - p1y;\n    const b12 = p1x - p2x;\n    const a20 = p0y - p2y;\n    const b20 = p2x - p0x;\n\n    // pre-multiplied z values at vertices\n    const a = orient(p0x, p0y, p1x, p1y, p2x, p2y);\n    const z0 = this.heightAt(p0x, p0y) / a;\n    const z1 = this.heightAt(p1x, p1y) / a;\n    const z2 = this.heightAt(p2x, p2y) / a;\n\n    // iterate over pixels in bounding box\n    let maxError = 0;\n    let mx = 0;\n    let my = 0;\n    let rms = 0;\n    for (let y = minY; y <= maxY; y++) {\n      // compute starting offset\n      let dx = 0;\n      if (w00 < 0 && a12 !== 0) {\n        dx = Math.max(dx, Math.floor(-w00 / a12));\n      }\n      if (w01 < 0 && a20 !== 0) {\n        dx = Math.max(dx, Math.floor(-w01 / a20));\n      }\n      if (w02 < 0 && a01 !== 0) {\n        dx = Math.max(dx, Math.floor(-w02 / a01));\n      }\n\n      let w0 = w00 + a12 * dx;\n      let w1 = w01 + a20 * dx;\n      let w2 = w02 + a01 * dx;\n\n      let wasInside = false;\n\n      for (let x = minX + dx; x <= maxX; x++) {\n        // check if inside triangle\n        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\n          wasInside = true;\n\n          // compute z using barycentric coordinates\n          const z = z0 * w0 + z1 * w1 + z2 * w2;\n          const dz = Math.abs(z - this.heightAt(x, y));\n          rms += dz * dz;\n          if (dz > maxError) {\n            maxError = dz;\n            mx = x;\n            my = y;\n          }\n        } else if (wasInside) {\n          break;\n        }\n\n        w0 += a12;\n        w1 += a20;\n        w2 += a01;\n      }\n\n      w00 += b12;\n      w01 += b20;\n      w02 += b01;\n    }\n\n    if ((mx === p0x && my === p0y) || (mx === p1x && my === p1y) || (mx === p2x && my === p2y)) {\n      maxError = 0;\n    }\n\n    // update triangle metadata\n    this._candidates[2 * t] = mx;\n    this._candidates[2 * t + 1] = my;\n    this._rms[t] = rms;\n\n    // add triangle to priority queue\n    this._queuePush(t, maxError, rms);\n  }\n\n  // process the next triangle in the queue, splitting it with a new point\n  _step() {\n    // pop triangle with highest error from priority queue\n    const t = this._queuePop();\n\n    const e0 = t * 3 + 0;\n    const e1 = t * 3 + 1;\n    const e2 = t * 3 + 2;\n\n    const p0 = this.triangles[e0];\n    const p1 = this.triangles[e1];\n    const p2 = this.triangles[e2];\n\n    const ax = this.coords[2 * p0];\n    const ay = this.coords[2 * p0 + 1];\n    const bx = this.coords[2 * p1];\n    const by = this.coords[2 * p1 + 1];\n    const cx = this.coords[2 * p2];\n    const cy = this.coords[2 * p2 + 1];\n    const px = this._candidates[2 * t];\n    const py = this._candidates[2 * t + 1];\n\n    const pn = this._addPoint(px, py);\n\n    if (orient(ax, ay, bx, by, px, py) === 0) {\n      this._handleCollinear(pn, e0);\n    } else if (orient(bx, by, cx, cy, px, py) === 0) {\n      this._handleCollinear(pn, e1);\n    } else if (orient(cx, cy, ax, ay, px, py) === 0) {\n      this._handleCollinear(pn, e2);\n    } else {\n      const h0 = this._halfedges[e0];\n      const h1 = this._halfedges[e1];\n      const h2 = this._halfedges[e2];\n\n      const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);\n      const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);\n      const t2 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);\n\n      this._legalize(t0);\n      this._legalize(t1);\n      this._legalize(t2);\n    }\n  }\n\n  // add coordinates for a new vertex\n  _addPoint(x, y) {\n    const i = this.coords.length >> 1;\n    this.coords.push(x, y);\n    return i;\n  }\n\n  // add or update a triangle in the mesh\n  _addTriangle(a, b, c, ab, bc, ca, e = this.triangles.length) {\n    const t = e / 3; // new triangle index\n\n    // add triangle vertices\n    this.triangles[e + 0] = a;\n    this.triangles[e + 1] = b;\n    this.triangles[e + 2] = c;\n\n    // add triangle halfedges\n    this._halfedges[e + 0] = ab;\n    this._halfedges[e + 1] = bc;\n    this._halfedges[e + 2] = ca;\n\n    // link neighboring halfedges\n    if (ab >= 0) {\n      this._halfedges[ab] = e + 0;\n    }\n    if (bc >= 0) {\n      this._halfedges[bc] = e + 1;\n    }\n    if (ca >= 0) {\n      this._halfedges[ca] = e + 2;\n    }\n\n    // init triangle metadata\n    this._candidates[2 * t + 0] = 0;\n    this._candidates[2 * t + 1] = 0;\n    this._queueIndices[t] = -1;\n    this._rms[t] = 0;\n\n    // add triangle to pending queue for later rasterization\n    this._pending[this._pendingLen++] = t;\n\n    // return first halfedge index\n    return e;\n  }\n\n  _legalize(a) {\n    // if the pair of triangles doesn't satisfy the Delaunay condition\n    // (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n    // then do the same check/flip recursively for the new pair of triangles\n    //\n    //           pl                    pl\n    //          /||\\                  /  \\\n    //       al/ || \\bl            al/    \\a\n    //        /  ||  \\              /      \\\n    //       /  a||b  \\    flip    /___ar___\\\n    //     p0\\   ||   /p1   =>   p0\\---bl---/p1\n    //        \\  ||  /              \\      /\n    //       ar\\ || /br             b\\    /br\n    //          \\||/                  \\  /\n    //           pr                    pr\n\n    const b = this._halfedges[a];\n\n    if (b < 0) {\n      return;\n    }\n\n    const a0 = a - (a % 3);\n    const b0 = b - (b % 3);\n    const al = a0 + ((a + 1) % 3);\n    const ar = a0 + ((a + 2) % 3);\n    const bl = b0 + ((b + 2) % 3);\n    const br = b0 + ((b + 1) % 3);\n    const p0 = this.triangles[ar];\n    const pr = this.triangles[a];\n    const pl = this.triangles[al];\n    const p1 = this.triangles[bl];\n    const coords = this.coords;\n\n    if (\n      !inCircle(\n        coords[2 * p0],\n        coords[2 * p0 + 1],\n        coords[2 * pr],\n        coords[2 * pr + 1],\n        coords[2 * pl],\n        coords[2 * pl + 1],\n        coords[2 * p1],\n        coords[2 * p1 + 1]\n      )\n    ) {\n      return;\n    }\n\n    const hal = this._halfedges[al];\n    const har = this._halfedges[ar];\n    const hbl = this._halfedges[bl];\n    const hbr = this._halfedges[br];\n\n    this._queueRemove(a0 / 3);\n    this._queueRemove(b0 / 3);\n\n    const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);\n    const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);\n\n    this._legalize(t0 + 1);\n    this._legalize(t1 + 2);\n  }\n\n  // handle a case where new vertex is on the edge of a triangle\n  _handleCollinear(pn, a) {\n    const a0 = a - (a % 3);\n    const al = a0 + ((a + 1) % 3);\n    const ar = a0 + ((a + 2) % 3);\n    const p0 = this.triangles[ar];\n    const pr = this.triangles[a];\n    const pl = this.triangles[al];\n    const hal = this._halfedges[al];\n    const har = this._halfedges[ar];\n\n    const b = this._halfedges[a];\n\n    if (b < 0) {\n      const t0 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);\n      const t1 = this._addTriangle(p0, pn, pl, t0, -1, hal);\n      this._legalize(t0 + 1);\n      this._legalize(t1 + 2);\n      return;\n    }\n\n    const b0 = b - (b % 3);\n    const bl = b0 + ((b + 2) % 3);\n    const br = b0 + ((b + 1) % 3);\n    const p1 = this.triangles[bl];\n    const hbl = this._halfedges[bl];\n    const hbr = this._halfedges[br];\n\n    this._queueRemove(b0 / 3);\n\n    const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);\n    const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);\n    const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);\n    const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);\n\n    this._legalize(t0);\n    this._legalize(t1);\n    this._legalize(t2);\n    this._legalize(t3);\n  }\n\n  // priority queue methods\n\n  _queuePush(t, error, rms) {\n    const i = this._queue.length;\n    this._queueIndices[t] = i;\n    this._queue.push(t);\n    this._errors.push(error);\n    this._rmsSum += rms;\n    this._queueUp(i);\n  }\n\n  _queuePop() {\n    const n = this._queue.length - 1;\n    this._queueSwap(0, n);\n    this._queueDown(0, n);\n    return this._queuePopBack();\n  }\n\n  _queuePopBack() {\n    const t = this._queue.pop();\n    this._errors.pop();\n    this._rmsSum -= this._rms[t];\n    this._queueIndices[t] = -1;\n    return t;\n  }\n\n  _queueRemove(t) {\n    const i = this._queueIndices[t];\n    if (i < 0) {\n      const it = this._pending.indexOf(t);\n      if (it !== -1) {\n        this._pending[it] = this._pending[--this._pendingLen];\n      } else {\n        throw new Error('Broken triangulation (something went wrong).');\n      }\n      return;\n    }\n    const n = this._queue.length - 1;\n    if (n !== i) {\n      this._queueSwap(i, n);\n      if (!this._queueDown(i, n)) {\n        this._queueUp(i);\n      }\n    }\n    this._queuePopBack();\n  }\n\n  _queueLess(i, j) {\n    return this._errors[i] > this._errors[j];\n  }\n\n  _queueSwap(i, j) {\n    const pi = this._queue[i];\n    const pj = this._queue[j];\n    this._queue[i] = pj;\n    this._queue[j] = pi;\n    this._queueIndices[pi] = j;\n    this._queueIndices[pj] = i;\n    const e = this._errors[i];\n    this._errors[i] = this._errors[j];\n    this._errors[j] = e;\n  }\n\n  _queueUp(j0) {\n    let j = j0;\n    while (true) {\n      const i = (j - 1) >> 1;\n      if (i === j || !this._queueLess(j, i)) {\n        break;\n      }\n      this._queueSwap(i, j);\n      j = i;\n    }\n  }\n\n  _queueDown(i0, n) {\n    let i = i0;\n    while (true) {\n      const j1 = 2 * i + 1;\n      if (j1 >= n || j1 < 0) {\n        break;\n      }\n      const j2 = j1 + 1;\n      let j = j1;\n      if (j2 < n && this._queueLess(j2, j1)) {\n        j = j2;\n      }\n      if (!this._queueLess(j, i)) {\n        break;\n      }\n      this._queueSwap(i, j);\n      i = j;\n    }\n    return i > i0;\n  }\n}\n\nfunction orient(ax, ay, bx, by, cx, cy) {\n  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n  const dx = ax - px;\n  const dy = ay - py;\n  const ex = bx - px;\n  const ey = by - py;\n  const fx = cx - px;\n  const fy = cy - py;\n\n  const ap = dx * dx + dy * dy;\n  const bp = ex * ex + ey * ey;\n  const cp = fx * fx + fy * fy;\n\n  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n}\n","import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\n/**\n * Returns generated mesh object from image data\n *\n * @param {object} terrainImage terrain image data\n * @param {object} terrainOptions terrain options\n * @returns mesh object\n */\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const {data, width, height} = terrainImage;\n\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & (width - 1))) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n\n  const {vertices} = mesh;\n  let {triangles} = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangles,\n      terrainOptions.skirtHeight\n    );\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: Uint32Array.from(triangles), size: 1},\n    attributes\n  };\n}\n\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  return {vertices, triangles};\n}\n\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  const {coords, triangles} = tin;\n  const vertices = coords;\n  return {vertices, triangles};\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMesh(image, options.terrain);\n}\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import type {Loader} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\n\n/**\n * Worker loader for quantized meshes\n */\nexport const TerrainLoader = {\n  name: 'Terrain',\n  id: 'terrain',\n  module: 'terrain',\n  version: VERSION,\n  worker: true,\n  extensions: ['png', 'pngraw'],\n  mimeTypes: ['image/png'],\n  options: {\n    terrain: {\n      tesselator: 'auto',\n      bounds: null,\n      meshMaxError: 10,\n      elevationDecoder: {\n        rScaler: 1,\n        gScaler: 0,\n        bScaler: 0,\n        offset: 0\n      },\n      skirtHeight: null\n    }\n  }\n};\n\n/**\n * Loader for quantized meshes\n */\nexport const _typecheckTerrainWorkerLoader: Loader = TerrainLoader;\n","import type {Loader} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\n\n/**\n * Worker loader for quantized meshes\n */\nexport const QuantizedMeshLoader = {\n  name: 'Quantized Mesh',\n  id: 'quantized-mesh',\n  module: 'terrain',\n  version: VERSION,\n  worker: true,\n  extensions: ['terrain'],\n  mimeTypes: ['application/vnd.quantized-mesh'],\n  options: {\n    'quantized-mesh': {\n      bounds: [0, 0, 1, 1],\n      skirtHeight: null\n    }\n  }\n};\n\nexport const _typecheckQuantizedMeshLoader: Loader = QuantizedMeshLoader;\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport parseQuantizedMesh from './lib/parse-quantized-mesh';\nimport loadTerrain from './lib/parse-terrain';\n\nimport {TerrainLoader as TerrainWorkerLoader} from './terrain-loader';\nimport {QuantizedMeshLoader as QuantizedMeshWorkerLoader} from './quantized-mesh-loader';\n\n// TerrainLoader\n\nexport {TerrainWorkerLoader};\n\nexport const TerrainLoader = {\n  ...TerrainWorkerLoader,\n  parse: loadTerrain\n};\n\nexport const _typecheckTerrainLoader: LoaderWithParser = TerrainLoader; // eslint-disable-line\n\n// QuantizedMeshLoader\n\nexport {QuantizedMeshWorkerLoader};\n\n/**\n * Loader for quantized meshes\n */\nexport const QuantizedMeshLoader = {\n  ...QuantizedMeshWorkerLoader,\n  parseSync: parseQuantizedMesh,\n  parse: async (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options)\n};\n\nexport const _typecheckQuantizedMeshLoader: LoaderWithParser = QuantizedMeshLoader;\n"],"sourceRoot":""}