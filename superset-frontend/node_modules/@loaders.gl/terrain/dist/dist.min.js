!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var i in n)("object"==typeof exports?exports:e)[i]=n[i]}}(window,(function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(i,s,function(t){return e[t]}.bind(null,s));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=2)}([function(e,t){},,function(e,t,n){(function(t){const i=n(4),s="undefined"==typeof window?t:window;s.loaders=s.loaders||{},e.exports=Object.assign(s.loaders,i)}).call(this,n(3))},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";function i(e){let t=1/0,n=1/0,i=1/0,s=-1/0,r=-1/0,o=-1/0;const a=e.POSITION?e.POSITION.value:[],h=a&&a.length;for(let e=0;e<h;e+=3){const h=a[e],u=a[e+1],c=a[e+2];t=h<t?h:t,n=u<n?u:n,i=c<i?c:i,s=h>s?h:s,r=u>r?u:r,o=c>o?c:o}return[[t,n,i],[s,r,o]]}n.r(t),n.d(t,"TerrainWorkerLoader",(function(){return x})),n.d(t,"TerrainLoader",(function(){return O})),n.d(t,"_typecheckTerrainLoader",(function(){return q})),n.d(t,"QuantizedMeshWorkerLoader",(function(){return v})),n.d(t,"QuantizedMeshLoader",(function(){return A})),n.d(t,"_typecheckQuantizedMeshLoader",(function(){return L}));const s=new Map([["centerX",Float64Array.BYTES_PER_ELEMENT],["centerY",Float64Array.BYTES_PER_ELEMENT],["centerZ",Float64Array.BYTES_PER_ELEMENT],["minHeight",Float32Array.BYTES_PER_ELEMENT],["maxHeight",Float32Array.BYTES_PER_ELEMENT],["boundingSphereCenterX",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterY",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterZ",Float64Array.BYTES_PER_ELEMENT],["boundingSphereRadius",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointX",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointY",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointZ",Float64Array.BYTES_PER_ELEMENT]]);function r(e){return e>>1^-(1&e)}function o(e,t,n,i,s=!0){let r;if(r=2===i?new Uint16Array(e,t,n):new Uint32Array(e,t,n),!s)return r;let o=0;for(let e=0;e<r.length;++e){const t=r[e];r[e]=o-t,0===t&&++o}return r}function a(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const h=1,u=2,c=3,l=4,d={maxDecodingStep:l};function g(e,t){const n=Object.assign({},d,t),i=new DataView(e),{header:g,headerEndPosition:_}=function(e){let t=0;const n={};for(const[i,r]of s){const s=8===r?e.getFloat64:e.getFloat32;n[i]=s.call(e,t,!0),t+=r}return{header:n,headerEndPosition:t}}(i);if(n.maxDecodingStep<h)return{header:g};const{vertexData:f,vertexDataEndPosition:E}=function(e,t){let n=t;const i=e.getUint32(n,!0),s=new Uint16Array(3*i);n+=Uint32Array.BYTES_PER_ELEMENT;const o=Uint16Array.BYTES_PER_ELEMENT,a=i*o,h=n,u=h+a,c=u+a;let l=0,d=0,g=0;for(let t=0;t<i;t++)l+=r(e.getUint16(h+o*t,!0)),d+=r(e.getUint16(u+o*t,!0)),g+=r(e.getUint16(c+o*t,!0)),s[t]=l,s[t+i]=d,s[t+2*i]=g;return n+=3*a,{vertexData:s,vertexDataEndPosition:n}}(i,_);if(n.maxDecodingStep<u)return{header:g,vertexData:f};const{triangleIndices:T,triangleIndicesEndPosition:p}=function(e,t,n){let i=n;const s=t.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT;i%s!=0&&(i+=s-i%s);const r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const a=3*r,h=o(e.buffer,i,a,s);return i+=a*s,{triangleIndicesEndPosition:i,triangleIndices:h}}(i,f,E);if(n.maxDecodingStep<c)return{header:g,vertexData:f,triangleIndices:T};const{westIndices:m,southIndices:y,eastIndices:w,northIndices:S,edgeIndicesEndPosition:b}=function(e,t,n){let i=n;const s=t.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT,r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const a=o(e.buffer,i,r,s,!1);i+=r*s;const h=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const u=o(e.buffer,i,h,s,!1);i+=h*s;const c=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const l=o(e.buffer,i,c,s,!1);i+=c*s;const d=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const g=o(e.buffer,i,d,s,!1);return i+=d*s,{edgeIndicesEndPosition:i,westIndices:a,southIndices:u,eastIndices:l,northIndices:g}}(i,f,p);if(n.maxDecodingStep<l)return{header:g,vertexData:f,triangleIndices:T,westIndices:m,northIndices:S,eastIndices:w,southIndices:y};const{extensions:P}=function(e,t){const n={};if(e.byteLength<=t)return{extensions:n,extensionsEndPosition:t};let i=t;for(;i<e.byteLength;){const t=e.getUint8(i,!0);i+=Uint8Array.BYTES_PER_ELEMENT;const r=e.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const o=new DataView(e.buffer,i,r);switch(t){case 1:n.vertexNormals=(s=o,new Uint8Array(s.buffer,s.byteOffset,s.byteLength));break;case 2:n.waterMask=a(o)}i+=r}var s;return{extensions:n,extensionsEndPosition:i}}(i,b);return{header:g,vertexData:f,triangleIndices:T,westIndices:m,northIndices:S,eastIndices:w,southIndices:y,extensions:P}}n(0);function _(...e){const t=e,n=t&&t.length>1&&t[0].constructor||null;if(!n)throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');const i=new n(t.reduce((e,t)=>e+t.length,0));let s=0;for(const e of t)i.set(e,s),s+=e.length;return i}function f(e,t,n,i=null){const s=i?function(e,t){e.westIndices.sort((e,n)=>t[3*e+1]-t[3*n+1]),e.eastIndices.sort((e,n)=>t[3*n+1]-t[3*e+1]),e.southIndices.sort((e,n)=>t[3*n]-t[3*e]),e.northIndices.sort((e,n)=>t[3*e]-t[3*n]);const n=[];for(const t in e){const i=e[t];for(let e=0;e<i.length-1;e++)n.push([i[e],i[e+1]])}return n}(i,e.POSITION.value):function(e){const t=[];for(let n=0;n<e.length;n+=3)t.push([e[n],e[n+1]]),t.push([e[n+1],e[n+2]]),t.push([e[n+2],e[n]]);t.sort((e,t)=>Math.min(...e)-Math.min(...t)||Math.max(...e)-Math.max(...t));const n=[];let i=1;for(;i<t.length;)t[i][0]===t[i-1][1]&&t[i][1]===t[i-1][0]?i+=2:(n.push(t[i-1]),i++);return n}(t),r=new e.POSITION.value.constructor(6*s.length),o=new e.TEXCOORD_0.value.constructor(4*s.length),a=new t.constructor(6*s.length);for(let t=0;t<s.length;t++){E({edge:s[t],edgeIndex:t,attributes:e,skirtHeight:n,newPosition:r,newTexcoord0:o,newTriangles:a})}e.POSITION.value=_(e.POSITION.value,r),e.TEXCOORD_0.value=_(e.TEXCOORD_0.value,o);return{attributes:e,triangles:t instanceof Array?t.concat(a):_(t,a)}}function E({edge:e,edgeIndex:t,attributes:n,skirtHeight:i,newPosition:s,newTexcoord0:r,newTriangles:o}){const a=n.POSITION.value.length,h=2*t,u=2*t+1;s.set(n.POSITION.value.subarray(3*e[0],3*e[0]+3),3*h),s[3*h+2]=s[3*h+2]-i,s.set(n.POSITION.value.subarray(3*e[1],3*e[1]+3),3*u),s[3*u+2]=s[3*u+2]-i,r.set(n.TEXCOORD_0.value.subarray(2*e[0],2*e[0]+2),2*h),r.set(n.TEXCOORD_0.value.subarray(2*e[1],2*e[1]+2),2*u);const c=2*t*3;o[c]=e[0],o[c+1]=e[1],o[c+2]=a/3+u,o[c+3]=a/3+u,o[c+4]=a/3+h,o[c+5]=e[0]}function T(e,t){if(!e)return null;const{bounds:n}=t,{header:s,vertexData:r,triangleIndices:o,westIndices:a,northIndices:h,eastIndices:c,southIndices:l}=g(e,u);let d=o,_=function(e,t,n){const{minHeight:i,maxHeight:s}=t,[r,o,a,h]=n||[0,0,1,1],u=a-r,c=h-o,l=s-i,d=e.length/3,g=new Float32Array(3*d),_=new Float32Array(2*d);for(let t=0;t<d;t++){const n=e[t]/32767,s=e[t+d]/32767,a=e[t+2*d]/32767;g[3*t+0]=n*u+r,g[3*t+1]=s*c+o,g[3*t+2]=a*l+i,_[2*t+0]=n,_[2*t+1]=s}return{POSITION:{value:g,size:3},TEXCOORD_0:{value:_,size:2}}}(r,s,n);const E=i(_);if(t.skirtHeight){const{attributes:e,triangles:n}=f(_,d,t.skirtHeight,{westIndices:a,northIndices:h,eastIndices:c,southIndices:l});_=e,d=n}return{loaderData:{header:{}},header:{vertexCount:d.length,boundingBox:E},mode:4,indices:{value:d,size:1},attributes:_}}function p(e,t){return T(e,t["quantized-mesh"])}class m{constructor(e=257){this.gridSize=e;const t=e-1;if(t&t-1)throw new Error(`Expected grid size to be 2^n+1, got ${e}.`);this.numTriangles=t*t*2-2,this.numParentTriangles=this.numTriangles-t*t,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let e=0;e<this.numTriangles;e++){let n=e+2,i=0,s=0,r=0,o=0,a=0,h=0;for(1&n?r=o=a=t:i=s=h=t;(n>>=1)>1;){const e=i+r>>1,t=s+o>>1;1&n?(r=i,o=s,i=a,s=h):(i=r,s=o,r=a,o=h),a=e,h=t}const u=4*e;this.coords[u+0]=i,this.coords[u+1]=s,this.coords[u+2]=r,this.coords[u+3]=o}}createTile(e){return new y(e,this)}}class y{constructor(e,t){const n=t.gridSize;if(e.length!==n*n)throw new Error(`Expected terrain data of length ${n*n} (${n} x ${n}), got ${e.length}.`);this.terrain=e,this.martini=t,this.errors=new Float32Array(e.length),this.update()}update(){const{numTriangles:e,numParentTriangles:t,coords:n,gridSize:i}=this.martini,{terrain:s,errors:r}=this;for(let o=e-1;o>=0;o--){const e=4*o,a=n[e+0],h=n[e+1],u=n[e+2],c=n[e+3],l=a+u>>1,d=h+c>>1,g=l+d-h,_=d+a-l,f=(s[h*i+a]+s[c*i+u])/2,E=d*i+l,T=Math.abs(f-s[E]);if(r[E]=Math.max(r[E],T),o<t){const e=(h+_>>1)*i+(a+g>>1),t=(c+_>>1)*i+(u+g>>1);r[E]=Math.max(r[E],r[e],r[t])}}}getMesh(e=0){const{gridSize:t,indices:n}=this.martini,{errors:i}=this;let s=0,r=0;const o=t-1;function a(o,h,u,c,l,d){const g=o+u>>1,_=h+c>>1;Math.abs(o-l)+Math.abs(h-d)>1&&i[_*t+g]>e?(a(l,d,o,h,g,_),a(u,c,l,d,g,_)):(n[h*t+o]=n[h*t+o]||++s,n[c*t+u]=n[c*t+u]||++s,n[d*t+l]=n[d*t+l]||++s,r++)}n.fill(0),a(0,0,o,o,o,0),a(o,o,0,0,0,o);const h=new Uint16Array(2*s),u=new Uint32Array(3*r);let c=0;function l(s,r,o,a,d,g){const _=s+o>>1,f=r+a>>1;if(Math.abs(s-d)+Math.abs(r-g)>1&&i[f*t+_]>e)l(d,g,s,r,_,f),l(o,a,d,g,_,f);else{const e=n[r*t+s]-1,i=n[a*t+o]-1,l=n[g*t+d]-1;h[2*e]=s,h[2*e+1]=r,h[2*i]=o,h[2*i+1]=a,h[2*l]=d,h[2*l+1]=g,u[c++]=e,u[c++]=i,u[c++]=l}}return l(0,0,o,o,o,0),l(o,o,0,0,0,o),{vertices:h,triangles:u}}}class w{constructor(e,t,n=t){this.data=e,this.width=t,this.height=n,this.coords=[],this.triangles=[],this._halfedges=[],this._candidates=[],this._queueIndices=[],this._queue=[],this._errors=[],this._rms=[],this._pending=[],this._pendingLen=0,this._rmsSum=0;const i=t-1,s=n-1,r=this._addPoint(0,0),o=this._addPoint(i,0),a=this._addPoint(0,s),h=this._addPoint(i,s),u=this._addTriangle(h,r,a,-1,-1,-1);this._addTriangle(r,h,o,u,-1,-1),this._flush()}run(e=1){for(;this.getMaxError()>e;)this.refine()}refine(){this._step(),this._flush()}getMaxError(){return this._errors[0]}getRMSD(){return this._rmsSum>0?Math.sqrt(this._rmsSum/(this.width*this.height)):0}heightAt(e,t){return this.data[this.width*t+e]}_flush(){const e=this.coords;for(let t=0;t<this._pendingLen;t++){const n=this._pending[t],i=2*this.triangles[3*n+0],s=2*this.triangles[3*n+1],r=2*this.triangles[3*n+2];this._findCandidate(e[i],e[i+1],e[s],e[s+1],e[r],e[r+1],n)}this._pendingLen=0}_findCandidate(e,t,n,i,s,r,o){const a=Math.min(e,n,s),h=Math.min(t,i,r),u=Math.max(e,n,s),c=Math.max(t,i,r);let l=S(n,i,s,r,a,h),d=S(s,r,e,t,a,h),g=S(e,t,n,i,a,h);const _=i-t,f=e-n,E=r-i,T=n-s,p=t-r,m=s-e,y=S(e,t,n,i,s,r),w=this.heightAt(e,t)/y,b=this.heightAt(n,i)/y,P=this.heightAt(s,r)/y;let I=0,M=0,x=0,v=0;for(let e=h;e<=c;e++){let t=0;l<0&&0!==E&&(t=Math.max(t,Math.floor(-l/E))),d<0&&0!==p&&(t=Math.max(t,Math.floor(-d/p))),g<0&&0!==_&&(t=Math.max(t,Math.floor(-g/_)));let n=l+E*t,i=d+p*t,s=g+_*t,r=!1;for(let o=a+t;o<=u;o++){if(n>=0&&i>=0&&s>=0){r=!0;const t=w*n+b*i+P*s,a=Math.abs(t-this.heightAt(o,e));v+=a*a,a>I&&(I=a,M=o,x=e)}else if(r)break;n+=E,i+=p,s+=_}l+=T,d+=m,g+=f}(M===e&&x===t||M===n&&x===i||M===s&&x===r)&&(I=0),this._candidates[2*o]=M,this._candidates[2*o+1]=x,this._rms[o]=v,this._queuePush(o,I,v)}_step(){const e=this._queuePop(),t=3*e+0,n=3*e+1,i=3*e+2,s=this.triangles[t],r=this.triangles[n],o=this.triangles[i],a=this.coords[2*s],h=this.coords[2*s+1],u=this.coords[2*r],c=this.coords[2*r+1],l=this.coords[2*o],d=this.coords[2*o+1],g=this._candidates[2*e],_=this._candidates[2*e+1],f=this._addPoint(g,_);if(0===S(a,h,u,c,g,_))this._handleCollinear(f,t);else if(0===S(u,c,l,d,g,_))this._handleCollinear(f,n);else if(0===S(l,d,a,h,g,_))this._handleCollinear(f,i);else{const e=this._halfedges[t],a=this._halfedges[n],h=this._halfedges[i],u=this._addTriangle(s,r,f,e,-1,-1,t),c=this._addTriangle(r,o,f,a,-1,u+1),l=this._addTriangle(o,s,f,h,u+2,c+1);this._legalize(u),this._legalize(c),this._legalize(l)}}_addPoint(e,t){const n=this.coords.length>>1;return this.coords.push(e,t),n}_addTriangle(e,t,n,i,s,r,o=this.triangles.length){const a=o/3;return this.triangles[o+0]=e,this.triangles[o+1]=t,this.triangles[o+2]=n,this._halfedges[o+0]=i,this._halfedges[o+1]=s,this._halfedges[o+2]=r,i>=0&&(this._halfedges[i]=o+0),s>=0&&(this._halfedges[s]=o+1),r>=0&&(this._halfedges[r]=o+2),this._candidates[2*a+0]=0,this._candidates[2*a+1]=0,this._queueIndices[a]=-1,this._rms[a]=0,this._pending[this._pendingLen++]=a,o}_legalize(e){const t=this._halfedges[e];if(t<0)return;const n=e-e%3,i=t-t%3,s=n+(e+1)%3,r=n+(e+2)%3,o=i+(t+2)%3,a=i+(t+1)%3,h=this.triangles[r],u=this.triangles[e],c=this.triangles[s],l=this.triangles[o],d=this.coords;if(!function(e,t,n,i,s,r,o,a){const h=e-o,u=t-a,c=n-o,l=i-a,d=s-o,g=r-a,_=c*c+l*l,f=d*d+g*g;return h*(l*f-_*g)-u*(c*f-_*d)+(h*h+u*u)*(c*g-l*d)<0}(d[2*h],d[2*h+1],d[2*u],d[2*u+1],d[2*c],d[2*c+1],d[2*l],d[2*l+1]))return;const g=this._halfedges[s],_=this._halfedges[r],f=this._halfedges[o],E=this._halfedges[a];this._queueRemove(n/3),this._queueRemove(i/3);const T=this._addTriangle(h,l,c,-1,f,g,n),p=this._addTriangle(l,h,u,T,_,E,i);this._legalize(T+1),this._legalize(p+2)}_handleCollinear(e,t){const n=t-t%3,i=n+(t+1)%3,s=n+(t+2)%3,r=this.triangles[s],o=this.triangles[t],a=this.triangles[i],h=this._halfedges[i],u=this._halfedges[s],c=this._halfedges[t];if(c<0){const t=this._addTriangle(e,r,o,-1,u,-1,n),i=this._addTriangle(r,e,a,t,-1,h);return this._legalize(t+1),void this._legalize(i+2)}const l=c-c%3,d=l+(c+2)%3,g=l+(c+1)%3,_=this.triangles[d],f=this._halfedges[d],E=this._halfedges[g];this._queueRemove(l/3);const T=this._addTriangle(r,o,e,u,-1,-1,n),p=this._addTriangle(o,_,e,E,-1,T+1,l),m=this._addTriangle(_,a,e,f,-1,p+1),y=this._addTriangle(a,r,e,h,T+2,m+1);this._legalize(T),this._legalize(p),this._legalize(m),this._legalize(y)}_queuePush(e,t,n){const i=this._queue.length;this._queueIndices[e]=i,this._queue.push(e),this._errors.push(t),this._rmsSum+=n,this._queueUp(i)}_queuePop(){const e=this._queue.length-1;return this._queueSwap(0,e),this._queueDown(0,e),this._queuePopBack()}_queuePopBack(){const e=this._queue.pop();return this._errors.pop(),this._rmsSum-=this._rms[e],this._queueIndices[e]=-1,e}_queueRemove(e){const t=this._queueIndices[e];if(t<0){const t=this._pending.indexOf(e);if(-1===t)throw new Error("Broken triangulation (something went wrong).");return void(this._pending[t]=this._pending[--this._pendingLen])}const n=this._queue.length-1;n!==t&&(this._queueSwap(t,n),this._queueDown(t,n)||this._queueUp(t)),this._queuePopBack()}_queueLess(e,t){return this._errors[e]>this._errors[t]}_queueSwap(e,t){const n=this._queue[e],i=this._queue[t];this._queue[e]=i,this._queue[t]=n,this._queueIndices[n]=t,this._queueIndices[i]=e;const s=this._errors[e];this._errors[e]=this._errors[t],this._errors[t]=s}_queueUp(e){let t=e;for(;;){const e=t-1>>1;if(e===t||!this._queueLess(t,e))break;this._queueSwap(e,t),t=e}}_queueDown(e,t){let n=e;for(;;){const e=2*n+1;if(e>=t||e<0)break;const i=e+1;let s=e;if(i<t&&this._queueLess(i,e)&&(s=i),!this._queueLess(s,n))break;this._queueSwap(n,s),n=s}return n>e}}function S(e,t,n,i,s,r){return(n-s)*(t-r)-(i-r)*(e-s)}function b(e,t,n,i,s){const{rScaler:r,bScaler:o,gScaler:a,offset:h}=i,u=new Float32Array((t+1)*(n+1));for(let i=0,s=0;s<n;s++)for(let n=0;n<t;n++,i++){const t=4*i,n=e[t+0],c=e[t+1],l=e[t+2];u[i+s]=n*r+c*a+l*o+h}if("martini"===s){for(let e=(t+1)*t,n=0;n<t;n++,e++)u[e]=u[e-t-1];for(let e=n,t=0;t<n+1;t++,e+=n+1)u[e]=u[e-1]}return u}function P(e,t){if(null===e)return null;const{meshMaxError:n,bounds:s,elevationDecoder:r}=t,{data:o,width:a,height:h}=e;let u,c;switch(t.tesselator){case"martini":u=b(o,a,h,r,t.tesselator),c=I(n,a,u);break;case"delatin":u=b(o,a,h,r,t.tesselator),c=M(n,a,h,u);break;default:a!==h||h&a-1?(u=b(o,a,h,r,"delatin"),c=M(n,a,h,u)):(u=b(o,a,h,r,"martini"),c=I(n,a,u))}const{vertices:l}=c;let{triangles:d}=c,g=function(e,t,n,i,s){const r=n+1,o=e.length/2,a=new Float32Array(3*o),h=new Float32Array(2*o),[u,c,l,d]=s||[0,0,n,i],g=(l-u)/n,_=(d-c)/i;for(let s=0;s<o;s++){const o=e[2*s],c=e[2*s+1],l=c*r+o;a[3*s+0]=o*g+u,a[3*s+1]=-c*_+d,a[3*s+2]=t[l],h[2*s+0]=o/n,h[2*s+1]=c/i}return{POSITION:{value:a,size:3},TEXCOORD_0:{value:h,size:2}}}(l,u,a,h,s);const _=i(g);if(t.skirtHeight){const{attributes:e,triangles:n}=f(g,d,t.skirtHeight);g=e,d=n}return{loaderData:{header:{}},header:{vertexCount:d.length,boundingBox:_},mode:4,indices:{value:Uint32Array.from(d),size:1},attributes:g}}function I(e,t,n){const i=new m(t+1).createTile(n),{vertices:s,triangles:r}=i.getMesh(e);return{vertices:s,triangles:r}}function M(e,t,n,i){const s=new w(i,t+1,n+1);s.run(e);const{coords:r,triangles:o}=s;return{vertices:r,triangles:o}}const x={name:"Terrain",id:"terrain",module:"terrain",version:"3.0.8",worker:!0,extensions:["png","pngraw"],mimeTypes:["image/png"],options:{terrain:{tesselator:"auto",bounds:null,meshMaxError:10,elevationDecoder:{rScaler:1,gScaler:0,bScaler:0,offset:0},skirtHeight:null}}},v={name:"Quantized Mesh",id:"quantized-mesh",module:"terrain",version:"3.0.8",worker:!0,extensions:["terrain"],mimeTypes:["application/vnd.quantized-mesh"],options:{"quantized-mesh":{bounds:[0,0,1,1],skirtHeight:null}}},O={...x,parse:async function(e,t,n){return t.image=t.image||{},t.image.type="data",P(await n.parse(e,t,t.baseUri),t.terrain)}},q=O,A={...v,parseSync:p,parse:async(e,t)=>p(e,t)},L=A}])}));
//# sourceMappingURL=dist.min.js.map