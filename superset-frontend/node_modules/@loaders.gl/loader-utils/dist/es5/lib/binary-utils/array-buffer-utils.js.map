{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.ts"],"names":["toArrayBuffer","data","node","ArrayBuffer","isView","buffer","text","uint8Array","TextEncoder","encode","_toArrayBuffer","Error","compareArrayBuffers","arrayBuffer1","arrayBuffer2","byteLength","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","concatenateTypedArrays","typedArrays","arrays","TypedArrayConstructor","constructor","sumLength","acc","value","array","sliceArrayBuffer","arrayBuffer","byteOffset","subArray","undefined","subarray","arrayCopy"],"mappings":";;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;AAKO,SAASA,aAAT,CAAuBC,IAAvB,EAA+C;AAEpD,MAAIC,IAAI,CAACF,aAAT,EAAwB;AAEtBC,IAAAA,IAAI,GAAGC,IAAI,CAACF,aAAL,CAAmBC,IAAnB,CAAP;AACD;;AAED,MAAIA,IAAI,YAAYE,WAApB,EAAiC;AAC/B,WAAOF,IAAP;AACD;;AAGD,MAAIE,WAAW,CAACC,MAAZ,CAAmBH,IAAnB,CAAJ,EAA8B;AAC5B,WAAOA,IAAI,CAACI,MAAZ;AACD;;AAED,MAAI,OAAOJ,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAMK,IAAI,GAAGL,IAAb;AACA,QAAMM,UAAU,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBH,IAAzB,CAAnB;AACA,WAAOC,UAAU,CAACF,MAAlB;AACD;;AAGD,MAAIJ,IAAI,IAAI,sBAAOA,IAAP,MAAgB,QAAxB,IAAoCA,IAAI,CAACS,cAA7C,EAA6D;AAC3D,WAAOT,IAAI,CAACS,cAAL,EAAP;AACD;;AAED,QAAM,IAAIC,KAAJ,CAAU,eAAV,CAAN;AACD;;AAQM,SAASC,mBAAT,CACLC,YADK,EAELC,YAFK,EAGLC,UAHK,EAII;AACTA,EAAAA,UAAU,GAAGA,UAAU,IAAIF,YAAY,CAACE,UAAxC;;AACA,MAAIF,YAAY,CAACE,UAAb,GAA0BA,UAA1B,IAAwCD,YAAY,CAACC,UAAb,GAA0BA,UAAtE,EAAkF;AAChF,WAAO,KAAP;AACD;;AACD,MAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAeJ,YAAf,CAAf;AACA,MAAMK,MAAM,GAAG,IAAID,UAAJ,CAAeH,YAAf,CAAf;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAA3B,EAAmC,EAAED,CAArC,EAAwC;AACtC,QAAIH,MAAM,CAACG,CAAD,CAAN,KAAcD,MAAM,CAACC,CAAD,CAAxB,EAA6B;AAC3B,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAMM,SAASE,uBAAT,GAAwF;AAAA,oCAApDC,OAAoD;AAApDA,IAAAA,OAAoD;AAAA;;AAE7F,MAAMC,YAAY,GAAGD,OAAO,CAACE,GAAR,CAAY,UAACC,OAAD;AAAA,WAC/BA,OAAO,YAAYtB,WAAnB,GAAiC,IAAIc,UAAJ,CAAeQ,OAAf,CAAjC,GAA2DA,OAD5B;AAAA,GAAZ,CAArB;AAKA,MAAMV,UAAU,GAAGQ,YAAY,CAACG,MAAb,CAAoB,UAACN,MAAD,EAASO,UAAT;AAAA,WAAwBP,MAAM,GAAGO,UAAU,CAACZ,UAA5C;AAAA,GAApB,EAA4E,CAA5E,CAAnB;AAGA,MAAMa,MAAM,GAAG,IAAIX,UAAJ,CAAeF,UAAf,CAAf;AAGA,MAAIc,MAAM,GAAG,CAAb;;AAb6F,6CAcnEN,YAdmE;AAAA;;AAAA;AAc7F,wDAAwC;AAAA,UAA7BO,WAA6B;AACtCF,MAAAA,MAAM,CAACG,GAAP,CAAWD,WAAX,EAAwBD,MAAxB;AACAA,MAAAA,MAAM,IAAIC,WAAW,CAACf,UAAtB;AACD;AAjB4F;AAAA;AAAA;AAAA;AAAA;;AAoB7F,SAAOa,MAAM,CAACvB,MAAd;AACD;;AAQM,SAAS2B,sBAAT,GAA2D;AAAA,qCAArBC,WAAqB;AAArBA,IAAAA,WAAqB;AAAA;;AAEhE,MAAMC,MAAM,GAAGD,WAAf;AAEA,MAAME,qBAAqB,GAAID,MAAM,IAAIA,MAAM,CAACd,MAAP,GAAgB,CAA1B,IAA+Bc,MAAM,CAAC,CAAD,CAAN,CAAUE,WAA1C,IAA0D,IAAxF;;AACA,MAAI,CAACD,qBAAL,EAA4B;AAC1B,UAAM,IAAIxB,KAAJ,CACJ,sGADI,CAAN;AAGD;;AAED,MAAM0B,SAAS,GAAGH,MAAM,CAACR,MAAP,CAAc,UAACY,GAAD,EAAMC,KAAN;AAAA,WAAgBD,GAAG,GAAGC,KAAK,CAACnB,MAA5B;AAAA,GAAd,EAAkD,CAAlD,CAAlB;AAEA,MAAMQ,MAAM,GAAG,IAAIO,qBAAJ,CAA0BE,SAA1B,CAAf;AACA,MAAIR,MAAM,GAAG,CAAb;;AACA,6BAAoBK,MAApB,6BAA4B;AAAvB,QAAMM,KAAK,cAAX;AACHZ,IAAAA,MAAM,CAACG,GAAP,CAAWS,KAAX,EAAkBX,MAAlB;AACAA,IAAAA,MAAM,IAAIW,KAAK,CAACpB,MAAhB;AACD;;AACD,SAAOQ,MAAP;AACD;;AAQM,SAASa,gBAAT,CACLC,WADK,EAELC,UAFK,EAGL5B,UAHK,EAIQ;AACb,MAAM6B,QAAQ,GACZ7B,UAAU,KAAK8B,SAAf,GACI,IAAI5B,UAAJ,CAAeyB,WAAf,EAA4BI,QAA5B,CAAqCH,UAArC,EAAiDA,UAAU,GAAG5B,UAA9D,CADJ,GAEI,IAAIE,UAAJ,CAAeyB,WAAf,EAA4BI,QAA5B,CAAqCH,UAArC,CAHN;AAIA,MAAMI,SAAS,GAAG,IAAI9B,UAAJ,CAAe2B,QAAf,CAAlB;AACA,SAAOG,SAAS,CAAC1C,MAAjB;AACD","sourcesContent":["import {TypedArray} from '../../types';\nimport * as node from '../node/buffer-utils.node';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"],"file":"array-buffer-utils.js"}