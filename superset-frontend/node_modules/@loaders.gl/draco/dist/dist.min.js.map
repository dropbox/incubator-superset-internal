{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///../worker-utils/src/lib/env-utils/globals.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/bundle.ts","webpack:////home/user/apps/loaders.gl/node_modules/process/browser.js","webpack:///./src/lib/utils/version.ts","webpack:///./src/draco-loader.ts","webpack:///../schema/src/lib/schema/impl/schema.ts","webpack:///../schema/src/lib/utils/assert.ts","webpack:///../schema/src/lib/schema/impl/enum.ts","webpack:///../schema/src/lib/schema/impl/type.ts","webpack:///../schema/src/lib/schema/impl/field.ts","webpack:///./src/lib/utils/schema-attribute-utils.ts","webpack:///../schema/src/lib/schema-utils/type-utils.ts","webpack:///./src/lib/draco-parser.ts","webpack:///../schema/src/category/mesh/mesh-utils.ts","webpack:///../worker-utils/src/lib/library-utils/library-utils.ts","webpack:///../worker-utils/src/lib/env-utils/assert.ts","webpack:///./src/lib/draco-module-loader.ts","webpack:///./src/lib/draco-builder.ts","webpack:///./src/draco-writer.ts","webpack:///./src/index.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","globals","self","global","document","global_","isBrowser","process","String","browser","isWorker","importScripts","matches","orientation","version","exec","parseFloat","g","this","Function","e","moduleExports","require","_global","loaders","assign","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","DracoLoader","id","worker","extensions","mimeTypes","binary","tests","options","draco","decoderType","WebAssembly","libraryPath","extraAttributes","attributeNameEntry","undefined","Schema","constructor","fields","metadata","condition","message","assert","isArray","usedNames","field","console","warn","checkNames","Map","compareTo","other","select","columnNames","nameMap","selectedFields","filter","selectAt","columnIndices","map","index","Boolean","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","m1","m2","Type","DataType","x","typeId","Null","Int","Float","Binary","Utf8","Bool","Decimal","Date","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Dictionary","NONE","isSigned","bitWidth","super","toString","Int8","Int16","Int32","Uint8","Uint16","Uint32","Precision","precision","Float32","Float64","listSize","child","children","type","valueType","Field","nullable","clone","getArrowFieldFromAttribute","attributeName","attribute","loaderData","metadataMap","makeMetadata","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","getArrowTypeFromTypedArray","size","set","JSON","stringify","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","1","2","3","4","5","6","9","DracoParser","decoder","Decoder","metadataQuerier","MetadataQuerier","destroy","parseSync","arrayBuffer","buffer","DecoderBuffer","Init","byteLength","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","TRIANGULAR_MESH","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","POINT_CLOUD","DecodeBufferToPointCloud","ok","ptr","error_msg","_getDracoLoaderData","geometry","_getMeshData","boundingBox","attributes","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","y","z","getMeshBoundingBox","schema","indices","namedLoaderDataAttributes","result","dracoAttribute","transformAttributesLoaderData","indicesField","makeSchemaFromAttributes","loader","header","vertexCount","num_points","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","topology","_getTriangleStripIndices","_getTriangleListIndices","loaderAttribute","_deduceAttributeName","_getAttributeValues","byteOffset","byteStride","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","slice","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","numValues","intArray","GetValue","getUint32Array","TypedArrayCtor","numComponents","BYTES_PER_ELEMENT","dataType","attributeType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","attributeUniqueId","entries","thisAttributeType","dracoAttributeConstant","entryName","string","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","skipAttributes","dracoAttributeName","SkipAttributeTransform","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","min_value","loadLibraryPromises","async","loadLibrary","libraryUrl","moduleName","library","startsWith","CDN","getLibraryUrl","endsWith","response","fetch","node","scriptSource","eval","script","createElement","appendChild","createTextNode","text","body","loadLibraryFromString","loadLibraryFromFile","loadDecoderPromise","loadEncoderPromise","loadDracoDecoderModule","draco3d","createDecoderModule","then","DracoDecoderModule","wasmBinary","Promise","all","globalThis","resolve","onModuleLoaded","initializeDracoDecoder","loadDracoDecoder","loadDracoEncoderModule","createEncoderModule","DracoEncoderModule","loadDracoEncoder","GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","COLOR_0","TEXCOORD_0","DracoBuilder","dracoEncoder","Encoder","dracoMeshBuilder","MeshBuilder","dracoMetadataBuilder","MetadataBuilder","destroyEncodedObject","encodeSync","mesh","log","_setOptions","pointcloud","_encodePointCloud","_encodeMesh","_getAttributesFromMesh","dracoPointCloud","_addGeometryMetadata","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","dracoInt8ArrayToArrayBuffer","dracoMesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","_getPositionAttribute","_addAttributeToMesh","_addAttributeMetadata","error","ArrayBuffer","isView","_getDracoAttributeType","numFaces","AddFacesToMesh","builder","AddInt8Attribute","AddInt16Attribute","AddInt32Attribute","Uint8ClampedArray","AddUInt8Attribute","AddUInt16Attribute","AddUInt32Attribute","AddFloatAttribute","toLowerCase","GENERIC","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","container","Math","trunc","AddIntEntry","AddDoubleEntry","AddIntEntryArray","AddStringEntry","outputBuffer","outputData","DracoWriter","encode","data","dracoBuilder","DRACOBuilder","DracoWorkerLoader","parse","dracoParser","_TypecheckDracoLoader"],"mappings":"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","file":"dist.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// @ts-nocheck\nconst moduleExports = require('./index');\nconst _global = typeof window === 'undefined' ? global : window;\n_global.loaders = _global.loaders || {};\nmodule.exports = Object.assign(_global.loaders, moduleExports);\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n","import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n","import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n","// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: number;\n  readonly bitWidth: number;\n\n  constructor(unit, bitWidth) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n","import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n","import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nimport {MeshAttribute, DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\nexport function makeSchemaFromAttributes(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  return new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadataMap\n  );\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}\n","import type {TypedArray} from '../../types';\nimport {DataType, Float32, Float64, Int16, Int32, Int8, Uint16, Uint32, Uint8} from '../schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n","/* eslint-disable camelcase */\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  TypedArray,\n  // standard mesh output data\n  MeshData,\n  MeshAttribute,\n  // standard mesh with draco metadata\n  DracoMeshData,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {makeSchemaFromAttributes} from './utils/schema-attribute-utils';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMeshData {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = makeSchemaFromAttributes(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMeshData = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshData {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n","// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\n\ntype Attribute = {\n  size?: number;\n  type?: number;\n  normalized?: boolean;\n  value: TypedArray;\n};\n\ntype TypedArrays = {[key: string]: TypedArray};\nexport type Attributes = {[key: string]: Attribute};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: Attributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n","/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName?: string, options?): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && (await node.requireFromFile(libraryUrl));\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n","// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_VERSION = '1.4.1';\nconst DRACO_JS_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_VERSION}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n","/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray, DracoMeshData} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMeshData, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMeshData) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMeshData, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMeshData` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n","import type {Writer} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData} from './lib/draco-types';\nimport type {DracoBuildOptions} from './lib/draco-builder';\nimport DRACOBuilder from './lib/draco-builder';\nimport {loadDracoEncoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoWriterOptions = DracoBuildOptions & {};\n\nconst DEFAULT_DRACO_OPTIONS = {\n  pointcloud: false, // Set to true if pointcloud (mode: 0, no indices)\n  attributeNameEntry: 'name'\n  // Draco Compression Parameters\n  // method: 'MESH_EDGEBREAKER_ENCODING',\n  // speed: [5, 5],\n  // quantization: {\n  //   POSITION: 10\n  // }\n};\n\n/**\n * Exporter for Draco3D compressed geometries\n */\nexport const DracoWriter: Writer = {\n  name: 'DRACO',\n  id: 'draco',\n  module: 'draco',\n  version: VERSION,\n  extensions: ['drc'],\n  encode,\n  options: {\n    draco: DEFAULT_DRACO_OPTIONS\n  }\n};\n\nasync function encode(\n  data: DracoMeshData,\n  options: {draco?: DracoWriterOptions} = {}\n): Promise<ArrayBuffer> {\n  // Dynamically load draco\n  const {draco} = await loadDracoEncoderModule(options);\n  const dracoBuilder = new DRACOBuilder(draco);\n\n  try {\n    return dracoBuilder.encodeSync(data, options.draco);\n  } finally {\n    dracoBuilder.destroy();\n  }\n}\n","import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMeshData, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\n\n// Draco data types\n\nexport type {DracoMeshData, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(\n  arrayBuffer: ArrayBuffer,\n  options?: DracoLoaderOptions\n): Promise<DracoMeshData> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n"],"sourceRoot":""}