"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _JSONArrow = _interopRequireDefault(require("./JSONArrow"));

var _getCollectionEntries = _interopRequireDefault(require("./getCollectionEntries"));

var _JSONNode = _interopRequireDefault(require("./JSONNode"));

var _ItemRange = _interopRequireDefault(require("./ItemRange"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function isRange(rangeOrEntry) {
  return rangeOrEntry.to !== undefined;
}

function renderChildNodes(props, from, to) {
  var nodeType = props.nodeType,
      data = props.data,
      collectionLimit = props.collectionLimit,
      circularCache = props.circularCache,
      keyPath = props.keyPath,
      postprocessValue = props.postprocessValue,
      sortObjectKeys = props.sortObjectKeys;
  var childNodes = [];
  (0, _getCollectionEntries.default)(nodeType, data, sortObjectKeys, collectionLimit, from, to).forEach(function (entry) {
    if (isRange(entry)) {
      childNodes.push( /*#__PURE__*/_react.default.createElement(_ItemRange.default, (0, _extends2.default)({}, props, {
        key: "ItemRange--".concat(entry.from, "-").concat(entry.to),
        from: entry.from,
        to: entry.to,
        renderChildNodes: renderChildNodes
      })));
    } else {
      var key = entry.key,
          value = entry.value;
      var isCircular = circularCache.indexOf(value) !== -1;
      childNodes.push( /*#__PURE__*/_react.default.createElement(_JSONNode.default, (0, _extends2.default)({}, props, {
        postprocessValue: postprocessValue,
        collectionLimit: collectionLimit,
        key: "Node--".concat(key),
        keyPath: [key].concat((0, _toConsumableArray2.default)(keyPath)),
        value: postprocessValue(value),
        circularCache: [].concat((0, _toConsumableArray2.default)(circularCache), [value]),
        isCircular: isCircular,
        hideRoot: false
      })));
    }
  });
  return childNodes;
}

function getStateFromProps(props) {
  // calculate individual node expansion if necessary
  var expanded = !props.isCircular ? props.shouldExpandNode(props.keyPath, props.data, props.level) : false;
  return {
    expanded: expanded
  };
}

var JSONNestedNode = /*#__PURE__*/function (_React$Component) {
  (0, _inherits2.default)(JSONNestedNode, _React$Component);

  var _super = _createSuper(JSONNestedNode);

  function JSONNestedNode(props) {
    var _this;

    (0, _classCallCheck2.default)(this, JSONNestedNode);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleClick", function () {
      if (_this.props.expandable) {
        _this.setState({
          expanded: !_this.state.expanded
        });
      }
    });
    _this.state = getStateFromProps(props);
    return _this;
  }

  (0, _createClass2.default)(JSONNestedNode, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var nextState = getStateFromProps(nextProps);

      if (getStateFromProps(this.props).expanded !== nextState.expanded) {
        this.setState(nextState);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var _this2 = this;

      return !!Object.keys(nextProps).find(function (key) {
        return key !== 'circularCache' && (key === 'keyPath' ? nextProps[key].join('/') !== _this2.props[key].join('/') : nextProps[key] !== _this2.props[key]);
      }) || nextState.expanded !== this.state.expanded;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          getItemString = _this$props.getItemString,
          nodeTypeIndicator = _this$props.nodeTypeIndicator,
          nodeType = _this$props.nodeType,
          data = _this$props.data,
          hideRoot = _this$props.hideRoot,
          createItemString = _this$props.createItemString,
          styling = _this$props.styling,
          collectionLimit = _this$props.collectionLimit,
          keyPath = _this$props.keyPath,
          labelRenderer = _this$props.labelRenderer,
          expandable = _this$props.expandable;
      var expanded = this.state.expanded;
      var renderedChildren = expanded || hideRoot && this.props.level === 0 ? renderChildNodes(_objectSpread(_objectSpread({}, this.props), {}, {
        level: this.props.level + 1
      })) : null;

      var itemType = /*#__PURE__*/_react.default.createElement("span", styling('nestedNodeItemType', expanded), nodeTypeIndicator);

      var renderedItemString = getItemString(nodeType, data, itemType, createItemString(data, collectionLimit), keyPath);
      var stylingArgs = [keyPath, nodeType, expanded, expandable];
      return hideRoot ? /*#__PURE__*/_react.default.createElement("li", styling.apply(void 0, ['rootNode'].concat(stylingArgs)), /*#__PURE__*/_react.default.createElement("ul", styling.apply(void 0, ['rootNodeChildren'].concat(stylingArgs)), renderedChildren)) : /*#__PURE__*/_react.default.createElement("li", styling.apply(void 0, ['nestedNode'].concat(stylingArgs)), expandable && /*#__PURE__*/_react.default.createElement(_JSONArrow.default, {
        styling: styling,
        nodeType: nodeType,
        expanded: expanded,
        onClick: this.handleClick
      }), /*#__PURE__*/_react.default.createElement("label", (0, _extends2.default)({}, styling.apply(void 0, [['label', 'nestedNodeLabel']].concat(stylingArgs)), {
        onClick: this.handleClick
      }), labelRenderer.apply(void 0, stylingArgs)), /*#__PURE__*/_react.default.createElement("span", (0, _extends2.default)({}, styling.apply(void 0, ['nestedNodeItemString'].concat(stylingArgs)), {
        onClick: this.handleClick
      }), renderedItemString), /*#__PURE__*/_react.default.createElement("ul", styling.apply(void 0, ['nestedNodeChildren'].concat(stylingArgs)), renderedChildren));
    }
  }]);
  return JSONNestedNode;
}(_react.default.Component);

exports.default = JSONNestedNode;
(0, _defineProperty2.default)(JSONNestedNode, "propTypes", {
  getItemString: _propTypes.default.func.isRequired,
  nodeTypeIndicator: _propTypes.default.any,
  nodeType: _propTypes.default.string.isRequired,
  data: _propTypes.default.any,
  hideRoot: _propTypes.default.bool.isRequired,
  createItemString: _propTypes.default.func.isRequired,
  styling: _propTypes.default.func.isRequired,
  collectionLimit: _propTypes.default.number,
  keyPath: _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])).isRequired,
  labelRenderer: _propTypes.default.func.isRequired,
  shouldExpandNode: _propTypes.default.func,
  level: _propTypes.default.number.isRequired,
  sortObjectKeys: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),
  isCircular: _propTypes.default.bool,
  expandable: _propTypes.default.bool
});
(0, _defineProperty2.default)(JSONNestedNode, "defaultProps", {
  data: [],
  circularCache: [],
  level: 0,
  expandable: true
});