import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _extends from "@babel/runtime/helpers/extends";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import JSONArrow from './JSONArrow';
import getCollectionEntries from './getCollectionEntries';
import JSONNode from './JSONNode';
import ItemRange from './ItemRange';

function isRange(rangeOrEntry) {
  return rangeOrEntry.to !== undefined;
}

function renderChildNodes(props, from, to) {
  var nodeType = props.nodeType,
      data = props.data,
      collectionLimit = props.collectionLimit,
      circularCache = props.circularCache,
      keyPath = props.keyPath,
      postprocessValue = props.postprocessValue,
      sortObjectKeys = props.sortObjectKeys;
  var childNodes = [];
  getCollectionEntries(nodeType, data, sortObjectKeys, collectionLimit, from, to).forEach(function (entry) {
    if (isRange(entry)) {
      childNodes.push( /*#__PURE__*/React.createElement(ItemRange, _extends({}, props, {
        key: "ItemRange--".concat(entry.from, "-").concat(entry.to),
        from: entry.from,
        to: entry.to,
        renderChildNodes: renderChildNodes
      })));
    } else {
      var key = entry.key,
          value = entry.value;
      var isCircular = circularCache.indexOf(value) !== -1;
      childNodes.push( /*#__PURE__*/React.createElement(JSONNode, _extends({}, props, {
        postprocessValue: postprocessValue,
        collectionLimit: collectionLimit,
        key: "Node--".concat(key),
        keyPath: [key].concat(_toConsumableArray(keyPath)),
        value: postprocessValue(value),
        circularCache: [].concat(_toConsumableArray(circularCache), [value]),
        isCircular: isCircular,
        hideRoot: false
      })));
    }
  });
  return childNodes;
}

function getStateFromProps(props) {
  // calculate individual node expansion if necessary
  var expanded = !props.isCircular ? props.shouldExpandNode(props.keyPath, props.data, props.level) : false;
  return {
    expanded: expanded
  };
}

var JSONNestedNode = /*#__PURE__*/function (_React$Component) {
  _inherits(JSONNestedNode, _React$Component);

  var _super = _createSuper(JSONNestedNode);

  function JSONNestedNode(props) {
    var _this;

    _classCallCheck(this, JSONNestedNode);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "handleClick", function () {
      if (_this.props.expandable) {
        _this.setState({
          expanded: !_this.state.expanded
        });
      }
    });

    _this.state = getStateFromProps(props);
    return _this;
  }

  _createClass(JSONNestedNode, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var nextState = getStateFromProps(nextProps);

      if (getStateFromProps(this.props).expanded !== nextState.expanded) {
        this.setState(nextState);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var _this2 = this;

      return !!Object.keys(nextProps).find(function (key) {
        return key !== 'circularCache' && (key === 'keyPath' ? nextProps[key].join('/') !== _this2.props[key].join('/') : nextProps[key] !== _this2.props[key]);
      }) || nextState.expanded !== this.state.expanded;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          getItemString = _this$props.getItemString,
          nodeTypeIndicator = _this$props.nodeTypeIndicator,
          nodeType = _this$props.nodeType,
          data = _this$props.data,
          hideRoot = _this$props.hideRoot,
          createItemString = _this$props.createItemString,
          styling = _this$props.styling,
          collectionLimit = _this$props.collectionLimit,
          keyPath = _this$props.keyPath,
          labelRenderer = _this$props.labelRenderer,
          expandable = _this$props.expandable;
      var expanded = this.state.expanded;
      var renderedChildren = expanded || hideRoot && this.props.level === 0 ? renderChildNodes(_objectSpread(_objectSpread({}, this.props), {}, {
        level: this.props.level + 1
      })) : null;
      var itemType = /*#__PURE__*/React.createElement("span", styling('nestedNodeItemType', expanded), nodeTypeIndicator);
      var renderedItemString = getItemString(nodeType, data, itemType, createItemString(data, collectionLimit), keyPath);
      var stylingArgs = [keyPath, nodeType, expanded, expandable];
      return hideRoot ? /*#__PURE__*/React.createElement("li", styling.apply(void 0, ['rootNode'].concat(stylingArgs)), /*#__PURE__*/React.createElement("ul", styling.apply(void 0, ['rootNodeChildren'].concat(stylingArgs)), renderedChildren)) : /*#__PURE__*/React.createElement("li", styling.apply(void 0, ['nestedNode'].concat(stylingArgs)), expandable && /*#__PURE__*/React.createElement(JSONArrow, {
        styling: styling,
        nodeType: nodeType,
        expanded: expanded,
        onClick: this.handleClick
      }), /*#__PURE__*/React.createElement("label", _extends({}, styling.apply(void 0, [['label', 'nestedNodeLabel']].concat(stylingArgs)), {
        onClick: this.handleClick
      }), labelRenderer.apply(void 0, stylingArgs)), /*#__PURE__*/React.createElement("span", _extends({}, styling.apply(void 0, ['nestedNodeItemString'].concat(stylingArgs)), {
        onClick: this.handleClick
      }), renderedItemString), /*#__PURE__*/React.createElement("ul", styling.apply(void 0, ['nestedNodeChildren'].concat(stylingArgs)), renderedChildren));
    }
  }]);

  return JSONNestedNode;
}(React.Component);

_defineProperty(JSONNestedNode, "propTypes", {
  getItemString: PropTypes.func.isRequired,
  nodeTypeIndicator: PropTypes.any,
  nodeType: PropTypes.string.isRequired,
  data: PropTypes.any,
  hideRoot: PropTypes.bool.isRequired,
  createItemString: PropTypes.func.isRequired,
  styling: PropTypes.func.isRequired,
  collectionLimit: PropTypes.number,
  keyPath: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,
  labelRenderer: PropTypes.func.isRequired,
  shouldExpandNode: PropTypes.func,
  level: PropTypes.number.isRequired,
  sortObjectKeys: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  isCircular: PropTypes.bool,
  expandable: PropTypes.bool
});

_defineProperty(JSONNestedNode, "defaultProps", {
  data: [],
  circularCache: [],
  level: 0,
  expandable: true
});

export { JSONNestedNode as default };