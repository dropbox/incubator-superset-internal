"use strict";

exports.__esModule = true;
exports.default = void 0;

var _d3Interpolate = require("d3-interpolate");

var _d3Scale = require("d3-scale");

var _SchemeWrapper = _interopRequireDefault(require("./SchemeWrapper"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArrayOfArray(x) {
  return Array.isArray(x[x.length - 1]);
}

class ContinuousSchemeWrapper extends _SchemeWrapper.default {
  get colors() {
    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined') {
      return this.scheme.colors;
    }

    return this.getColors();
  }

  get interpolator() {
    if ('interpolator' in this.scheme && typeof this.scheme.interpolator !== 'undefined') {
      return this.scheme.interpolator;
    }

    const colors = this.scheme.colors;
    return (0, _d3Interpolate.piecewise)(_d3Interpolate.interpolateRgb, (isArrayOfArray(colors) ? colors[colors.length - 1] : colors).slice());
  }
  /**
   * Get colors from this scheme
   * @param numColors number of colors to return.
   * Will interpolate the current scheme to match the number of colors requested
   * @param extent The extent of the color range to use.
   * For example [0.2, 1] will rescale the color scheme
   * such that color values in the range [0, 0.2) are excluded from the scheme.
   */


  getColors(numColors = 2, extent = [0, 1]) {
    if ('colors' in this.scheme && typeof this.scheme.colors !== 'undefined' && extent[0] === 0 && extent[1] === 1) {
      const {
        colors
      } = this.scheme;

      if (isArrayOfArray(colors)) {
        if (typeof colors[numColors] !== 'undefined') {
          return colors[numColors].slice();
        }
      } else if (numColors === colors.length) {
        return colors.slice();
      }
    }

    const {
      interpolator
    } = this;
    const adjustExtent = (0, _d3Scale.scaleLinear)().range(extent).clamp(true);
    return (0, _d3Interpolate.quantize)(t => interpolator(adjustExtent(t)), numColors);
  }

  createScaleLinear() {
    // The manual casting is necessary until @types/d3-scale is corrected
    // In recent version of d3-scale the output from scaleSequential is compatible with linear scale
    // (It has .range(),  ...)
    return (0, _d3Scale.scaleSequential)(this.interpolator);
  }

}

exports.default = ContinuousSchemeWrapper;