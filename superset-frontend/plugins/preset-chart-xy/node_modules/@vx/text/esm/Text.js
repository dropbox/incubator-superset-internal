import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import reduceCSSCalc from 'reduce-css-calc';
import getStringWidth from './util/getStringWidth';
var SVG_STYLE = {
  overflow: 'visible'
};

function isNumber(val) {
  return typeof val === 'number';
}

var Text = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Text, _React$Component);

  function Text() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      wordsByLines: []
    });

    _defineProperty(_assertThisInitialized(_this), "wordsWithWidth", []);

    _defineProperty(_assertThisInitialized(_this), "spaceWidth", 0);

    return _this;
  }

  var _proto = Text.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateWordsByLines(this.props, true);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // We calculated a new state, break out of the loop.
    if (prevState.wordsByLines !== this.state.wordsByLines) {
      return;
    }

    var needCalculate = prevProps.children !== this.props.children || prevProps.style !== this.props.style;
    this.updateWordsByLines(this.props, needCalculate);
  };

  _proto.updateWordsByLines = function updateWordsByLines(props, needCalculate) {
    if (needCalculate === void 0) {
      needCalculate = false;
    }

    // Only perform calculations if using features that require them (multiline, scaleToFit)
    if (props.width || props.scaleToFit) {
      if (needCalculate) {
        var words = props.children ? props.children.toString().split(/(?:(?!\u00A0+)\s+)/) : [];
        this.wordsWithWidth = words.map(function (word) {
          return {
            word: word,
            width: getStringWidth(word, props.style) || 0
          };
        });
        this.spaceWidth = getStringWidth("\xA0", props.style) || 0;
      }

      var wordsByLines = this.calculateWordsByLines(this.wordsWithWidth, this.spaceWidth, props.width);
      this.setState({
        wordsByLines: wordsByLines
      });
    } else {
      this.updateWordsWithoutCalculate(props);
    }
  };

  _proto.updateWordsWithoutCalculate = function updateWordsWithoutCalculate(props) {
    var words = props.children ? props.children.toString().split(/(?:(?!\u00A0+)\s+)/) : [];
    this.setState({
      wordsByLines: [{
        words: words
      }]
    });
  };

  _proto.calculateWordsByLines = function calculateWordsByLines(wordsWithWidth, spaceWidth, lineWidth) {
    var scaleToFit = this.props.scaleToFit;
    return wordsWithWidth.reduce(function (result, _ref) {
      var word = _ref.word,
          width = _ref.width;
      var currentLine = result[result.length - 1];

      if (currentLine && (lineWidth == null || scaleToFit || (currentLine.width || 0) + width + spaceWidth < lineWidth)) {
        // Word can be added to an existing line
        currentLine.words.push(word);
        currentLine.width = currentLine.width || 0;
        currentLine.width += width + spaceWidth;
      } else {
        // Add first word to line or word is too long to scaleToFit on existing line
        var newLine = {
          words: [word],
          width: width
        };
        result.push(newLine);
      }

      return result;
    }, []);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        dx = _this$props.dx,
        dy = _this$props.dy,
        textAnchor = _this$props.textAnchor,
        verticalAnchor = _this$props.verticalAnchor,
        scaleToFit = _this$props.scaleToFit,
        angle = _this$props.angle,
        lineHeight = _this$props.lineHeight,
        capHeight = _this$props.capHeight,
        innerRef = _this$props.innerRef,
        width = _this$props.width,
        textProps = _objectWithoutPropertiesLoose(_this$props, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "innerRef", "width"]);

    var wordsByLines = this.state.wordsByLines;
    var x = textProps.x,
        y = textProps.y;
    var startDy;

    if (verticalAnchor === 'start') {
      startDy = reduceCSSCalc("calc(" + capHeight + ")");
    } else if (verticalAnchor === 'middle') {
      startDy = reduceCSSCalc("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))");
    } else {
      startDy = reduceCSSCalc("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
    }

    var transform;
    var transforms = [];

    if (isNumber(x) && isNumber(y) && isNumber(width) && scaleToFit && wordsByLines.length > 0) {
      var lineWidth = wordsByLines[0].width || 1;
      var sx = width / lineWidth;
      var sy = sx;
      var originX = x - sx * x;
      var originY = y - sy * y;
      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
    }

    if (angle) {
      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
    }

    if (transforms.length > 0) {
      transform = transforms.join(' ');
    }

    return /*#__PURE__*/React.createElement("svg", {
      ref: innerRef,
      x: dx,
      y: dy,
      fontSize: textProps.fontSize,
      style: SVG_STYLE
    }, /*#__PURE__*/React.createElement("text", _extends({
      transform: transform
    }, textProps, {
      textAnchor: textAnchor
    }), wordsByLines.map(function (line, index) {
      return /*#__PURE__*/React.createElement("tspan", {
        key: index,
        x: x,
        dy: index === 0 ? startDy : lineHeight
      }, line.words.join(' '));
    })));
  };

  return Text;
}(React.Component);

_defineProperty(Text, "propTypes", {
  className: _pt.string,
  scaleToFit: _pt.bool,
  angle: _pt.number,
  textAnchor: _pt.oneOf(['start', 'middle', 'end', 'inherit']),
  verticalAnchor: _pt.oneOf(['start', 'middle', 'end']),
  innerRef: _pt.oneOfType([_pt.string, _pt.func, _pt.object]),
  x: _pt.oneOfType([_pt.string, _pt.number]),
  y: _pt.oneOfType([_pt.string, _pt.number]),
  dx: _pt.oneOfType([_pt.string, _pt.number]),
  dy: _pt.oneOfType([_pt.string, _pt.number]),
  fontSize: _pt.oneOfType([_pt.string, _pt.number]),
  fontFamily: _pt.string,
  fill: _pt.string,
  width: _pt.number,
  children: _pt.oneOfType([_pt.string, _pt.number])
});

_defineProperty(Text, "defaultProps", {
  x: 0,
  y: 0,
  dx: 0,
  dy: 0,
  lineHeight: '1em',
  capHeight: '0.71em',
  // Magic number from d3
  scaleToFit: false,
  textAnchor: 'start',
  verticalAnchor: 'end' // default SVG behavior

});

export default Text;