{"version":3,"file":"899517fd62d084d3de3d.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","webpack://superset/../../../src/utils/tesselator.ts","webpack://superset/../../../src/solid-polygon-layer/polygon.ts","webpack://superset/../../../src/solid-polygon-layer/polygon-tesselator.ts","webpack://superset/../../../src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.ts","webpack://superset/../../../src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.ts","webpack://superset/../../../src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.ts","webpack://superset/../../../src/solid-polygon-layer/solid-polygon-layer.ts","webpack://superset/../../../src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.ts","webpack://superset/./node_modules/earcut/src/earcut.js"],"sourcesContent":["export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";\n//# sourceMappingURL=lights.glsl.js.map","import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";\n//# sourceMappingURL=phong-lighting.glsl.js.map","import { lights } from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nimport type {Position} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\n\ntype WindingOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\n/** A scratch object for sending winding options */\nconst windingOptions: WindingOptions = {\n  isClosed: true\n};\n\n// 4 data formats are supported:\n\n/** Simple Polygon: an array of points */\nexport type NestedSimplePolygonGeometry = Position[];\n/** Complex Polygon: an array of array of points (array of rings)\n * with the first ring representing the outer hull and other rings representing holes\n */\nexport type NestedComplexPolygonGeometry = Position[][];\n/** An array of numbers (flattened \"simple polygon\") */\nexport type FlatSimplePolygonGeometry = NumericArray;\n/** Flattened \"complex polygon\" */\nexport type FlatComplexPolygonGeometry = {positions: NumericArray; holeIndices: NumericArray};\n\nexport type PolygonGeometry =\n  | NestedSimplePolygonGeometry\n  | NestedComplexPolygonGeometry\n  | FlatSimplePolygonGeometry\n  | FlatComplexPolygonGeometry;\n\nexport type NormalizedPolygonGeometry = FlatSimplePolygonGeometry | FlatComplexPolygonGeometry;\n\n/**\n * Ensure a polygon is valid format\n */\nfunction validate(polygon: PolygonGeometry): void {\n  polygon = (polygon && (polygon as FlatComplexPolygonGeometry).positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/** Get the positions from a normalized polygon */\nexport function getPositions(polygon: NormalizedPolygonGeometry): NumericArray {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\n\n/** Get the hole indices from a normalized polygon */\nexport function getHoleIndices(polygon: NormalizedPolygonGeometry): NumericArray | null {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\n/**\n * Check if a polygon is nested or flat\n * Returns true if the polygon is a flat polygon (i.e. not an array of polygons)\n */\nfunction isNested(\n  polygon: PolygonGeometry\n): polygon is NestedSimplePolygonGeometry | NestedComplexPolygonGeometry {\n  return Array.isArray(polygon[0]);\n}\n\n/**\n * Check if a polygon is simple or complex\n * Returns true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(\n  polygon: NestedSimplePolygonGeometry | NestedComplexPolygonGeometry\n): polygon is NestedSimplePolygonGeometry {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * Returns true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon: NestedSimplePolygonGeometry): boolean {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * Returns true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  startIndex: number,\n  /** end index of the path in the positions array */\n  endIndex: number\n): boolean {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyNestedRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  simplePolygon: NestedSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** modify polygon to be of the specified winding direction */\n  windingDirection: number\n): number {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyFlatRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  srcStartIndex: number = 0,\n  /** end index of the path in the positions array */\n  srcEndIndex: number,\n  windingDirection: number\n): number {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n */\n/* eslint-disable max-statements */\nexport function normalize(\n  polygon: PolygonGeometry,\n  positionSize: number\n): NormalizedPolygonGeometry {\n  validate(polygon);\n\n  const positions: number[] = [];\n  const holeIndices: number[] = [];\n\n  if ('positions' in polygon) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i],\n          i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (!isNested(polygon)) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(\n        positions,\n        targetIndex,\n        simplePolygon,\n        positionSize,\n        polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n      );\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Calculate the area of a single plane of the polygon\n */\nfunction getPlaneArea(positions: NumericArray, xIndex: number, yIndex: number): number {\n  const numVerts = positions.length / 3;\n  let area = 0;\n  for (let i = 0; i < numVerts; i++) {\n    const j = (i + 1) % numVerts;\n    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];\n    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];\n  }\n  return Math.abs(area / 2);\n}\n\nfunction permutePositions(positions: NumericArray, xIndex: number, yIndex: number, zIndex: number) {\n  const numVerts = positions.length / 3;\n  for (let i = 0; i < numVerts; i++) {\n    const o = i * 3;\n\n    const x = positions[o + 0];\n    const y = positions[o + 1];\n    const z = positions[o + 2];\n\n    positions[o + xIndex] = x;\n    positions[o + yIndex] = y;\n    positions[o + zIndex] = z;\n  }\n}\n\n/*\n * Get vertex indices for drawing polygon mesh (triangulation)\n */\n// eslint-disable-next-line complexity, max-statements\nexport function getSurfaceIndices(\n  polygon: NormalizedPolygonGeometry,\n  positionSize: number,\n  preproject?: (xy: number[]) => number[],\n  full3d?: boolean\n): number[] {\n  let holeIndices = getHoleIndices(polygon);\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n\n  const is3d = full3d && positionSize === 3;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n\n    // Clone the array\n    positions = positions.slice();\n\n    const p: number[] = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n\n      if (is3d) {\n        p[2] = positions[i + 2];\n      }\n\n      const xy = preproject(p);\n\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n\n      if (is3d) {\n        positions[i + 2] = xy[2];\n      }\n    }\n  }\n\n  if (is3d) {\n    // calculate plane with largest area\n    const xyArea = getPlaneArea(positions, 0, 1);\n    const xzArea = getPlaneArea(positions, 0, 2);\n    const yzArea = getPlaneArea(positions, 1, 2);\n\n    if (!xyArea && !xzArea && !yzArea) {\n      return []; // no planes have area, nothing we can do\n    }\n\n    // permute positions to make the largest plane xy for earcut\n    if (xyArea > xzArea && xyArea > yzArea) {\n      // xy plane largest, nothing to do\n    } else if (xzArea > yzArea) {\n      // xz plane largest, permute to make xyz -> xzy\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 0, 2, 1);\n    } else {\n      // yz plane largest, permute to make xyz -> yzx\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 2, 0, 1);\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n    full3d?: boolean;\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(\n      polygon,\n      this.positionSize,\n      this.opts.preproject,\n      this.opts.full3d\n    );\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, hasFeatures, FEATURES} from '@luma.gl/core';\n\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from './polygon-tesselator';\n\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Color,\n  Material,\n  Accessor,\n  AccessorFunction,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {PolygonGeometry} from './polygon';\n\ntype _SolidPolygonLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** Whether to fill the polygons\n   * @default true\n   */\n  filled?: boolean;\n  /** Whether to extrude the polygons\n   * @default false\n   */\n  extruded?: boolean;\n  /** Whether to generate a line wireframe of the polygon.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * (Experimental) If `false`, will skip normalizing the coordinates returned by `getPolygon`.\n   * @default true\n   */\n  _normalize?: boolean;\n  /**\n   * (Experimental) This prop is only effective with `_normalize: false`.\n   * It specifies the winding order of rings in the polygon data, one of 'CW' (clockwise) and 'CCW' (counter-clockwise)\n   */\n  _windingOrder?: 'CW' | 'CCW';\n\n  /**\n   * (Experimental) This prop is only effective with `XYZ` data.\n   * When true, polygon tesselation will be performed on the plane with the largest area, instead of the xy plane.\n   * @default false\n   */\n  _full3d?: boolean;\n\n  /** Elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /** Polygon geometry accessor. */\n  getPolygon?: AccessorFunction<DataT, PolygonGeometry>;\n  /** Extrusion height accessor.\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n  /** Fill color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n  /** Stroke color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** Render filled and/or extruded polygons. */\nexport type SolidPolygonLayerProps<DataT = any> = _SolidPolygonLayerProps<DataT> & LayerProps;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<SolidPolygonLayerProps> = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  getElevation: {type: 'accessor', value: 1000},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  material: true\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class SolidPolygonLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SolidPolygonLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SolidPolygonLayer';\n\n  state!: {\n    topModel?: Model;\n    sideModel?: Model;\n    models?: Model[];\n    numInstances: number;\n    polygonTesselator: PolygonTesselator;\n  };\n\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  initializeState() {\n    const {gl, viewport} = this.context;\n    let {coordinateSystem} = this.props;\n    const {_full3d} = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    let preproject: ((xy: number[]) => number[]) | undefined;\n\n    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n\n    const attributeManager = this.getAttributeManager()!;\n    const noAlloc = true;\n\n    attributeManager.remove(['instancePickingColors']);\n\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateIndices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: GL.UNSIGNED_BYTE,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = (data as any[]).find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  disablePickingIndex(objectIndex: number) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < (data as any[]).length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {extruded, filled, wireframe, elevationScale} = this.props;\n    const {topModel, sideModel, polygonTesselator} = this.state;\n\n    const renderUniforms = {\n      ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    // Note: the order is important\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n      if (wireframe) {\n        sideModel.setDrawMode(GL.LINE_STRIP);\n        sideModel.setUniforms({isWireframe: true}).draw();\n      }\n      if (filled) {\n        sideModel.setDrawMode(GL.TRIANGLE_FAN);\n        sideModel.setUniforms({isWireframe: false}).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams: UpdateParameters<this>) {\n    super.updateState(updateParams);\n\n    this.updateGeometry(updateParams);\n\n    const {props, oldProps, changeFlags} = updateParams;\n    const attributeManager = this.getAttributeManager();\n\n    const regenerateModels =\n      changeFlags.extensionsChanged ||\n      props.filled !== oldProps.filled ||\n      props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.delete());\n\n      this.setState(this._getModels(this.context.gl));\n      attributeManager!.invalidateAll();\n    }\n  }\n\n  protected updateGeometry({props, oldProps, changeFlags}: UpdateParameters<this>) {\n    const geometryConfigChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {polygonTesselator} = this.state;\n      const buffers = (props.data as any).attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager()!.invalidateAll();\n      }\n    }\n  }\n\n  protected _getModels(gl: WebGLRenderingContext): Model {\n    const {id, filled, extruded} = this.props;\n\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n\n      topModel = new Model(gl, {\n        ...shaders,\n        id: `${id}-top`,\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n    if (extruded) {\n      sideModel = new Model(gl, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        geometry: new Geometry({\n          drawMode: GL.LINES,\n          vertexCount: 4,\n          attributes: {\n            // top right - top left - bootom left - bottom right\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n\n      sideModel.userData.excludeAttributes = {indices: true};\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  protected calculateIndices(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  protected calculatePositions(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  protected calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n"],"names":["INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","arguments","length","undefined","map","component","lights","name","vs","fs","getUniforms","opts","ambientLight","pointLights","directionalLights","Object","assign","_ref","lightSourceUniforms","forEach","pointLight","index","concat","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","type","push","defines","MAX_LIGHTS","material","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","x","getMaterialUniforms","gouraudLighting","dependencies","LIGHTING_VERTEX","phongLighting","LIGHTING_FRAGMENT","Tesselator","constructor","_defineProperty","attributes","this","typedArrayManager","defaultTypedArrayManager","_attributeDefs","updateGeometry","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","assert","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","ArrayBuffer","isView","getAccessorFromBuffer","offset","stride","_allocate","instanceCount","copy","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","createIterable","object","indexStarts","vertexStarts","Infinity","normalizedData","geometry","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","Buffer","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount","OUTER_POLYGON_WINDING","WINDING","CLOCKWISE","HOLE_POLYGON_WINDING","COUNTER_CLOCKWISE","windingOptions","isClosed","getPositions","polygon","getHoleIndices","holeIndices","copyNestedRing","target","targetStartIndex","simplePolygon","windingDirection","targetIndex","len","i","j","p0","p1","isNestedRingClosed","start","end","modifyPolygonWindingDirection","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","startIndex","endIndex","isFlatRingClosed","Error","validate","srcPositions","srcHoleIndices","pop","isNested","Number","isFinite","isSimple","polygonIndex","entries","getPlaneArea","xIndex","yIndex","numVerts","area","Math","abs","permutePositions","zIndex","o","y","z","getSurfaceIndices","preproject","full3d","positionIndex","is3d","n","slice","p","xy","xyArea","xzArea","yzArea","earcut","PolygonTesselator","fp64","IndexType","Uint32Array","super","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","externalIndices","normalizedPolygon","Polygon","resolution","cutPolygonByGrid","gridResolution","edgeTypes","wrapLongitude","cutPolygonByMercatorBounds","maxLatitude","isCut","subPolygon","_updateIndices","_updatePositions","_updateVertexValid","_ref2","polygonPositions","_ref3","set","fill","main","DEFAULT_COLOR","defaultProps","filled","extruded","wireframe","_normalize","_windingOrder","_full3d","elevationScale","min","getPolygon","f","getElevation","getFillColor","getLineColor","ATTRIBUTE_TRANSITION","enter","chunk","SolidPolygonLayer","Layer","getShaders","vsTop","vsSide","RING_WINDING_ORDER_CW","props","modules","project32","picking","initializeState","gl","viewport","coordinateSystem","isGeospatial","COORDINATE_SYSTEM","DEFAULT","LNGLAT","projectPosition","bind","projectFlat","setState","numInstances","polygonTesselator","use64bitPositions","hasFeatures","FEATURES","ELEMENT_INDEX_UINT32","Uint16Array","attributeManager","getAttributeManager","noAlloc","remove","add","isIndexed","update","calculateIndices","transition","calculatePositions","shaderAttributes","vertexOffset","divisor","instancePositions","nextPositions","calculateVertexValid","elevations","instanceElevations","fillColors","colorFormat","normalized","defaultValue","instanceFillColors","lineColors","instanceLineColors","pickingColors","encodePickingColor","__source","instancePickingColors","getPickingInfo","params","info","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","topModel","sideModel","state","renderUniforms","setInstanceCount","setUniforms","setDrawMode","isWireframe","setVertexCount","updateState","updateParams","oldProps","changeFlags","_this$state$models","extensionsChanged","models","model","delete","_getModels","invalidateAll","updateTriggersChanged","all","id","shaders","NON_INSTANCED_MODEL","Model","drawMode","vertexPositions","isSideVertex","Geometry","isInstanced","userData","excludeAttributes","filter","attribute","dim","minX","minY","maxX","maxY","invSize","hasHoles","outerLen","outerNode","linkedList","triangles","next","prev","list","queue","steiner","getLeftmost","sort","compareX","eliminateHole","eliminateHoles","max","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","again","ear","pass","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","bridge","m","hx","hy","qx","tan","mx","my","tanMin","sectorContainsSector","findHoleBridge","bridgeReverse","leftmost","px","py","intersectsPolygon","inside","middleInside","r","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","num","a2","Node","b2","an","bp","sum","module","exports","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex"],"sourceRoot":""}