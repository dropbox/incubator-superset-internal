{"version":3,"file":"1a073f010d43997e37d2.chunk.js","mappings":"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","sources":["webpack://superset/../../../src/utils/tesselator.ts","webpack://superset/../../../src/path-layer/path-tesselator.ts","webpack://superset/../../../src/path-layer/path.ts","webpack://superset/../../../src/path-layer/path-layer-vertex.glsl.ts","webpack://superset/../../../src/path-layer/path-layer.ts","webpack://superset/../../../src/path-layer/path-layer-fragment.glsl.ts","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/layers/Path/Path.tsx"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Tesselator} from '@deck.gl/core';\nimport {normalizePath} from './path';\n\nimport type {TypedArray} from '@math.gl/core';\nimport type {PathGeometry, FlatPathGeometry, NormalizedPathGeometry} from './path';\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator<\n  PathGeometry,\n  NormalizedPathGeometry,\n  {\n    fp64?: boolean;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    loop?: boolean;\n  }\n> {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {size: 1, type: Uint8ClampedArray}\n      }\n    });\n  }\n\n  /** Get packed attribute by name */\n  get(attributeName: string): TypedArray | null {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return null;\n  }\n\n  /* Implement base Tesselator interface */\n  protected normalizeGeometry(path: PathGeometry): number[][] | PathGeometry {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n\n  /* Implement base Tesselator interface */\n  protected getGeometrySize(path: NormalizedPathGeometry): number {\n    if (isCut(path)) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n\n  /* Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    path: NormalizedPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ): void {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n\n  private _updateSegmentTypes(\n    path: FlatPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ) {\n    const segmentTypes = this.attributes.segmentTypes as TypedArray;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {vertexStart, geometrySize} = context;\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  private _updatePositions(\n    path: FlatPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ) {\n    const {positions} = this.attributes;\n    if (!positions || !path) {\n      return;\n    }\n    const {vertexStart, geometrySize} = context;\n    const p = new Array(3);\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  // Utilities\n  /** Returns the number of points in the path */\n  private getPathLength(path: FlatPathGeometry): number {\n    return path.length / this.positionSize;\n  }\n\n  /** Returns a point on the path at the specified index */\n  private getPointOnPath(path: FlatPathGeometry, index: number, target: number[] = []): number[] {\n    const {positionSize} = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = (positionSize === 3 && path[i + 2]) || 0;\n    return target;\n  }\n\n  // Returns true if the first and last points are identical\n  private isClosed(path: FlatPathGeometry): boolean {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n    const {positionSize} = this;\n    const lastPointIndex = path.length - positionSize;\n    return (\n      path[0] === path[lastPointIndex] &&\n      path[1] === path[lastPointIndex + 1] &&\n      (positionSize === 2 || path[2] === path[lastPointIndex + 2])\n    );\n  }\n}\n\nfunction isCut(path: NormalizedPathGeometry): path is FlatPathGeometry[] {\n  return Array.isArray(path[0]);\n}\n","import {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\nimport type {NumericArray} from '@math.gl/core';\nimport type {Position} from '@deck.gl/core';\n\nexport type NestedPathGeometry = Position[];\nexport type FlatPathGeometry = NumericArray;\nexport type PathGeometry = NestedPathGeometry | FlatPathGeometry;\nexport type NormalizedPathGeometry = FlatPathGeometry[] | FlatPathGeometry;\n\n/**\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n * Returns a flat array of path positions, or a list of flat arrays representing multiple paths\n */\nexport function normalizePath(\n  path: PathGeometry,\n  size: number,\n  gridResolution?: number,\n  wrapLongitude?: boolean\n): number[][] | NumericArray {\n  let flatPath: NumericArray;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path as NumericArray;\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\n\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Color,\n  Accessor,\n  AccessorFunction,\n  Unit,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {PathGeometry} from './path';\n\ntype _PathLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** The units of the line width, one of `'meters'`, `'common'`, and `'pixels'`\n   * @default 'meters'\n   */\n  widthUnits?: Unit;\n  /**\n   * Path width multiplier.\n   * @default 1\n   */\n  widthScale?: number;\n  /**\n   * The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n   * @default 0\n   */\n  widthMinPixels?: number;\n  /**\n   * The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  widthMaxPixels?: number;\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   * @default false\n   */\n  jointRounded?: boolean;\n  /**\n   * Type of caps. If `true`, draw round caps. Otherwise draw square caps.\n   * @default false\n   */\n  capRounded?: boolean;\n  /**\n   * The maximum extent of a joint in ratio to the stroke width. Only works if `jointRounded` is `false`.\n   * @default 4\n   */\n  miterLimit?: number;\n  /**\n   * If `true`, extrude the path in screen space (width always faces the camera).\n   * If `false`, the width always faces up (z).\n   * @default false\n   */\n  billboard?: boolean;\n  /**\n   * (Experimental) If `'loop'` or `'open'`, will skip normalizing the coordinates returned by `getPath` and instead assume all paths are to be loops or open paths.\n   * When normalization is disabled, paths must be specified in the format of flat array. Open paths must contain at least 2 vertices and closed paths must contain at least 3 vertices.\n   * @default null\n   */\n  _pathType?: null | 'loop' | 'open';\n  /**\n   * Path geometry accessor.\n   */\n  getPath?: AccessorFunction<DataT, PathGeometry>;\n  /**\n   * Path color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color | Color[]>;\n  /**\n   * Path width accessor.\n   * @default 1\n   */\n  getWidth?: Accessor<DataT, number | number[]>;\n  /**\n   * @deprecated Use `jointRounded` and `capRounded` instead\n   */\n  rounded?: boolean;\n};\n\nexport type PathLayerProps<DataT = any> = _PathLayerProps<DataT> & LayerProps;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<PathLayerProps> = {\n  widthUnits: 'meters',\n  widthScale: {type: 'number', min: 0, value: 1},\n  widthMinPixels: {type: 'number', min: 0, value: 0},\n  widthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {type: 'number', min: 0, value: 4},\n  billboard: false,\n  _pathType: null,\n\n  getPath: {type: 'accessor', value: object => object.path},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n\n  // deprecated props\n  rounded: {deprecatedFor: ['jointRounded', 'capRounded']}\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\n/** Render lists of coordinate points as extruded polylines with mitering. */\nexport default class PathLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_PathLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'PathLayer';\n\n  state!: {\n    model?: Model;\n    pathTesselator: PathTesselator;\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]}); // 'project' module added by default.\n  }\n\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager!.addInstanced({\n      positions: {\n        size: 3,\n        // Start filling buffer from 1 vertex in\n        vertexOffset: 1,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, changeFlags} = params;\n\n    const attributeManager = this.getAttributeManager();\n\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath));\n\n    if (geometryChanged) {\n      const {pathTesselator} = this.state;\n      const buffers = (props.data as any).attributes || {};\n\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        attributeManager!.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager!.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = (data as any[]).find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  /** Override base Layer method */\n  disablePickingIndex(objectIndex: number) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < (data as any[]).length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        jointType: Number(jointRounded),\n        capType: Number(capRounded),\n        billboard,\n        widthUnits: UNIT[widthUnits],\n        widthScale,\n        miterLimit,\n        widthMinPixels,\n        widthMaxPixels\n      })\n      .draw();\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    /*\n     *       _\n     *        \"-_ 1                   3                       5\n     *     _     \"o---------------------o-------------------_-o\n     *       -   / \"\"--..__              '.             _.-' /\n     *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n     *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n     *       \"o----------------------------\"\"-o'    :     /\n     *      0,2                            4 / '.  :     /\n     *                                      /   '.:     /\n     *                                     /     :'.   /\n     *                                    /     :  ', /\n     *                                   /     :     o\n     */\n\n    // prettier-ignore\n    const SEGMENT_INDICES = [\n      // start corner\n      0, 1, 2,\n      // body\n      1, 4, 2,\n      1, 3, 4,\n      // end corner\n      3, 5, 4\n    ];\n\n    // [0] position on segment - 0: start, 1: end\n    // [1] side of path - -1: left, 0: center (joint), 1: right\n    // prettier-ignore\n    const SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0,\n      // start inner corner\n      0, -1,\n      // start outer corner\n      0, 1,\n      // end inner corner\n      1, -1,\n      // end outer corner\n      1, 1,\n      // bevel end corner\n      1, 0\n    ];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {value: new Float32Array(SEGMENT_POSITIONS), size: 2}\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  protected calculatePositions(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  protected calculateSegmentTypes(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","/* eslint-disable react/no-array-index-key */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport { PathLayer } from 'deck.gl/typed';\nimport { JsonObject, QueryFormData } from '@superset-ui/core';\nimport { commonLayerProps } from '../common';\nimport sandboxedEval from '../../utils/sandbox';\nimport { createDeckGLComponent } from '../../factory';\nimport TooltipRow from '../../TooltipRow';\nimport { TooltipProps } from '../../components/Tooltip';\nimport { Point } from '../../types';\n\nfunction setTooltipContent(o: JsonObject) {\n  return (\n    o.object.extraProps && (\n      <div className=\"deckgl-tooltip\">\n        {Object.keys(o.object.extraProps).map((prop, index) => (\n          <TooltipRow\n            key={`prop-${index}`}\n            label={`${prop}: `}\n            value={`${o.object.extraProps[prop]}`}\n          />\n        ))}\n      </div>\n    )\n  );\n}\n\nexport function getLayer(\n  formData: QueryFormData,\n  payload: JsonObject,\n  onAddFilter: () => void,\n  setTooltip: (tooltip: TooltipProps['tooltip']) => void,\n) {\n  const fd = formData;\n  const c = fd.color_picker;\n  const fixedColor = [c.r, c.g, c.b, 255 * c.a];\n  let data = payload.data.features.map((feature: JsonObject) => ({\n    ...feature,\n    path: feature.path,\n    width: fd.line_width,\n    color: fixedColor,\n  }));\n\n  if (fd.js_data_mutator) {\n    const jsFnMutator = sandboxedEval(fd.js_data_mutator);\n    data = jsFnMutator(data);\n  }\n\n  return new PathLayer({\n    id: `path-layer-${fd.slice_id}` as const,\n    getColor: d => d.color,\n    getPath: d => d.path,\n    getWidth: d => d.width,\n    data,\n    rounded: true,\n    widthScale: 1,\n    widthUnits: fd.line_width_unit,\n    ...commonLayerProps(fd, setTooltip, setTooltipContent),\n  });\n}\n\nfunction getPoints(data: JsonObject[]) {\n  let points: Point[] = [];\n  data.forEach(d => {\n    points = points.concat(d.path);\n  });\n\n  return points;\n}\n\nexport default createDeckGLComponent(getLayer, getPoints);\n"],"names":["Tesselator","constructor","opts","_defineProperty","attributes","this","typedArrayManager","defaultTypedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","assert","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","_ref","startRow","endRow","value","ArrayBuffer","isView","getAccessorFromBuffer","offset","stride","_allocate","instanceCount","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","createIterable","object","index","indexStarts","vertexStarts","Infinity","normalizedData","geometry","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","Buffer","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount","PathTesselator","super","padding","initialize","type","fp64","Float64Array","Float32Array","segmentTypes","Uint8ClampedArray","get","attributeName","path","gridResolution","wrapLongitude","flatPath","i","j","cutPolylineByGrid","cutPolylineByMercatorBounds","normalizePath","resolution","isCut","subPath","numPoints","getPathLength","isClosed","_updateSegmentTypes","_updatePositions","isPathClosed","fill","p","ptIndex","getPointOnPath","target","loop","lastPointIndex","DEFAULT_COLOR","defaultProps","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","jointRounded","capRounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","rounded","deprecatedFor","ATTRIBUTE_TRANSITION","enter","chunk","subarray","PathLayer","Layer","arguments","getShaders","vs","fs","modules","project32","picking","initializeState","getAttributeManager","addInstanced","vertexOffset","use64bitPositions","transition","update","calculatePositions","noAlloc","shaderAttributes","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","defaultValue","instanceColors","props","colorFormat","normalized","instancePickingColors","encodePickingColor","__source","setState","pathTesselator","updateState","params","changeFlags","attributeManager","updateTriggersChanged","all","state","viewport","numInstances","invalidateAll","extensionsChanged","_this$state$model","gl","model","delete","_getModel","getPickingInfo","info","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","_ref2","uniforms","setUniforms","jointType","capType","UNIT","Model","id","Geometry","drawMode","indices","Uint16Array","isInstanced","attribute","setTooltipContent","o","extraProps","___EmotionJSX","className","keys","map","prop","TooltipRow","key","label","getLayer","formData","payload","onAddFilter","setTooltip","fd","c","color_picker","fixedColor","r","g","b","a","features","feature","width","line_width","color","js_data_mutator","sandboxedEval","jsFnMutator","slice_id","line_width_unit","commonLayerProps","createDeckGLComponent","points","forEach","concat"],"sourceRoot":""}