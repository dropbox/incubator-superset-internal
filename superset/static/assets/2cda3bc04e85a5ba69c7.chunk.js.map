{"version":3,"file":"2cda3bc04e85a5ba69c7.chunk.js","mappings":"0IAAA,20BCCMA,EAAyB,CAC7BC,aAAc,CAAC,GAGjB,SAASC,IACP,IAAI,MACFC,EAAQ,CAAC,EAAG,EAAG,GAAE,UACjBC,EAAY,GACVC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzE,OAAOF,EAAMK,KAAIC,GAAaA,EAAYL,EAAY,KACxD,CAwFO,MAAMM,EAAS,CACpBC,KAAM,SACNC,GAAI,EACJC,GAAI,EACJC,YA9DF,SAASA,IACP,IAAIC,EAAOV,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAKL,EAE/E,GAAI,iBAAkBe,EAAM,CAC1B,MAAM,aACJC,EAAY,YACZC,EAAW,kBACXC,GACEH,EAAKd,cAAgB,CAAC,EAG1B,OAFkBe,GAAgBC,GAAeA,EAAYX,OAAS,GAAKY,GAAqBA,EAAkBZ,OAAS,EAQpHa,OAAOC,OAAO,CAAC,EA7C1B,SAAgCC,GAC9B,IAAI,aACFL,EAAY,YACZC,EAAc,GAAE,kBAChBC,EAAoB,IAClBG,EACJ,MAAMC,EAAsB,CAAC,EAmB7B,OAhBEA,EAAoB,gCADlBN,EACoDd,EAAac,GAEb,CAAC,EAAG,EAAG,GAG/DC,EAAYM,SAAQ,CAACC,EAAYC,KAC/BH,EAAoB,wBAAwBI,OAAOD,EAAO,YAAcvB,EAAasB,GACrFF,EAAoB,wBAAwBI,OAAOD,EAAO,eAAiBD,EAAWG,SACtFL,EAAoB,wBAAwBI,OAAOD,EAAO,kBAAoBD,EAAWI,aAAe,CAAC,EAAG,EAAG,EAAE,IAEnHN,EAAoBO,0BAA4BZ,EAAYX,OAC5DY,EAAkBK,SAAQ,CAACO,EAAkBL,KAC3CH,EAAoB,8BAA8BI,OAAOD,EAAO,YAAcvB,EAAa4B,GAC3FR,EAAoB,8BAA8BI,OAAOD,EAAO,gBAAkBK,EAAiBC,SAAS,IAE9GT,EAAoBU,gCAAkCd,EAAkBZ,OACjEgB,CACT,CAmB6BW,CAAuB,CAC9CjB,eACAC,cACAC,sBACE,CACFgB,mBAAmB,IAVZ,CACLA,mBAAmB,EAWzB,CAEA,GAAI,WAAYnB,EAAM,CACpB,MAAMd,EAAe,CACnBgB,YAAa,GACbC,kBAAmB,IAGrB,IAAK,MAAMiB,KAASpB,EAAKL,QAAU,GACjC,OAAQyB,EAAMC,MACZ,IAAK,UACHnC,EAAae,aAAemB,EAC5B,MAEF,IAAK,cACHlC,EAAaiB,kBAAkBmB,KAAKF,GACpC,MAEF,IAAK,QACHlC,EAAagB,YAAYoB,KAAKF,GAOpC,OAAOrB,EAAY,CACjBb,gBAEJ,CAEA,MAAO,CAAC,CACV,EAOEqC,QAAS,CACPC,WAAY,ICzGhB,shGCEM,EAAyB,CAAC,EAiBhC,SAAS,IACP,IAAIxB,EAAOV,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,EAE/E,KAAM,aAAcU,GAClB,MAAO,CAAC,EAGV,MAAM,SACJyB,GACEzB,EAEJ,OAAKyB,EA1BP,SAA6BA,GAC3B,MAAM,QACJC,EAAU,IAAI,QACdC,EAAU,GAAG,UACbC,EAAY,GAAE,cACdC,EAAgB,CAAC,GAAI,GAAI,KACvBJ,EACJ,MAAO,CACLK,kBAAmBJ,EACnBK,kBAAmBJ,EACnBK,oBAAqBJ,EACrBK,wBAAyBJ,EAAcpC,KAAIyC,GAAKA,EAAI,MAExD,CAmBSC,CAAoBV,GALlB,CACLN,mBAAmB,EAKzB,CAEO,MAAMiB,EAAkB,CAC7BxC,KAAM,mBACNyC,aAAc,CAAC1C,GACfE,GAAI,EACJ0B,QAAS,CACPe,gBAAiB,GAEnBvC,YAAW,GAEAwC,EAAgB,CAC3B3C,KAAM,iBACNyC,aAAc,CAAC1C,GACfG,GAAI,EACJyB,QAAS,CACPiB,kBAAmB,GAErBzC,YAAW,E,8GCvDT0C,EAAUC,KAAKC,GAAK,EACpBC,EAAS,CAAC,EAAGH,EAAS,EAAIA,EAAS,EAAIA,EAAS,EAAIA,EAAS,EAAIA,GAErE,SAASI,EAAOC,GACd,OAAOA,EAAE,EACX,CAEA,SAASC,EAAOD,GACd,OAAOA,EAAE,EACX,C,qCCiCA,SAASE,IAAQ,CAEjB,MAAMC,EAAgD,CAEpDC,YAAa,KACbC,WAAYC,EAAAA,EACZC,cAAe,CAAChC,KAAM,WAAYiC,MAAO,MACzCC,eAAgB,CAAClC,KAAM,WAAYiC,MAAO,GAC1CE,iBAAkB,MAClBC,gBAAiB,CAACpC,KAAM,SAAUiC,MAAO,EAAGI,IAAK,EAAGC,IAAK,KACzDC,gBAAiB,CAACvC,KAAM,SAAUiC,MAAO,IAAKI,IAAK,EAAGC,IAAK,KAC3DE,eAAgB,WAChBC,iBAAkBd,EAGlBe,gBAAiB,KACjBC,eAAgB,CAAC,EAAG,KACpBC,kBAAmB,CAAC5C,KAAM,WAAYiC,MAAO,MAC7CY,mBAAoB,CAAC7C,KAAM,WAAYiC,MAAO,GAC9Ca,qBAAsB,MACtBC,yBAA0B,CAAC/C,KAAM,SAAUiC,MAAO,EAAGI,IAAK,EAAGC,IAAK,KAClEU,yBAA0B,CAAChD,KAAM,SAAUiC,MAAO,IAAKI,IAAK,EAAGC,IAAK,KACpEW,eAAgB,CAACjD,KAAM,SAAUqC,IAAK,EAAGJ,MAAO,GAChDiB,mBAAoB,SACpBC,qBAAsBxB,EAEtByB,OAAQ,CAACpD,KAAM,SAAUiC,MAAO,IAAMI,IAAK,GAC3CgB,SAAU,CAACrD,KAAM,SAAUqC,IAAK,EAAGC,IAAK,EAAGL,MAAO,GAClDqB,UAAU,EACVC,kBCvCK,SAAuBC,EAAOC,GACnC,MAAM,KAACC,EAAD,OAAON,GAAUI,GACjB,SAACG,EAAD,WAAWC,GAAcH,EAEzBI,EAAeH,EAAKxF,OA4CrB,SAAyBwF,EAAMD,GACpC,MAAM,WAACG,GAAcH,EACfK,EAAYF,EAAWE,UAAU7B,OACjC,KAAC8B,GAAQH,EAAWE,UAAUE,cAEpC,IAIIC,EAJAC,EAAOC,IACPC,EAAOD,IACPE,GAAO,IACPC,GAAO,IAGX,IAAKL,EAAI,EAAGA,EAAIF,EAAOL,EAAKxF,OAAQ+F,GAAKF,EAAM,CAC7C,MAAMlD,EAAIiD,EAAUG,GACdM,EAAIT,EAAUG,EAAI,GACFO,OAAOC,SAAS5D,IAAM2D,OAAOC,SAASF,KAG1DL,EAAO7C,KAAKgB,IAAIxB,EAAGqD,GACnBG,EAAOhD,KAAKiB,IAAIzB,EAAGwD,GACnBD,EAAO/C,KAAKgB,IAAIkC,EAAGH,GACnBE,EAAOjD,KAAKiB,IAAIiC,EAAGD,GAEtB,CAGD,MAAO,CAACJ,EAAME,EAAMC,EAAMC,GAAMI,MAAMF,OAAOC,UACzC,EAAEP,EAAOG,GAAQ,GAAID,EAAOE,GAAQ,GACpC,IACL,CAxEoCK,CAAgBjB,EAAMD,GAAqB,KACxEmB,EAiFD,SAA2BxB,EAAQO,EAAUkB,GAClD,MAAM,cAACC,GAAiBnB,EAASoB,kBAAkBF,GAEnD,OAAOzB,EAAS0B,EAAc,EAC/B,CArFsBE,CAAkB5B,EAAQO,EAAUE,GAGnDoB,EAAe,IACf,SAACC,EAAD,WAAWC,IAAcC,EAAAA,EAAAA,IAAe1B,GACxCI,EAAYF,EAAWE,UAAU7B,OACjC,KAAC8B,GAAQH,EAAWE,UAAUE,cACpC,IAAK,MAAMqB,KAAUH,EAAU,CAC7BC,EAAW9F,QACX,MAAMiG,EAAWH,EAAW9F,MAAQ0E,EAC9BxE,EAAW,CAACuE,EAAUwB,GAAWxB,EAAUwB,EAAW,IACtCd,OAAOC,SAASlF,EAAS,KAAOiF,OAAOC,SAASlF,EAAS,IAE7E0F,EAAahF,KAAK,CAChBsF,YAAa5B,EAAS6B,YAAYjG,GAClCkG,OAAQJ,EACRhG,MAAO8F,EAAW9F,QAGpBqG,EAAAA,EAAIC,KAAK,iCAATD,EAEH,CAED,MAAME,EFjDO,WACb,IAMIC,EACAC,EACAC,EARAC,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EACLtF,EAAIW,EACJ+C,EAAI7C,EAKR,SAAS0E,EAAOC,GACd,IAA8BpC,EAA1BqC,EAAW,CAAC,EAAGC,EAAO,GAAOC,EAAIH,EAAOnI,OAE5C,IAAK+F,EAAI,EAAGA,EAAIuC,IAAKvC,EACnB,IAAIwC,MAAMC,GAAM7F,EAAE8F,KAAK,KAAMC,EAAQP,EAAOpC,GAAIA,EAAGoC,MAC5CI,MAAMI,GAAMtC,EAAEoC,KAAK,KAAMC,EAAO3C,EAAGoC,IAD1C,CAGA,IAAIO,EACAF,EACAG,EACAC,EAAKzF,KAAK0F,MAAMF,GAAUd,GAC1BiB,EAAK3F,KAAK0F,MAAML,EAAKA,EAAKZ,GAAW,EAALgB,GAAU,GAC1CG,EAAMJ,EAAKC,EAEf,GAAoB,EAAhBzF,KAAK6F,IAAID,GAAW,EAAG,CACzB,IAAIE,EAAMT,EAAKM,EACXI,EAAMJ,GAAMN,EAAKM,GAAM,EAAI,GAAK,EAChCK,EAAMP,GAAMD,EAAKC,GAAM,EAAI,GAC3BQ,EAAMZ,EAAKU,EACXG,EAAMV,EAAKQ,EACXF,EAAMA,EAAMF,EAAMA,EAAMK,EAAMA,EAAMC,EAAMA,IAAKP,EAAKI,GAAY,EAALN,EAAS,GAAK,GAAK,EAAGA,EAAKO,EAC5F,CAEA,IAAIG,EAAKR,EAAK,IAAMF,EAAIW,EAAMnB,EAASkB,GACnCC,EAAKA,EAAIxH,KAAK2G,IAEhBL,EAAKtG,KAAKwH,EAAMnB,EAASkB,GAAM,CAACZ,IAChCa,EAAI5G,GAAKmG,GAAW,EAALF,GAAU,GAAKhB,EAC9B2B,EAAIlD,EAAIuC,EAAKf,EAvB6C,CA2B9D,OAAOQ,CACT,CAEA,SAASmB,EAAQtE,GACf,IAAI4C,EAAK,EAAGC,EAAK,EACjB,OAAO1E,EAAOnD,KAAI,SAASuJ,GACzB,IAAIzB,EAAK7E,KAAKuG,IAAID,GAASvE,EACvB+C,GAAM9E,KAAKwG,IAAIF,GAASvE,EACxB0C,EAAKI,EAAKF,EACVD,EAAKI,EAAKF,EAEd,OADAD,EAAKE,EAAID,EAAKE,EACP,CAACL,EAAIC,EACd,GACF,CA2CA,OAzCAK,EAAOsB,QAAU,SAAStE,GACxB,MAAO,IAAMsE,EAAkB,MAAVtE,EAAiByC,GAAKzC,GAAQ0E,KAAK,KAAO,GACjE,EAEA1B,EAAO2B,QAAU,WAIf,IAHA,IAAIA,EAAU,GACVC,EAAI3G,KAAK0F,MAAMd,EAAKF,GACpB9B,EAAI5C,KAAK0F,MAAMf,EAAKF,GACfvB,EAAIyD,EAAIjC,EAAIxB,EAAI4B,EAAKN,EAAGtB,GAAKwB,IAAMiC,EAC1C,IAAK,IAAInH,EAAIoD,EAAI6B,GAAU,EAAJkC,GAASlC,EAAK,EAAGjF,EAAIqF,EAAKJ,EAAK,EAAGjF,GAAKiF,EAC5DiC,EAAQ9H,KAAK,CAACY,EAAG0D,IAGrB,OAAOwD,CACT,EAEA3B,EAAO6B,KAAO,WACZ,IAAIC,EAAWR,EAAQ7B,GAAGsC,MAAM,EAAG,GAAGL,KAAK,KAC3C,OAAO1B,EAAO2B,UAAU3J,KAAI,SAASgK,GAAK,MAAO,IAAMA,EAAI,IAAMF,CAAU,IAAGJ,KAAK,GACrF,EAEA1B,EAAOvF,EAAI,SAASwH,GAClB,OAAOpK,UAAUC,QAAU2C,EAAIwH,EAAGjC,GAAUvF,CAC9C,EAEAuF,EAAO7B,EAAI,SAAS8D,GAClB,OAAOpK,UAAUC,QAAUqG,EAAI8D,EAAGjC,GAAU7B,CAC9C,EAEA6B,EAAOhD,OAAS,SAASiF,GACvB,OAAOpK,UAAUC,QAAkB4H,EAAS,GAAjBD,GAAKwC,GAAgBhH,KAAKuG,IAAIxG,GAAU2E,EAAS,IAAJF,EAASO,GAAUP,CAC7F,EAEAO,EAAOrC,KAAO,SAASsE,GACrB,OAAOpK,UAAUC,QAAU8H,EAAKC,EAAK,EAAGC,GAAMmC,EAAE,GAAIlC,GAAMkC,EAAE,GAAIjC,GAAU,CAACF,EAAKF,EAAIG,EAAKF,EAC3F,EAEAG,EAAOkC,OAAS,SAASD,GACvB,OAAOpK,UAAUC,QAAU8H,GAAMqC,EAAE,GAAG,GAAIpC,GAAMoC,EAAE,GAAG,GAAInC,GAAMmC,EAAE,GAAG,GAAIlC,GAAMkC,EAAE,GAAG,GAAIjC,GAAU,CAAC,CAACJ,EAAIC,GAAK,CAACC,EAAIC,GACnH,EAEOC,EAAOhD,OAAO,EACvB,CEnDoBgD,GACfhD,OAAOwB,GACP/D,GAAEY,GAAKA,EAAE8D,YAAY,KACrBhB,GAAE9C,GAAKA,EAAE8D,YAAY,KAIxB,MAAO,CACLgD,SAHkB3C,EAAUX,GAGN7G,KAAI,CAACoK,EAAKnJ,KAAN,CACxBE,SAAUoE,EAAS8E,cAAc,CAACD,EAAI3H,EAAG2H,EAAIjE,IAC7C8B,OAAQmC,EACRnJ,YAEFuF,eAEH,EDHC8D,YAAa,CAAC1I,KAAM,WAAYiC,MAAOpB,GAAKA,EAAEtB,UAE9Ca,UAAU,EAGVuI,YAAa,CAAC3I,KAAM,WAAYiC,MAAO,KAAM2G,UAAU,IA4K1C,MAAMC,UAAyDC,EAAAA,EAG5EC,cAAA,SAAA9K,YAAA+K,EAAAA,EAAAA,GAAA,qBAQAC,kBACE,MAAMC,EAAgB,IAAIC,EAAAA,EAAc,CACtCC,cAAe5F,GAASA,EAAMD,kBAC9B8F,YAAa7F,GAASA,EAAMJ,SAG9BkG,KAAKC,MAAQ,CACXL,gBACAM,gBAAiBN,EAAcK,MAC/BE,SAAU,MAEaH,KAAKI,sBACbC,IAAI,CACnB7F,UAAW,CAACC,KAAM,EAAG/D,KAAM,KAAW4J,SAAU,gBAInD,CAEDC,YAAYlL,GAGV,GAFAmL,MAAMD,YAAYlL,GAEdA,EAAKoL,YAAYC,mBAAoB,CACvC,MAAMR,EAAkBF,KAAKC,MAAML,cAAcW,YAAYlL,EAAM,CACjEgF,SAAU2F,KAAKW,QAAQtG,SACvBC,WAAY0F,KAAKY,kBAEnB,GAAIZ,KAAKC,MAAMC,gBAAgBW,YAAcX,EAAgBW,UAAW,CAGtE,MAAM,gBAACC,GAAmBZ,EAAgBW,WAAa,CAAC,EACxDb,KAAKe,SAAS,CACZZ,SAAUW,GAAmBd,KAAKgB,2BAA2BF,IAEhE,CAEDd,KAAKe,SAAS,CAEZb,mBAEH,CACF,CAEDc,2BAA2BF,GACzB,MAAM,SAACzG,GAAY2F,KAAKW,QACxB,GAAIM,MAAMC,QAAQJ,IAA+C,IAA3BA,EAAgBlM,OAAc,CAElE,MAAMuM,EAAUL,EAAgB,GAC1BM,EAAUN,EAAgB,GAE1BO,EAAW,EAAEF,EAAQ,GAAKC,EAAQ,IAAM,GAAID,EAAQ,GAAKC,EAAQ,IAAM,GACvEE,EAAejH,EAAS6B,YAAYmF,IAEpC,cAACE,GAAiBlH,EAASoB,kBAAkB4F,GAYnD,OATiBP,EAAgBhM,KAAI0M,IACnC,MAAMC,EAASpH,EAAS6B,YAAYsF,GAEpC,MAAO,EACJC,EAAO,GAAKH,EAAa,IAAMC,EAAc,IAC7CE,EAAO,GAAKH,EAAa,IAAMC,EAAc,GAFhD,GAOH,CAGD,OADAnF,EAAAA,EAAIsF,MAAM,iEAAVtF,GACO,IACR,CAEDuF,eAAchM,GAAU,IAAT,KAACiM,GAAFjM,EACZ,OAAOqK,KAAKC,MAAML,cAAc+B,eAAe,CAACC,QACjD,CAGDC,oBAAoBC,GAClB,OAAO9B,KAAKC,MAAML,cAAclF,YAAY,YAArCsF,CAAkD8B,EAC1D,CAGDC,wBAAwBD,GACtB,OAAO9B,KAAKC,MAAML,cAAclF,YAAY,YAArCsF,CAAkD8B,EAC1D,CAEDE,6BACE,OAAOhC,KAAKC,MAAML,cAAcqC,kBAAkBjC,KAAK9F,MACxD,CAEDgI,eACE,MAAM,eAACvI,EAAD,SAAiBK,EAAjB,SAA2BD,EAA3B,SAAqCjD,EAArC,YAA+CqL,GAAenC,KAAK9F,OACnE,gBAACgG,EAAD,SAAkBC,GAAYH,KAAKC,MAEnCmC,EAAgBpC,KAAKqC,iBAAiB,eAAgBC,EAAAA,GACtDC,EAAiBvC,KAAKgC,6BAU5B,OAAO,IAAII,EACT,IATejC,EACb,CAACA,WAAUrG,OAAQ,GACnB,CAEEA,OAAQoG,EAAgBW,UAAUvF,cAAgB,EAClDkH,YAAa,SACbnE,MAAO,IAKToE,eAAgB,EAChB9I,iBACAK,WACAD,WACAjD,WAEA4L,aAAc1C,KAAK6B,oBAAoBc,KAAK3C,MAC5C4C,aAAc5C,KAAK+B,wBAAwBY,KAAK3C,MAChDmC,YAAaA,GAAe,CAC1BO,aAAcP,EAAYzJ,eAAiByJ,EAAYvJ,eACvDgK,aAAcT,EAAY7I,mBAAqB6I,EAAY5I,qBAG/DyG,KAAK6C,iBAAiB,CACpB3E,GAAI,eACJqE,mBAEF,CACEnI,KAAM8F,EAAgBW,UAAUzG,MAGrC,G,OA5IkBmF,EAAAA,YAIA,iB,OAJAA,EAAAA,eAKGjH,G,qGE5NxB,SAASwK,EAAkBC,GACzB,OACEC,EAAAA,EAAAA,IAAA,OAAKC,UAAU,mBACbD,EAAAA,EAAAA,IAACE,EAAAA,EAAU,CACTC,OAAOC,EAAAA,EAAAA,GAAE,uCACTzK,MAAO,IAAIoK,EAAEM,WAAW,OAAON,EAAEM,WAAW,SAE9CL,EAAAA,EAAAA,IAACE,EAAAA,EACC,CACAC,OAAOC,EAAAA,EAAAA,GAAE,UAAY,KACrBzK,MAAO,GAAGoK,EAAEhH,OAAOuH,mBAI3B,CAEM,SAAUC,EACdC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAKJ,EAELhL,EADaqL,EAA0BC,SAASF,EAAGG,cAEtDC,QACAlP,KAAIL,IAASwP,EAAAA,EAAAA,UAASxP,KACzB,IAAI2F,EAAOqJ,EAAQrJ,KAAK8J,SAEpBN,EAAGO,kBAGL/J,GADoBgK,EAAAA,EAAAA,GAAcR,EAAGO,gBAC9BE,CAAYjK,IAErB,MAAMkK,GAAUC,EAAAA,EAAAA,GAAWX,EAAGY,iBAAiB1F,GAAM,MAADA,OAAC,EAADA,EAAG2F,SAEvD,OAAO,IAAIlF,EAAa,CACtBrB,GAAI,aAAa0F,EAAGc,WACpBtK,OACAN,OAAQ8J,EAAGe,UACX3K,SAAU4J,EAAG5J,SACbxB,aACAoM,SAAS,EAETtL,kBAAmBgL,EAEnB5L,cAAe4L,MACZO,EAAAA,EAAAA,GAAiBjB,EAAID,EAAYb,IAExC,CAMA,SAAegC,EAAAA,EAAAA,GAAsBvB,GAJrC,SAAmBnJ,GACjB,OAAOA,EAAKtF,KAAIqD,GAAKA,EAAElC,UACzB,G","sources":["webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","webpack://superset/./node_modules/d3-hexbin/src/hexbin.js","webpack://superset/../../../src/hexagon-layer/hexagon-layer.ts","webpack://superset/../../../src/hexagon-layer/hexagon-aggregator.js","webpack://superset/./plugins/legacy-preset-chart-deckgl/src/layers/Hex/Hex.tsx"],"sourcesContent":["export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";\n//# sourceMappingURL=lights.glsl.js.map","import lightingShader from './lights.glsl';\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          lightSources.ambientLight = light;\n          break;\n\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";\n//# sourceMappingURL=phong-lighting.glsl.js.map","import { lights } from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map","var thirdPi = Math.PI / 3,\n    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];\n\nfunction pointX(d) {\n  return d[0];\n}\n\nfunction pointY(d) {\n  return d[1];\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      x = pointX,\n      y = pointY,\n      r,\n      dx,\n      dy;\n\n  function hexbin(points) {\n    var binsById = {}, bins = [], i, n = points.length;\n\n    for (i = 0; i < n; ++i) {\n      if (isNaN(px = +x.call(null, point = points[i], i, points))\n          || isNaN(py = +y.call(null, point, i, points))) continue;\n\n      var point,\n          px,\n          py,\n          pj = Math.round(py = py / dy),\n          pi = Math.round(px = px / dx - (pj & 1) / 2),\n          py1 = py - pj;\n\n      if (Math.abs(py1) * 3 > 1) {\n        var px1 = px - pi,\n            pi2 = pi + (px < pi ? -1 : 1) / 2,\n            pj2 = pj + (py < pj ? -1 : 1),\n            px2 = px - pi2,\n            py2 = py - pj2;\n        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n      }\n\n      var id = pi + \"-\" + pj, bin = binsById[id];\n      if (bin) bin.push(point);\n      else {\n        bins.push(bin = binsById[id] = [point]);\n        bin.x = (pi + (pj & 1) / 2) * dx;\n        bin.y = pj * dy;\n      }\n    }\n\n    return bins;\n  }\n\n  function hexagon(radius) {\n    var x0 = 0, y0 = 0;\n    return angles.map(function(angle) {\n      var x1 = Math.sin(angle) * radius,\n          y1 = -Math.cos(angle) * radius,\n          dx = x1 - x0,\n          dy = y1 - y0;\n      x0 = x1, y0 = y1;\n      return [dx, dy];\n    });\n  }\n\n  hexbin.hexagon = function(radius) {\n    return \"m\" + hexagon(radius == null ? r : +radius).join(\"l\") + \"z\";\n  };\n\n  hexbin.centers = function() {\n    var centers = [],\n        j = Math.round(y0 / dy),\n        i = Math.round(x0 / dx);\n    for (var y = j * dy; y < y1 + r; y += dy, ++j) {\n      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {\n        centers.push([x, y]);\n      }\n    }\n    return centers;\n  };\n\n  hexbin.mesh = function() {\n    var fragment = hexagon(r).slice(0, 4).join(\"l\");\n    return hexbin.centers().map(function(p) { return \"M\" + p + \"m\" + fragment; }).join(\"\");\n  };\n\n  hexbin.x = function(_) {\n    return arguments.length ? (x = _, hexbin) : x;\n  };\n\n  hexbin.y = function(_) {\n    return arguments.length ? (y = _, hexbin) : y;\n  };\n\n  hexbin.radius = function(_) {\n    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;\n  };\n\n  hexbin.size = function(_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];\n  };\n\n  hexbin.extent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];\n  };\n\n  return hexbin.radius(1);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  log,\n  Position,\n  Material,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\n\nimport {defaultColorRange} from '../utils/color-utils';\n\nimport {pointToHexbin} from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\n\nimport GL from '@luma.gl/constants';\nimport {AggregateAccessor} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() {}\n\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  radius: {type: 'number', value: 1000, min: 1},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\n/** All properties supported by by HexagonLayer. */\nexport type HexagonLayerProps<DataT = any> = _HexagonLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by HexagonLayer. */\ntype _HexagonLayerProps<DataT = any> = {\n  /**\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Function to aggregate data into hexagonal bins.\n   * @default d3-hexbin\n   */\n  hexagonAggregator?: (props: any, params: any) => any;\n\n  /**\n   * Color scale input domain.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Hexagon radius multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain. The elevation scale is a linear scale that maps number of counts to elevation.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Hexagon elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter bins and re-calculate color by `upperPercentile`.\n   * Hexagons with color value larger than the `upperPercentile` will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate color by `lowerPercentile`.\n   * Hexagons with color value smaller than the `lowerPercentile` will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationUpperPercentile`.\n   * Hexagons with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationLowerPercentile`.\n   * Hexagons with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   */\n  elevationScaleType?: 'linear';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a bin.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its color is based on.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a bin.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its elevation is based on.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when cell color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when cell elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * (Experimental) Filter data objects\n   */\n  _filterData: null | ((d: DataT) => boolean);\n};\n\n/** Aggregates data into a hexagon-based heatmap. The color and height of a hexagon are determined based on the objects it contains. */\nexport default class HexagonLayer<DataT, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_HexagonLayerProps>\n> {\n  static layerName = 'HexagonLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    cpuAggregator: CPUAggregator;\n    aggregatorState: any;\n  };\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      vertices: null\n    };\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calculated using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n\n    if (opts.changeFlags.propsOrDataChanged) {\n      const aggregatorState = this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes()\n      });\n      if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {\n        // if user provided custom aggregator and returns hexagonVertices,\n        // Need to recalculate radius and angle based on vertices\n        const {hexagonVertices} = aggregatorState.layerData || {};\n        this.setState({\n          vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)\n        });\n      }\n\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState\n      });\n    }\n  }\n\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {viewport} = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      // get centroid of hexagons\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n\n      const {metersPerUnit} = viewport.getDistanceScales(centroid);\n\n      // offset all points by centroid to meter offset\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n\n        return [\n          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n        ];\n      });\n\n      return vertices;\n    }\n\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {elevationScale, extruded, coverage, material, transitions} = this.props;\n    const {aggregatorState, vertices} = this.state;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    const geometry = vertices\n      ? {vertices, radius: 1}\n      : {\n          // default geometry\n          radius: aggregatorState.layerData.radiusCommon || 1,\n          radiusUnits: 'common',\n          angle: 90\n        };\n    return new SubLayerClass(\n      {\n        ...geometry,\n        diskResolution: 6,\n        elevationScale,\n        extruded,\n        coverage,\n        material,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers\n      }),\n      {\n        data: aggregatorState.layerData.data\n      }\n    );\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {hexbin} from 'd3-hexbin';\nimport {createIterable, log} from '@deck.gl/core';\n\n/**\n * Use d3-hexbin to performs hexagonal binning from geo points to hexagons\n * @param {Iterable} data - array of points\n * @param {Number} radius - hexagon radius in meter\n * @param {function} getPosition - get points lon lat\n * @param {Object} viewport - current viewport object\n\n * @return {Object} - hexagons and countRange\n */\nexport function pointToHexbin(props, aggregationParams) {\n  const {data, radius} = props;\n  const {viewport, attributes} = aggregationParams;\n  // get hexagon radius in mercator world unit\n  const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;\n  const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);\n\n  // add world space coordinates to points\n  const screenPoints = [];\n  const {iterable, objectInfo} = createIterable(data);\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  for (const object of iterable) {\n    objectInfo.index++;\n    const posIndex = objectInfo.index * size;\n    const position = [positions[posIndex], positions[posIndex + 1]];\n    const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);\n    if (arrayIsFinite) {\n      screenPoints.push({\n        screenCoord: viewport.projectFlat(position),\n        source: object,\n        index: objectInfo.index\n      });\n    } else {\n      log.warn('HexagonLayer: invalid position')();\n    }\n  }\n\n  const newHexbin = hexbin()\n    .radius(radiusCommon)\n    .x(d => d.screenCoord[0])\n    .y(d => d.screenCoord[1]);\n\n  const hexagonBins = newHexbin(screenPoints);\n\n  return {\n    hexagons: hexagonBins.map((hex, index) => ({\n      position: viewport.unprojectFlat([hex.x, hex.y]),\n      points: hex,\n      index\n    })),\n    radiusCommon\n  };\n}\n\n/**\n * Get the bounding box of all data points\n */\nexport function getPointsCenter(data, aggregationParams) {\n  const {attributes} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let i;\n\n  for (i = 0; i < size * data.length; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const arrayIsFinite = Number.isFinite(x) && Number.isFinite(y);\n\n    if (arrayIsFinite) {\n      minX = Math.min(x, minX);\n      maxX = Math.max(x, maxX);\n      minY = Math.min(y, minY);\n      maxY = Math.max(y, maxY);\n    }\n  }\n\n  // return center\n  return [minX, minY, maxX, maxY].every(Number.isFinite)\n    ? [(minX + maxX) / 2, (minY + maxY) / 2]\n    : null;\n}\n\n/**\n * Get radius in mercator world space coordinates from meter\n * @param {Number} radius - in meter\n * @param {Object} viewport - current viewport object\n * @param {Array<Number>} center - data center\n\n * @return {Number} radius in mercator world spcae coordinates\n */\nexport function getRadiusInCommon(radius, viewport, center) {\n  const {unitsPerMeter} = viewport.getDistanceScales(center);\n  // x, y distance should be the same\n  return radius * unitsPerMeter[0];\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { HexagonLayer, Color } from 'deck.gl/typed';\nimport React from 'react';\nimport {\n  t,\n  CategoricalColorNamespace,\n  QueryFormData,\n  JsonObject,\n} from '@superset-ui/core';\n\nimport { commonLayerProps, getAggFunc } from '../common';\nimport sandboxedEval from '../../utils/sandbox';\nimport { hexToRGB } from '../../utils/colors';\nimport { createDeckGLComponent } from '../../factory';\nimport TooltipRow from '../../TooltipRow';\nimport { TooltipProps } from '../../components/Tooltip';\n\nfunction setTooltipContent(o: JsonObject) {\n  return (\n    <div className=\"deckgl-tooltip\">\n      <TooltipRow\n        label={t('Centroid (Longitude and Latitude): ')}\n        value={`(${o.coordinate[0]}, ${o.coordinate[1]})`}\n      />\n      <TooltipRow\n        // eslint-disable-next-line prefer-template\n        label={t('Height') + ': '}\n        value={`${o.object.elevationValue}`}\n      />\n    </div>\n  );\n}\n\nexport function getLayer(\n  formData: QueryFormData,\n  payload: JsonObject,\n  onAddFilter: () => void,\n  setTooltip: (tooltip: TooltipProps['tooltip']) => void,\n) {\n  const fd = formData;\n  const colorScale = CategoricalColorNamespace.getScale(fd.color_scheme);\n  const colorRange = colorScale\n    .range()\n    .map(color => hexToRGB(color)) as Color[];\n  let data = payload.data.features;\n\n  if (fd.js_data_mutator) {\n    // Applying user defined data mutator if defined\n    const jsFnMutator = sandboxedEval(fd.js_data_mutator);\n    data = jsFnMutator(data);\n  }\n  const aggFunc = getAggFunc(fd.js_agg_function, p => p?.weight);\n\n  return new HexagonLayer({\n    id: `hex-layer-${fd.slice_id}` as const,\n    data,\n    radius: fd.grid_size,\n    extruded: fd.extruded,\n    colorRange,\n    outline: false,\n    // @ts-ignore\n    getElevationValue: aggFunc,\n    // @ts-ignore\n    getColorValue: aggFunc,\n    ...commonLayerProps(fd, setTooltip, setTooltipContent),\n  });\n}\n\nfunction getPoints(data: JsonObject[]) {\n  return data.map(d => d.position);\n}\n\nexport default createDeckGLComponent(getLayer, getPoints);\n"],"names":["INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","arguments","length","undefined","map","component","lights","name","vs","fs","getUniforms","opts","ambientLight","pointLights","directionalLights","Object","assign","_ref","lightSourceUniforms","forEach","pointLight","index","concat","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","type","push","defines","MAX_LIGHTS","material","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","x","getMaterialUniforms","gouraudLighting","dependencies","LIGHTING_VERTEX","phongLighting","LIGHTING_FRAGMENT","thirdPi","Math","PI","angles","pointX","d","pointY","nop","defaultProps","colorDomain","colorRange","defaultColorRange","getColorValue","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationLowerPercentile","elevationUpperPercentile","elevationScale","elevationScaleType","onSetElevationDomain","radius","coverage","extruded","hexagonAggregator","props","aggregationParams","data","viewport","attributes","centerLngLat","positions","size","getAccessor","i","minX","Infinity","minY","maxX","maxY","y","Number","isFinite","every","getPointsCenter","radiusCommon","center","unitsPerMeter","getDistanceScales","getRadiusInCommon","screenPoints","iterable","objectInfo","createIterable","object","posIndex","screenCoord","projectFlat","source","log","warn","newHexbin","r","dx","dy","x0","y0","x1","y1","hexbin","points","binsById","bins","n","isNaN","px","call","point","py","pj","round","pi","py1","abs","px1","pi2","pj2","px2","py2","id","bin","hexagon","angle","sin","cos","join","centers","j","mesh","fragment","slice","p","_","extent","hexagons","hex","unprojectFlat","getPosition","_filterData","optional","HexagonLayer","AggregationLayer","constructor","_defineProperty","initializeState","cpuAggregator","CPUAggregator","getAggregator","getCellSize","this","state","aggregatorState","vertices","getAttributeManager","add","accessor","updateState","super","changeFlags","propsOrDataChanged","context","getAttributes","layerData","hexagonVertices","setState","convertLatLngToMeterOffset","Array","isArray","vertex0","vertex3","centroid","centroidFlat","metersPerUnit","vt","vtFlat","error","getPickingInfo","info","_onGetSublayerColor","cell","_onGetSublayerElevation","_getSublayerUpdateTriggers","getUpdateTriggers","renderLayers","transitions","SubLayerClass","getSubLayerClass","ColumnLayer","updateTriggers","radiusUnits","diskResolution","getFillColor","bind","getElevation","getSubLayerProps","setTooltipContent","o","___EmotionJSX","className","TooltipRow","label","t","coordinate","elevationValue","getLayer","formData","payload","onAddFilter","setTooltip","fd","CategoricalColorNamespace","getScale","color_scheme","range","hexToRGB","features","js_data_mutator","sandboxedEval","jsFnMutator","aggFunc","getAggFunc","js_agg_function","weight","slice_id","grid_size","outline","commonLayerProps","createDeckGLComponent"],"sourceRoot":""}