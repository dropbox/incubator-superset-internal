(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[2862,7040,7893],{95644:(t,i,e)=>{"use strict";e.d(i,{N:()=>l});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r({color:t=[0,0,0],intensity:i=1}={}){return t.map((t=>t*i/255))}const a={};const l={name:"gouraud-lighting",dependencies:[{name:"lights",vs:n,fs:n,getUniforms:function t(i=o){if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:n}=i.lightSources||{};return t||e&&e.length>0||n&&n.length>0?Object.assign({},function({ambientLight:t,pointLights:i=[],directionalLights:e=[]}){const n={};return n["lighting_uAmbientLight.color"]=t?r(t):[0,0,0],i.forEach(((t,i)=>{n["lighting_uPointLight[".concat(i,"].color")]=r(t),n["lighting_uPointLight[".concat(i,"].position")]=t.position,n["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),n.lighting_uPointLightCount=i.length,e.forEach(((t,i)=>{n["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),n["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),n.lighting_uDirectionalLightCount=e.length,n}({ambientLight:t,pointLights:e,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights.push(t);break;case"point":e.pointLights.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}],vs:"\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",defines:{LIGHTING_VERTEX:1},getUniforms:function(t=a){if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}}},1186:(t,i,e)=>{"use strict";e.r(i),e.d(i,{default:()=>x,getLayer:()=>w});var n=e(80744),o=e(15103),r=e(4516),a=Math.PI/3,l=[0,a,2*a,3*a,4*a,5*a];function g(t){return t[0]}function s(t){return t[1]}var c=e(38550),u=e(73728),h=e(63295);function d(){}const p={colorDomain:null,colorRange:r.K,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:d,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:d,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(t,i){const{data:e,radius:o}=t,{viewport:r,attributes:u}=i,h=e.length?function(t,i){const{attributes:e}=i,n=e.positions.value,{size:o}=e.positions.getAccessor();let r,a=1/0,l=1/0,g=-1/0,s=-1/0;for(r=0;r<o*t.length;r+=o){const t=n[r],i=n[r+1];Number.isFinite(t)&&Number.isFinite(i)&&(a=Math.min(t,a),g=Math.max(t,g),l=Math.min(i,l),s=Math.max(i,s))}return[a,l,g,s].every(Number.isFinite)?[(a+g)/2,(l+s)/2]:null}(e,i):null,d=function(t,i,e){const{unitsPerMeter:n}=i.getDistanceScales(e);return t*n[0]}(o,r,h),p=[],{iterable:f,objectInfo:_}=(0,c.jB)(e),m=u.positions.value,{size:v}=u.positions.getAccessor();for(const t of f){_.index++;const i=_.index*v,e=[m[i],m[i+1]];Number.isFinite(e[0])&&Number.isFinite(e[1])?p.push({screenCoord:r.projectFlat(e),source:t,index:_.index}):n.Z.warn("HexagonLayer: invalid position")()}const L=function(){var t,i,e,n=0,o=0,r=1,c=1,u=g,h=s;function d(t){var n,o={},r=[],a=t.length;for(n=0;n<a;++n)if(!isNaN(g=+u.call(null,l=t[n],n,t))&&!isNaN(s=+h.call(null,l,n,t))){var l,g,s,c=Math.round(s/=e),d=Math.round(g=g/i-(1&c)/2),p=s-c;if(3*Math.abs(p)>1){var f=g-d,_=d+(g<d?-1:1)/2,m=c+(s<c?-1:1),v=g-_,L=s-m;f*f+p*p>v*v+L*L&&(d=_+(1&c?1:-1)/2,c=m)}var b=d+"-"+c,C=o[b];C?C.push(l):(r.push(C=o[b]=[l]),C.x=(d+(1&c)/2)*i,C.y=c*e)}return r}function p(t){var i=0,e=0;return l.map((function(n){var o=Math.sin(n)*t,r=-Math.cos(n)*t,a=o-i,l=r-e;return i=o,e=r,[a,l]}))}return d.hexagon=function(i){return"m"+p(null==i?t:+i).join("l")+"z"},d.centers=function(){for(var a=[],l=Math.round(o/e),g=Math.round(n/i),s=l*e;s<c+t;s+=e,++l)for(var u=g*i+(1&l)*i/2;u<r+i/2;u+=i)a.push([u,s]);return a},d.mesh=function(){var i=p(t).slice(0,4).join("l");return d.centers().map((function(t){return"M"+t+"m"+i})).join("")},d.x=function(t){return arguments.length?(u=t,d):u},d.y=function(t){return arguments.length?(h=t,d):h},d.radius=function(n){return arguments.length?(i=2*(t=+n)*Math.sin(a),e=1.5*t,d):t},d.size=function(t){return arguments.length?(n=o=0,r=+t[0],c=+t[1],d):[r-n,c-o]},d.extent=function(t){return arguments.length?(n=+t[0][0],o=+t[0][1],r=+t[1][0],c=+t[1][1],d):[[n,o],[r,c]]},d.radius(1)}().radius(d).x((t=>t.screenCoord[0])).y((t=>t.screenCoord[1]));return{hexagons:L(p).map(((t,i)=>({position:r.unprojectFlat([t.x,t.y]),points:t,index:i}))),radiusCommon:d}},getPosition:{type:"accessor",value:t=>t.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class f extends h.Z{shouldUpdateState({changeFlags:t}){return t.somethingChanged}initializeState(){const t=new u.Z({getAggregator:t=>t.hexagonAggregator,getCellSize:t=>t.radius});this.state={cpuAggregator:t,aggregatorState:t.state,hexagonVertices:null},this.getAttributeManager().add({positions:{size:3,accessor:"getPosition"}})}updateState(t){super.updateState(t);const{cpuAggregator:i,hexagonVertices:e}=this.state;t.changeFlags.propsOrDataChanged&&this.setState({aggregatorState:i.updateState(t,{viewport:this.context.viewport,attributes:this.getAttributes()})});const{hexagonVertices:n}=i.state.layerData||{};if(n&&e!==n){const t=this.convertLatLngToMeterOffset(n);t&&this.setState({hexagonVertices:n,vertices:t})}else this.updateRadiusAngle()}updateRadiusAngle(t){const{viewport:i}=this.context,{unitsPerMeter:e}=i.getDistanceScales(),{cpuAggregator:n}=this.state;if(n.state.layerData&&n.state.layerData.radiusCommon){const{radiusCommon:t}=n.state.layerData,i=t/e[0];this.setState({angle:90,radius:i})}}convertLatLngToMeterOffset(t){const{viewport:i}=this.context;if(Array.isArray(t)&&6===t.length){const e=t[0],n=t[3],o=[(e[0]+n[0])/2,(e[1]+n[1])/2],r=i.projectFlat(o),{metersPerUnit:a}=i.getDistanceScales(o);return t.map((t=>{const e=i.projectFlat(t);return[(e[0]-r[0])*a[0],(e[1]-r[1])*a[1]]}))}return n.Z.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:t}){return this.state.cpuAggregator.getPickingInfo({info:t})}_onGetSublayerColor(t){return this.state.cpuAggregator.getAccessor("fillColor")(t)}_onGetSublayerElevation(t){return this.state.cpuAggregator.getAccessor("elevation")(t)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:t,extruded:i,coverage:e,material:n,transitions:r}=this.props,{angle:a,radius:l,cpuAggregator:g,vertices:s}=this.state,c=this.getSubLayerClass("hexagon-cell",o.Z),u=this._getSublayerUpdateTriggers();return new c({...s&&s.length?{vertices:s,radius:1}:{radius:l,angle:a},diskResolution:6,elevationScale:t,extruded:i,coverage:e,material:n,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:r&&{getFillColor:r.getColorValue||r.getColorWeight,getElevation:r.getElevationValue||r.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:u}),{data:g.state.layerData.data})}}f.layerName="HexagonLayer",f.defaultProps=p;var _=e(67294),m=e(60650),v=e(37032),L=e(88574),b=e(52598),C=e(57981);function y(){return y=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var e=arguments[i];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])}return t},y.apply(this,arguments)}function S(t){return _.createElement("div",{className:"deckgl-tooltip"},_.createElement(C.Z,{label:(0,m.t)("Centroid (Longitude and Latitude)")+": ",value:"("+t.coordinate[0]+", "+t.coordinate[1]+")"}),_.createElement(C.Z,{label:(0,m.t)("Height")+": ",value:""+t.object.elevationValue}))}function w(t,i,e,n){const o=t,r=o.color_picker;let a=i.data.features.map((t=>y({},t,{color:[r.r,r.g,r.b,255*r.a]})));o.js_data_mutator&&(a=(0,L.Z)(o.js_data_mutator)(a));const l=(0,v.Z)(o.js_agg_function,(t=>t.weight));return new f(y({id:"hex-layer-"+o.slice_id,data:a,pickable:!0,radius:o.grid_size,minColor:[0,0,0,0],extruded:o.extruded,maxColor:[r.r,r.g,r.b,255*r.a],outline:!1,getElevationValue:l,getColorValue:l},(0,v.N)(o,n,S)))}const x=(0,b.G)(w,(function(t){return t.map((t=>t.position))}))},92540:()=>{},95751:()=>{},75307:()=>{}}]);