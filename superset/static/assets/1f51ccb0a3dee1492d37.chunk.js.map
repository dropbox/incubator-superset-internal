{"version":3,"file":"1f51ccb0a3dee1492d37.chunk.js","mappings":"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","sources":["webpack://superset/./node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","webpack://superset/./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/lineclip.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/utils.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","webpack://superset/./node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"],"sourcesContent":["const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null,\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,\n  pickingActive: false,\n  pickingAttribute: false\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n\n  if (opts.pickingSelectedColor !== undefined) {\n    if (!opts.pickingSelectedColor) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = opts.pickingSelectedColor.slice(0, 3);\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n\n  if (opts.pickingHighlightColor) {\n    const color = Array.from(opts.pickingHighlightColor, x => x / 255);\n\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n\n    uniforms.picking_uHighlightColor = color;\n  }\n\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = Boolean(opts.pickingActive);\n    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);\n  }\n\n  return uniforms;\n}\n\nconst vs = \"uniform bool picking_uActive;\\nuniform bool picking_uAttribute;\\nuniform vec3 picking_uSelectedColor;\\nuniform bool picking_uSelectedColorValid;\\n\\nout vec4 picking_vRGBcolor_Avalid;\\n\\nconst float COLOR_SCALE = 1. / 255.;\\n\\nbool picking_isColorValid(vec3 color) {\\n  return dot(color, vec3(1.0)) > 0.001;\\n}\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    picking_uSelectedColorValid &&\\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\\n}\\n\\nvoid picking_setPickingColor(vec3 pickingColor) {\\n  if (picking_uActive) {\\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\\n\\n    if (!picking_uAttribute) {\\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\\n    }\\n  } else {\\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\\n  }\\n}\\n\\nvoid picking_setPickingAttribute(float value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.r = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec2 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rg = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec3 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rgb = value;\\n  }\\n}\\n\";\nconst fs = \"uniform bool picking_uActive;\\nuniform vec3 picking_uSelectedColor;\\nuniform vec4 picking_uHighlightColor;\\n\\nin vec4 picking_vRGBcolor_Avalid;\\nvec4 picking_filterHighlightColor(vec4 color) {\\n  if (picking_uActive) {\\n    return color;\\n  }\\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\\n\\n  if (selected) {\\n    float highLightAlpha = picking_uHighlightColor.a;\\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\\n    float highLightRatio = highLightAlpha / blendedAlpha;\\n\\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\\n    return vec4(blendedRGB, blendedAlpha);\\n  } else {\\n    return color;\\n  }\\n}\\nvec4 picking_filterPickingColor(vec4 color) {\\n  if (picking_uActive) {\\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\\n      discard;\\n    }\\n    return picking_vRGBcolor_Avalid;\\n  }\\n  return color;\\n}\\nvec4 picking_filterColor(vec4 color) {\\n  vec4 highightColor = picking_filterHighlightColor(color);\\n  return picking_filterPickingColor(highightColor);\\n}\\n\\n\";\nexport const picking = {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n//# sourceMappingURL=picking.js.map","import { picking } from '@luma.gl/core';\nexport default {\n  inject: {\n    'vs:DECKGL_FILTER_COLOR': \"\\n  picking_setPickingColor(geometry.pickingColor);\\n  // for picking depth values\\n  picking_setPickingAttribute(geometry.position.z);\\n  \",\n    'fs:DECKGL_FILTER_COLOR': {\n      order: 99,\n      injection: \"\\n  // use highlight color if this fragment belongs to the selected object.\\n  color = picking_filterHighlightColor(color);\\n\\n  // use picking color if rendering to picking FBO.\\n  color = picking_filterPickingColor(color);\\n    \"\n    }\n  },\n  ...picking\n};\n//# sourceMappingURL=picking.js.map","import { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox, options = {}) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox, options = {}) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options;\n  let {\n    startIndex = 0\n  } = options;\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map","export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options = {}) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices, options = {}) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options;\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions, options = {}) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options;\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices, options = {}) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options;\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map"],"names":["DEFAULT_MODULE_OPTIONS","pickingSelectedColor","pickingHighlightColor","Uint8Array","pickingActive","pickingAttribute","inject","order","injection","name","vs","fs","getUniforms","opts","uniforms","undefined","selectedColor","slice","picking_uSelectedColorValid","picking_uSelectedColor","color","Array","from","x","Number","isFinite","picking_uHighlightColor","picking_uActive","Boolean","picking_uAttribute","WINDING","CLOCKWISE","COUNTER_CLOCKWISE","points","direction","options","windingDirection","Math","sign","start","end","length","dim","size","area","i","j","getPolygonWindingDirection","numPoints","numSwaps","floor","b1","b2","tmp","reversePolygon","intersect","a","b","edge","bbox","out","t","snap","bitCode","p","code","target","source","startIndex","isDuplicate","positions","index","offset","startI","cutPolylineByGrid","broken","gridResolution","gridOffset","endIndex","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","push","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","type","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","Infinity","maxX","minY","maxY","y","cutPolylineByMercatorBounds","normalize","newPositions","wrapLongitudesForShortestPath","shiftLongitudesIntoRange","cutPolygonByMercatorBounds","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","insertPoleVertices","maxLatitude","pop","maxLat","pointIndex","lat","abs","firstLng","lastLng","round","lng","prevLng","delta","refLng","pointCount"],"sourceRoot":""}