"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[8230],{28230:(e,t,a)=>{a.r(t),a.d(t,{default:()=>V,getLayer:()=>N});var o=a(67294),i=a(45697),n=a.n(i),s=a(80744),r=a(78651),l=a(15614),g=a(44211),c=a(6948),u=a(281),d=a(53982),p=a(95772),h=a(51331),m=a(4516);const f=[0,0,0,0],x=[0,255,0,255],v=["minColor","maxColor","colorRange","colorDomain"],C={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:m.K};class S extends p.Z{static isSupported(e){return(0,g.ag)(e,[c.h.TEXTURE_FLOAT])}getShaders(){return{vs:"#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[h.Z]}}initializeState(){const{gl:e}=this.context;this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel(e)})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState({oldProps:e,props:t,changeFlags:a}){super.updateState({oldProps:e,props:t,changeFlags:a});const o=this.getAttributeManager();t.numInstances!==e.numInstances?o.invalidateAll():e.cellSizePixels!==t.cellSizePixels&&o.invalidate("instancePositions"),this._updateUniforms(e,t,a)}draw({uniforms:e}){const{parameters:t,maxTexture:a}=this.props,o=this.props.minColor||f,i=this.props.maxColor||x,n=this.props.colorDomain||[1,0],{model:s}=this.state;s.setUniforms(e).setUniforms({minColor:o,maxColor:i,maxTexture:a,colorDomain:n}).draw({parameters:{depthTest:!1,depthMask:!1,...t}})}calculateInstancePositions(e,{numInstances:t}){const{width:a,height:o}=this.context.viewport,{cellSizePixels:i}=this.props,n=Math.ceil(a/i),{value:s,size:r}=e;for(let e=0;e<t;e++){const t=e%n,l=Math.floor(e/n);s[e*r+0]=t*i/a*2-1,s[e*r+1]=1-l*i/o*2,s[e*r+2]=0}}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new d.Z({drawMode:6,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:a,colorRange:o}=this.props;return e||t?(s.Z.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!a&&!o}_updateUniforms(e,t,a){const{model:o}=this.state;if(v.some((a=>e[a]!==t[a]))&&o.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&o.setUniforms({colorRange:(0,m.P)(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||a.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:a,cellMarginPixels:i}=this.props,n=a>i?i:0,s=new Float32Array([(a-n)/e*2,-(a-n)/t*2,1]);o.setUniforms({cellScale:s})}}}S.layerName="ScreenGridCellLayer",S.defaultProps=C;var y=a(13208),b=a(92637);const w={...S.defaultProps,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},P="positions",_={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class A extends y.Z{initializeState(){const{gl:e}=this.context;if(!S.isSupported(e))return this.setState({supported:!1}),void s.Z.error("ScreenGridLayer: ".concat(this.id," is not supported on this browser"))();super.initializeState({dimensions:_,getCellSize:e=>e.cellSizePixels});const t={count:{size:1,operation:l.KM.SUM,needMax:!0,maxTexture:(0,b.hq)(e,{id:"".concat(this.id,"-max-texture")})}};this.setState({supported:!0,projectPoints:!0,weights:t,subLayerData:{attributes:{}},maxTexture:t.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[P]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return this.state.supported&&e.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:e,numRow:t,numCol:a,weights:o}=this.state,{updateTriggers:i}=this.props,{aggregationBuffer:n}=o.count;return new(this.getSubLayerClass("cells",S))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:i}),{data:{attributes:{instanceCounts:n}},maxTexture:e,numInstances:t*a})}finalizeState(){super.finalizeState();const{aggregationBuffer:e,maxBuffer:t,maxTexture:a}=this.state;null==e||e.delete(),null==t||t.delete(),null==a||a.delete()}getPickingInfo({info:e,mode:t}){const{index:a}=e;if(a>=0){const{gpuGridAggregator:t,gpuAggregation:o,weights:i}=this.state,n=o?t.getData("count"):i.count;e.object=r.Z.getAggregationData({pixelIndex:a,...n})}return e}updateResults({aggregationData:e,maxData:t}){const{count:a}=this.state.weights;a.aggregationData=e,a.aggregationBuffer.setData({data:e}),a.maxData=t,a.maxTexture.setImageData({data:t})}updateAggregationState(e){const t=e.props.cellSizePixels,a=e.oldProps.cellSizePixels!==t,{viewportChanged:o}=e.changeFlags;let i=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&i&&!r.Z.isSupported(this.context.gl)&&(s.Z.warn("GPU Grid Aggregation not supported, falling back to CPU")(),i=!1);const n=i!==this.state.gpuAggregation;this.setState({gpuAggregation:i});const l=this.isAttributeChanged(P),{dimensions:g}=this.state,{data:c,weights:u}=g,d=l||n||o||this.isAggregationDirty(e,{compareAll:i,dimension:c}),p=this.isAggregationDirty(e,{dimension:u});this.setState({aggregationDataDirty:d,aggregationWeightsDirty:p});const{viewport:h}=this.context;if(o||a){const{width:e,height:a}=h,o=Math.ceil(e/t),i=Math.ceil(a/t);this.allocateResources(i,o),this.setState({scaling:[e/2,-a/2,1],gridOffset:{xOffset:t,yOffset:t},width:e,height:a,numCol:o,numRow:i})}p&&this._updateAccessors(e),(d||p)&&this._resetResults()}_updateAccessors(e){const{getWeight:t,aggregation:a,data:o}=e.props,{count:i}=this.state.weights;i&&(i.getWeight=t,i.operation=l.KM[a]),this.setState({getValue:(0,l._D)(a,t,{data:o})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}}A.layerName="ScreenGridLayer",A.defaultProps=w;var D=a(60650),M=a(89759),R=a(57485),T=a(88574),z=a(37032),U=a(57981),L=a(50980);function E(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function k(){return k=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var o in a)Object.prototype.hasOwnProperty.call(a,o)&&(e[o]=a[o])}return e},k.apply(this,arguments)}function F(e){return o.createElement("div",{className:"deckgl-tooltip"},o.createElement(U.Z,{label:(0,D.t)("Longitude and Latitude")+": ",value:e.coordinate[0]+", "+e.coordinate[1]}),o.createElement(U.Z,{label:(0,D.t)("Weight")+": ",value:""+e.object.weight}))}function N(e,t,a,o,i,n,s){const r=e,l=r.color_picker;let g=t.data.features.map((e=>k({},e,{color:[l.r,l.g,l.b,255*l.a]})));if(r.js_data_mutator){const e=(0,T.Z)(r.js_data_mutator);g=e(g)}return null!=s&&s.forEach((e=>{g=g.filter((t=>e(t)))})),new A(k({id:"screengrid-layer-"+r.slice_id,data:g,pickable:!0,cellSizePixels:r.grid_size,minColor:[l.r,l.g,l.b,0],maxColor:[l.r,l.g,l.b,255*l.a],outline:!1,getWeight:e=>e.weight||0},(0,z.N)(r,o,F)))}const O={formData:n().object.isRequired,payload:n().object.isRequired,setControlValue:n().func.isRequired,viewport:n().object.isRequired,onAddFilter:n().func,width:n().number.isRequired,height:n().number.isRequired},Z={onAddFilter(){}};class I extends o.PureComponent{constructor(e){super(e),E(this,"containerRef",o.createRef()),E(this,"setTooltip",(e=>{const{current:t}=this.containerRef;t&&t.setTooltip(e)})),this.state=I.getDerivedStateFromProps(e),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this)}static getDerivedStateFromProps(e,t){if(t&&e.payload.form_data===t.formData)return null;const a=e.payload.data.features||[],o=a.map((e=>e.__timestamp)),i=e.payload.form_data.time_grain_sqla||e.payload.form_data.granularity||"P1D",{start:n,end:s,getStep:r,values:l,disabled:g}=(0,R.g)(o,i),{width:c,height:u,formData:d}=e;let{viewport:p}=e;var h;return d.autozoom&&(p=(0,L.Z)(p,{width:c,height:u,points:(h=a,h.map((e=>e.position)))})),{start:n,end:s,getStep:r,values:l,disabled:g,viewport:p,selected:[],lastClick:0,formData:e.payload.form_data}}onValuesChange(e){this.setState({values:Array.isArray(e)?e:[e,e+this.state.getStep(e)]})}getLayers(e){const t=[];return e[0]===e[1]||e[1]===this.end?t.push((t=>t.__timestamp>=e[0]&&t.__timestamp<=e[1])):t.push((t=>t.__timestamp>=e[0]&&t.__timestamp<e[1])),[N(this.props.formData,this.props.payload,this.props.onAddFilter,this.setTooltip)]}render(){const{formData:e,payload:t,setControlValue:a}=this.props;return o.createElement("div",null,o.createElement(M.Z,{ref:this.containerRef,aggregation:!0,getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,width:this.props.width,height:this.props.height,mapboxApiAccessToken:t.data.mapboxApiKey,mapStyle:e.mapbox_style,setControlValue:a,onValuesChange:this.onValuesChange,onViewportChange:this.onViewportChange}))}}I.propTypes=O,I.defaultProps=Z;const V=I}}]);