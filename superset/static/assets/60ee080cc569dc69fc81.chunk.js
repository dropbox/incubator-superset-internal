"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3795],{95644:(i,n,t)=>{t.d(n,{N:()=>h,s:()=>s});const o="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",e={lightSources:{}};function l(){let{color:i=[0,0,0],intensity:n=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i.map((i=>i*n/255))}const r={name:"lights",vs:o,fs:o,getUniforms:function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e;if("lightSources"in n){const{ambientLight:i,pointLights:t,directionalLights:o}=n.lightSources||{};return i||t&&t.length>0||o&&o.length>0?Object.assign({},function(i){let{ambientLight:n,pointLights:t=[],directionalLights:o=[]}=i;const e={};return e["lighting_uAmbientLight.color"]=n?l(n):[0,0,0],t.forEach(((i,n)=>{e["lighting_uPointLight[".concat(n,"].color")]=l(i),e["lighting_uPointLight[".concat(n,"].position")]=i.position,e["lighting_uPointLight[".concat(n,"].attenuation")]=i.attenuation||[1,0,0]})),e.lighting_uPointLightCount=t.length,o.forEach(((i,n)=>{e["lighting_uDirectionalLight[".concat(n,"].color")]=l(i),e["lighting_uDirectionalLight[".concat(n,"].direction")]=i.direction})),e.lighting_uDirectionalLightCount=o.length,e}({ambientLight:i,pointLights:t,directionalLights:o}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in n){const t={pointLights:[],directionalLights:[]};for(const i of n.lights||[])switch(i.type){case"ambient":t.ambientLight=i;break;case"directional":t.directionalLights.push(i);break;case"point":t.pointLights.push(i)}return i({lightSources:t})}return{}},defines:{MAX_LIGHTS:3}},g="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",a={};function c(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a;if(!("material"in i))return{};const{material:n}=i;return n?function(i){const{ambient:n=.35,diffuse:t=.6,shininess:o=32,specularColor:e=[30,30,30]}=i;return{lighting_uAmbient:n,lighting_uDiffuse:t,lighting_uShininess:o,lighting_uSpecularColor:e.map((i=>i/255))}}(n):{lighting_uEnabled:!1}}const h={name:"gouraud-lighting",dependencies:[r],vs:g,defines:{LIGHTING_VERTEX:1},getUniforms:c},s={name:"phong-lighting",dependencies:[r],fs:g,defines:{LIGHTING_FRAGMENT:1},getUniforms:c}},72502:(i,n,t)=>{t.r(n),t.d(n,{default:()=>d,getLayer:()=>_});var o=t(51047),e=(t(67294),t(61988)),l=t(28062),r=t(58371),g=t(63241),a=t(89503),c=t(89691),h=t(51805),s=t(11965);function u(i){return(0,s.tZ)("div",{className:"deckgl-tooltip"},(0,s.tZ)(h.Z,{label:(0,e.t)("Longitude and Latitude")+": ",value:`${i.coordinate[0]}, ${i.coordinate[1]}`}),(0,s.tZ)(h.Z,{label:(0,e.t)("Height")+": ",value:`${i.object.elevationValue}`}))}function _(i,n,t,e){const c=i,h=l.getScale(c.color_scheme).range().map((i=>(0,a.hexToRGB)(i)));let s=n.data.features;c.js_data_mutator&&(s=(0,g.Z)(c.js_data_mutator)(s));const _=(0,r.Z)(c.js_agg_function,(i=>i.weight));return new o.Z({id:`grid-layer-${c.slice_id}`,data:s,cellSize:c.grid_size,extruded:c.extruded,colorRange:h,outline:!1,getElevationValue:_,getColorValue:_,...(0,r.N)(c,e,u)})}const d=(0,c.G)(_,(function(i){return i.map((i=>i.position))}))}}]);
//# sourceMappingURL=60ee080cc569dc69fc81.chunk.js.map